(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,o,l=e[0],s=e[1],c=e[2],d=0,p=[];d<l.length;d++)o=l[d],Object.prototype.hasOwnProperty.call(r,o)&&r[o]&&p.push(r[o][0]),r[o]=0;for(a in s)Object.prototype.hasOwnProperty.call(s,a)&&(n[a]=s[a]);for(u&&u(e);p.length;)p.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],a=!0,l=1;l<t.length;l++){var s=t[l];0!==r[s]&&(a=!1)}a&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var a={},r={1:0},i=[];function o(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=r[n]=[e,a]}));e.push(t[2]=a);var i,l=document.createElement("script");l.charset="utf-8",l.timeout=120,o.nc&&l.setAttribute("nonce",o.nc),l.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"30e55919",3:"b0bc2f21",4:"3836de01",5:"8a07afc3",6:"da731992",7:"d39d7410",8:"8a54b5ba",9:"a324023b",10:"6dd928bf",11:"fc981f88",12:"003bca26",13:"c0dc86e1",14:"c1783ece",15:"16e780b8",16:"b916de41",17:"c45d983a",18:"e3c8271b",19:"2a7a2146",20:"6afe62d0",21:"9cf58890",22:"2cadb00a",23:"5c23936f",24:"8e25fb4b",25:"6c8cb25c",26:"4e571371",27:"8fd49fab",28:"3cc34add",29:"608ac964",30:"a06d0d7f",31:"c0f3a8cb",32:"87b7292f",33:"25510cbe",34:"db07b3ab",35:"ed9a7f2c",36:"dd205a71",37:"1c7c0ffb",38:"26195a9c",39:"e80c2c37",40:"9688b111",41:"e23b3345",42:"461237be",43:"a8ce3f43",44:"2c7dfdcc",45:"3b24e9f7",46:"a5c66640",47:"3cf06166",48:"460f7381",49:"cfcaa431",50:"0c2057cd",51:"b2a465db",52:"f6576dfc",53:"b35a5317",54:"b4facfb4",55:"9b576d84",56:"50e3bb52",57:"d063402e",58:"a6f680cd",59:"0d797650",60:"c3f07c87",61:"db1a2806",62:"0724d7a8",63:"f9f388cb",64:"36844333",65:"3539ae2f",66:"55dcd8aa",67:"48a5a68a"}[n]+".js"}(n);var s=new Error;i=function(e){l.onerror=l.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;s.message="Loading chunk "+n+" failed.\n("+a+": "+i+")",s.name="ChunkLoadError",s.type=a,s.request=i,t[1](s)}r[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:l})}),12e4);l.onerror=l.onload=i,document.head.appendChild(l)}return Promise.all(e)},o.m=n,o.c=a,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)o.d(t,a,function(e){return n[e]}.bind(null,a));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/javacore/",o.oe=function(n){throw console.error(n),n};var l=window.webpackJsonp=window.webpackJsonp||[],s=l.push.bind(l);l.push=e,l=l.slice();for(var c=0;c<l.length;c++)e(l[c]);var u=s;i.push([241,0]),t()}([function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var a=t(0),r=t(38).f,i=t(24),o=t(14),l=t(115),s=t(119),c=t(106);n.exports=function(n,e){var t,u,d,p,m,h=n.target,v=n.global,g=n.stat;if(t=v?a:g?a[h]||l(h,{}):(a[h]||{}).prototype)for(u in e){if(p=e[u],d=n.noTargetGet?(m=r(t,u))&&m.value:t[u],!c(v?u:h+(g?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;s(p,d)}(n.sham||d&&d.sham)&&i(p,"sham",!0),o(t,u,p,n)}}},function(n,e,t){var a=t(65),r=Function.prototype,i=r.bind,o=r.call,l=a&&i.bind(o,o);n.exports=a?function(n){return n&&l(n)}:function(n){return n&&function(){return o.apply(n,arguments)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var a=t(0),r=t(51),i=t(9),o=t(85),l=t(52),s=t(156),c=r("wks"),u=a.Symbol,d=u&&u.for,p=s?u:u&&u.withoutSetter||o;n.exports=function(n){if(!i(c,n)||!l&&"string"!=typeof c[n]){var e="Symbol."+n;l&&i(u,n)?c[n]=u[n]:c[n]=s&&d?d(e):p(e)}return c[n]}},function(n,e,t){var a=t(122),r=t(14),i=t(261);a||r(Object.prototype,"toString",i,{unsafe:!0})},function(n,e,t){var a=t(65),r=Function.prototype.call;n.exports=a?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e,t){var a=t(3);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var a=t(2),r=t(16),i=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(r(n),e)}},function(n,e,t){var a=t(0),r=t(11),i=a.String,o=a.TypeError;n.exports=function(n){if(r(n))return n;throw o(i(n)+" is not an object")}},function(n,e,t){var a=t(4);n.exports=function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(0),r=t(82),i=a.String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){var a=t(0),r=t(8),i=t(158),o=t(157),l=t(10),s=t(87),c=a.TypeError,u=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=r?o?function(n,e,t){if(l(n),e=s(e),l(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=d(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return u(n,e,t)}:u:function(n,e,t){if(l(n),e=s(e),l(t),i)try{return u(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(0),r=t(4),i=t(9),o=t(24),l=t(115),s=t(91),c=t(37),u=t(70).CONFIGURABLE,d=c.get,p=c.enforce,m=String(String).split("String");(n.exports=function(n,e,t,s){var c,d=!!s&&!!s.unsafe,h=!!s&&!!s.enumerable,v=!!s&&!!s.noTargetGet,g=s&&void 0!==s.name?s.name:e;r(t)&&("Symbol("===String(g).slice(0,7)&&(g="["+String(g).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!i(t,"name")||u&&t.name!==g)&&o(t,"name",g),(c=p(t)).source||(c.source=m.join("string"==typeof g?g:""))),n!==a?(d?!v&&n[e]&&(h=!0):delete n[e],h?n[e]=t:o(n,e,t)):h?n[e]=t:l(e,t)})(Function.prototype,"toString",(function(){return r(this)&&d(this).source||s(this)}))},function(n,e,t){var a=t(0),r=t(4),i=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(0),r=t(18),i=a.Object;n.exports=function(n){return i(r(n))}},function(n,e){n.exports=!1},function(n,e,t){var a=t(0).TypeError;n.exports=function(n){if(null==n)throw a("Can't call method on "+n);return n}},function(n,e,t){"use strict";var a=t(1),r=t(97);a({target:"RegExp",proto:!0,forced:/./.exec!==r},{exec:r})},function(n,e,t){var a=t(54);n.exports=function(n){return a(n.length)}},function(n,e,t){var a=t(64),r=t(18);n.exports=function(n){return a(r(n))}},function(n,e,t){var a=t(0),r=t(4),i=t(67),o=a.TypeError;n.exports=function(n){if(r(n))return n;throw o(i(n)+" is not a function")}},function(n,e,t){var a=t(2),r=a({}.toString),i=a("".slice);n.exports=function(n){return i(r(n),8,-1)}},function(n,e,t){var a=t(8),r=t(13),i=t(49);n.exports=a?function(n,e,t){return r.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";var a=t(175).charAt,r=t(12),i=t(37),o=t(162),l=i.set,s=i.getterFor("String Iterator");o(String,"String",(function(n){l(this,{type:"String Iterator",string:r(n),index:0})}),(function(){var n,e=s(this),t=e.string,r=e.index;return r>=t.length?{value:void 0,done:!0}:(n=a(t,r),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var a=t(14),r=t(282),i=Error.prototype;i.toString!==r&&a(i,"toString",r)},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(15);n.exports=a("navigator","userAgent")||""},function(n,e,t){var a=t(192),r="object"==typeof self&&self&&self.Object===Object&&self,i=a||r||Function("return this")();n.exports=i},function(n,e,t){"use strict";function a(n,e,t,a,r,i,o,l){var s,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),o?(s=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=s):r&&(s=l?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),s)if(c.functional){c._injectStyles=s;var u=c.render;c.render=function(n,e){return s.call(e),u(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,s):[s]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e,t){"use strict";var a=t(1),r=t(59).filter;a({target:"Array",proto:!0,forced:!t(75)("filter")},{filter:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var a=t(0),r=t(176),i=t(177),o=t(145),l=t(24),s=t(5),c=s("iterator"),u=s("toStringTag"),d=o.values,p=function(n,e){if(n){if(n[c]!==d)try{l(n,c,d)}catch(e){n[c]=d}if(n[u]||l(n,u,e),r[e])for(var t in o)if(n[t]!==o[t])try{l(n,t,o[t])}catch(e){n[t]=o[t]}}};for(var m in r)p(a[m]&&a[m].prototype,m);p(i,"DOMTokenList")},function(n,e,t){"use strict";var a=t(1),r=t(181);a({target:"Array",proto:!0,forced:[].forEach!=r},{forEach:r})},function(n,e,t){var a=t(0),r=t(176),i=t(177),o=t(181),l=t(24),s=function(n){if(n&&n.forEach!==o)try{l(n,"forEach",o)}catch(e){n.forEach=o}};for(var c in r)r[c]&&s(a[c]&&a[c].prototype);s(i)},function(n,e,t){var a,r=t(10),i=t(146),o=t(117),l=t(68),s=t(161),c=t(86),u=t(90),d=u("IE_PROTO"),p=function(){},m=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e},v=function(){try{a=new ActiveXObject("htmlfile")}catch(n){}var n,e;v="undefined"!=typeof document?document.domain&&a?h(a):((e=c("iframe")).style.display="none",s.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F):h(a);for(var t=o.length;t--;)delete v.prototype[o[t]];return v()};l[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=r(n),t=new p,p.prototype=null,t[d]=n):t=v(),void 0===e?t:i.f(t,e)}},function(n,e,t){var a=t(2);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a,r,i,o=t(243),l=t(0),s=t(2),c=t(11),u=t(24),d=t(9),p=t(114),m=t(90),h=t(68),v=l.TypeError,g=l.WeakMap;if(o||p.state){var f=p.state||(p.state=new g),b=s(f.get),y=s(f.has),x=s(f.set);a=function(n,e){if(y(f,n))throw new v("Object already initialized");return e.facade=n,x(f,n,e),e},r=function(n){return b(f,n)||{}},i=function(n){return y(f,n)}}else{var k=m("state");h[k]=!0,a=function(n,e){if(d(n,k))throw new v("Object already initialized");return e.facade=n,u(n,k,e),e},r=function(n){return d(n,k)?n[k]:{}},i=function(n){return d(n,k)}}n.exports={set:a,get:r,has:i,enforce:function(n){return i(n)?r(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=r(e)).type!==n)throw v("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(8),r=t(7),i=t(118),o=t(49),l=t(21),s=t(87),c=t(9),u=t(158),d=Object.getOwnPropertyDescriptor;e.f=a?d:function(n,e){if(n=l(n),e=s(e),u)try{return d(n,e)}catch(n){}if(c(n,e))return o(!r(i.f,n,e),n[e])}},function(n,e,t){var a=t(65),r=Function.prototype,i=r.apply,o=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){var a=t(1),r=t(0),i=t(39),o=t(278),l=r.WebAssembly,s=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,s),a({global:!0,forced:s},t)},u=function(n,e){if(l&&l[n]){var t={};t[n]=o("WebAssembly."+n,e,s),a({target:"WebAssembly",stat:!0,forced:s},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){var a=t(302),r=t(305);n.exports=function(n,e){var t=r(n,e);return a(t)?t:void 0}},function(n,e,t){t(378),t(379)},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return s})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return u})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return f})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));t(19),t(45),t(140),t(81),t(138),t(113),t(44),t(33),t(6),t(34),t(31),t(84),t(80),t(155),t(79),t(213),t(26),t(144);var a=/#.*$/,r=/\.(md|html)$/,i=/\/$/,o=/^[a-z]+:/i;function l(n){return decodeURI(n).replace(a,"").replace(r,"")}function s(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function d(n){if(s(n))return n;if(!n)return"404";var e=n.match(a),t=e?e[0]:"",r=l(n);return i.test(r)?n:r+".html"+t}function p(n,e){var t=n.hash,r=function(n){var e=n&&n.match(a);if(e)return e[0]}(e);return(!r||t===r)&&l(n.path)===l(e)}function m(n,e,t){if(s(e))return{type:"external",path:e};t&&(e=function(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var l=i[o];".."===l?r.pop():"."!==l&&r.push(l)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));for(var a=l(e),r=0;r<n.length;r++)if(l(n[r].regularPath)===a)return Object.assign({},n[r],{type:"page",path:d(n[r].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function h(n,e,t,a){var r=t.pages,i=t.themeConfig,o=a&&i.locales&&i.locales[a]||i;if("auto"===(n.frontmatter.sidebar||o.sidebar||i.sidebar))return v(n);var l=o.sidebar||i.sidebar;if(l){var s=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(a=n,/(\.html|\/)$/.test(a)?a:a+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var a;return{}}(e,l),c=s.base,u=s.config;return"auto"===u?v(n):u?u.map((function(n){return function n(e,t,a){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return m(t,e,a);if(Array.isArray(e))return Object.assign(m(t,e[0],a),{title:e[1]});r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var i=e.children||[];return 0===i.length&&e.path?Object.assign(m(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map((function(e){return n(e,t,a,r+1)})),collapsable:!1!==e.collapsable}}(n,r,c)})):[]}return[]}function v(n){var e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}function g(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function f(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){var e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e,t){"use strict";var a=t(1),r=t(59).map;a({target:"Array",proto:!0,forced:!t(75)("map")},{map:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a=t(39),r=t(7),i=t(2),o=t(111),l=t(3),s=t(10),c=t(4),u=t(46),d=t(54),p=t(12),m=t(18),h=t(127),v=t(48),g=t(283),f=t(112),b=t(5)("replace"),y=Math.max,x=Math.min,k=i([].concat),w=i([].push),j=i("".indexOf),S=i("".slice),T="$0"==="a".replace(/./,"$0"),I=!!/./[b]&&""===/./[b]("a","$0");o("replace",(function(n,e,t){var i=I?"$":"$0";return[function(n,t){var a=m(this),i=null==n?void 0:v(n,b);return i?r(i,n,a,t):r(e,p(a),n,t)},function(n,r){var o=s(this),l=p(n);if("string"==typeof r&&-1===j(r,i)&&-1===j(r,"$<")){var m=t(e,o,l,r);if(m.done)return m.value}var v=c(r);v||(r=p(r));var b=o.global;if(b){var T=o.unicode;o.lastIndex=0}for(var I=[];;){var C=f(o,l);if(null===C)break;if(w(I,C),!b)break;""===p(C[0])&&(o.lastIndex=h(l,d(o.lastIndex),T))}for(var z,E="",A=0,M=0;M<I.length;M++){for(var J=p((C=I[M])[0]),L=y(x(u(C.index),l.length),0),O=[],P=1;P<C.length;P++)w(O,void 0===(z=C[P])?z:String(z));var _=C.groups;if(v){var D=k([J],O,L,l);void 0!==_&&w(D,_);var R=p(a(r,void 0,D))}else R=g(J,l,L,O,_,r);L>=A&&(E+=S(l,A,L)+R,A=L+J.length)}return E+S(l,A)}]}),!!l((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!T||I)},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=function(n){var e=+n;return e!=e||0===e?0:(e>0?a:t)(e)}},function(n,e,t){"use strict";var a=t(3);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(22);n.exports=function(n,e){var t=n[e];return null==t?void 0:a(t)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var a=t(17),r=t(114);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.22.2",mode:a?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){var a=t(53),r=t(3);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a,r,i=t(0),o=t(28),l=i.process,s=i.Deno,c=l&&l.versions||s&&s.version,u=c&&c.v8;u&&(r=(a=u.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!r&&o&&(!(a=o.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=o.match(/Chrome\/(\d+)/))&&(r=+a[1]),n.exports=r},function(n,e,t){var a=t(46),r=Math.min;n.exports=function(n){return n>0?r(a(n),9007199254740991):0}},function(n,e,t){var a=t(0);n.exports=a.Promise},function(n,e,t){"use strict";var a=t(87),r=t(13),i=t(49);n.exports=function(n,e,t){var o=a(e);o in n?r.f(n,o,i(0,t)):n[o]=t}},function(n,e,t){"use strict";var a=t(1),r=t(0),i=t(62),o=t(94),l=t(11),s=t(89),c=t(20),u=t(21),d=t(56),p=t(5),m=t(75),h=t(72),v=m("slice"),g=p("species"),f=r.Array,b=Math.max;a({target:"Array",proto:!0,forced:!v},{slice:function(n,e){var t,a,r,p=u(this),m=c(p),v=s(n,m),y=s(void 0===e?m:e,m);if(i(p)&&(t=p.constructor,(o(t)&&(t===f||i(t.prototype))||l(t)&&null===(t=t[g]))&&(t=void 0),t===f||void 0===t))return h(p,v,y);for(a=new(void 0===t?f:t)(b(y-v,0)),r=0;v<y;v++,r++)v in p&&d(a,r,p[v]);return a.length=r,a}})},function(n,e,t){var a=t(2),r=t(22),i=t(65),o=a(a.bind);n.exports=function(n,e){return r(n),void 0===e?n:i?o(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){var a=t(58),r=t(2),i=t(64),o=t(16),l=t(20),s=t(108),c=r([].push),u=function(n){var e=1==n,t=2==n,r=3==n,u=4==n,d=6==n,p=7==n,m=5==n||d;return function(h,v,g,f){for(var b,y,x=o(h),k=i(x),w=a(v,g),j=l(k),S=0,T=f||s,I=e?T(h,j):t||p?T(h,0):void 0;j>S;S++)if((m||S in k)&&(y=w(b=k[S],S,x),n))if(e)I[S]=y;else if(y)switch(n){case 3:return!0;case 5:return b;case 6:return S;case 2:c(I,b)}else switch(n){case 4:return!1;case 7:c(I,b)}return d?-1:r||u?u:I}};n.exports={forEach:u(0),map:u(1),filter:u(2),some:u(3),every:u(4),find:u(5),findIndex:u(6),filterReject:u(7)}},function(n,e,t){var a=t(160),r=t(117).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,r)}},function(n,e,t){var a=t(13).f,r=t(9),i=t(5)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!r(n,i)&&a(n,i,{configurable:!0,value:e})}},function(n,e,t){var a=t(23);n.exports=Array.isArray||function(n){return"Array"==a(n)}},function(n,e,t){var a=t(76),r=t(287),i=t(288),o=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?r(n):i(n)}},function(n,e,t){var a=t(0),r=t(2),i=t(3),o=t(23),l=a.Object,s=r("".split);n.exports=i((function(){return!l("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?s(n,""):l(n)}:l},function(n,e,t){var a=t(3);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var a=t(0),r=t(15),i=t(4),o=t(36),l=t(156),s=a.Object;n.exports=l?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return i(e)&&o(e.prototype,s(n))}},function(n,e,t){var a=t(0).String;n.exports=function(n){try{return a(n)}catch(n){return"Object"}}},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var a=t(8),r=t(9),i=Function.prototype,o=a&&Object.getOwnPropertyDescriptor,l=r(i,"name"),s=l&&"something"===function(){}.name,c=l&&(!a||a&&o(i,"name").configurable);n.exports={EXISTS:l,PROPER:s,CONFIGURABLE:c}},function(n,e,t){var a=t(2),r=t(10),i=t(244);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return r(t),i(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e,t){var a=t(2);n.exports=a([].slice)},function(n,e,t){var a=t(0),r=t(55),i=t(4),o=t(106),l=t(91),s=t(5),c=t(252),u=t(17),d=t(53),p=r&&r.prototype,m=s("species"),h=!1,v=i(a.PromiseRejectionEvent),g=o("Promise",(function(){var n=l(r),e=n!==String(r);if(!e&&66===d)return!0;if(u&&(!p.catch||!p.finally))return!0;if(d>=51&&/native code/.test(n))return!1;var t=new r((function(n){n(1)})),a=function(n){n((function(){}),(function(){}))};return(t.constructor={})[m]=a,!(h=t.then((function(){}))instanceof a)||!e&&c&&!v}));n.exports={CONSTRUCTOR:g,REJECTION_EVENT:v,SUBCLASSING:h}},function(n,e,t){"use strict";var a=t(22),r=function(n){var e,t;this.promise=new n((function(n,a){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=a})),this.resolve=a(e),this.reject=a(t)};n.exports.f=function(n){return new r(n)}},function(n,e,t){var a=t(3),r=t(5),i=t(53),o=r("species");n.exports=function(n){return i>=51||!a((function(){var e=[];return(e.constructor={})[o]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){var a=t(29).Symbol;n.exports=a},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(84);var a=t(78);t(83),t(96),t(6),t(126),t(25),t(32),t(187);var r=t(103);t(40),t(26);function i(n){return function(n){if(Array.isArray(n))return Object(a.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(r.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function a(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,a=new Array(e);t<e;t++)a[t]=n[t];return a}t.d(e,"a",(function(){return a}))},function(n,e,t){"use strict";var a=t(1),r=t(0),i=t(3),o=t(62),l=t(11),s=t(16),c=t(20),u=t(56),d=t(108),p=t(75),m=t(5),h=t(53),v=m("isConcatSpreadable"),g=r.TypeError,f=h>=51||!i((function(){var n=[];return n[v]=!1,n.concat()[0]!==n})),b=p("concat"),y=function(n){if(!l(n))return!1;var e=n[v];return void 0!==e?!!e:o(n)};a({target:"Array",proto:!0,forced:!f||!b},{concat:function(n){var e,t,a,r,i,o=s(this),l=d(o,0),p=0;for(e=-1,a=arguments.length;e<a;e++)if(y(i=-1===e?o:arguments[e])){if(p+(r=c(i))>9007199254740991)throw g("Maximum allowed index exceeded");for(t=0;t<r;t++,p++)t in i&&u(l,p,i[t])}else{if(p>=9007199254740991)throw g("Maximum allowed index exceeded");u(l,p++,i)}return l.length=p,l}})},function(n,e,t){"use strict";var a=t(1),r=t(2),i=t(116).indexOf,o=t(47),l=r([].indexOf),s=!!l&&1/l([1],1,-0)<0,c=o("indexOf");a({target:"Array",proto:!0,forced:s||!c},{indexOf:function(n){var e=arguments.length>1?arguments[1]:void 0;return s?l(this,n,e)||0:i(this,n,e)}})},function(n,e,t){"use strict";t(19);var a,r,i=t(1),o=t(0),l=t(7),s=t(2),c=t(4),u=t(11),d=(a=!1,(r=/[ac]/).exec=function(){return a=!0,/./.exec.apply(this,arguments)},!0===r.test("abc")&&a),p=o.Error,m=s(/./.test);i({target:"RegExp",proto:!0,forced:!d},{test:function(n){var e=this.exec;if(!c(e))return m(this,n);var t=l(e,this,n);if(null!==t&&!u(t))throw new p("RegExp exec method returned something other than an Object or null");return!!t}})},function(n,e,t){var a=t(0),r=t(122),i=t(4),o=t(23),l=t(5)("toStringTag"),s=a.Object,c="Arguments"==o(function(){return arguments}());n.exports=r?o:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),l))?t:c?o(e):"Object"==(a=o(e))&&i(e.callee)?"Arguments":a}},function(n,e,t){t(270),t(273),t(274),t(125),t(275)},function(n,e,t){t(1)({target:"Array",stat:!0},{isArray:t(62)})},function(n,e,t){var a=t(2),r=0,i=Math.random(),o=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++r+i,36)}},function(n,e,t){var a=t(0),r=t(11),i=a.document,o=r(i)&&r(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){var a=t(159),r=t(66);n.exports=function(n){var e=a(n,"string");return r(e)?e:e+""}},function(n,e,t){var a=t(160),r=t(117);n.exports=Object.keys||function(n){return a(n,r)}},function(n,e,t){var a=t(46),r=Math.max,i=Math.min;n.exports=function(n,e){var t=a(n);return t<0?r(t+e,0):i(t,e)}},function(n,e,t){var a=t(51),r=t(85),i=a("keys");n.exports=function(n){return i[n]||(i[n]=r(n))}},function(n,e,t){var a=t(2),r=t(4),i=t(114),o=a(Function.toString);r(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(23),r=t(0);n.exports="process"==a(r.process)},function(n,e,t){var a=t(2),r=t(3),i=t(4),o=t(82),l=t(15),s=t(91),c=function(){},u=[],d=l("Reflect","construct"),p=/^\s*(?:class|function)\b/,m=a(p.exec),h=!p.exec(c),v=function(n){if(!i(n))return!1;try{return d(c,u,n),!0}catch(n){return!1}},g=function(n){if(!i(n))return!1;switch(o(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return h||!!m(p,s(n))}catch(n){return!0}};g.sham=!0,n.exports=!d||r((function(){var n;return v(v.call)||!v(Object)||!v((function(){n=!0}))||n}))?g:v},function(n,e,t){"use strict";t.d(e,"a",(function(){return r}));t(6);function a(n,e,t,a,r,i,o){try{var l=n[i](o),s=l.value}catch(n){return void t(n)}l.done?e(s):Promise.resolve(s).then(a,r)}function r(n){return function(){var e=this,t=arguments;return new Promise((function(r,i){var o=n.apply(e,t);function l(n){a(o,r,i,l,s,"next",n)}function s(n){a(o,r,i,l,s,"throw",n)}l(void 0)}))}}},function(n,e,t){"use strict";var a=t(1),r=t(8),i=t(0),o=t(2),l=t(9),s=t(4),c=t(36),u=t(12),d=t(13).f,p=t(119),m=i.Symbol,h=m&&m.prototype;if(r&&s(m)&&(!("description"in h)||void 0!==m().description)){var v={},g=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:u(arguments[0]),e=c(h,this)?new m(n):void 0===n?m():m(n);return""===n&&(v[e]=!0),e};p(g,m),g.prototype=h,h.constructor=g;var f="Symbol(test)"==String(m("test")),b=o(h.toString),y=o(h.valueOf),x=/^Symbol\((.*)\)[^)]+$/,k=o("".replace),w=o("".slice);d(h,"description",{configurable:!0,get:function(){var n=y(this),e=b(n);if(l(v,n))return"";var t=f?w(e,7,-1):k(e,x,"$1");return""===t?void 0:t}}),a({global:!0,forced:!0},{Symbol:g})}},function(n,e,t){"use strict";var a,r,i=t(7),o=t(2),l=t(12),s=t(188),c=t(110),u=t(51),d=t(35),p=t(37).get,m=t(226),h=t(232),v=u("native-string-replace",String.prototype.replace),g=RegExp.prototype.exec,f=g,b=o("".charAt),y=o("".indexOf),x=o("".replace),k=o("".slice),w=(r=/b*/g,i(g,a=/a/,"a"),i(g,r,"a"),0!==a.lastIndex||0!==r.lastIndex),j=c.BROKEN_CARET,S=void 0!==/()??/.exec("")[1];(w||S||j||m||h)&&(f=function(n){var e,t,a,r,o,c,u,m=this,h=p(m),T=l(n),I=h.raw;if(I)return I.lastIndex=m.lastIndex,e=i(f,I,T),m.lastIndex=I.lastIndex,e;var C=h.groups,z=j&&m.sticky,E=i(s,m),A=m.source,M=0,J=T;if(z&&(E=x(E,"y",""),-1===y(E,"g")&&(E+="g"),J=k(T,m.lastIndex),m.lastIndex>0&&(!m.multiline||m.multiline&&"\n"!==b(T,m.lastIndex-1))&&(A="(?: "+A+")",J=" "+J,M++),t=new RegExp("^(?:"+A+")",E)),S&&(t=new RegExp("^"+A+"$(?!\\s)",E)),w&&(a=m.lastIndex),r=i(g,z?t:m,J),z?r?(r.input=k(r.input,M),r[0]=k(r[0],M),r.index=m.lastIndex,m.lastIndex+=r[0].length):m.lastIndex=0:w&&r&&(m.lastIndex=m.global?r.index+r[0].length:a),S&&r&&r.length>1&&i(v,r[0],t,(function(){for(o=1;o<arguments.length-2;o++)void 0===arguments[o]&&(r[o]=void 0)})),r&&C)for(r.groups=c=d(null),o=0;o<C.length;o++)c[(u=C[o])[0]]=r[u[1]];return r}),n.exports=f},function(n,e,t){var a=t(292),r=t(293),i=t(294),o=t(295),l=t(296);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}s.prototype.clear=a,s.prototype.delete=r,s.prototype.get=i,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e,t){var a=t(194);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(41)(Object,"create");n.exports=a},function(n,e,t){var a=t(314);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(135);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return r}));t(57),t(6),t(109),t(187),t(25),t(19),t(81);var a=t(78);function r(n,e){if(n){if("string"==typeof n)return Object(a.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(a.a)(n,e):void 0}}},function(n,e,t){var a,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,a.minimum,1),t.status=1===n?null:n;var s=t.render(!e),c=s.querySelector(a.barSelector),u=a.speed,d=a.easing;return s.offsetWidth,o((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),l(c,function(n,e,t){var r;return(r="translate3d"===a.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,r}(n,u,d)),1===n?(l(s,{transition:"none",opacity:1}),s.offsetWidth,setTimeout((function(){l(s,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var r,o=e.querySelector(a.barSelector),s=n?"-100":i(t.status||0),u=document.querySelector(a.parent);return l(o,{transition:"all 0 linear",transform:"translate3d("+s+"%,0,0)"}),a.showSpinner||(r=e.querySelector(a.spinnerSelector))&&p(r),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),l=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,r=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((a=n[r]+i)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,r,i=arguments;if(2==i.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&a(n,t,r);else a(n,i[1],i[2])}}();function s(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),a=t+e;s(t,e)||(n.className=a.substring(1))}function u(n,e){var t,a=d(n);s(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=r)},function(n,e,t){var a=t(1),r=t(16),i=t(88);a({target:"Object",stat:!0,forced:t(3)((function(){i(1)}))},{keys:function(n){return i(r(n))}})},function(n,e,t){var a=t(3),r=t(4),i=/#|\.prototype\./,o=function(n,e){var t=s[l(n)];return t==u||t!=c&&(r(e)?a(e):!!e)},l=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},s=o.data={},c=o.NATIVE="N",u=o.POLYFILL="P";n.exports=o},function(n,e,t){var a=t(82),r=t(48),i=t(69),o=t(5)("iterator");n.exports=function(n){if(null!=n)return r(n,o)||r(n,"@@iterator")||i[a(n)]}},function(n,e,t){var a=t(262);n.exports=function(n,e){return new(a(n))(0===e?0:e)}},function(n,e,t){var a=t(8),r=t(70).EXISTS,i=t(2),o=t(13).f,l=Function.prototype,s=i(l.toString),c=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,u=i(c.exec);a&&!r&&o(l,"name",{configurable:!0,get:function(){try{return u(c,s(this))[1]}catch(n){return""}}})},function(n,e,t){var a=t(3),r=t(0).RegExp,i=a((function(){var n=r("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),o=i||a((function(){return!r("a","y").sticky})),l=i||a((function(){var n=r("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:l,MISSED_STICKY:o,UNSUPPORTED_Y:i}},function(n,e,t){"use strict";t(19);var a=t(2),r=t(14),i=t(97),o=t(3),l=t(5),s=t(24),c=l("species"),u=RegExp.prototype;n.exports=function(n,e,t,d){var p=l(n),m=!o((function(){var e={};return e[p]=function(){return 7},7!=""[n](e)})),h=m&&!o((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[c]=function(){return t},t.flags="",t[p]=/./[p]),t.exec=function(){return e=!0,null},t[p](""),!e}));if(!m||!h||t){var v=a(/./[p]),g=e(p,""[n],(function(n,e,t,r,o){var l=a(n),s=e.exec;return s===i||s===u.exec?m&&!o?{done:!0,value:v(e,t,r)}:{done:!0,value:l(t,e,r)}:{done:!1}}));r(String.prototype,n,g[0]),r(u,p,g[1])}d&&s(u[p],"sham",!0)}},function(n,e,t){var a=t(0),r=t(7),i=t(10),o=t(4),l=t(23),s=t(97),c=a.TypeError;n.exports=function(n,e){var t=n.exec;if(o(t)){var a=r(t,n,e);return null!==a&&i(a),a}if("RegExp"===l(n))return r(s,n,e);throw c("RegExp#exec called on incompatible receiver")}},function(n,e,t){"use strict";var a=t(1),r=t(2),i=t(64),o=t(21),l=t(47),s=r([].join),c=i!=Object,u=l("join",",");a({target:"Array",proto:!0,forced:c||!u},{join:function(n){return s(o(this),void 0===n?",":n)}})},function(n,e,t){var a=t(0),r=t(115),i=a["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=i},function(n,e,t){var a=t(0),r=Object.defineProperty;n.exports=function(n,e){try{r(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(21),r=t(89),i=t(20),o=function(n){return function(e,t,o){var l,s=a(e),c=i(s),u=r(o,c);if(n&&t!=t){for(;c>u;)if((l=s[u++])!=l)return!0}else for(;c>u;u++)if((n||u in s)&&s[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,i=r&&!a.call({1:2},1);e.f=i?function(n){var e=r(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(9),r=t(163),i=t(38),o=t(13);n.exports=function(n,e,t){for(var l=r(e),s=o.f,c=i.f,u=0;u<l.length;u++){var d=l[u];a(n,d)||t&&a(t,d)||s(n,d,c(e,d))}}},function(n,e,t){var a=t(0),r=t(9),i=t(4),o=t(16),l=t(90),s=t(165),c=l("IE_PROTO"),u=a.Object,d=u.prototype;n.exports=s?u.getPrototypeOf:function(n){var e=o(n);if(r(e,c))return e[c];var t=e.constructor;return i(t)&&e instanceof t?t.prototype:e instanceof u?d:null}},function(n,e,t){var a=t(10),r=t(166),i=t(5)("species");n.exports=function(n,e){var t,o=a(n).constructor;return void 0===o||null==(t=a(o)[i])?e:r(t)}},function(n,e,t){var a={};a[t(5)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e,t){var a=t(0),r=t(89),i=t(20),o=t(56),l=a.Array,s=Math.max;n.exports=function(n,e,t){for(var a=i(n),c=r(e,a),u=r(void 0===t?a:t,a),d=l(s(u-c,0)),p=0;c<u;c++,p++)o(d,p,n[c]);return d.length=p,d}},function(n,e,t){var a=t(1),r=t(15),i=t(39),o=t(7),l=t(2),s=t(3),c=t(62),u=t(4),d=t(11),p=t(66),m=t(72),h=t(52),v=r("JSON","stringify"),g=l(/./.exec),f=l("".charAt),b=l("".charCodeAt),y=l("".replace),x=l(1..toString),k=/[\uD800-\uDFFF]/g,w=/^[\uD800-\uDBFF]$/,j=/^[\uDC00-\uDFFF]$/,S=!h||s((function(){var n=r("Symbol")();return"[null]"!=v([n])||"{}"!=v({a:n})||"{}"!=v(Object(n))})),T=s((function(){return'"\\udf06\\ud834"'!==v("\udf06\ud834")||'"\\udead"'!==v("\udead")})),I=function(n,e){var t=m(arguments),a=e;if((d(e)||void 0!==n)&&!p(n))return c(e)||(e=function(n,e){if(u(a)&&(e=o(a,this,n,e)),!p(e))return e}),t[1]=e,i(v,null,t)},C=function(n,e,t){var a=f(t,e-1),r=f(t,e+1);return g(w,n)&&!g(j,r)||g(j,n)&&!g(w,a)?"\\u"+x(b(n,0),16):n};v&&a({target:"JSON",stat:!0,forced:S||T},{stringify:function(n,e,t){var a=m(arguments),r=i(S?I:v,null,a);return T&&"string"==typeof r?y(r,k,C):r}})},function(n,e,t){t(185)("iterator")},function(n,e,t){"use strict";var a=t(175).charAt;n.exports=function(n,e,t){return e+(t?a(n,e).length:1)}},function(n,e,t){var a=t(286),r=t(50),i=Object.prototype,o=i.hasOwnProperty,l=i.propertyIsEnumerable,s=a(function(){return arguments}())?a:function(n){return r(n)&&o.call(n,"callee")&&!l.call(n,"callee")};n.exports=s},function(n,e,t){var a=t(41)(t(29),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(306),r=t(313),i=t(315),o=t(316),l=t(317);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}s.prototype.clear=a,s.prototype.delete=r,s.prototype.get=i,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(27),r=t(135),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(63),r=t(50);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.d(e,"a",(function(){return r}));t(84);t(83),t(96),t(6),t(126),t(25),t(32);var a=t(103);t(40),t(26);function r(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var a,r,i=[],o=!0,l=!1;try{for(t=t.call(n);!(o=(a=t.next()).done)&&(i.push(a.value),!e||i.length!==e);o=!0);}catch(n){l=!0,r=n}finally{try{o||null==t.return||t.return()}finally{if(l)throw r}}return i}}(n,e)||Object(a.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";var a=t(39),r=t(7),i=t(2),o=t(111),l=t(149),s=t(10),c=t(18),u=t(121),d=t(127),p=t(54),m=t(12),h=t(48),v=t(124),g=t(112),f=t(97),b=t(110),y=t(3),x=b.UNSUPPORTED_Y,k=Math.min,w=[].push,j=i(/./.exec),S=i(w),T=i("".slice);o("split",(function(n,e,t){var i;return i="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var i=m(c(this)),o=void 0===t?4294967295:t>>>0;if(0===o)return[];if(void 0===n)return[i];if(!l(n))return r(e,i,n,o);for(var s,u,d,p=[],h=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),g=0,b=new RegExp(n.source,h+"g");(s=r(f,b,i))&&!((u=b.lastIndex)>g&&(S(p,T(i,g,s.index)),s.length>1&&s.index<i.length&&a(w,p,v(s,1)),d=s[0].length,g=u,p.length>=o));)b.lastIndex===s.index&&b.lastIndex++;return g===i.length?!d&&j(b,"")||S(p,""):S(p,T(i,g)),p.length>o?v(p,0,o):p}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:r(e,this,n,t)}:e,[function(e,t){var a=c(this),o=null==e?void 0:h(e,n);return o?r(o,e,a,t):r(i,m(a),e,t)},function(n,a){var r=s(this),o=m(n),l=t(i,r,o,a,i!==e);if(l.done)return l.value;var c=u(r,RegExp),h=r.unicode,v=(r.ignoreCase?"i":"")+(r.multiline?"m":"")+(r.unicode?"u":"")+(x?"g":"y"),f=new c(x?"^(?:"+r.source+")":r,v),b=void 0===a?4294967295:a>>>0;if(0===b)return[];if(0===o.length)return null===g(f,o)?[o]:[];for(var y=0,w=0,j=[];w<o.length;){f.lastIndex=x?0:w;var I,C=g(f,x?T(o,w):o);if(null===C||(I=k(p(f.lastIndex+(x?w:0)),o.length))===y)w=d(o,w,h);else{if(S(j,T(o,y,w)),j.length===b)return j;for(var z=1;z<=C.length-1;z++)if(S(j,C[z]),j.length===b)return j;w=y=I}}return S(j,T(o,y)),j}]}),!!y((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),x)},function(n,e,t){"use strict";var a=t(1),r=t(59).some;a({target:"Array",proto:!0,forced:!t(47)("some")},{some:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a=t(7),r=t(111),i=t(10),o=t(54),l=t(12),s=t(18),c=t(48),u=t(127),d=t(112);r("match",(function(n,e,t){return[function(e){var t=s(this),r=null==e?void 0:c(e,n);return r?a(r,e,t):new RegExp(e)[n](l(t))},function(n){var a=i(this),r=l(n),s=t(e,a,r);if(s.done)return s.value;if(!a.global)return d(a,r);var c=a.unicode;a.lastIndex=0;for(var p,m=[],h=0;null!==(p=d(a,r));){var v=l(p[0]);m[h]=v,""===v&&(a.lastIndex=u(r,o(a.lastIndex),c)),h++}return 0===h?null:m}]}))},function(n,e,t){var a=t(5),r=t(35),i=t(13),o=a("unscopables"),l=Array.prototype;null==l[o]&&i.f(l,o,{configurable:!0,value:r(null)}),n.exports=function(n){l[o][n]=!0}},function(n,e,t){var a=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,a="function"==typeof Symbol?Symbol:{},r=a.iterator||"@@iterator",i=a.asyncIterator||"@@asyncIterator",o=a.toStringTag||"@@toStringTag";function l(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{l({},"")}catch(n){l=function(n,e,t){return n[e]=t}}function s(n,e,t,a){var r=e&&e.prototype instanceof d?e:d,i=Object.create(r.prototype),o=new j(a||[]);return i._invoke=function(n,e,t){var a="suspendedStart";return function(r,i){if("executing"===a)throw new Error("Generator is already running");if("completed"===a){if("throw"===r)throw i;return T()}for(t.method=r,t.arg=i;;){var o=t.delegate;if(o){var l=x(o,t);if(l){if(l===u)continue;return l}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===a)throw a="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);a="executing";var s=c(n,e,t);if("normal"===s.type){if(a=t.done?"completed":"suspendedYield",s.arg===u)continue;return{value:s.arg,done:t.done}}"throw"===s.type&&(a="completed",t.method="throw",t.arg=s.arg)}}}(n,t,o),i}function c(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=s;var u={};function d(){}function p(){}function m(){}var h={};l(h,r,(function(){return this}));var v=Object.getPrototypeOf,g=v&&v(v(S([])));g&&g!==e&&t.call(g,r)&&(h=g);var f=m.prototype=d.prototype=Object.create(h);function b(n){["next","throw","return"].forEach((function(e){l(n,e,(function(n){return this._invoke(e,n)}))}))}function y(n,e){var a;this._invoke=function(r,i){function o(){return new e((function(a,o){!function a(r,i,o,l){var s=c(n[r],n,i);if("throw"!==s.type){var u=s.arg,d=u.value;return d&&"object"==typeof d&&t.call(d,"__await")?e.resolve(d.__await).then((function(n){a("next",n,o,l)}),(function(n){a("throw",n,o,l)})):e.resolve(d).then((function(n){u.value=n,o(u)}),(function(n){return a("throw",n,o,l)}))}l(s.arg)}(r,i,a,o)}))}return a=a?a.then(o,o):o()}}function x(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,x(n,e),"throw"===e.method))return u;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return u}var a=c(t,n.iterator,e.arg);if("throw"===a.type)return e.method="throw",e.arg=a.arg,e.delegate=null,u;var r=a.arg;return r?r.done?(e[n.resultName]=r.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,u):r:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,u)}function k(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function w(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function j(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(k,this),this.reset(!0)}function S(n){if(n){var e=n[r];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var a=-1,i=function e(){for(;++a<n.length;)if(t.call(n,a))return e.value=n[a],e.done=!1,e;return e.value=void 0,e.done=!0,e};return i.next=i}}return{next:T}}function T(){return{value:void 0,done:!0}}return p.prototype=m,l(f,"constructor",m),l(m,"constructor",p),p.displayName=l(m,o,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===p||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,m):(n.__proto__=m,l(n,o,"GeneratorFunction")),n.prototype=Object.create(f),n},n.awrap=function(n){return{__await:n}},b(y.prototype),l(y.prototype,i,(function(){return this})),n.AsyncIterator=y,n.async=function(e,t,a,r,i){void 0===i&&(i=Promise);var o=new y(s(e,t,a,r),i);return n.isGeneratorFunction(t)?o:o.next().then((function(n){return n.done?n.value:o.next()}))},b(f),l(f,o,"Generator"),l(f,r,(function(){return this})),l(f,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var a=e.pop();if(a in n)return t.value=a,t.done=!1,t}return t.done=!0,t}},n.values=S,j.prototype={constructor:j,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(w),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function a(t,a){return o.type="throw",o.arg=n,e.next=t,a&&(e.method="next",e.arg=void 0),!!a}for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r],o=i.completion;if("root"===i.tryLoc)return a("end");if(i.tryLoc<=this.prev){var l=t.call(i,"catchLoc"),s=t.call(i,"finallyLoc");if(l&&s){if(this.prev<i.catchLoc)return a(i.catchLoc,!0);if(this.prev<i.finallyLoc)return a(i.finallyLoc)}else if(l){if(this.prev<i.catchLoc)return a(i.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return a(i.finallyLoc)}}}},abrupt:function(n,e){for(var a=this.tryEntries.length-1;a>=0;--a){var r=this.tryEntries[a];if(r.tryLoc<=this.prev&&t.call(r,"finallyLoc")&&this.prev<r.finallyLoc){var i=r;break}}i&&("break"===n||"continue"===n)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=n,o.arg=e,i?(this.method="next",this.next=i.finallyLoc,u):this.complete(o)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),u},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),w(t),u}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var a=t.completion;if("throw"===a.type){var r=a.arg;w(t)}return r}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:S(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),u}},n}(n.exports);try{regeneratorRuntime=a}catch(n){"object"==typeof globalThis?globalThis.regeneratorRuntime=a:Function("r","regeneratorRuntime = r")(a)}},function(n,e,t){var a=t(1),r=t(8),i=t(13).f;a({target:"Object",stat:!0,forced:Object.defineProperty!==i,sham:!r},{defineProperty:i})},function(n,e,t){"use strict";var a=t(70).PROPER,r=t(14),i=t(10),o=t(12),l=t(3),s=t(238),c=RegExp.prototype.toString,u=l((function(){return"/a/b"!=c.call({source:"a",flags:"b"})})),d=a&&"toString"!=c.name;(u||d)&&r(RegExp.prototype,"toString",(function(){var n=i(this);return"/"+o(n.source)+"/"+o(s(n))}),{unsafe:!0})},function(n,e,t){"use strict";var a=t(21),r=t(141),i=t(69),o=t(37),l=t(13).f,s=t(162),c=t(17),u=t(8),d=o.set,p=o.getterFor("Array Iterator");n.exports=s(Array,"Array",(function(n,e){d(this,{type:"Array Iterator",target:a(n),index:0,kind:e})}),(function(){var n=p(this),e=n.target,t=n.kind,a=n.index++;return!e||a>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:a,done:!1}:"values"==t?{value:e[a],done:!1}:{value:[a,e[a]],done:!1}}),"values");var m=i.Arguments=i.Array;if(r("keys"),r("values"),r("entries"),!c&&u&&"values"!==m.name)try{l(m,"name",{value:"values"})}catch(n){}},function(n,e,t){var a=t(8),r=t(157),i=t(13),o=t(10),l=t(21),s=t(88);e.f=a&&!r?Object.defineProperties:function(n,e){o(n);for(var t,a=l(e),r=s(e),c=r.length,u=0;c>u;)i.f(n,t=r[u++],a[t]);return n}},function(n,e,t){var a=t(0).TypeError;n.exports=function(n,e){if(n<e)throw a("Not enough arguments");return n}},function(n,e,t){var a=t(0),r=t(7),i=t(22),o=t(10),l=t(67),s=t(107),c=a.TypeError;n.exports=function(n,e){var t=arguments.length<2?s(n):e;if(i(t))return o(r(t,n));throw c(l(n)+" is not iterable")}},function(n,e,t){var a=t(11),r=t(23),i=t(5)("match");n.exports=function(n){var e;return a(n)&&(void 0!==(e=n[i])?!!e:"RegExp"==r(n))}},function(n,e,t){var a=t(4),r=t(11),i=t(71);n.exports=function(n,e,t){var o,l;return i&&a(o=e.constructor)&&o!==t&&r(l=o.prototype)&&l!==t.prototype&&i(n,l),n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,l="object"==typeof global&&global&&global.Object===Object&&global,s="object"==typeof self&&self&&self.Object===Object&&self,c=l||s||Function("return this")(),u=Object.prototype.toString,d=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function v(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var l=r.test(n);return l||i.test(n)?o(n.slice(2),l?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,r,i,o,l,s,c=0,u=!1,g=!1,f=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=a,i=r;return a=r=void 0,c=e,o=n.apply(i,t)}function y(n){return c=n,l=setTimeout(k,e),u?b(n):o}function x(n){var t=n-s;return void 0===s||t>=e||t<0||g&&n-c>=i}function k(){var n=m();if(x(n))return w(n);l=setTimeout(k,function(n){var t=e-(n-s);return g?p(t,i-(n-c)):t}(n))}function w(n){return l=void 0,f&&a?b(n):(a=r=void 0,o)}function j(){var n=m(),t=x(n);if(a=arguments,r=this,s=n,t){if(void 0===l)return y(s);if(g)return l=setTimeout(k,e),b(s)}return void 0===l&&(l=setTimeout(k,e)),o}return e=v(e)||0,h(t)&&(u=!!t.leading,i=(g="maxWait"in t)?d(v(t.maxWait)||0,e):i,f="trailing"in t?!!t.trailing:f),j.cancel=function(){void 0!==l&&clearTimeout(l),c=0,a=s=r=l=void 0},j.flush=function(){return void 0===l?o:w(m())},j}},function(n,e,t){var a=t(2),r=t(18),i=t(12),o=t(154),l=a("".replace),s="["+o+"]",c=RegExp("^"+s+s+"*"),u=RegExp(s+s+"*$"),d=function(n){return function(e){var t=i(r(e));return 1&n&&(t=l(t,c,"")),2&n&&(t=l(t,u,"")),t}};n.exports={start:d(1),end:d(2),trim:d(3)}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){var a=t(2),r=t(14),i=Date.prototype,o=a(i.toString),l=a(i.getTime);"Invalid Date"!=String(new Date(NaN))&&r(i,"toString",(function(){var n=l(this);return n==n?o(this):"Invalid Date"}))},function(n,e,t){var a=t(52);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(8),r=t(3);n.exports=a&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(8),r=t(3),i=t(86);n.exports=!a&&!r((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(0),r=t(7),i=t(11),o=t(66),l=t(48),s=t(242),c=t(5),u=a.TypeError,d=c("toPrimitive");n.exports=function(n,e){if(!i(n)||o(n))return n;var t,a=l(n,d);if(a){if(void 0===e&&(e="default"),t=r(a,n,e),!i(t)||o(t))return t;throw u("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var a=t(2),r=t(9),i=t(21),o=t(116).indexOf,l=t(68),s=a([].push);n.exports=function(n,e){var t,a=i(n),c=0,u=[];for(t in a)!r(l,t)&&r(a,t)&&s(u,t);for(;e.length>c;)r(a,t=e[c++])&&(~o(u,t)||s(u,t));return u}},function(n,e,t){var a=t(15);n.exports=a("document","documentElement")},function(n,e,t){"use strict";var a=t(1),r=t(7),i=t(17),o=t(70),l=t(4),s=t(227),c=t(120),u=t(71),d=t(61),p=t(24),m=t(14),h=t(5),v=t(69),g=t(164),f=o.PROPER,b=o.CONFIGURABLE,y=g.IteratorPrototype,x=g.BUGGY_SAFARI_ITERATORS,k=h("iterator"),w=function(){return this};n.exports=function(n,e,t,o,h,g,j){s(t,e,o);var S,T,I,C=function(n){if(n===h&&J)return J;if(!x&&n in A)return A[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},z=e+" Iterator",E=!1,A=n.prototype,M=A[k]||A["@@iterator"]||h&&A[h],J=!x&&M||C(h),L="Array"==e&&A.entries||M;if(L&&(S=c(L.call(new n)))!==Object.prototype&&S.next&&(i||c(S)===y||(u?u(S,y):l(S[k])||m(S,k,w)),d(S,z,!0,!0),i&&(v[z]=w)),f&&"values"==h&&M&&"values"!==M.name&&(!i&&b?p(A,"name","values"):(E=!0,J=function(){return r(M,this)})),h)if(T={values:C("values"),keys:g?J:C("keys"),entries:C("entries")},j)for(I in T)(x||E||!(I in A))&&m(A,I,T[I]);else a({target:e,proto:!0,forced:x||E},T);return i&&!j||A[k]===J||m(A,k,J,{name:h}),v[e]=J,T}},function(n,e,t){var a=t(15),r=t(2),i=t(60),o=t(92),l=t(10),s=r([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=i.f(l(n)),t=o.f;return t?s(e,t(n)):e}},function(n,e,t){"use strict";var a,r,i,o=t(3),l=t(4),s=t(35),c=t(120),u=t(14),d=t(5),p=t(17),m=d("iterator"),h=!1;[].keys&&("next"in(i=[].keys())?(r=c(c(i)))!==Object.prototype&&(a=r):h=!0),null==a||o((function(){var n={};return a[m].call(n)!==n}))?a={}:p&&(a=s(a)),l(a[m])||u(a,m,(function(){return this})),n.exports={IteratorPrototype:a,BUGGY_SAFARI_ITERATORS:h}},function(n,e,t){var a=t(3);n.exports=!a((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var a=t(0),r=t(94),i=t(67),o=a.TypeError;n.exports=function(n){if(r(n))return n;throw o(i(n)+" is not a constructor")}},function(n,e,t){var a,r,i,o,l=t(0),s=t(39),c=t(58),u=t(4),d=t(9),p=t(3),m=t(161),h=t(72),v=t(86),g=t(147),f=t(168),b=t(93),y=l.setImmediate,x=l.clearImmediate,k=l.process,w=l.Dispatch,j=l.Function,S=l.MessageChannel,T=l.String,I=0,C={};try{a=l.location}catch(n){}var z=function(n){if(d(C,n)){var e=C[n];delete C[n],e()}},E=function(n){return function(){z(n)}},A=function(n){z(n.data)},M=function(n){l.postMessage(T(n),a.protocol+"//"+a.host)};y&&x||(y=function(n){g(arguments.length,1);var e=u(n)?n:j(n),t=h(arguments,1);return C[++I]=function(){s(e,void 0,t)},r(I),I},x=function(n){delete C[n]},b?r=function(n){k.nextTick(E(n))}:w&&w.now?r=function(n){w.now(E(n))}:S&&!f?(o=(i=new S).port2,i.port1.onmessage=A,r=c(o.postMessage,o)):l.addEventListener&&u(l.postMessage)&&!l.importScripts&&a&&"file:"!==a.protocol&&!p(M)?(r=M,l.addEventListener("message",A,!1)):r="onreadystatechange"in v("script")?function(n){m.appendChild(v("script")).onreadystatechange=function(){m.removeChild(this),z(n)}}:function(n){setTimeout(E(n),0)}),n.exports={set:y,clear:x}},function(n,e,t){var a=t(28);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(a)},function(n,e,t){var a=t(0),r=t(58),i=t(7),o=t(10),l=t(67),s=t(170),c=t(20),u=t(36),d=t(148),p=t(107),m=t(171),h=a.TypeError,v=function(n,e){this.stopped=n,this.result=e},g=v.prototype;n.exports=function(n,e,t){var a,f,b,y,x,k,w,j=t&&t.that,S=!(!t||!t.AS_ENTRIES),T=!(!t||!t.IS_ITERATOR),I=!(!t||!t.INTERRUPTED),C=r(e,j),z=function(n){return a&&m(a,"normal",n),new v(!0,n)},E=function(n){return S?(o(n),I?C(n[0],n[1],z):C(n[0],n[1])):I?C(n,z):C(n)};if(T)a=n;else{if(!(f=p(n)))throw h(l(n)+" is not iterable");if(s(f)){for(b=0,y=c(n);y>b;b++)if((x=E(n[b]))&&u(g,x))return x;return new v(!1)}a=d(n,f)}for(k=a.next;!(w=i(k,a)).done;){try{x=E(w.value)}catch(n){m(a,"throw",n)}if("object"==typeof x&&x&&u(g,x))return x}return new v(!1)}},function(n,e,t){var a=t(5),r=t(69),i=a("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(r.Array===n||o[i]===n)}},function(n,e,t){var a=t(7),r=t(10),i=t(48);n.exports=function(n,e,t){var o,l;r(n);try{if(!(o=i(n,"return"))){if("throw"===e)throw t;return t}o=a(o,n)}catch(n){l=!0,o=n}if("throw"===e)throw t;if(l)throw o;return r(o),t}},function(n,e,t){var a=t(55),r=t(173),i=t(73).CONSTRUCTOR;n.exports=i||!r((function(n){a.all(n).then(void 0,(function(){}))}))},function(n,e,t){var a=t(5)("iterator"),r=!1;try{var i=0,o={next:function(){return{done:!!i++}},return:function(){r=!0}};o[a]=function(){return this},Array.from(o,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!r)return!1;var t=!1;try{var i={};i[a]=function(){return{next:function(){return{done:t=!0}}}},n(i)}catch(n){}return t}},function(n,e,t){var a=t(10),r=t(11),i=t(74);n.exports=function(n,e){if(a(n),r(e)&&e.constructor===n)return e;var t=i.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){var a=t(2),r=t(46),i=t(12),o=t(18),l=a("".charAt),s=a("".charCodeAt),c=a("".slice),u=function(n){return function(e,t){var a,u,d=i(o(e)),p=r(t),m=d.length;return p<0||p>=m?n?"":void 0:(a=s(d,p))<55296||a>56319||p+1===m||(u=s(d,p+1))<56320||u>57343?n?l(d,p):a:n?c(d,p,p+2):u-56320+(a-55296<<10)+65536}};n.exports={codeAt:u(!1),charAt:u(!0)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var a=t(86)("span").classList,r=a&&a.constructor&&a.constructor.prototype;n.exports=r===Object.prototype?void 0:r},function(n,e,t){var a=t(1),r=t(3),i=t(16),o=t(120),l=t(165);a({target:"Object",stat:!0,forced:r((function(){o(1)})),sham:!l},{getPrototypeOf:function(n){return o(i(n))}})},function(n,e,t){var a=t(0),r=t(149),i=a.TypeError;n.exports=function(n){if(r(n))throw i("The method doesn't accept regular expressions");return n}},function(n,e,t){var a=t(5)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[a]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){"use strict";var a=t(59).forEach,r=t(47)("forEach");n.exports=r?[].forEach:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var a=t(3);n.exports=!a((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var a=t(23),r=t(21),i=t(60).f,o=t(124),l="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return l&&"Window"==a(n)?function(n){try{return i(n)}catch(n){return o(l)}}(n):i(r(n))}},function(n,e,t){var a=t(5);e.f=a},function(n,e,t){var a=t(271),r=t(9),i=t(184),o=t(13).f;n.exports=function(n){var e=a.Symbol||(a.Symbol={});r(e,n)||o(e,n,{value:i.f(n)})}},function(n,e,t){var a=t(52);n.exports=a&&!!Symbol.for&&!!Symbol.keyFor},function(n,e,t){var a=t(1),r=t(276);a({target:"Array",stat:!0,forced:!t(173)((function(n){Array.from(n)}))},{from:r})},function(n,e,t){"use strict";var a=t(10);n.exports=function(){var n=a(this),e="";return n.hasIndices&&(e+="d"),n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var a=t(12);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){t(1)({target:"Object",stat:!0,sham:!t(8)},{create:t(35)})},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,r=n.length;++t<a;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(98),r=t(297),i=t(298),o=t(299),l=t(300),s=t(301);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=l,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(63),r=t(130);n.exports=function(n){if(!r(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(318),r=t(50);n.exports=function n(e,t,i,o,l){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:a(e,t,i,o,n,l))}},function(n,e,t){var a=t(199),r=t(321),i=t(200);n.exports=function(n,e,t,o,l,s){var c=1&t,u=n.length,d=e.length;if(u!=d&&!(c&&d>u))return!1;var p=s.get(n),m=s.get(e);if(p&&m)return p==e&&m==n;var h=-1,v=!0,g=2&t?new a:void 0;for(s.set(n,e),s.set(e,n);++h<u;){var f=n[h],b=e[h];if(o)var y=c?o(b,f,h,e,n,s):o(f,b,h,n,e,s);if(void 0!==y){if(y)continue;v=!1;break}if(g){if(!r(e,(function(n,e){if(!i(g,e)&&(f===n||l(f,n,t,o,s)))return g.push(e)}))){v=!1;break}}else if(f!==b&&!l(f,b,t,o,s)){v=!1;break}}return s.delete(n),s.delete(e),v}},function(n,e,t){var a=t(131),r=t(319),i=t(320);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=r,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(331),r=t(337),i=t(205);n.exports=function(n){return i(n)?a(n):r(n)}},function(n,e,t){(function(n){var a=t(29),r=t(333),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,l=o&&o.exports===i?a.Buffer:void 0,s=(l?l.isBuffer:void 0)||r;n.exports=s}).call(this,t(151)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(334),r=t(335),i=t(336),o=i&&i.isTypedArray,l=o?r(o):a;n.exports=l},function(n,e,t){var a=t(195),r=t(133);n.exports=function(n){return null!=n&&r(n.length)&&!a(n)}},function(n,e,t){var a=t(41)(t(29),"Set");n.exports=a},function(n,e,t){var a=t(130);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(210),r=t(102);n.exports=function(n,e){for(var t=0,i=(e=a(e,n)).length;null!=n&&t<i;)n=n[r(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var a=t(27),r=t(134),i=t(348),o=t(351);n.exports=function(n,e){return a(n)?n:r(n,e)?[n]:i(o(n))}},function(n,e,t){var a=t(0),r=t(39),i=t(4),o=t(28),l=t(72),s=t(147),c=/MSIE .\./.test(o),u=a.Function,d=function(n){return c?function(e,t){var a=s(arguments.length,1)>2,o=i(e)?e:u(e),c=a?l(arguments,2):void 0;return n(a?function(){r(o,this,c)}:o,t)}:n};n.exports={setTimeout:d(a.setTimeout),setInterval:d(a.setInterval)}},function(n,e,t){"use strict";var a=t(0),r=t(2),i=t(22),o=t(11),l=t(9),s=t(72),c=t(65),u=a.Function,d=r([].concat),p=r([].join),m={},h=function(n,e,t){if(!l(m,e)){for(var a=[],r=0;r<e;r++)a[r]="a["+r+"]";m[e]=u("C,a","return new C("+p(a,",")+")")}return m[e](n,t)};n.exports=c?u.bind:function(n){var e=i(this),t=e.prototype,a=s(arguments,1),r=function(){var t=d(a,s(arguments));return this instanceof r?h(e,t.length,t):e.apply(n,t)};return o(t)&&(r.prototype=t),r}},function(n,e,t){"use strict";var a=t(1),r=t(385).start;a({target:"String",proto:!0,forced:t(387)},{padStart:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){},function(n,e,t){},function(n,e,t){t(1)({target:"Object",stat:!0},{setPrototypeOf:t(71)})},function(n,e,t){var a=t(1),r=t(15),i=t(39),o=t(212),l=t(166),s=t(10),c=t(11),u=t(35),d=t(3),p=r("Reflect","construct"),m=Object.prototype,h=[].push,v=d((function(){function n(){}return!(p((function(){}),[],n)instanceof n)})),g=!d((function(){p((function(){}))})),f=v||g;a({target:"Reflect",stat:!0,forced:f,sham:f},{construct:function(n,e){l(n),s(e);var t=arguments.length<3?n:l(arguments[2]);if(g&&!v)return p(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var a=[null];return i(h,a,e),new(i(o,n,a))}var r=t.prototype,d=u(c(r)?r:m),f=i(n,d,e);return c(f)?f:d}})},function(n,e,t){var a=t(1),r=t(0),i=t(61);a({global:!0},{Reflect:{}}),i(r.Reflect,"Reflect",!0)},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(284),r=t(289),i=t(360),o=t(368),l=t(377),s=t(236),c=i((function(n){var e=s(n);return l(e)&&(e=void 0),o(a(n,1,l,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=a.exec(t);if(!r)return t;var i="",o=0,l=0;for(o=r.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}l!==o&&(i+=t.substring(l,o)),l=o+1,i+=e}return l!==o?i+t.substring(l,o):i}},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(388),t(30)),i=Object(r.a)(a,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);t(33),t(6),t(34),t(44),t(31);var a={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(e,t){return""===e.componentOptions.propsData.active&&(n.activeCodeTabIndex=t),{title:e.componentOptions.propsData.title,elm:e.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},r=(t(389),t(30)),i=Object(r.a)(a,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(e,a){return t("li",{key:e.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(e.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e,t){"use strict";var a=t(8),r=t(0),i=t(2),o=t(106),l=t(14),s=t(9),c=t(150),u=t(36),d=t(66),p=t(159),m=t(3),h=t(60).f,v=t(38).f,g=t(13).f,f=t(384),b=t(153).trim,y=r.Number,x=y.prototype,k=r.TypeError,w=i("".slice),j=i("".charCodeAt),S=function(n){var e=p(n,"number");return"bigint"==typeof e?e:T(e)},T=function(n){var e,t,a,r,i,o,l,s,c=p(n,"number");if(d(c))throw k("Cannot convert a Symbol value to a number");if("string"==typeof c&&c.length>2)if(c=b(c),43===(e=j(c,0))||45===e){if(88===(t=j(c,2))||120===t)return NaN}else if(48===e){switch(j(c,1)){case 66:case 98:a=2,r=49;break;case 79:case 111:a=8,r=55;break;default:return+c}for(o=(i=w(c,2)).length,l=0;l<o;l++)if((s=j(i,l))<48||s>r)return NaN;return parseInt(i,a)}return+c};if(o("Number",!y(" 0o1")||!y("0b1")||y("+0x1"))){for(var I,C=function(n){var e=arguments.length<1?0:y(S(n)),t=this;return u(x,t)&&m((function(){f(t)}))?c(Object(e),t,C):e},z=a?h(y):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),E=0;z.length>E;E++)s(y,I=z[E])&&!s(C,I)&&g(C,I,v(y,I));C.prototype=x,x.constructor=C,l(r,"Number",C)}},function(n,e,t){var a=t(3),r=t(0).RegExp;n.exports=a((function(){var n=r(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){"use strict";var a=t(164).IteratorPrototype,r=t(35),i=t(49),o=t(61),l=t(69),s=function(){return this};n.exports=function(n,e,t,c){var u=e+" Iterator";return n.prototype=r(a,{next:i(+!c,t)}),o(n,u,!1,!0),l[u]=s,n}},function(n,e,t){var a=t(14);n.exports=function(n,e,t){for(var r in e)a(n,r,e[r],t);return n}},function(n,e,t){"use strict";var a=t(15),r=t(13),i=t(5),o=t(8),l=i("species");n.exports=function(n){var e=a(n),t=r.f;o&&e&&!e[l]&&t(e,l,{configurable:!0,get:function(){return this}})}},function(n,e,t){var a=t(0),r=t(36),i=a.TypeError;n.exports=function(n,e){if(r(e,n))return n;throw i("Incorrect invocation")}},function(n,e,t){var a=t(1),r=t(8),i=t(163),o=t(21),l=t(38),s=t(56);a({target:"Object",stat:!0,sham:!r},{getOwnPropertyDescriptors:function(n){for(var e,t,a=o(n),r=l.f,c=i(a),u={},d=0;c.length>d;)void 0!==(t=r(a,e=c[d++]))&&s(u,e,t);return u}})},function(n,e,t){var a=t(3),r=t(0).RegExp;n.exports=a((function(){var n=r("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e,t){var a=t(13).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var a=t(1),r=t(116).includes,i=t(141);a({target:"Array",proto:!0},{includes:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}}),i("includes")},function(n,e,t){"use strict";var a=t(1),r=t(2),i=t(179),o=t(18),l=t(12),s=t(180),c=r("".indexOf);a({target:"String",proto:!0,forced:!s("includes")},{includes:function(n){return!!~c(l(o(this)),l(i(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var a=t(1),r=t(153).trim;a({target:"String",proto:!0,forced:t(382)("trim")},{trim:function(){return r(this)}})},function(n,e,t){var a=t(7),r=t(9),i=t(36),o=t(188),l=RegExp.prototype;n.exports=function(n){var e=n.flags;return void 0!==e||"flags"in l||r(n,"flags")||!i(l,n)?e:a(o,n)}},function(n,e,t){var a=t(124),r=Math.floor,i=function(n,e){var t=n.length,s=r(t/2);return t<8?o(n,e):l(n,i(a(n,0,s),e),i(a(n,s),e),e)},o=function(n,e){for(var t,a,r=n.length,i=1;i<r;){for(a=i,t=n[i];a&&e(n[a-1],t)>0;)n[a]=n[--a];a!==i++&&(n[a]=t)}return n},l=function(n,e,t,a){for(var r=e.length,i=t.length,o=0,l=0;o<r||l<i;)n[o+l]=o<r&&l<i?a(e[o],t[l])<=0?e[o++]:t[l++]:o<r?e[o++]:t[l++];return n};n.exports=i},function(n,e,t){var a=t(0),r=t(8),i=t(110).MISSED_STICKY,o=t(23),l=t(13).f,s=t(37).get,c=RegExp.prototype,u=a.TypeError;r&&i&&l(c,"sticky",{configurable:!0,get:function(){if(this!==c){if("RegExp"===o(this))return!!s(this).sticky;throw u("Incompatible receiver, RegExp required")}}})},function(n,e,t){n.exports=t(399)},function(n,e,t){var a=t(0),r=t(7),i=t(4),o=t(11),l=a.TypeError;n.exports=function(n,e){var t,a;if("string"===e&&i(t=n.toString)&&!o(a=r(t,n)))return a;if(i(t=n.valueOf)&&!o(a=r(t,n)))return a;if("string"!==e&&i(t=n.toString)&&!o(a=r(t,n)))return a;throw l("Can't convert object to primitive value")}},function(n,e,t){var a=t(0),r=t(4),i=t(91),o=a.WeakMap;n.exports=r(o)&&/native code/.test(i(o))},function(n,e,t){var a=t(0),r=t(4),i=a.String,o=a.TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw o("Can't set "+i(n)+" as a prototype")}},function(n,e,t){t(246),t(253),t(254),t(255),t(256),t(257)},function(n,e,t){"use strict";var a,r,i,o=t(1),l=t(17),s=t(93),c=t(0),u=t(7),d=t(14),p=t(228),m=t(71),h=t(61),v=t(229),g=t(22),f=t(4),b=t(11),y=t(230),x=t(121),k=t(167).set,w=t(247),j=t(250),S=t(123),T=t(251),I=t(37),C=t(55),z=t(73),E=t(74),A=z.CONSTRUCTOR,M=z.REJECTION_EVENT,J=z.SUBCLASSING,L=I.getterFor("Promise"),O=I.set,P=C&&C.prototype,_=C,D=P,R=c.TypeError,B=c.document,F=c.process,N=E.f,q=N,V=!!(B&&B.createEvent&&c.dispatchEvent),U=function(n){var e;return!(!b(n)||!f(e=n.then))&&e},H=function(n,e){var t,a,r,i=e.value,o=1==e.state,l=o?n.ok:n.fail,s=n.resolve,c=n.reject,d=n.domain;try{l?(o||(2===e.rejection&&X(e),e.rejection=1),!0===l?t=i:(d&&d.enter(),t=l(i),d&&(d.exit(),r=!0)),t===n.promise?c(R("Promise-chain cycle")):(a=U(t))?u(a,t,s,c):s(t)):c(i)}catch(n){d&&!r&&d.exit(),c(n)}},G=function(n,e){n.notified||(n.notified=!0,w((function(){for(var t,a=n.reactions;t=a.get();)H(t,n);n.notified=!1,e&&!n.rejection&&W(n)})))},$=function(n,e,t){var a,r;V?((a=B.createEvent("Event")).promise=e,a.reason=t,a.initEvent(n,!1,!0),c.dispatchEvent(a)):a={promise:e,reason:t},!M&&(r=c["on"+n])?r(a):"unhandledrejection"===n&&j("Unhandled promise rejection",t)},W=function(n){u(k,c,(function(){var e,t=n.facade,a=n.value;if(K(n)&&(e=S((function(){s?F.emit("unhandledRejection",a,t):$("unhandledrejection",t,a)})),n.rejection=s||K(n)?2:1,e.error))throw e.value}))},K=function(n){return 1!==n.rejection&&!n.parent},X=function(n){u(k,c,(function(){var e=n.facade;s?F.emit("rejectionHandled",e):$("rejectionhandled",e,n.value)}))},Q=function(n,e,t){return function(a){n(e,a,t)}},Y=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,G(n,!0))},Z=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw R("Promise can't be resolved itself");var a=U(e);a?w((function(){var t={done:!1};try{u(a,e,Q(Z,t,n),Q(Y,t,n))}catch(e){Y(t,e,n)}})):(n.value=e,n.state=1,G(n,!1))}catch(e){Y({done:!1},e,n)}}};if(A&&(D=(_=function(n){y(this,D),g(n),u(a,this);var e=L(this);try{n(Q(Z,e),Q(Y,e))}catch(n){Y(e,n)}}).prototype,(a=function(n){O(this,{type:"Promise",done:!1,notified:!1,parent:!1,reactions:new T,rejection:!1,state:0,value:void 0})}).prototype=p(D,{then:function(n,e){var t=L(this),a=N(x(this,_));return t.parent=!0,a.ok=!f(n)||n,a.fail=f(e)&&e,a.domain=s?F.domain:void 0,0==t.state?t.reactions.add(a):w((function(){H(a,t)})),a.promise}}),r=function(){var n=new a,e=L(n);this.promise=n,this.resolve=Q(Z,e),this.reject=Q(Y,e)},E.f=N=function(n){return n===_||void 0===n?new r(n):q(n)},!l&&f(C)&&P!==Object.prototype)){i=P.then,J||d(P,"then",(function(n,e){var t=this;return new _((function(n,e){u(i,t,n,e)})).then(n,e)}),{unsafe:!0});try{delete P.constructor}catch(n){}m&&m(P,D)}o({global:!0,wrap:!0,forced:A},{Promise:_}),h(_,"Promise",!1,!0),v("Promise")},function(n,e,t){var a,r,i,o,l,s,c,u,d=t(0),p=t(58),m=t(38).f,h=t(167).set,v=t(168),g=t(248),f=t(249),b=t(93),y=d.MutationObserver||d.WebKitMutationObserver,x=d.document,k=d.process,w=d.Promise,j=m(d,"queueMicrotask"),S=j&&j.value;S||(a=function(){var n,e;for(b&&(n=k.domain)&&n.exit();r;){e=r.fn,r=r.next;try{e()}catch(n){throw r?o():i=void 0,n}}i=void 0,n&&n.enter()},v||b||f||!y||!x?!g&&w&&w.resolve?((c=w.resolve(void 0)).constructor=w,u=p(c.then,c),o=function(){u(a)}):b?o=function(){k.nextTick(a)}:(h=p(h,d),o=function(){h(a)}):(l=!0,s=x.createTextNode(""),new y(a).observe(s,{characterData:!0}),o=function(){s.data=l=!l})),n.exports=S||function(n){var e={fn:n,next:void 0};i&&(i.next=e),r||(r=e,o()),i=e}},function(n,e,t){var a=t(28),r=t(0);n.exports=/ipad|iphone|ipod/i.test(a)&&void 0!==r.Pebble},function(n,e,t){var a=t(28);n.exports=/web0s(?!.*chrome)/i.test(a)},function(n,e,t){var a=t(0);n.exports=function(n,e){var t=a.console;t&&t.error&&(1==arguments.length?t.error(n):t.error(n,e))}},function(n,e){var t=function(){this.head=null,this.tail=null};t.prototype={add:function(n){var e={item:n,next:null};this.head?this.tail.next=e:this.head=e,this.tail=e},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=t},function(n,e){n.exports="object"==typeof window&&"object"!=typeof Deno},function(n,e,t){"use strict";var a=t(1),r=t(7),i=t(22),o=t(74),l=t(123),s=t(169);a({target:"Promise",stat:!0,forced:t(172)},{all:function(n){var e=this,t=o.f(e),a=t.resolve,c=t.reject,u=l((function(){var t=i(e.resolve),o=[],l=0,u=1;s(n,(function(n){var i=l++,s=!1;u++,r(t,e,n).then((function(n){s||(s=!0,o[i]=n,--u||a(o))}),c)})),--u||a(o)}));return u.error&&c(u.value),t.promise}})},function(n,e,t){"use strict";var a=t(1),r=t(17),i=t(73).CONSTRUCTOR,o=t(55),l=t(15),s=t(4),c=t(14),u=o&&o.prototype;if(a({target:"Promise",proto:!0,forced:i,real:!0},{catch:function(n){return this.then(void 0,n)}}),!r&&s(o)){var d=l("Promise").prototype.catch;u.catch!==d&&c(u,"catch",d,{unsafe:!0})}},function(n,e,t){"use strict";var a=t(1),r=t(7),i=t(22),o=t(74),l=t(123),s=t(169);a({target:"Promise",stat:!0,forced:t(172)},{race:function(n){var e=this,t=o.f(e),a=t.reject,c=l((function(){var o=i(e.resolve);s(n,(function(n){r(o,e,n).then(t.resolve,a)}))}));return c.error&&a(c.value),t.promise}})},function(n,e,t){"use strict";var a=t(1),r=t(7),i=t(74);a({target:"Promise",stat:!0,forced:t(73).CONSTRUCTOR},{reject:function(n){var e=i.f(this);return r(e.reject,void 0,n),e.promise}})},function(n,e,t){"use strict";var a=t(1),r=t(15),i=t(17),o=t(55),l=t(73).CONSTRUCTOR,s=t(174),c=r("Promise"),u=i&&!l;a({target:"Promise",stat:!0,forced:i||l},{resolve:function(n){return s(u&&this===c?o:this,n)}})},function(n,e,t){var a=t(1),r=t(259);a({target:"Object",stat:!0,forced:Object.assign!==r},{assign:r})},function(n,e,t){"use strict";var a=t(8),r=t(2),i=t(7),o=t(3),l=t(88),s=t(92),c=t(118),u=t(16),d=t(64),p=Object.assign,m=Object.defineProperty,h=r([].concat);n.exports=!p||o((function(){if(a&&1!==p({b:1},p(m({},"a",{enumerable:!0,get:function(){m(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=p({},n)[t]||"abcdefghijklmnopqrst"!=l(p({},e)).join("")}))?function(n,e){for(var t=u(n),r=arguments.length,o=1,p=s.f,m=c.f;r>o;)for(var v,g=d(arguments[o++]),f=p?h(l(g),p(g)):l(g),b=f.length,y=0;b>y;)v=f[y++],a&&!i(m,g,v)||(t[v]=g[v]);return t}:p},function(n,e,t){"use strict";var a=t(1),r=t(17),i=t(55),o=t(3),l=t(15),s=t(4),c=t(121),u=t(174),d=t(14),p=i&&i.prototype;if(a({target:"Promise",proto:!0,real:!0,forced:!!i&&o((function(){p.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=c(this,l("Promise")),t=s(n);return this.then(t?function(t){return u(e,n()).then((function(){return t}))}:n,t?function(t){return u(e,n()).then((function(){throw t}))}:n)}}),!r&&s(i)){var m=l("Promise").prototype.finally;p.finally!==m&&d(p,"finally",m,{unsafe:!0})}},function(n,e,t){"use strict";var a=t(122),r=t(82);n.exports=a?{}.toString:function(){return"[object "+r(this)+"]"}},function(n,e,t){var a=t(0),r=t(62),i=t(94),o=t(11),l=t(5)("species"),s=a.Array;n.exports=function(n){var e;return r(n)&&(e=n.constructor,(i(e)&&(e===s||r(e.prototype))||o(e)&&null===(e=e[l]))&&(e=void 0)),void 0===e?s:e}},function(n,e,t){"use strict";var a=t(1),r=t(264).left,i=t(47),o=t(53),l=t(93);a({target:"Array",proto:!0,forced:!i("reduce")||!l&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){var a=t(0),r=t(22),i=t(16),o=t(64),l=t(20),s=a.TypeError,c=function(n){return function(e,t,a,c){r(t);var u=i(e),d=o(u),p=l(u),m=n?p-1:0,h=n?-1:1;if(a<2)for(;;){if(m in d){c=d[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw s("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in d&&(c=t(c,d[m],m,u));return c}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var a,r=t(1),i=t(2),o=t(38).f,l=t(54),s=t(12),c=t(179),u=t(18),d=t(180),p=t(17),m=i("".startsWith),h=i("".slice),v=Math.min,g=d("startsWith");r({target:"String",proto:!0,forced:!!(p||g||(a=o(String.prototype,"startsWith"),!a||a.writable))&&!g},{startsWith:function(n){var e=s(u(this));c(n);var t=l(v(arguments.length>1?arguments[1]:void 0,e.length)),a=s(n);return m?m(e,a,t):h(e,t,t+a.length)===a}})},function(n,e,t){var a=t(1),r=t(182),i=t(3),o=t(11),l=t(267).onFreeze,s=Object.freeze;a({target:"Object",stat:!0,forced:i((function(){s(1)})),sham:!r},{freeze:function(n){return s&&o(n)?s(l(n)):n}})},function(n,e,t){var a=t(1),r=t(2),i=t(68),o=t(11),l=t(9),s=t(13).f,c=t(60),u=t(183),d=t(268),p=t(85),m=t(182),h=!1,v=p("meta"),g=0,f=function(n){s(n,v,{value:{objectID:"O"+g++,weakData:{}}})},b=n.exports={enable:function(){b.enable=function(){},h=!0;var n=c.f,e=r([].splice),t={};t[v]=1,n(t).length&&(c.f=function(t){for(var a=n(t),r=0,i=a.length;r<i;r++)if(a[r]===v){e(a,r,1);break}return a},a({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:u.f}))},fastKey:function(n,e){if(!o(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!l(n,v)){if(!d(n))return"F";if(!e)return"E";f(n)}return n[v].objectID},getWeakData:function(n,e){if(!l(n,v)){if(!d(n))return!0;if(!e)return!1;f(n)}return n[v].weakData},onFreeze:function(n){return m&&h&&d(n)&&!l(n,v)&&f(n),n}};i[v]=!0},function(n,e,t){var a=t(3),r=t(11),i=t(23),o=t(269),l=Object.isExtensible,s=a((function(){l(1)}));n.exports=s||o?function(n){return!!r(n)&&((!o||"ArrayBuffer"!=i(n))&&(!l||l(n)))}:l},function(n,e,t){var a=t(3);n.exports=a((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,e,t){"use strict";var a=t(1),r=t(0),i=t(7),o=t(2),l=t(17),s=t(8),c=t(52),u=t(3),d=t(9),p=t(36),m=t(10),h=t(21),v=t(87),g=t(12),f=t(49),b=t(35),y=t(88),x=t(60),k=t(183),w=t(92),j=t(38),S=t(13),T=t(146),I=t(118),C=t(14),z=t(51),E=t(90),A=t(68),M=t(85),J=t(5),L=t(184),O=t(185),P=t(272),_=t(61),D=t(37),R=t(59).forEach,B=E("hidden"),F=D.set,N=D.getterFor("Symbol"),q=Object.prototype,V=r.Symbol,U=V&&V.prototype,H=r.TypeError,G=r.QObject,$=j.f,W=S.f,K=k.f,X=I.f,Q=o([].push),Y=z("symbols"),Z=z("op-symbols"),nn=z("wks"),en=!G||!G.prototype||!G.prototype.findChild,tn=s&&u((function(){return 7!=b(W({},"a",{get:function(){return W(this,"a",{value:7}).a}})).a}))?function(n,e,t){var a=$(q,e);a&&delete q[e],W(n,e,t),a&&n!==q&&W(q,e,a)}:W,an=function(n,e){var t=Y[n]=b(U);return F(t,{type:"Symbol",tag:n,description:e}),s||(t.description=e),t},rn=function(n,e,t){n===q&&rn(Z,e,t),m(n);var a=v(e);return m(t),d(Y,a)?(t.enumerable?(d(n,B)&&n[B][a]&&(n[B][a]=!1),t=b(t,{enumerable:f(0,!1)})):(d(n,B)||W(n,B,f(1,{})),n[B][a]=!0),tn(n,a,t)):W(n,a,t)},on=function(n,e){m(n);var t=h(e),a=y(t).concat(un(t));return R(a,(function(e){s&&!i(ln,t,e)||rn(n,e,t[e])})),n},ln=function(n){var e=v(n),t=i(X,this,e);return!(this===q&&d(Y,e)&&!d(Z,e))&&(!(t||!d(this,e)||!d(Y,e)||d(this,B)&&this[B][e])||t)},sn=function(n,e){var t=h(n),a=v(e);if(t!==q||!d(Y,a)||d(Z,a)){var r=$(t,a);return!r||!d(Y,a)||d(t,B)&&t[B][a]||(r.enumerable=!0),r}},cn=function(n){var e=K(h(n)),t=[];return R(e,(function(n){d(Y,n)||d(A,n)||Q(t,n)})),t},un=function(n){var e=n===q,t=K(e?Z:h(n)),a=[];return R(t,(function(n){!d(Y,n)||e&&!d(q,n)||Q(a,Y[n])})),a};c||(C(U=(V=function(){if(p(U,this))throw H("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?g(arguments[0]):void 0,e=M(n),t=function(n){this===q&&i(t,Z,n),d(this,B)&&d(this[B],e)&&(this[B][e]=!1),tn(this,e,f(1,n))};return s&&en&&tn(q,e,{configurable:!0,set:t}),an(e,n)}).prototype,"toString",(function(){return N(this).tag})),C(V,"withoutSetter",(function(n){return an(M(n),n)})),I.f=ln,S.f=rn,T.f=on,j.f=sn,x.f=k.f=cn,w.f=un,L.f=function(n){return an(J(n),n)},s&&(W(U,"description",{configurable:!0,get:function(){return N(this).description}}),l||C(q,"propertyIsEnumerable",ln,{unsafe:!0}))),a({global:!0,wrap:!0,forced:!c,sham:!c},{Symbol:V}),R(y(nn),(function(n){O(n)})),a({target:"Symbol",stat:!0,forced:!c},{useSetter:function(){en=!0},useSimple:function(){en=!1}}),a({target:"Object",stat:!0,forced:!c,sham:!s},{create:function(n,e){return void 0===e?b(n):on(b(n),e)},defineProperty:rn,defineProperties:on,getOwnPropertyDescriptor:sn}),a({target:"Object",stat:!0,forced:!c},{getOwnPropertyNames:cn}),P(),_(V,"Symbol"),A[B]=!0},function(n,e,t){var a=t(0);n.exports=a},function(n,e,t){var a=t(7),r=t(15),i=t(5),o=t(14);n.exports=function(){var n=r("Symbol"),e=n&&n.prototype,t=e&&e.valueOf,l=i("toPrimitive");e&&!e[l]&&o(e,l,(function(n){return a(t,this)}))}},function(n,e,t){var a=t(1),r=t(15),i=t(9),o=t(12),l=t(51),s=t(186),c=l("string-to-symbol-registry"),u=l("symbol-to-string-registry");a({target:"Symbol",stat:!0,forced:!s},{for:function(n){var e=o(n);if(i(c,e))return c[e];var t=r("Symbol")(e);return c[e]=t,u[t]=e,t}})},function(n,e,t){var a=t(1),r=t(9),i=t(66),o=t(67),l=t(51),s=t(186),c=l("symbol-to-string-registry");a({target:"Symbol",stat:!0,forced:!s},{keyFor:function(n){if(!i(n))throw TypeError(o(n)+" is not a symbol");if(r(c,n))return c[n]}})},function(n,e,t){var a=t(1),r=t(52),i=t(3),o=t(92),l=t(16);a({target:"Object",stat:!0,forced:!r||i((function(){o.f(1)}))},{getOwnPropertySymbols:function(n){var e=o.f;return e?e(l(n)):[]}})},function(n,e,t){"use strict";var a=t(0),r=t(58),i=t(7),o=t(16),l=t(277),s=t(170),c=t(94),u=t(20),d=t(56),p=t(148),m=t(107),h=a.Array;n.exports=function(n){var e=o(n),t=c(this),a=arguments.length,v=a>1?arguments[1]:void 0,g=void 0!==v;g&&(v=r(v,a>2?arguments[2]:void 0));var f,b,y,x,k,w,j=m(e),S=0;if(!j||this==h&&s(j))for(f=u(e),b=t?new this(f):h(f);f>S;S++)w=g?v(e[S],S):e[S],d(b,S,w);else for(k=(x=p(e,j)).next,b=t?new this:[];!(y=i(k,x)).done;S++)w=g?l(x,v,[y.value,S],!0):y.value,d(b,S,w);return b.length=S,b}},function(n,e,t){var a=t(10),r=t(171);n.exports=function(n,e,t,i){try{return i?e(a(t)[0],t[1]):e(t)}catch(e){r(n,"throw",e)}}},function(n,e,t){"use strict";var a=t(15),r=t(9),i=t(24),o=t(36),l=t(71),s=t(119),c=t(233),u=t(150),d=t(189),p=t(279),m=t(280),h=t(281),v=t(8),g=t(17);n.exports=function(n,e,t,f){var b=f?2:1,y=n.split("."),x=y[y.length-1],k=a.apply(null,y);if(k){var w=k.prototype;if(!g&&r(w,"cause")&&delete w.cause,!t)return k;var j=a("Error"),S=e((function(n,e){var t=d(f?e:n,void 0),a=f?new k(n):new k;return void 0!==t&&i(a,"message",t),h&&i(a,"stack",m(a.stack,2)),this&&o(w,this)&&u(a,this,S),arguments.length>b&&p(a,arguments[b]),a}));if(S.prototype=w,"Error"!==x?l?l(S,j):s(S,j,{name:!0}):v&&"stackTraceLimit"in k&&(c(S,k,"stackTraceLimit"),c(S,k,"prepareStackTrace")),s(S,k),!g)try{w.name!==x&&i(w,"name",x),w.constructor=S}catch(n){}return S}}},function(n,e,t){var a=t(11),r=t(24);n.exports=function(n,e){a(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var a=t(2),r=Error,i=a("".replace),o=String(r("zxcasd").stack),l=/\n\s*at [^:]*:[^\n]*/,s=l.test(o);n.exports=function(n,e){if(s&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=i(n,l,"");return n}},function(n,e,t){var a=t(3),r=t(49);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var a=t(8),r=t(3),i=t(10),o=t(35),l=t(189),s=Error.prototype.toString,c=r((function(){if(a){var n=o(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==s.call(n))return!0}return"2: 1"!==s.call({message:1,name:2})||"Error"!==s.call({})}));n.exports=c?function(){var n=i(this),e=l(n.name,"Error"),t=l(n.message);return e?t?e+": "+t:e:t}:s},function(n,e,t){var a=t(2),r=t(16),i=Math.floor,o=a("".charAt),l=a("".replace),s=a("".slice),c=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,u=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,a,d,p){var m=t+n.length,h=a.length,v=u;return void 0!==d&&(d=r(d),v=c),l(p,v,(function(r,l){var c;switch(o(l,0)){case"$":return"$";case"&":return n;case"`":return s(e,0,t);case"'":return s(e,m);case"<":c=d[s(l,1,-1)];break;default:var u=+l;if(0===u)return r;if(u>h){var p=i(u/10);return 0===p?r:p<=h?void 0===a[p-1]?o(l,1):a[p-1]+o(l,1):r}c=a[u-1]}return void 0===c?"":c}))}},function(n,e,t){var a=t(191),r=t(285);n.exports=function n(e,t,i,o,l){var s=-1,c=e.length;for(i||(i=r),l||(l=[]);++s<c;){var u=e[s];t>0&&i(u)?t>1?n(u,t-1,i,o,l):a(l,u):o||(l[l.length]=u)}return l}},function(n,e,t){var a=t(76),r=t(128),i=t(27),o=a?a.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||r(n)||!!(o&&n&&n[o])}},function(n,e,t){var a=t(63),r=t(50);n.exports=function(n){return r(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(76),r=Object.prototype,i=r.hasOwnProperty,o=r.toString,l=a?a.toStringTag:void 0;n.exports=function(n){var e=i.call(n,l),t=n[l];try{n[l]=void 0;var a=!0}catch(n){}var r=o.call(n);return a&&(e?n[l]=t:delete n[l]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(290),r=t(346),i=t(136),o=t(27),l=t(357);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?r(n[0],n[1]):a(n):l(n)}},function(n,e,t){var a=t(291),r=t(345),i=t(208);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(193),r=t(197);n.exports=function(n,e,t,i){var o=t.length,l=o,s=!i;if(null==n)return!l;for(n=Object(n);o--;){var c=t[o];if(s&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<l;){var u=(c=t[o])[0],d=n[u],p=c[1];if(s&&c[2]){if(void 0===d&&!(u in n))return!1}else{var m=new a;if(i)var h=i(d,p,u,n,e,m);if(!(void 0===h?r(p,d,3,i,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(99),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(99);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(99);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(99);n.exports=function(n,e){var t=this.__data__,r=a(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var a=t(98);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(98),r=t(129),i=t(131);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var o=t.__data__;if(!r||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(195),r=t(303),i=t(130),o=t(196),l=/^\[object .+?Constructor\]$/,s=Function.prototype,c=Object.prototype,u=s.toString,d=c.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||r(n))&&(a(n)?p:l).test(o(n))}},function(n,e,t){var a,r=t(304),i=(a=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var a=t(29)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(307),r=t(98),i=t(129);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(i||r),string:new a}}},function(n,e,t){var a=t(308),r=t(309),i=t(310),o=t(311),l=t(312);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}s.prototype.clear=a,s.prototype.delete=r,s.prototype.get=i,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e,t){var a=t(100);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(100),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(100),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var a=t(100);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(101);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(101);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(101);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(101);n.exports=function(n,e){var t=a(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var a=t(193),r=t(198),i=t(322),o=t(325),l=t(341),s=t(27),c=t(202),u=t(204),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,v){var g=s(n),f=s(e),b=g?"[object Array]":l(n),y=f?"[object Array]":l(e),x=(b="[object Arguments]"==b?d:b)==d,k=(y="[object Arguments]"==y?d:y)==d,w=b==y;if(w&&c(n)){if(!c(e))return!1;g=!0,x=!1}if(w&&!x)return v||(v=new a),g||u(n)?r(n,e,t,m,h,v):i(n,e,b,t,m,h,v);if(!(1&t)){var j=x&&p.call(n,"__wrapped__"),S=k&&p.call(e,"__wrapped__");if(j||S){var T=j?n.value():n,I=S?e.value():e;return v||(v=new a),h(T,I,t,m,v)}}return!!w&&(v||(v=new a),o(n,e,t,m,h,v))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(76),r=t(323),i=t(194),o=t(198),l=t(324),s=t(132),c=a?a.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=l;case"[object Set]":var h=1&a;if(m||(m=s),n.size!=e.size&&!h)return!1;var v=p.get(n);if(v)return v==e;a|=2,p.set(n,e);var g=o(m(n),m(e),a,c,d,p);return p.delete(n),g;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var a=t(29).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(326),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,l){var s=1&t,c=a(n),u=c.length;if(u!=a(e).length&&!s)return!1;for(var d=u;d--;){var p=c[d];if(!(s?p in e:r.call(e,p)))return!1}var m=l.get(n),h=l.get(e);if(m&&h)return m==e&&h==n;var v=!0;l.set(n,e),l.set(e,n);for(var g=s;++d<u;){var f=n[p=c[d]],b=e[p];if(i)var y=s?i(b,f,p,e,n,l):i(f,b,p,n,e,l);if(!(void 0===y?f===b||o(f,b,t,i,l):y)){v=!1;break}g||(g="constructor"==p)}if(v&&!g){var x=n.constructor,k=e.constructor;x==k||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof k&&k instanceof k||(v=!1)}return l.delete(n),l.delete(e),v}},function(n,e,t){var a=t(327),r=t(328),i=t(201);n.exports=function(n){return a(n,i,r)}},function(n,e,t){var a=t(191),r=t(27);n.exports=function(n,e,t){var i=e(n);return r(n)?i:a(i,t(n))}},function(n,e,t){var a=t(329),r=t(330),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,l=o?function(n){return null==n?[]:(n=Object(n),a(o(n),(function(e){return i.call(n,e)})))}:r;n.exports=l},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=0,i=[];++t<a;){var o=n[t];e(o,t,n)&&(i[r++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(332),r=t(128),i=t(27),o=t(202),l=t(203),s=t(204),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),u=!t&&r(n),d=!t&&!u&&o(n),p=!t&&!u&&!d&&s(n),m=t||u||d||p,h=m?a(n.length,String):[],v=h.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||d&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||l(g,v))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(63),r=t(133),i=t(50),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&r(n.length)&&!!o[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(192),r=e&&!e.nodeType&&e,i=r&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===r&&a.process,l=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=l}).call(this,t(151)(n))},function(n,e,t){var a=t(338),r=t(339),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return r(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(340)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(342),r=t(129),i=t(343),o=t(206),l=t(344),s=t(63),c=t(196),u=c(a),d=c(r),p=c(i),m=c(o),h=c(l),v=s;(a&&"[object DataView]"!=v(new a(new ArrayBuffer(1)))||r&&"[object Map]"!=v(new r)||i&&"[object Promise]"!=v(i.resolve())||o&&"[object Set]"!=v(new o)||l&&"[object WeakMap]"!=v(new l))&&(v=function(n){var e=s(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=v},function(n,e,t){var a=t(41)(t(29),"DataView");n.exports=a},function(n,e,t){var a=t(41)(t(29),"Promise");n.exports=a},function(n,e,t){var a=t(41)(t(29),"WeakMap");n.exports=a},function(n,e,t){var a=t(207),r=t(201);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,a(o)]}return e}},function(n,e,t){var a=t(197),r=t(347),i=t(354),o=t(134),l=t(207),s=t(208),c=t(102);n.exports=function(n,e){return o(n)&&l(e)?s(c(n),e):function(t){var o=r(t,n);return void 0===o&&o===e?i(t,n):a(e,o,3)}}},function(n,e,t){var a=t(209);n.exports=function(n,e,t){var r=null==n?void 0:a(n,e);return void 0===r?t:r}},function(n,e,t){var a=t(349),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,a,r){e.push(a?r.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var a=t(350);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(131);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,r=e?e.apply(this,a):a[0],i=t.cache;if(i.has(r))return i.get(r);var o=n.apply(this,a);return t.cache=i.set(r,o)||i,o};return t.cache=new(r.Cache||a),t}r.Cache=a,n.exports=r},function(n,e,t){var a=t(352);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(76),r=t(353),i=t(27),o=t(135),l=a?a.prototype:void 0,s=l?l.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return r(e,n)+"";if(o(e))return s?s.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=Array(a);++t<a;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var a=t(355),r=t(356);n.exports=function(n,e){return null!=n&&r(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(210),r=t(128),i=t(27),o=t(203),l=t(133),s=t(102);n.exports=function(n,e,t){for(var c=-1,u=(e=a(e,n)).length,d=!1;++c<u;){var p=s(e[c]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++c!=u?d:!!(u=null==n?0:n.length)&&l(u)&&o(p,u)&&(i(n)||r(n))}},function(n,e,t){var a=t(358),r=t(359),i=t(134),o=t(102);n.exports=function(n){return i(n)?a(o(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(209);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(136),r=t(361),i=t(363);n.exports=function(n,e){return i(r(n,e,a),n+"")}},function(n,e,t){var a=t(362),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,l=r(i.length-e,0),s=Array(l);++o<l;)s[o]=i[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=i[o];return c[e]=t(s),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(364),r=t(367)(a);n.exports=r},function(n,e,t){var a=t(365),r=t(366),i=t(136),o=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(41),r=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var r=t(),i=16-(r-a);if(a=r,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(199),r=t(369),i=t(374),o=t(200),l=t(375),s=t(132);n.exports=function(n,e,t){var c=-1,u=r,d=n.length,p=!0,m=[],h=m;if(t)p=!1,u=i;else if(d>=200){var v=e?null:l(n);if(v)return s(v);p=!1,u=o,h=new a}else h=e?[]:m;n:for(;++c<d;){var g=n[c],f=e?e(g):g;if(g=t||0!==g?g:0,p&&f==f){for(var b=h.length;b--;)if(h[b]===f)continue n;e&&h.push(f),m.push(g)}else u(h,f,t)||(h!==m&&h.push(f),m.push(g))}return m}},function(n,e,t){var a=t(370);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(371),r=t(372),i=t(373);n.exports=function(n,e,t){return e==e?i(n,e,t):a(n,r,t)}},function(n,e){n.exports=function(n,e,t,a){for(var r=n.length,i=t+(a?1:-1);a?i--:++i<r;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,r=n.length;++a<r;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,r=null==n?0:n.length;++a<r;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(206),r=t(376),i=t(132),o=a&&1/i(new a([,-0]))[1]==1/0?function(n){return new a(n)}:r;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(205),r=t(50);n.exports=function(n){return r(n)&&a(n)}},function(n,e,t){var a=t(1),r=t(0),i=t(211).setInterval;a({global:!0,bind:!0,forced:r.setInterval!==i},{setInterval:i})},function(n,e,t){var a=t(1),r=t(0),i=t(211).setTimeout;a({global:!0,bind:!0,forced:r.setTimeout!==i},{setTimeout:i})},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(70).PROPER,r=t(3),i=t(154);n.exports=function(n){return r((function(){return!!i[n]()||"​᠎"!=="​᠎"[n]()||a&&i[n].name!==n}))}},function(n,e,t){var a=t(1),r=t(212);a({target:"Function",proto:!0,forced:Function.bind!==r},{bind:r})},function(n,e,t){var a=t(2);n.exports=a(1..valueOf)},function(n,e,t){var a=t(2),r=t(54),i=t(12),o=t(386),l=t(18),s=a(o),c=a("".slice),u=Math.ceil,d=function(n){return function(e,t,a){var o,d,p=i(l(e)),m=r(t),h=p.length,v=void 0===a?" ":i(a);return m<=h||""==v?p:((d=s(v,u((o=m-h)/v.length))).length>o&&(d=c(d,0,o)),n?p+d:d+p)}};n.exports={start:d(!1),end:d(!0)}},function(n,e,t){"use strict";var a=t(0),r=t(46),i=t(12),o=t(18),l=a.RangeError;n.exports=function(n){var e=i(o(this)),t="",a=r(n);if(a<0||a==1/0)throw l("Wrong number of repetitions");for(;a>0;(a>>>=1)&&(e+=e))1&a&&(t+=e);return t}},function(n,e,t){var a=t(28);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(a)},function(n,e,t){"use strict";t(214)},function(n,e,t){"use strict";t(215)},function(n,e,t){"use strict";var a=t(1),r=t(2),i=t(22),o=t(16),l=t(20),s=t(12),c=t(3),u=t(239),d=t(47),p=t(391),m=t(392),h=t(53),v=t(393),g=[],f=r(g.sort),b=r(g.push),y=c((function(){g.sort(void 0)})),x=c((function(){g.sort(null)})),k=d("sort"),w=!c((function(){if(h)return h<70;if(!(p&&p>3)){if(m)return!0;if(v)return v<603;var n,e,t,a,r="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(a=0;a<47;a++)g.push({k:e+a,v:t})}for(g.sort((function(n,e){return e.v-n.v})),a=0;a<g.length;a++)e=g[a].k.charAt(0),r.charAt(r.length-1)!==e&&(r+=e);return"DGBEFHACIJK"!==r}}));a({target:"Array",proto:!0,forced:y||!x||!k||!w},{sort:function(n){void 0!==n&&i(n);var e=o(this);if(w)return void 0===n?f(e):f(e,n);var t,a,r=[],c=l(e);for(a=0;a<c;a++)a in e&&b(r,e[a]);for(u(r,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:s(e)>s(t)?1:-1}}(n)),t=r.length,a=0;a<t;)e[a]=r[a++];for(;a<c;)delete e[a++];return e}})},function(n,e,t){var a=t(28).match(/firefox\/(\d+)/i);n.exports=!!a&&+a[1]},function(n,e,t){var a=t(28);n.exports=/MSIE|Trident/.test(a)},function(n,e,t){var a=t(28).match(/AppleWebKit\/(\d+)\./);n.exports=!!a&&+a[1]},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";var a=t(1),r=t(0),i=t(89),o=t(46),l=t(20),s=t(16),c=t(108),u=t(56),d=t(75)("splice"),p=r.TypeError,m=Math.max,h=Math.min;a({target:"Array",proto:!0,forced:!d},{splice:function(n,e){var t,a,r,d,v,g,f=s(this),b=l(f),y=i(n,b),x=arguments.length;if(0===x?t=a=0:1===x?(t=0,a=b-y):(t=x-2,a=h(m(o(e),0),b-y)),b+t-a>9007199254740991)throw p("Maximum allowed length exceeded");for(r=c(f,a),d=0;d<a;d++)(v=y+d)in f&&u(r,d,f[v]);if(r.length=a,t<a){for(d=y;d<b-a;d++)g=d+t,(v=d+a)in f?f[g]=f[v]:delete f[g];for(d=b;d>b-a+t;d--)delete f[d-1]}else if(t>a)for(d=b-a;d>y;d--)g=d+t-1,(v=d+a-1)in f?f[g]=f[v]:delete f[g];for(d=0;d<t;d++)f[d+y]=arguments[d+2];return f.length=b-a+t,r}})},function(n,e,t){"use strict";t(219)},function(n,e,t){"use strict";t(220)},function(n,e,t){"use strict";t.r(e);t(145),t(245),t(258),t(260);var a=t(95),r=(t(142),t(57),t(6),t(25),t(32),t(44),t(31),Object.freeze({}));function i(n){return null==n}function o(n){return null!=n}function l(n){return!0===n}function s(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function d(n){return"[object Object]"===u.call(n)}function p(n){return"[object RegExp]"===u.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function v(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function g(n){var e=parseFloat(n);return isNaN(e)?n:e}function f(n,e){for(var t=Object.create(null),a=n.split(","),r=0;r<a.length;r++)t[a[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}f("slot,component",!0);var b=f("key,ref,slot,slot-scope,is");function y(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var x=Object.prototype.hasOwnProperty;function k(n,e){return x.call(n,e)}function w(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var j=/-(\w)/g,S=w((function(n){return n.replace(j,(function(n,e){return e?e.toUpperCase():""}))})),T=w((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),I=/\B([A-Z])/g,C=w((function(n){return n.replace(I,"-$1").toLowerCase()}));var z=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function E(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function A(n,e){for(var t in e)n[t]=e[t];return n}function M(n){for(var e={},t=0;t<n.length;t++)n[t]&&A(e,n[t]);return e}function J(n,e,t){}var L=function(n,e,t){return!1},O=function(n){return n};function P(n,e){if(n===e)return!0;var t=c(n),a=c(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=Array.isArray(n),i=Array.isArray(e);if(r&&i)return n.length===e.length&&n.every((function(n,t){return P(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||i)return!1;var o=Object.keys(n),l=Object.keys(e);return o.length===l.length&&o.every((function(t){return P(n[t],e[t])}))}catch(n){return!1}}function _(n,e){for(var t=0;t<n.length;t++)if(P(n[t],e))return t;return-1}function D(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var R=["component","directive","filter"],B=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:L,isReservedAttr:L,isUnknownElement:L,getTagNamespace:J,parsePlatformTagName:O,mustUseProp:L,async:!0,_lifecycleHooks:B},N=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function q(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var V=new RegExp("[^"+N.source+".$_\\d]");var U,H="__proto__"in{},G="undefined"!=typeof window,$="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,W=$&&WXEnvironment.platform.toLowerCase(),K=G&&window.navigator.userAgent.toLowerCase(),X=K&&/msie|trident/.test(K),Q=K&&K.indexOf("msie 9.0")>0,Y=K&&K.indexOf("edge/")>0,Z=(K&&K.indexOf("android"),K&&/iphone|ipad|ipod|ios/.test(K)||"ios"===W),nn=(K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K),K&&K.match(/firefox\/(\d+)/)),en={}.watch,tn=!1;if(G)try{var an={};Object.defineProperty(an,"passive",{get:function(){tn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var rn=function(){return void 0===U&&(U=!G&&!$&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),U},on=G&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var sn,cn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);sn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=J,dn=0,pn=function(){this.id=dn++,this.subs=[]};pn.prototype.addSub=function(n){this.subs.push(n)},pn.prototype.removeSub=function(n){y(this.subs,n)},pn.prototype.depend=function(){pn.target&&pn.target.addDep(this)},pn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},pn.target=null;var mn=[];function hn(n){mn.push(n),pn.target=n}function vn(){mn.pop(),pn.target=mn[mn.length-1]}var gn=function(n,e,t,a,r,i,o,l){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=r,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=l,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},fn={child:{configurable:!0}};fn.child.get=function(){return this.componentInstance},Object.defineProperties(gn.prototype,fn);var bn=function(n){void 0===n&&(n="");var e=new gn;return e.text=n,e.isComment=!0,e};function yn(n){return new gn(void 0,void 0,void 0,String(n))}function xn(n){var e=new gn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var kn=Array.prototype,wn=Object.create(kn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=kn[n];q(wn,n,(function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];var r,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&o.observeArray(r),o.dep.notify(),i}))}));var jn=Object.getOwnPropertyNames(wn),Sn=!0;function Tn(n){Sn=n}var In=function(n){this.value=n,this.dep=new pn,this.vmCount=0,q(n,"__ob__",this),Array.isArray(n)?(H?function(n,e){n.__proto__=e}(n,wn):function(n,e,t){for(var a=0,r=t.length;a<r;a++){var i=t[a];q(n,i,e[i])}}(n,wn,jn),this.observeArray(n)):this.walk(n)};function Cn(n,e){var t;if(c(n)&&!(n instanceof gn))return k(n,"__ob__")&&n.__ob__ instanceof In?t=n.__ob__:Sn&&!rn()&&(Array.isArray(n)||d(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new In(n)),e&&t&&t.vmCount++,t}function zn(n,e,t,a,r){var i=new pn,o=Object.getOwnPropertyDescriptor(n,e);if(!o||!1!==o.configurable){var l=o&&o.get,s=o&&o.set;l&&!s||2!==arguments.length||(t=n[e]);var c=!r&&Cn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=l?l.call(n):t;return pn.target&&(i.depend(),c&&(c.dep.depend(),Array.isArray(e)&&Mn(e))),e},set:function(e){var a=l?l.call(n):t;e===a||e!=e&&a!=a||l&&!s||(s?s.call(n,e):t=e,c=!r&&Cn(e),i.notify())}})}}function En(n,e,t){if(Array.isArray(n)&&m(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var a=n.__ob__;return n._isVue||a&&a.vmCount?t:a?(zn(a.value,e,t),a.dep.notify(),t):(n[e]=t,t)}function An(n,e){if(Array.isArray(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||k(n,e)&&(delete n[e],t&&t.dep.notify())}}function Mn(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&Mn(e)}In.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)zn(n,e[t])},In.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Cn(n[e])};var Jn=F.optionMergeStrategies;function Ln(n,e){if(!e)return n;for(var t,a,r,i=cn?Reflect.ownKeys(e):Object.keys(e),o=0;o<i.length;o++)"__ob__"!==(t=i[o])&&(a=n[t],r=e[t],k(n,t)?a!==r&&d(a)&&d(r)&&Ln(a,r):En(n,t,r));return n}function On(n,e,t){return t?function(){var a="function"==typeof e?e.call(t,t):e,r="function"==typeof n?n.call(t,t):n;return a?Ln(a,r):r}:e?n?function(){return Ln("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function Pn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function _n(n,e,t,a){var r=Object.create(n||null);return e?A(r,e):r}Jn.data=function(n,e,t){return t?On(n,e,t):e&&"function"!=typeof e?n:On(n,e)},B.forEach((function(n){Jn[n]=Pn})),R.forEach((function(n){Jn[n+"s"]=_n})),Jn.watch=function(n,e,t,a){if(n===en&&(n=void 0),e===en&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var r={};for(var i in A(r,n),e){var o=r[i],l=e[i];o&&!Array.isArray(o)&&(o=[o]),r[i]=o?o.concat(l):Array.isArray(l)?l:[l]}return r},Jn.props=Jn.methods=Jn.inject=Jn.computed=function(n,e,t,a){if(!n)return e;var r=Object.create(null);return A(r,n),e&&A(r,e),r},Jn.provide=On;var Dn=function(n,e){return void 0===e?n:e};function Rn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var a,r,i={};if(Array.isArray(t))for(a=t.length;a--;)"string"==typeof(r=t[a])&&(i[S(r)]={type:null});else if(d(t))for(var o in t)r=t[o],i[S(o)]=d(r)?r:{type:r};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(Array.isArray(t))for(var r=0;r<t.length;r++)a[t[r]]={from:t[r]};else if(d(t))for(var i in t){var o=t[i];a[i]=d(o)?A({from:i},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];"function"==typeof a&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=Rn(n,e.extends,t)),e.mixins))for(var a=0,r=e.mixins.length;a<r;a++)n=Rn(n,e.mixins[a],t);var i,o={};for(i in n)l(i);for(i in e)k(n,i)||l(i);function l(a){var r=Jn[a]||Dn;o[a]=r(n[a],e[a],t,a)}return o}function Bn(n,e,t,a){if("string"==typeof t){var r=n[e];if(k(r,t))return r[t];var i=S(t);if(k(r,i))return r[i];var o=T(i);return k(r,o)?r[o]:r[t]||r[i]||r[o]}}function Fn(n,e,t,a){var r=e[n],i=!k(t,n),o=t[n],l=Un(Boolean,r.type);if(l>-1)if(i&&!k(r,"default"))o=!1;else if(""===o||o===C(n)){var s=Un(String,r.type);(s<0||l<s)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!k(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof a&&"Function"!==qn(e.type)?a.call(n):a}(a,r,n);var c=Sn;Tn(!0),Cn(o),Tn(c)}return o}var Nn=/^\s*function (\w+)/;function qn(n){var e=n&&n.toString().match(Nn);return e?e[1]:""}function Vn(n,e){return qn(n)===qn(e)}function Un(n,e){if(!Array.isArray(e))return Vn(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Vn(e[t],n))return t;return-1}function Hn(n,e,t){hn();try{if(e)for(var a=e;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var i=0;i<r.length;i++)try{if(!1===r[i].call(a,n,e,t))return}catch(n){$n(n,a,"errorCaptured hook")}}$n(n,e,t)}finally{vn()}}function Gn(n,e,t,a,r){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&h(i)&&!i._handled&&(i.catch((function(n){return Hn(n,a,r+" (Promise/async)")})),i._handled=!0)}catch(n){Hn(n,a,r)}return i}function $n(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Wn(e,null,"config.errorHandler")}Wn(n,e,t)}function Wn(n,e,t){if(!G&&!$||"undefined"==typeof console)throw n;console.error(n)}var Kn,Xn=!1,Qn=[],Yn=!1;function Zn(){Yn=!1;var n=Qn.slice(0);Qn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var ne=Promise.resolve();Kn=function(){ne.then(Zn),Z&&setTimeout(J)},Xn=!0}else if(X||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Kn="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Zn)}:function(){setTimeout(Zn,0)};else{var ee=1,te=new MutationObserver(Zn),ae=document.createTextNode(String(ee));te.observe(ae,{characterData:!0}),Kn=function(){ee=(ee+1)%2,ae.data=String(ee)},Xn=!0}function re(n,e){var t;if(Qn.push((function(){if(n)try{n.call(e)}catch(n){Hn(n,e,"nextTick")}else t&&t(e)})),Yn||(Yn=!0,Kn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var ie=new sn;function oe(n){!function n(e,t){var a,r,i=Array.isArray(e);if(!i&&!c(e)||Object.isFrozen(e)||e instanceof gn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(i)for(a=e.length;a--;)n(e[a],t);else for(r=Object.keys(e),a=r.length;a--;)n(e[r[a]],t)}(n,ie),ie.clear()}var le=w((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function se(n,e){function t(){var n=arguments,a=t.fns;if(!Array.isArray(a))return Gn(a,null,arguments,e,"v-on handler");for(var r=a.slice(),i=0;i<r.length;i++)Gn(r[i],null,n,e,"v-on handler")}return t.fns=n,t}function ce(n,e,t,a,r,o){var s,c,u,d;for(s in n)c=n[s],u=e[s],d=le(s),i(c)||(i(u)?(i(c.fns)&&(c=n[s]=se(c,o)),l(d.once)&&(c=n[s]=r(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==u&&(u.fns=c,n[s]=u));for(s in e)i(n[s])&&a((d=le(s)).name,e[s],d.capture)}function ue(n,e,t){var a;n instanceof gn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function s(){t.apply(this,arguments),y(a.fns,s)}i(r)?a=se([s]):o(r.fns)&&l(r.merged)?(a=r).fns.push(s):a=se([r,s]),a.merged=!0,n[e]=a}function de(n,e,t,a,r){if(o(e)){if(k(e,t))return n[t]=e[t],r||delete e[t],!0;if(k(e,a))return n[t]=e[a],r||delete e[a],!0}return!1}function pe(n){return s(n)?[yn(n)]:Array.isArray(n)?function n(e,t){var a,r,c,u,d=[];for(a=0;a<e.length;a++)i(r=e[a])||"boolean"==typeof r||(c=d.length-1,u=d[c],Array.isArray(r)?r.length>0&&(me((r=n(r,(t||"")+"_"+a))[0])&&me(u)&&(d[c]=yn(u.text+r[0].text),r.shift()),d.push.apply(d,r)):s(r)?me(u)?d[c]=yn(u.text+r):""!==r&&d.push(yn(r)):me(r)&&me(u)?d[c]=yn(u.text+r.text):(l(e._isVList)&&o(r.tag)&&i(r.key)&&o(t)&&(r.key="__vlist"+t+"_"+a+"__"),d.push(r)));return d}(n):void 0}function me(n){return o(n)&&o(n.text)&&!1===n.isComment}function he(n,e){if(n){for(var t=Object.create(null),a=cn?Reflect.ownKeys(n):Object.keys(n),r=0;r<a.length;r++){var i=a[r];if("__ob__"!==i){for(var o=n[i].from,l=e;l;){if(l._provided&&k(l._provided,o)){t[i]=l._provided[o];break}l=l.$parent}if(!l)if("default"in n[i]){var s=n[i].default;t[i]="function"==typeof s?s.call(e):s}else 0}}return t}}function ve(n,e){if(!n||!n.length)return{};for(var t={},a=0,r=n.length;a<r;a++){var i=n[a],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var l=o.slot,s=t[l]||(t[l]=[]);"template"===i.tag?s.push.apply(s,i.children||[]):s.push(i)}}for(var c in t)t[c].every(ge)&&delete t[c];return t}function ge(n){return n.isComment&&!n.asyncFactory||" "===n.text}function fe(n){return n.isComment&&n.asyncFactory}function be(n,e,t){var a,i=Object.keys(e).length>0,o=n?!!n.$stable:!i,l=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&t&&t!==r&&l===t.$key&&!i&&!t.$hasNormal)return t;for(var s in a={},n)n[s]&&"$"!==s[0]&&(a[s]=ye(e,s,n[s]))}else a={};for(var c in e)c in a||(a[c]=xe(e,c));return n&&Object.isExtensible(n)&&(n._normalized=a),q(a,"$stable",o),q(a,"$key",l),q(a,"$hasNormal",i),a}function ye(n,e,t){var a=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:pe(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!fe(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:a,enumerable:!0,configurable:!0}),a}function xe(n,e){return function(){return n[e]}}function ke(n,e){var t,a,r,i,l;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),a=0,r=n.length;a<r;a++)t[a]=e(n[a],a);else if("number"==typeof n)for(t=new Array(n),a=0;a<n;a++)t[a]=e(a+1,a);else if(c(n))if(cn&&n[Symbol.iterator]){t=[];for(var s=n[Symbol.iterator](),u=s.next();!u.done;)t.push(e(u.value,t.length)),u=s.next()}else for(i=Object.keys(n),t=new Array(i.length),a=0,r=i.length;a<r;a++)l=i[a],t[a]=e(n[l],l,a);return o(t)||(t=[]),t._isVList=!0,t}function we(n,e,t,a){var r,i=this.$scopedSlots[n];i?(t=t||{},a&&(t=A(A({},a),t)),r=i(t)||("function"==typeof e?e():e)):r=this.$slots[n]||("function"==typeof e?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},r):r}function je(n){return Bn(this.$options,"filters",n)||O}function Se(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Te(n,e,t,a,r){var i=F.keyCodes[e]||t;return r&&a&&!F.keyCodes[e]?Se(r,a):i?Se(i,n):a?C(a)!==e:void 0===n}function Ie(n,e,t,a,r){if(t)if(c(t)){var i;Array.isArray(t)&&(t=M(t));var o=function(o){if("class"===o||"style"===o||b(o))i=n;else{var l=n.attrs&&n.attrs.type;i=a||F.mustUseProp(e,l,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var s=S(o),c=C(o);s in i||c in i||(i[o]=t[o],r&&((n.on||(n.on={}))["update:"+o]=function(n){t[o]=n}))};for(var l in t)o(l)}else;return n}function Ce(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||Ee(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),a}function ze(n,e,t){return Ee(n,"__once__"+e+(t?"_"+t:""),!0),n}function Ee(n,e,t){if(Array.isArray(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&Ae(n[a],e+"_"+a,t);else Ae(n,e,t)}function Ae(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Me(n,e){if(e)if(d(e)){var t=n.on=n.on?A({},n.on):{};for(var a in e){var r=t[a],i=e[a];t[a]=r?[].concat(r,i):i}}else;return n}function Je(n,e,t,a){e=e||{$stable:!t};for(var r=0;r<n.length;r++){var i=n[r];Array.isArray(i)?Je(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return a&&(e.$key=a),e}function Le(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function Oe(n,e){return"string"==typeof n?e+n:n}function Pe(n){n._o=ze,n._n=g,n._s=v,n._l=ke,n._t=we,n._q=P,n._i=_,n._m=Ce,n._f=je,n._k=Te,n._b=Ie,n._v=yn,n._e=bn,n._u=Je,n._g=Me,n._d=Le,n._p=Oe}function _e(n,e,t,a,i){var o,s=this,c=i.options;k(a,"_uid")?(o=Object.create(a))._original=a:(o=a,a=a._original);var u=l(c._compiled),d=!u;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=he(c.inject,a),this.slots=function(){return s.$slots||be(n.scopedSlots,s.$slots=ve(t,a)),s.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return be(n.scopedSlots,this.slots())}}),u&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=be(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,r){var i=Ve(o,n,e,t,r,d);return i&&!Array.isArray(i)&&(i.fnScopeId=c._scopeId,i.fnContext=a),i}:this._c=function(n,e,t,a){return Ve(o,n,e,t,a,d)}}function De(n,e,t,a,r){var i=xn(n);return i.fnContext=t,i.fnOptions=a,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function Re(n,e){for(var t in e)n[S(t)]=e[t]}Pe(_e.prototype);var Be={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Be.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;o(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ye)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,i){0;var o=a.data.scopedSlots,l=n.$scopedSlots,s=!!(o&&!o.$stable||l!==r&&!l.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||s);n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a);if(n.$options._renderChildren=i,n.$attrs=a.data.attrs||r,n.$listeners=t||r,e&&n.$options.props){Tn(!1);for(var u=n._props,d=n.$options._propKeys||[],p=0;p<d.length;p++){var m=d[p],h=n.$options.props;u[m]=Fn(m,h,e,n)}Tn(!0),n.$options.propsData=e}t=t||r;var v=n.$options._parentListeners;n.$options._parentListeners=t,Qe(n,t,v),c&&(n.$slots=ve(i,a.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,tt(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,rt.push(e)):et(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,nt(e)))return;if(!e._inactive){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);tt(e,"deactivated")}}(e,!0):e.$destroy())}},Fe=Object.keys(Be);function Ne(n,e,t,a,s){if(!i(n)){var u=t.$options._base;if(c(n)&&(n=u.extend(n)),"function"==typeof n){var d;if(i(n.cid)&&void 0===(n=function(n,e){if(l(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=He;t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(l(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var a=n.owners=[t],r=!0,s=null,u=null;t.$on("hook:destroyed",(function(){return y(a,t)}));var d=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==s&&(clearTimeout(s),s=null),null!==u&&(clearTimeout(u),u=null))},p=D((function(t){n.resolved=Ge(t,e),r?a.length=0:d(!0)})),m=D((function(e){o(n.errorComp)&&(n.error=!0,d(!0))})),v=n(p,m);return c(v)&&(h(v)?i(n.resolved)&&v.then(p,m):h(v.component)&&(v.component.then(p,m),o(v.error)&&(n.errorComp=Ge(v.error,e)),o(v.loading)&&(n.loadingComp=Ge(v.loading,e),0===v.delay?n.loading=!0:s=setTimeout((function(){s=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,d(!1))}),v.delay||200)),o(v.timeout)&&(u=setTimeout((function(){u=null,i(n.resolved)&&m(null)}),v.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(d=n,u)))return function(n,e,t,a,r){var i=bn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:a,tag:r},i}(d,e,t,a,s);e=e||{},St(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var r=e.on||(e.on={}),i=r[a],l=e.model.callback;o(i)?(Array.isArray(i)?-1===i.indexOf(l):i!==l)&&(r[a]=[l].concat(i)):r[a]=l}(n.options,e);var p=function(n,e,t){var a=e.options.props;if(!i(a)){var r={},l=n.attrs,s=n.props;if(o(l)||o(s))for(var c in a){var u=C(c);de(r,s,c,u,!0)||de(r,l,c,u,!1)}return r}}(e,n);if(l(n.options.functional))return function(n,e,t,a,i){var l=n.options,s={},c=l.props;if(o(c))for(var u in c)s[u]=Fn(u,c,e||r);else o(t.attrs)&&Re(s,t.attrs),o(t.props)&&Re(s,t.props);var d=new _e(t,s,i,a,n),p=l.render.call(null,d._c,d);if(p instanceof gn)return De(p,t,d.parent,l,d);if(Array.isArray(p)){for(var m=pe(p)||[],h=new Array(m.length),v=0;v<m.length;v++)h[v]=De(m[v],t,d.parent,l,d);return h}}(n,p,e,t,a);var m=e.on;if(e.on=e.nativeOn,l(n.options.abstract)){var v=e.slot;e={},v&&(e.slot=v)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Fe.length;t++){var a=Fe[t],r=e[a],i=Be[a];r===i||r&&r._merged||(e[a]=r?qe(i,r):i)}}(e);var g=n.options.name||s;return new gn("vue-component-"+n.cid+(g?"-"+g:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:m,tag:s,children:a},d)}}}function qe(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}function Ve(n,e,t,a,r,u){return(Array.isArray(t)||s(t))&&(r=a,a=t,t=void 0),l(u)&&(r=2),function(n,e,t,a,r){if(o(t)&&o(t.__ob__))return bn();o(t)&&o(t.is)&&(e=t.is);if(!e)return bn();0;Array.isArray(a)&&"function"==typeof a[0]&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===r?a=pe(a):1===r&&(a=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var s,u;if("string"==typeof e){var d;u=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),s=F.isReservedTag(e)?new gn(F.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!o(d=Bn(n.$options,"components",e))?new gn(e,t,a,void 0,void 0,n):Ne(d,t,n,a,e)}else s=Ne(e,t,n,a);return Array.isArray(s)?s:o(s)?(o(u)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(o(e.children))for(var r=0,s=e.children.length;r<s;r++){var c=e.children[r];o(c.tag)&&(i(c.ns)||l(a)&&"svg"!==c.tag)&&n(c,t,a)}}(s,u),o(t)&&function(n){c(n.style)&&oe(n.style);c(n.class)&&oe(n.class)}(t),s):bn()}(n,e,t,a,r)}var Ue,He=null;function Ge(n,e){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function $e(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||fe(t)))return t}}function We(n,e){Ue.$on(n,e)}function Ke(n,e){Ue.$off(n,e)}function Xe(n,e){var t=Ue;return function a(){var r=e.apply(null,arguments);null!==r&&t.$off(n,a)}}function Qe(n,e,t){Ue=n,ce(e,t||{},We,Ke,Xe,n),Ue=void 0}var Ye=null;function Ze(n){var e=Ye;return Ye=n,function(){Ye=e}}function nt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function et(n,e){if(e){if(n._directInactive=!1,nt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)et(n.$children[t]);tt(n,"activated")}}function tt(n,e){hn();var t=n.$options[e],a=e+" hook";if(t)for(var r=0,i=t.length;r<i;r++)Gn(t[r],n,null,n,a);n._hasHookEvent&&n.$emit("hook:"+e),vn()}var at=[],rt=[],it={},ot=!1,lt=!1,st=0;var ct=0,ut=Date.now;if(G&&!X){var dt=window.performance;dt&&"function"==typeof dt.now&&ut()>document.createEvent("Event").timeStamp&&(ut=function(){return dt.now()})}function pt(){var n,e;for(ct=ut(),lt=!0,at.sort((function(n,e){return n.id-e.id})),st=0;st<at.length;st++)(n=at[st]).before&&n.before(),e=n.id,it[e]=null,n.run();var t=rt.slice(),a=at.slice();st=at.length=rt.length=0,it={},ot=lt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,et(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a._watcher===t&&a._isMounted&&!a._isDestroyed&&tt(a,"updated")}}(a),on&&F.devtools&&on.emit("flush")}var mt=0,ht=function(n,e,t,a,r){this.vm=n,r&&(n._watcher=this),n._watchers.push(this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++mt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new sn,this.newDepIds=new sn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=J)),this.value=this.lazy?void 0:this.get()};ht.prototype.get=function(){var n;hn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Hn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&oe(n),vn(),this.cleanupDeps()}return n},ht.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},ht.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},ht.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==it[e]){if(it[e]=!0,lt){for(var t=at.length-1;t>st&&at[t].id>n.id;)t--;at.splice(t+1,0,n)}else at.push(n);ot||(ot=!0,re(pt))}}(this)},ht.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Gn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},ht.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},ht.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},ht.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||y(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var vt={enumerable:!0,configurable:!0,get:J,set:J};function gt(n,e,t){vt.get=function(){return this[e][t]},vt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,vt)}function ft(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props={},r=n.$options._propKeys=[];n.$parent&&Tn(!1);var i=function(i){r.push(i);var o=Fn(i,e,t,n);zn(a,i,o),i in n||gt(n,"_props",i)};for(var o in e)i(o);Tn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?J:z(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;d(e=n._data="function"==typeof e?function(n,e){hn();try{return n.call(e,e)}catch(n){return Hn(n,e,"data()"),{}}finally{vn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var i=t[r];0,a&&k(a,i)||(o=void 0,36!==(o=(i+"").charCodeAt(0))&&95!==o&&gt(n,"_data",i))}var o;Cn(e,!0)}(n):Cn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=rn();for(var r in e){var i=e[r],o="function"==typeof i?i:i.get;0,a||(t[r]=new ht(n,o||J,J,bt)),r in n||yt(n,r,i)}}(n,e.computed),e.watch&&e.watch!==en&&function(n,e){for(var t in e){var a=e[t];if(Array.isArray(a))for(var r=0;r<a.length;r++)wt(n,t,a[r]);else wt(n,t,a)}}(n,e.watch)}var bt={lazy:!0};function yt(n,e,t){var a=!rn();"function"==typeof t?(vt.get=a?xt(e):kt(t),vt.set=J):(vt.get=t.get?a&&!1!==t.cache?xt(e):kt(t.get):J,vt.set=t.set||J),Object.defineProperty(n,e,vt)}function xt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),pn.target&&e.depend(),e.value}}function kt(n){return function(){return n.call(this,this)}}function wt(n,e,t,a){return d(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var jt=0;function St(n){var e=n.options;if(n.super){var t=St(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var r in t)t[r]!==a[r]&&(e||(e={}),e[r]=t[r]);return e}(n);a&&A(n.extendOptions,a),(e=n.options=Rn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Tt(n){this._init(n)}function It(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,r=n._Ctor||(n._Ctor={});if(r[a])return r[a];var i=n.name||t.options.name;var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Rn(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)gt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)yt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,R.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=A({},o.options),r[a]=o,o}}function Ct(n){return n&&(n.Ctor.options.name||n.tag)}function zt(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function Et(n,e){var t=n.cache,a=n.keys,r=n._vnode;for(var i in t){var o=t[i];if(o){var l=o.name;l&&!e(l)&&At(t,i,a,r)}}}function At(n,e,t,a){var r=n[e];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),n[e]=null,y(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=jt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var r=a.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Rn(St(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Qe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=ve(e._renderChildren,a),n.$scopedSlots=r,n._c=function(e,t,a,r){return Ve(n,e,t,a,r,!1)},n.$createElement=function(e,t,a,r){return Ve(n,e,t,a,r,!0)};var i=t&&t.data;zn(n,"$attrs",i&&i.attrs||r,null,!0),zn(n,"$listeners",e._parentListeners||r,null,!0)}(e),tt(e,"beforeCreate"),function(n){var e=he(n.$options.inject,n);e&&(Tn(!1),Object.keys(e).forEach((function(t){zn(n,t,e[t])})),Tn(!0))}(e),ft(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),tt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Tt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=En,n.prototype.$delete=An,n.prototype.$watch=function(n,e,t){if(d(e))return wt(this,n,e,t);(t=t||{}).user=!0;var a=new ht(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'+a.expression+'"';hn(),Gn(e,this,[a.value],this,r),vn()}return function(){a.teardown()}}}(Tt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(Array.isArray(n))for(var r=0,i=n.length;r<i;r++)a.$on(n[r],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var a=0,r=n.length;a<r;a++)t.$off(n[a],e);return t}var i,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var l=o.length;l--;)if((i=o[l])===e||i.fn===e){o.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?E(t):t;for(var a=E(arguments,1),r='event handler for "'+n+'"',i=0,o=t.length;i<o;i++)Gn(t[i],e,a,e,r)}return e}}(Tt),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,r=t._vnode,i=Ze(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),i(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){tt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),tt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Tt),function(n){Pe(n.prototype),n.prototype.$nextTick=function(n){return re(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,r=t._parentVnode;r&&(e.$scopedSlots=be(r.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=r;try{He=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){Hn(t,e,"render"),n=e._vnode}finally{He=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof gn||(n=bn()),n.parent=r,n}}(Tt);var Mt=[String,RegExp,Array],Jt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Mt,exclude:Mt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var r=t.tag,i=t.componentInstance,o=t.componentOptions;n[a]={name:Ct(o),tag:r,componentInstance:i},e.push(a),this.max&&e.length>parseInt(this.max)&&At(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)At(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Et(n,(function(n){return zt(e,n)}))})),this.$watch("exclude",(function(e){Et(n,(function(n){return!zt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=$e(n),t=e&&e.componentOptions;if(t){var a=Ct(t),r=this.include,i=this.exclude;if(r&&(!a||!zt(r,a))||i&&a&&zt(i,a))return e;var o=this.cache,l=this.keys,s=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;o[s]?(e.componentInstance=o[s].componentInstance,y(l,s),l.push(s)):(this.vnodeToCache=e,this.keyToCache=s),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:un,extend:A,mergeOptions:Rn,defineReactive:zn},n.set=En,n.delete=An,n.nextTick=re,n.observable=function(n){return Cn(n),n},n.options=Object.create(null),R.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,A(n.options.components,Jt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=E(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Rn(this.options,n),this}}(n),It(n),function(n){R.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Tt),Object.defineProperty(Tt.prototype,"$isServer",{get:rn}),Object.defineProperty(Tt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Tt,"FunctionalRenderContext",{value:_e}),Tt.version="2.6.14";var Lt=f("style,class"),Ot=f("input,textarea,option,select,progress"),Pt=f("contenteditable,draggable,spellcheck"),_t=f("events,caret,typing,plaintext-only"),Dt=f("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Rt="http://www.w3.org/1999/xlink",Bt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Ft=function(n){return Bt(n)?n.slice(6,n.length):""},Nt=function(n){return null==n||!1===n};function qt(n){for(var e=n.data,t=n,a=n;o(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=Vt(a.data,e));for(;o(t=t.parent);)t&&t.data&&(e=Vt(e,t.data));return function(n,e){if(o(n)||o(e))return Ut(n,Ht(e));return""}(e.staticClass,e.class)}function Vt(n,e){return{staticClass:Ut(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function Ut(n,e){return n?e?n+" "+e:n:e||""}function Ht(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,r=n.length;a<r;a++)o(e=Ht(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Gt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},$t=f("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Wt=f("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Kt=function(n){return $t(n)||Wt(n)};var Xt=Object.create(null);var Qt=f("text,number,password,search,email,tel,url");var Yt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Gt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Zt={create:function(n,e){na(e)},update:function(n,e){n.data.ref!==e.data.ref&&(na(n,!0),na(e))},destroy:function(n){na(n,!0)}};function na(n,e){var t=n.data.ref;if(o(t)){var a=n.context,r=n.componentInstance||n.elm,i=a.$refs;e?Array.isArray(i[t])?y(i[t],r):i[t]===r&&(i[t]=void 0):n.data.refInFor?Array.isArray(i[t])?i[t].indexOf(r)<0&&i[t].push(r):i[t]=[r]:i[t]=r}}var ea=new gn("",{},[]),ta=["create","activate","update","remove","destroy"];function aa(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=o(t=n.data)&&o(t=t.attrs)&&t.type,r=o(t=e.data)&&o(t=t.attrs)&&t.type;return a===r||Qt(a)&&Qt(r)}(n,e)||l(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function ra(n,e,t){var a,r,i={};for(a=e;a<=t;++a)o(r=n[a].key)&&(i[r]=a);return i}var ia={create:oa,update:oa,destroy:function(n){oa(n,ea)}};function oa(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,r,i=n===ea,o=e===ea,l=sa(n.data.directives,n.context),s=sa(e.data.directives,e.context),c=[],u=[];for(t in s)a=l[t],r=s[t],a?(r.oldValue=a.value,r.oldArg=a.arg,ua(r,"update",e,n),r.def&&r.def.componentUpdated&&u.push(r)):(ua(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var d=function(){for(var t=0;t<c.length;t++)ua(c[t],"inserted",e,n)};i?ue(e,"insert",d):d()}u.length&&ue(e,"postpatch",(function(){for(var t=0;t<u.length;t++)ua(u[t],"componentUpdated",e,n)}));if(!i)for(t in l)s[t]||ua(l[t],"unbind",n,n,o)}(n,e)}var la=Object.create(null);function sa(n,e){var t,a,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++)(a=n[t]).modifiers||(a.modifiers=la),r[ca(a)]=a,a.def=Bn(e.$options,"directives",a.name);return r}function ca(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function ua(n,e,t,a,r){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,a,r)}catch(a){Hn(a,t.context,"directive "+n.name+" "+e+" hook")}}var da=[Zt,ia];function pa(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var a,r,l=e.elm,s=n.data.attrs||{},c=e.data.attrs||{};for(a in o(c.__ob__)&&(c=e.data.attrs=A({},c)),c)r=c[a],s[a]!==r&&ma(l,a,r,e.data.pre);for(a in(X||Y)&&c.value!==s.value&&ma(l,"value",c.value),s)i(c[a])&&(Bt(a)?l.removeAttributeNS(Rt,Ft(a)):Pt(a)||l.removeAttribute(a))}}function ma(n,e,t,a){a||n.tagName.indexOf("-")>-1?ha(n,e,t):Dt(e)?Nt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Pt(e)?n.setAttribute(e,function(n,e){return Nt(e)||"false"===e?"false":"contenteditable"===n&&_t(e)?e:"true"}(e,t)):Bt(e)?Nt(t)?n.removeAttributeNS(Rt,Ft(e)):n.setAttributeNS(Rt,e,t):ha(n,e,t)}function ha(n,e,t){if(Nt(t))n.removeAttribute(e);else{if(X&&!Q&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var va={create:pa,update:pa};function ga(n,e){var t=e.elm,a=e.data,r=n.data;if(!(i(a.staticClass)&&i(a.class)&&(i(r)||i(r.staticClass)&&i(r.class)))){var l=qt(e),s=t._transitionClasses;o(s)&&(l=Ut(l,Ht(s))),l!==t._prevClass&&(t.setAttribute("class",l),t._prevClass=l)}}var fa,ba={create:ga,update:ga};function ya(n,e,t){var a=fa;return function r(){var i=e.apply(null,arguments);null!==i&&wa(n,r,t,a)}}var xa=Xn&&!(nn&&Number(nn[1])<=53);function ka(n,e,t,a){if(xa){var r=ct,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}fa.addEventListener(n,e,tn?{capture:t,passive:a}:t)}function wa(n,e,t,a){(a||fa).removeEventListener(n,e._wrapper||e,t)}function ja(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},a=n.data.on||{};fa=e.elm,function(n){if(o(n.__r)){var e=X?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),ce(t,a,ka,wa,ya,e.context),fa=void 0}}var Sa,Ta={create:ja,update:ja};function Ia(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,a,r=e.elm,l=n.data.domProps||{},s=e.data.domProps||{};for(t in o(s.__ob__)&&(s=e.data.domProps=A({},s)),l)t in s||(r[t]="");for(t in s){if(a=s[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=a;var c=i(a)?"":String(a);Ca(r,c)&&(r.value=c)}else if("innerHTML"===t&&Wt(r.tagName)&&i(r.innerHTML)){(Sa=Sa||document.createElement("div")).innerHTML="<svg>"+a+"</svg>";for(var u=Sa.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;u.firstChild;)r.appendChild(u.firstChild)}else if(a!==l[t])try{r[t]=a}catch(n){}}}}function Ca(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(o(a)){if(a.number)return g(t)!==g(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var za={create:Ia,update:Ia},Ea=w((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Aa(n){var e=Ma(n.style);return n.staticStyle?A(n.staticStyle,e):e}function Ma(n){return Array.isArray(n)?M(n):"string"==typeof n?Ea(n):n}var Ja,La=/^--/,Oa=/\s*!important$/,Pa=function(n,e,t){if(La.test(e))n.style.setProperty(e,t);else if(Oa.test(t))n.style.setProperty(C(e),t.replace(Oa,""),"important");else{var a=Da(e);if(Array.isArray(t))for(var r=0,i=t.length;r<i;r++)n.style[a]=t[r];else n.style[a]=t}},_a=["Webkit","Moz","ms"],Da=w((function(n){if(Ja=Ja||document.createElement("div").style,"filter"!==(n=S(n))&&n in Ja)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<_a.length;t++){var a=_a[t]+e;if(a in Ja)return a}}));function Ra(n,e){var t=e.data,a=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(a.staticStyle)&&i(a.style))){var r,l,s=e.elm,c=a.staticStyle,u=a.normalizedStyle||a.style||{},d=c||u,p=Ma(e.data.style)||{};e.data.normalizedStyle=o(p.__ob__)?A({},p):p;var m=function(n,e){var t,a={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Aa(r.data))&&A(a,t);(t=Aa(n.data))&&A(a,t);for(var i=n;i=i.parent;)i.data&&(t=Aa(i.data))&&A(a,t);return a}(e,!0);for(l in d)i(m[l])&&Pa(s,l,"");for(l in m)(r=m[l])!==d[l]&&Pa(s,l,null==r?"":r)}}var Ba={create:Ra,update:Ra},Fa=/\s+/;function Na(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Fa).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function qa(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Fa).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Va(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&A(e,Ua(n.name||"v")),A(e,n),e}return"string"==typeof n?Ua(n):void 0}}var Ua=w((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Ha=G&&!Q,Ga="transition",$a="transitionend",Wa="animation",Ka="animationend";Ha&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Ga="WebkitTransition",$a="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Wa="WebkitAnimation",Ka="webkitAnimationEnd"));var Xa=G?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Qa(n){Xa((function(){Xa(n)}))}function Ya(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Na(n,e))}function Za(n,e){n._transitionClasses&&y(n._transitionClasses,e),qa(n,e)}function nr(n,e,t){var a=tr(n,e),r=a.type,i=a.timeout,o=a.propCount;if(!r)return t();var l="transition"===r?$a:Ka,s=0,c=function(){n.removeEventListener(l,u),t()},u=function(e){e.target===n&&++s>=o&&c()};setTimeout((function(){s<o&&c()}),i+1),n.addEventListener(l,u)}var er=/\b(transform|all)(,|$)/;function tr(n,e){var t,a=window.getComputedStyle(n),r=(a[Ga+"Delay"]||"").split(", "),i=(a[Ga+"Duration"]||"").split(", "),o=ar(r,i),l=(a[Wa+"Delay"]||"").split(", "),s=(a[Wa+"Duration"]||"").split(", "),c=ar(l,s),u=0,d=0;return"transition"===e?o>0&&(t="transition",u=o,d=i.length):"animation"===e?c>0&&(t="animation",u=c,d=s.length):d=(t=(u=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?i.length:s.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&er.test(a[Ga+"Property"])}}function ar(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return rr(e)+rr(n[t])})))}function rr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ir(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=Va(n.data.transition);if(!i(a)&&!o(t._enterCb)&&1===t.nodeType){for(var r=a.css,l=a.type,s=a.enterClass,u=a.enterToClass,d=a.enterActiveClass,p=a.appearClass,m=a.appearToClass,h=a.appearActiveClass,v=a.beforeEnter,f=a.enter,b=a.afterEnter,y=a.enterCancelled,x=a.beforeAppear,k=a.appear,w=a.afterAppear,j=a.appearCancelled,S=a.duration,T=Ye,I=Ye.$vnode;I&&I.parent;)T=I.context,I=I.parent;var C=!T._isMounted||!n.isRootInsert;if(!C||k||""===k){var z=C&&p?p:s,E=C&&h?h:d,A=C&&m?m:u,M=C&&x||v,J=C&&"function"==typeof k?k:f,L=C&&w||b,O=C&&j||y,P=g(c(S)?S.enter:S);0;var _=!1!==r&&!Q,R=sr(J),B=t._enterCb=D((function(){_&&(Za(t,A),Za(t,E)),B.cancelled?(_&&Za(t,z),O&&O(t)):L&&L(t),t._enterCb=null}));n.data.show||ue(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),J&&J(t,B)})),M&&M(t),_&&(Ya(t,z),Ya(t,E),Qa((function(){Za(t,z),B.cancelled||(Ya(t,A),R||(lr(P)?setTimeout(B,P):nr(t,l,B)))}))),n.data.show&&(e&&e(),J&&J(t,B)),_||R||B()}}}function or(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=Va(n.data.transition);if(i(a)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var r=a.css,l=a.type,s=a.leaveClass,u=a.leaveToClass,d=a.leaveActiveClass,p=a.beforeLeave,m=a.leave,h=a.afterLeave,v=a.leaveCancelled,f=a.delayLeave,b=a.duration,y=!1!==r&&!Q,x=sr(m),k=g(c(b)?b.leave:b);0;var w=t._leaveCb=D((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Za(t,u),Za(t,d)),w.cancelled?(y&&Za(t,s),v&&v(t)):(e(),h&&h(t)),t._leaveCb=null}));f?f(j):j()}function j(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(Ya(t,s),Ya(t,d),Qa((function(){Za(t,s),w.cancelled||(Ya(t,u),x||(lr(k)?setTimeout(w,k):nr(t,l,w)))}))),m&&m(t,w),y||x||w())}}function lr(n){return"number"==typeof n&&!isNaN(n)}function sr(n){if(i(n))return!1;var e=n.fns;return o(e)?sr(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function cr(n,e){!0!==e.data.show&&ir(e)}var ur=function(n){var e,t,a={},r=n.modules,c=n.nodeOps;for(e=0;e<ta.length;++e)for(a[ta[e]]=[],t=0;t<r.length;++t)o(r[t][ta[e]])&&a[ta[e]].push(r[t][ta[e]]);function u(n){var e=c.parentNode(n);o(e)&&c.removeChild(e,n)}function d(n,e,t,r,i,s,u){if(o(n.elm)&&o(s)&&(n=s[u]=xn(n)),n.isRootInsert=!i,!function(n,e,t,r){var i=n.data;if(o(i)){var s=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return p(n,e),m(t,n.elm,r),l(s)&&function(n,e,t,r){var i,l=n;for(;l.componentInstance;)if(l=l.componentInstance._vnode,o(i=l.data)&&o(i=i.transition)){for(i=0;i<a.activate.length;++i)a.activate[i](ea,l);e.push(l);break}m(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var d=n.data,v=n.children,f=n.tag;o(f)?(n.elm=n.ns?c.createElementNS(n.ns,f):c.createElement(f,n),b(n),h(n,v,e),o(d)&&g(n,e),m(t,n.elm,r)):l(n.isComment)?(n.elm=c.createComment(n.text),m(t,n.elm,r)):(n.elm=c.createTextNode(n.text),m(t,n.elm,r))}}function p(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,v(n)?(g(n,e),b(n)):(na(n),e.push(n))}function m(n,e,t){o(n)&&(o(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function h(n,e,t){if(Array.isArray(e)){0;for(var a=0;a<e.length;++a)d(e[a],t,n.elm,null,!0,e,a)}else s(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function v(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function g(n,t){for(var r=0;r<a.create.length;++r)a.create[r](ea,n);o(e=n.data.hook)&&(o(e.create)&&e.create(ea,n),o(e.insert)&&t.push(n))}function b(n){var e;if(o(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;o(e=Ye)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function y(n,e,t,a,r,i){for(;a<=r;++a)d(t[a],i,n,e,!1,t,a)}function x(n){var e,t,r=n.data;if(o(r))for(o(e=r.hook)&&o(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function k(n,e,t){for(;e<=t;++e){var a=n[e];o(a)&&(o(a.tag)?(w(a),x(a)):u(a.elm))}}function w(n,e){if(o(e)||o(n.data)){var t,r=a.remove.length+1;for(o(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,r),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&w(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else u(n.elm)}function j(n,e,t,a){for(var r=t;r<a;r++){var i=e[r];if(o(i)&&aa(n,i))return r}}function S(n,e,t,r,s,u){if(n!==e){o(e.elm)&&o(r)&&(e=r[s]=xn(e));var p=e.elm=n.elm;if(l(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?C(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(l(e.isStatic)&&l(n.isStatic)&&e.key===n.key&&(l(e.isCloned)||l(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;o(h)&&o(m=h.hook)&&o(m=m.prepatch)&&m(n,e);var g=n.children,f=e.children;if(o(h)&&v(e)){for(m=0;m<a.update.length;++m)a.update[m](n,e);o(m=h.hook)&&o(m=m.update)&&m(n,e)}i(e.text)?o(g)&&o(f)?g!==f&&function(n,e,t,a,r){var l,s,u,p=0,m=0,h=e.length-1,v=e[0],g=e[h],f=t.length-1,b=t[0],x=t[f],w=!r;for(0;p<=h&&m<=f;)i(v)?v=e[++p]:i(g)?g=e[--h]:aa(v,b)?(S(v,b,a,t,m),v=e[++p],b=t[++m]):aa(g,x)?(S(g,x,a,t,f),g=e[--h],x=t[--f]):aa(v,x)?(S(v,x,a,t,f),w&&c.insertBefore(n,v.elm,c.nextSibling(g.elm)),v=e[++p],x=t[--f]):aa(g,b)?(S(g,b,a,t,m),w&&c.insertBefore(n,g.elm,v.elm),g=e[--h],b=t[++m]):(i(l)&&(l=ra(e,p,h)),i(s=o(b.key)?l[b.key]:j(b,e,p,h))?d(b,a,n,v.elm,!1,t,m):aa(u=e[s],b)?(S(u,b,a,t,m),e[s]=void 0,w&&c.insertBefore(n,u.elm,v.elm)):d(b,a,n,v.elm,!1,t,m),b=t[++m]);p>h?y(n,i(t[f+1])?null:t[f+1].elm,t,m,f,a):m>f&&k(e,p,h)}(p,g,f,t,u):o(f)?(o(n.text)&&c.setTextContent(p,""),y(p,null,f,0,f.length-1,t)):o(g)?k(g,0,g.length-1):o(n.text)&&c.setTextContent(p,""):n.text!==e.text&&c.setTextContent(p,e.text),o(h)&&o(m=h.hook)&&o(m=m.postpatch)&&m(n,e)}}}function T(n,e,t){if(l(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var I=f("attrs,class,staticClass,staticStyle,key");function C(n,e,t,a){var r,i=e.tag,s=e.data,c=e.children;if(a=a||s&&s.pre,e.elm=n,l(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(s)&&(o(r=s.hook)&&o(r=r.init)&&r(e,!0),o(r=e.componentInstance)))return p(e,t),!0;if(o(i)){if(o(c))if(n.hasChildNodes())if(o(r=s)&&o(r=r.domProps)&&o(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,m=0;m<c.length;m++){if(!d||!C(d,c[m],t,a)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else h(e,c,t);if(o(s)){var v=!1;for(var f in s)if(!I(f)){v=!0,g(e,t);break}!v&&s.class&&oe(s.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!i(e)){var s,u=!1,p=[];if(i(n))u=!0,d(e,p);else{var m=o(n.nodeType);if(!m&&aa(n,e))S(n,e,p,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),l(t)&&C(n,e,p))return T(e,p,!0),n;s=n,n=new gn(c.tagName(s).toLowerCase(),{},[],void 0,s)}var h=n.elm,g=c.parentNode(h);if(d(e,p,h._leaveCb?null:g,c.nextSibling(h)),o(e.parent))for(var f=e.parent,b=v(e);f;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](f);if(f.elm=e.elm,b){for(var w=0;w<a.create.length;++w)a.create[w](ea,f);var j=f.data.hook.insert;if(j.merged)for(var I=1;I<j.fns.length;I++)j.fns[I]()}else na(f);f=f.parent}o(g)?k([n],0,0):o(n.tag)&&x(n)}}return T(e,p,u),e.elm}o(n)&&x(n)}}({nodeOps:Yt,modules:[va,ba,Ta,za,Ba,G?{create:cr,activate:cr,remove:function(n,e){!0!==n.data.show?or(n,e):e()}}:{}].concat(da)});Q&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&br(n,"input")}));var dr={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?ue(t,"postpatch",(function(){dr.componentUpdated(n,e,t)})):pr(n,e,t.context),n._vOptions=[].map.call(n.options,vr)):("textarea"===t.tag||Qt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",gr),n.addEventListener("compositionend",fr),n.addEventListener("change",fr),Q&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){pr(n,e,t.context);var a=n._vOptions,r=n._vOptions=[].map.call(n.options,vr);if(r.some((function(n,e){return!P(n,a[e])})))(n.multiple?e.value.some((function(n){return hr(n,r)})):e.value!==e.oldValue&&hr(e.value,r))&&br(n,"change")}}};function pr(n,e,t){mr(n,e,t),(X||Y)&&setTimeout((function(){mr(n,e,t)}),0)}function mr(n,e,t){var a=e.value,r=n.multiple;if(!r||Array.isArray(a)){for(var i,o,l=0,s=n.options.length;l<s;l++)if(o=n.options[l],r)i=_(a,vr(o))>-1,o.selected!==i&&(o.selected=i);else if(P(vr(o),a))return void(n.selectedIndex!==l&&(n.selectedIndex=l));r||(n.selectedIndex=-1)}}function hr(n,e){return e.every((function(e){return!P(e,n)}))}function vr(n){return"_value"in n?n._value:n.value}function gr(n){n.target.composing=!0}function fr(n){n.target.composing&&(n.target.composing=!1,br(n.target,"input"))}function br(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function yr(n){return!n.componentInstance||n.data&&n.data.transition?n:yr(n.componentInstance._vnode)}var xr={model:dr,show:{bind:function(n,e,t){var a=e.value,r=(t=yr(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&r?(t.data.show=!0,ir(t,(function(){n.style.display=i}))):n.style.display=a?i:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=yr(t)).data&&t.data.transition?(t.data.show=!0,a?ir(t,(function(){n.style.display=n.__vOriginalDisplay})):or(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,r){r||(n.style.display=n.__vOriginalDisplay)}}},kr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function wr(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?wr($e(e.children)):n}function jr(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var r=t._parentListeners;for(var i in r)e[S(i)]=r[i];return e}function Sr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Tr=function(n){return n.tag||fe(n)},Ir=function(n){return"show"===n.name},Cr={name:"transition",props:kr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Tr)).length){0;var a=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var i=wr(r);if(!i)return r;if(this._leaving)return Sr(n,r);var o="__transition-"+this._uid+"-";i.key=null==i.key?i.isComment?o+"comment":o+i.tag:s(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var l=(i.data||(i.data={})).transition=jr(this),c=this._vnode,u=wr(c);if(i.data.directives&&i.data.directives.some(Ir)&&(i.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,u)&&!fe(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=A({},l);if("out-in"===a)return this._leaving=!0,ue(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Sr(n,r);if("in-out"===a){if(fe(i))return c;var p,m=function(){p()};ue(l,"afterEnter",m),ue(l,"enterCancelled",m),ue(d,"delayLeave",(function(n){p=n}))}}return r}}},zr=A({tag:String,moveClass:String},kr);function Er(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ar(n){n.data.newPos=n.elm.getBoundingClientRect()}function Mr(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,r=e.top-t.top;if(a||r){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate("+a+"px,"+r+"px)",i.transitionDuration="0s"}}delete zr.mode;var Jr={Transition:Cr,TransitionGroup:{props:zr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var r=Ze(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],i=this.children=[],o=jr(this),l=0;l<r.length;l++){var s=r[l];if(s.tag)if(null!=s.key&&0!==String(s.key).indexOf("__vlist"))i.push(s),t[s.key]=s,(s.data||(s.data={})).transition=o;else;}if(a){for(var c=[],u=[],d=0;d<a.length;d++){var p=a[d];p.data.transition=o,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?c.push(p):u.push(p)}this.kept=n(e,null,c),this.removed=u}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Er),n.forEach(Ar),n.forEach(Mr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;Ya(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener($a,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener($a,n),t._moveCb=null,Za(t,e))})}})))},methods:{hasMove:function(n,e){if(!Ha)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){qa(t,n)})),Na(t,e),t.style.display="none",this.$el.appendChild(t);var a=tr(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};Tt.config.mustUseProp=function(n,e,t){return"value"===t&&Ot(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Tt.config.isReservedTag=Kt,Tt.config.isReservedAttr=Lt,Tt.config.getTagNamespace=function(n){return Wt(n)?"svg":"math"===n?"math":void 0},Tt.config.isUnknownElement=function(n){if(!G)return!0;if(Kt(n))return!1;if(n=n.toLowerCase(),null!=Xt[n])return Xt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Xt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Xt[n]=/HTMLUnknownElement/.test(e.toString())},A(Tt.options.directives,xr),A(Tt.options.components,Jr),Tt.prototype.__patch__=G?ur:J,Tt.prototype.$mount=function(n,e){return function(n,e,t){var a;return n.$el=e,n.$options.render||(n.$options.render=bn),tt(n,"beforeMount"),a=function(){n._update(n._render(),t)},new ht(n,a,J,{before:function(){n._isMounted&&!n._isDestroyed&&tt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,tt(n,"mounted")),n}(this,n=n&&G?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},G&&setTimeout((function(){F.devtools&&on&&on.emit("init",Tt)}),0);var Lr=Tt;
/*!
  * vue-router v3.5.3
  * (c) 2021 Evan You
  * @license MIT
  */function Or(n,e){for(var t in e)n[t]=e[t];return n}var Pr=/[!'()*]/g,_r=function(n){return"%"+n.charCodeAt(0).toString(16)},Dr=/%2C/g,Rr=function(n){return encodeURIComponent(n).replace(Pr,_r).replace(Dr,",")};function Br(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Fr=function(n){return null==n||"object"==typeof n?n:String(n)};function Nr(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=Br(t.shift()),r=t.length>0?Br(t.join("=")):null;void 0===e[a]?e[a]=r:Array.isArray(e[a])?e[a].push(r):e[a]=[e[a],r]})),e):e}function qr(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Rr(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(Rr(e)):a.push(Rr(e)+"="+Rr(n)))})),a.join("&")}return Rr(e)+"="+Rr(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Vr=/\/?$/;function Ur(n,e,t,a){var r=a&&a.options.stringifyQuery,i=e.query||{};try{i=Hr(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:Wr(e,r),matched:n?$r(n):[]};return t&&(o.redirectedFrom=Wr(t,r)),Object.freeze(o)}function Hr(n){if(Array.isArray(n))return n.map(Hr);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=Hr(n[t]);return e}return n}var Gr=Ur(null,{path:"/"});function $r(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Wr(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||qr)(a)+r}function Kr(n,e,t){return e===Gr?n===e:!!e&&(n.path&&e.path?n.path.replace(Vr,"")===e.path.replace(Vr,"")&&(t||n.hash===e.hash&&Xr(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Xr(n.query,e.query)&&Xr(n.params,e.params))))}function Xr(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,r){var i=n[t];if(a[r]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?Xr(i,o):String(i)===String(o)}))}function Qr(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var r=t.instances[a],i=t.enteredCbs[a];if(r&&i){delete t.enteredCbs[a];for(var o=0;o<i.length;o++)r._isBeingDestroyed||i[o](r)}}}}var Yr={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,r=e.parent,i=e.data;i.routerView=!0;for(var o=r.$createElement,l=t.name,s=r.$route,c=r._routerViewCache||(r._routerViewCache={}),u=0,d=!1;r&&r._routerRoot!==r;){var p=r.$vnode?r.$vnode.data:{};p.routerView&&u++,p.keepAlive&&r._directInactive&&r._inactive&&(d=!0),r=r.$parent}if(i.routerViewDepth=u,d){var m=c[l],h=m&&m.component;return h?(m.configProps&&Zr(h,i,m.route,m.configProps),o(h,i,a)):o()}var v=s.matched[u],g=v&&v.components[l];if(!v||!g)return c[l]=null,o();c[l]={component:g},i.registerRouteInstance=function(n,e){var t=v.instances[l];(e&&t!==n||!e&&t===n)&&(v.instances[l]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){v.instances[l]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==v.instances[l]&&(v.instances[l]=n.componentInstance),Qr(s)};var f=v.props&&v.props[l];return f&&(Or(c[l],{route:s,configProps:f}),Zr(g,i,s,f)),o(g,i,a)}};function Zr(n,e,t,a){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(r){r=e.props=Or({},r);var i=e.attrs=e.attrs||{};for(var o in r)n.props&&o in n.props||(i[o]=r[o],delete r[o])}}function ni(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var l=i[o];".."===l?r.pop():"."!==l&&r.push(l)}return""!==r[0]&&r.unshift(""),r.join("/")}function ei(n){return n.replace(/\/+/g,"/")}var ti=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ai=fi,ri=ci,ii=function(n,e){return di(ci(n,e),e)},oi=di,li=gi,si=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function ci(n,e){for(var t,a=[],r=0,i=0,o="",l=e&&e.delimiter||"/";null!=(t=si.exec(n));){var s=t[0],c=t[1],u=t.index;if(o+=n.slice(i,u),i=u+s.length,c)o+=c[1];else{var d=n[i],p=t[2],m=t[3],h=t[4],v=t[5],g=t[6],f=t[7];o&&(a.push(o),o="");var b=null!=p&&null!=d&&d!==p,y="+"===g||"*"===g,x="?"===g||"*"===g,k=t[2]||l,w=h||v;a.push({name:m||r++,prefix:p||"",delimiter:k,optional:x,repeat:y,partial:b,asterisk:!!f,pattern:w?mi(w):f?".*":"[^"+pi(k)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&a.push(o),a}function ui(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function di(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",vi(e)));return function(e,a){for(var r="",i=e||{},o=(a||{}).pretty?ui:encodeURIComponent,l=0;l<n.length;l++){var s=n[l];if("string"!=typeof s){var c,u=i[s.name];if(null==u){if(s.optional){s.partial&&(r+=s.prefix);continue}throw new TypeError('Expected "'+s.name+'" to be defined')}if(ti(u)){if(!s.repeat)throw new TypeError('Expected "'+s.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(s.optional)continue;throw new TypeError('Expected "'+s.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(c=o(u[d]),!t[l].test(c))throw new TypeError('Expected all "'+s.name+'" to match "'+s.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===d?s.prefix:s.delimiter)+c}}else{if(c=s.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(u),!t[l].test(c))throw new TypeError('Expected "'+s.name+'" to match "'+s.pattern+'", but received "'+c+'"');r+=s.prefix+c}}else r+=s}return r}}function pi(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function mi(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function hi(n,e){return n.keys=e,n}function vi(n){return n&&n.sensitive?"":"i"}function gi(n,e,t){ti(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,r=!1!==t.end,i="",o=0;o<n.length;o++){var l=n[o];if("string"==typeof l)i+=pi(l);else{var s=pi(l.prefix),c="(?:"+l.pattern+")";e.push(l),l.repeat&&(c+="(?:"+s+c+")*"),i+=c=l.optional?l.partial?s+"("+c+")?":"(?:"+s+"("+c+"))?":s+"("+c+")"}}var u=pi(t.delimiter||"/"),d=i.slice(-u.length)===u;return a||(i=(d?i.slice(0,-u.length):i)+"(?:"+u+"(?=$))?"),i+=r?"$":a&&d?"":"(?="+u+"|$)",hi(new RegExp("^"+i,vi(t)),e)}function fi(n,e,t){return ti(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return hi(n,e)}(n,e):ti(n)?function(n,e,t){for(var a=[],r=0;r<n.length;r++)a.push(fi(n[r],e,t).source);return hi(new RegExp("(?:"+a.join("|")+")",vi(t)),e)}(n,e,t):function(n,e,t){return gi(ci(n,t),e,t)}(n,e,t)}ai.parse=ri,ai.compile=ii,ai.tokensToFunction=oi,ai.tokensToRegExp=li;var bi=Object.create(null);function yi(n,e,t){e=e||{};try{var a=bi[n]||(bi[n]=ai.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function xi(n,e,t,a){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var i=(r=Or({},n)).params;return i&&"object"==typeof i&&(r.params=Or({},i)),r}if(!r.path&&r.params&&e){(r=Or({},r))._normalized=!0;var o=Or(Or({},e.params),r.params);if(e.name)r.name=e.name,r.params=o;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;r.path=yi(l,o,e.path)}else 0;return r}var s=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),c=e&&e.path||"/",u=s.path?ni(s.path,c,t||r.append):c,d=function(n,e,t){void 0===e&&(e={});var a,r=t||Nr;try{a=r(n||"")}catch(n){a={}}for(var i in e){var o=e[i];a[i]=Array.isArray(o)?o.map(Fr):Fr(o)}return a}(s.query,r.query,a&&a.options.parseQuery),p=r.hash||s.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:u,query:d,hash:p}}var ki,wi=function(){},ji={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,r=t.resolve(this.to,a,this.append),i=r.location,o=r.route,l=r.href,s={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,p=null==u?"router-link-exact-active":u,m=null==this.activeClass?d:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,v=o.redirectedFrom?Ur(null,xi(o.redirectedFrom),null,t):o;s[h]=Kr(a,v,this.exactPath),s[m]=this.exact||this.exactPath?s[h]:function(n,e){return 0===n.path.replace(Vr,"/").indexOf(e.path.replace(Vr,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,v);var g=s[h]?this.ariaCurrentValue:null,f=function(n){Si(n)&&(e.replace?t.replace(i,wi):t.push(i,wi))},b={click:Si};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=f})):b[this.event]=f;var y={class:s},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:o,navigate:f,isActive:s[m],isExactActive:s[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:l,"aria-current":g};else{var k=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(k){k.isStatic=!1;var w=k.data=Or({},k.data);for(var j in w.on=w.on||{},w.on){var S=w.on[j];j in b&&(w.on[j]=Array.isArray(S)?S:[S])}for(var T in b)T in w.on?w.on[T].push(b[T]):w.on[T]=f;var I=k.data.attrs=Or({},k.data.attrs);I.href=l,I["aria-current"]=g}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Si(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ti="undefined"!=typeof window;function Ii(n,e,t,a,r){var i=e||[],o=t||Object.create(null),l=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,r,i,o){var l=r.path,s=r.name;0;var c=r.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ei(e.path+"/"+n)}(l,i,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var d={path:u,regex:Ci(u,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:s,parent:i,matchAs:o,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var i=o?ei(o+"/"+r.path):void 0;n(e,t,a,r,d,i)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==r.alias)for(var p=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:r.children};n(e,t,a,h,i,d.path||"/")}s&&(a[s]||(a[s]=d))}(i,o,l,n,r)}));for(var s=0,c=i.length;s<c;s++)"*"===i[s]&&(i.push(i.splice(s,1)[0]),c--,s--);return{pathList:i,pathMap:o,nameMap:l}}function Ci(n,e){return ai(n,[],e)}function zi(n,e){var t=Ii(n),a=t.pathList,r=t.pathMap,i=t.nameMap;function o(n,t,o){var l=xi(n,t,!1,e),c=l.name;if(c){var u=i[c];if(!u)return s(null,l);var d=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof l.params&&(l.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in l.params)&&d.indexOf(p)>-1&&(l.params[p]=t.params[p]);return l.path=yi(u.path,l.params),s(u,l,o)}if(l.path){l.params={};for(var m=0;m<a.length;m++){var h=a[m],v=r[h];if(Ei(v.regex,l.path,l.params))return s(v,l,o)}}return s(null,l)}function l(n,t){var a=n.redirect,r="function"==typeof a?a(Ur(n,t,null,e)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return s(null,t);var l=r,c=l.name,u=l.path,d=t.query,p=t.hash,m=t.params;if(d=l.hasOwnProperty("query")?l.query:d,p=l.hasOwnProperty("hash")?l.hash:p,m=l.hasOwnProperty("params")?l.params:m,c){i[c];return o({_normalized:!0,name:c,query:d,hash:p,params:m},void 0,t)}if(u){var h=function(n,e){return ni(n,e.parent?e.parent.path:"/",!0)}(u,n);return o({_normalized:!0,path:yi(h,m),query:d,hash:p},void 0,t)}return s(null,t)}function s(n,t,a){return n&&n.redirect?l(n,a||t):n&&n.matchAs?function(n,e,t){var a=o({_normalized:!0,path:yi(t,e.params)});if(a){var r=a.matched,i=r[r.length-1];return e.params=a.params,s(i,e)}return s(null,e)}(0,t,n.matchAs):Ur(n,t,a,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Ii([e||n],a,r,i,t),t&&t.alias.length&&Ii(t.alias.map((function(n){return{path:n,children:[e]}})),a,r,i,t)},getRoutes:function(){return a.map((function(n){return r[n]}))},addRoutes:function(n){Ii(n,a,r,i)}}}function Ei(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var r=1,i=a.length;r<i;++r){var o=n.keys[r-1];o&&(t[o.name||"pathMatch"]="string"==typeof a[r]?Br(a[r]):a[r])}return!0}var Ai=Ti&&window.performance&&window.performance.now?window.performance:Date;function Mi(){return Ai.now().toFixed(3)}var Ji=Mi();function Li(){return Ji}function Oi(n){return Ji=n}var Pi=Object.create(null);function _i(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Or({},window.history.state);return t.key=Li(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Bi),function(){window.removeEventListener("popstate",Bi)}}function Di(n,e,t,a){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var i=function(){var n=Li();if(n)return Pi[n]}(),o=r.call(n,e,t,a?i:null);o&&("function"==typeof o.then?o.then((function(n){Ui(n,i)})).catch((function(n){0})):Ui(o,i))}))}}function Ri(){var n=Li();n&&(Pi[n]={x:window.pageXOffset,y:window.pageYOffset})}function Bi(n){Ri(),n.state&&n.state.key&&Oi(n.state.key)}function Fi(n){return qi(n.x)||qi(n.y)}function Ni(n){return{x:qi(n.x)?n.x:window.pageXOffset,y:qi(n.y)?n.y:window.pageYOffset}}function qi(n){return"number"==typeof n}var Vi=/^#\d/;function Ui(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var r=Vi.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(r,i={x:qi((t=i).x)?t.x:0,y:qi(t.y)?t.y:0})}else Fi(n)&&(e=Ni(n))}else a&&Fi(n)&&(e=Ni(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var Hi,Gi=Ti&&((-1===(Hi=window.navigator.userAgent).indexOf("Android 2.")&&-1===Hi.indexOf("Android 4.0")||-1===Hi.indexOf("Mobile Safari")||-1!==Hi.indexOf("Chrome")||-1!==Hi.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function $i(n,e){Ri();var t=window.history;try{if(e){var a=Or({},t.state);a.key=Li(),t.replaceState(a,"",n)}else t.pushState({key:Oi(Mi())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Wi(n){$i(n,!0)}function Ki(n,e,t){var a=function(r){r>=n.length?t():n[r]?e(n[r],(function(){a(r+1)})):a(r+1)};a(0)}var Xi={redirected:2,aborted:4,cancelled:8,duplicated:16};function Qi(n,e){return Zi(n,e,Xi.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return no.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Yi(n,e){return Zi(n,e,Xi.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Zi(n,e,t,a){var r=new Error(a);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var no=["params","query","hash"];function eo(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function to(n,e){return eo(n)&&n._isRouter&&(null==e||n.type===e)}function ao(n){return function(e,t,a){var r=!1,i=0,o=null;ro(n,(function(n,e,t,l){if("function"==typeof n&&void 0===n.cid){r=!0,i++;var s,c=lo((function(e){var r;((r=e).__esModule||oo&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:ki.extend(e),t.components[l]=e,--i<=0&&a()})),u=lo((function(n){var e="Failed to resolve async component "+l+": "+n;o||(o=eo(n)?n:new Error(e),a(o))}));try{s=n(c,u)}catch(n){u(n)}if(s)if("function"==typeof s.then)s.then(c,u);else{var d=s.component;d&&"function"==typeof d.then&&d.then(c,u)}}})),r||a()}}function ro(n,e){return io(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function io(n){return Array.prototype.concat.apply([],n)}var oo="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function lo(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var so=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ti){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Gr,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function co(n,e,t,a){var r=ro(n,(function(n,a,r,i){var o=function(n,e){"function"!=typeof n&&(n=ki.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,a,r,i)})):t(o,a,r,i)}));return io(a?r.reverse():r)}function uo(n,e){if(e)return function(){return n.apply(e,arguments)}}so.prototype.listen=function(n){this.cb=n},so.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},so.prototype.onError=function(n){this.errorCbs.push(n)},so.prototype.transitionTo=function(n,e,t){var a,r=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),e&&e(a),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(a,i)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!r.ready&&(to(n,Xi.redirected)&&i===Gr||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},so.prototype.confirmTransition=function(n,e,t){var a=this,r=this.current;this.pending=n;var i,o,l=function(n){!to(n)&&eo(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},s=n.matched.length-1,c=r.matched.length-1;if(Kr(n,r)&&s===c&&n.matched[s]===r.matched[c])return this.ensureURL(),n.hash&&Di(this.router,r,n,!1),l(((o=Zi(i=r,n,Xi.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var u=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=u.updated,p=u.deactivated,m=u.activated,h=[].concat(function(n){return co(n,"beforeRouteLeave",uo,!0)}(p),this.router.beforeHooks,function(n){return co(n,"beforeRouteUpdate",uo)}(d),m.map((function(n){return n.beforeEnter})),ao(m)),v=function(e,t){if(a.pending!==n)return l(Yi(r,n));try{e(n,r,(function(e){!1===e?(a.ensureURL(!0),l(function(n,e){return Zi(n,e,Xi.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):eo(e)?(a.ensureURL(!0),l(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(l(Qi(r,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){l(n)}};Ki(h,v,(function(){Ki(function(n){return co(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,r,i){return n(a,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,a)}))}(m).concat(a.router.resolveHooks),v,(function(){if(a.pending!==n)return l(Yi(r,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){Qr(n)}))}))}))},so.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},so.prototype.setupListeners=function(){},so.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Gr,this.pending=null};var po=function(n){function e(e,t){n.call(this,e,t),this._startLocation=mo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=Gi&&t;a&&this.listeners.push(_i());var r=function(){var t=n.current,r=mo(n.base);n.current===Gr&&r===n._startLocation||n.transitionTo(r,(function(n){a&&Di(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){$i(ei(a.base+n.fullPath)),Di(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Wi(ei(a.base+n.fullPath)),Di(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(mo(this.base)!==this.current.fullPath){var e=ei(this.base+this.current.fullPath);n?$i(e):Wi(e)}},e.prototype.getCurrentLocation=function(){return mo(this.base)},e}(so);function mo(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(ei(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var ho=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=mo(n);if(!/^\/#/.test(e))return window.location.replace(ei(n+"/#"+e)),!0}(this.base)||vo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Gi&&e;t&&this.listeners.push(_i());var a=function(){var e=n.current;vo()&&n.transitionTo(go(),(function(a){t&&Di(n.router,a,e,!0),Gi||yo(a.fullPath)}))},r=Gi?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){bo(n.fullPath),Di(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){yo(n.fullPath),Di(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;go()!==e&&(n?bo(e):yo(e))},e.prototype.getCurrentLocation=function(){return go()},e}(so);function vo(){var n=go();return"/"===n.charAt(0)||(yo("/"+n),!1)}function go(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function fo(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function bo(n){Gi?$i(fo(n)):window.location.hash=n}function yo(n){Gi?Wi(fo(n)):window.location.replace(fo(n))}var xo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){to(n,Xi.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(so),ko=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=zi(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Gi&&!1!==n.fallback,this.fallback&&(e="hash"),Ti||(e="abstract"),this.mode=e,e){case"history":this.history=new po(this,n.base);break;case"hash":this.history=new ho(this,n.base,this.fallback);break;case"abstract":this.history=new xo(this,n.base);break;default:0}},wo={currentRoute:{configurable:!0}};function jo(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}ko.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},wo.currentRoute.get=function(){return this.history&&this.history.current},ko.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof po||t instanceof ho){var a=function(n){t.setupListeners(),function(n){var a=t.current,r=e.options.scrollBehavior;Gi&&r&&"fullPath"in n&&Di(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},ko.prototype.beforeEach=function(n){return jo(this.beforeHooks,n)},ko.prototype.beforeResolve=function(n){return jo(this.resolveHooks,n)},ko.prototype.afterEach=function(n){return jo(this.afterHooks,n)},ko.prototype.onReady=function(n,e){this.history.onReady(n,e)},ko.prototype.onError=function(n){this.history.onError(n)},ko.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},ko.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},ko.prototype.go=function(n){this.history.go(n)},ko.prototype.back=function(){this.go(-1)},ko.prototype.forward=function(){this.go(1)},ko.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},ko.prototype.resolve=function(n,e,t){var a=xi(n,e=e||this.history.current,t,this),r=this.match(a,e),i=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?ei(n+"/"+a):a}(this.history.base,i,this.mode),normalizedTo:a,resolved:r}},ko.prototype.getRoutes=function(){return this.matcher.getRoutes()},ko.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Gr&&this.history.transitionTo(this.history.getCurrentLocation())},ko.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Gr&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(ko.prototype,wo),ko.install=function n(e){if(!n.installed||ki!==e){n.installed=!0,ki=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Yr),e.component("RouterLink",ji);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},ko.version="3.5.3",ko.isNavigationFailure=to,ko.NavigationFailureType=Xi,ko.START_LOCATION=Gr,Ti&&window.Vue&&window.Vue.use(ko);var So=ko;t(231),t(178),t(263),t(105),t(265),t(33),t(34),t(266);function To(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(83),t(96),t(126);function Io(n){return(Io="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}var Co=t(77),zo=(t(190),t(19),t(45),t(234),t(235),t(40),t(26),{NotFound:function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,492))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,491))}}),Eo={"v-3153b7fc":function(){return t.e(5).then(t.bind(null,493))},"v-10edfa45":function(){return t.e(6).then(t.bind(null,494))},"v-e5b5cf7c":function(){return t.e(7).then(t.bind(null,495))},"v-3d2ab288":function(){return t.e(8).then(t.bind(null,496))},"v-d34be976":function(){return t.e(9).then(t.bind(null,497))},"v-7a009923":function(){return t.e(10).then(t.bind(null,498))},"v-7c6b52a2":function(){return t.e(11).then(t.bind(null,499))},"v-7139151c":function(){return t.e(12).then(t.bind(null,500))},"v-cee742ae":function(){return t.e(13).then(t.bind(null,501))},"v-5587af85":function(){return t.e(14).then(t.bind(null,502))},"v-588a32fe":function(){return t.e(15).then(t.bind(null,503))},"v-4b2a057d":function(){return t.e(16).then(t.bind(null,504))},"v-028ab83c":function(){return t.e(17).then(t.bind(null,505))},"v-754b2a7f":function(){return t.e(18).then(t.bind(null,506))},"v-d972a732":function(){return t.e(19).then(t.bind(null,507))},"v-0488142c":function(){return t.e(20).then(t.bind(null,508))},"v-77b9ba0f":function(){return t.e(21).then(t.bind(null,509))},"v-2b1eb9dc":function(){return t.e(22).then(t.bind(null,510))},"v-4d01f884":function(){return t.e(23).then(t.bind(null,511))},"v-6680f397":function(){return t.e(24).then(t.bind(null,512))},"v-db310efe":function(){return t.e(25).then(t.bind(null,513))},"v-10aec85a":function(){return t.e(26).then(t.bind(null,514))},"v-4a35b4c6":function(){return t.e(27).then(t.bind(null,515))},"v-25ace197":function(){return t.e(28).then(t.bind(null,516))},"v-547c7992":function(){return t.e(29).then(t.bind(null,517))},"v-3c0b8b37":function(){return t.e(30).then(t.bind(null,518))},"v-ece8b2de":function(){return t.e(31).then(t.bind(null,519))},"v-66468b6a":function(){return t.e(32).then(t.bind(null,520))},"v-894864aa":function(){return t.e(33).then(t.bind(null,521))},"v-52187be7":function(){return t.e(34).then(t.bind(null,522))},"v-1a226c27":function(){return t.e(35).then(t.bind(null,523))},"v-ca7e680c":function(){return t.e(36).then(t.bind(null,524))},"v-78bf0d7d":function(){return t.e(37).then(t.bind(null,525))},"v-c2d85758":function(){return t.e(38).then(t.bind(null,526))},"v-01edae99":function(){return t.e(39).then(t.bind(null,527))},"v-7127b67f":function(){return t.e(40).then(t.bind(null,528))},"v-03ec984a":function(){return t.e(41).then(t.bind(null,529))},"v-2d65902d":function(){return t.e(42).then(t.bind(null,530))},"v-04c588a5":function(){return t.e(43).then(t.bind(null,531))},"v-3ce16de3":function(){return t.e(44).then(t.bind(null,532))},"v-2b9ad123":function(){return t.e(45).then(t.bind(null,533))},"v-4514b826":function(){return t.e(46).then(t.bind(null,534))},"v-44bda162":function(){return t.e(47).then(t.bind(null,535))},"v-39d421ee":function(){return t.e(48).then(t.bind(null,536))},"v-43f2d4d3":function(){return t.e(49).then(t.bind(null,537))},"v-63688c1a":function(){return t.e(50).then(t.bind(null,538))},"v-28d2db4f":function(){return t.e(51).then(t.bind(null,539))},"v-740dc458":function(){return t.e(52).then(t.bind(null,540))},"v-89b8bfb2":function(){return t.e(53).then(t.bind(null,541))},"v-15000fa6":function(){return t.e(54).then(t.bind(null,542))},"v-9f9ce560":function(){return t.e(55).then(t.bind(null,543))},"v-7b2d21b6":function(){return t.e(56).then(t.bind(null,544))},"v-6d0e3968":function(){return t.e(57).then(t.bind(null,545))},"v-f2b27b04":function(){return t.e(58).then(t.bind(null,546))},"v-7c58f187":function(){return t.e(59).then(t.bind(null,547))},"v-4de46402":function(){return t.e(60).then(t.bind(null,548))},"v-97c6d734":function(){return t.e(61).then(t.bind(null,549))},"v-4a04eb05":function(){return t.e(62).then(t.bind(null,550))},"v-c9acc070":function(){return t.e(63).then(t.bind(null,551))},"v-3f7bcbb6":function(){return t.e(64).then(t.bind(null,552))},"v-67a474f6":function(){return t.e(65).then(t.bind(null,553))},"v-73f01fa5":function(){return t.e(66).then(t.bind(null,554))},"v-ceebf0d4":function(){return t.e(67).then(t.bind(null,555))}};function Ao(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var Mo=/-(\w)/g,Jo=Ao((function(n){return n.replace(Mo,(function(n,e){return e?e.toUpperCase():""}))})),Lo=/\B([A-Z])/g,Oo=Ao((function(n){return n.replace(Lo,"-$1").toLowerCase()})),Po=Ao((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function _o(n,e){if(e)return n(e)?n(e):e.includes("-")?n(Po(Jo(e))):n(Po(e))||n(Oo(e))}var Do=Object.assign({},zo,Eo),Ro=function(n){return Do[n]},Bo=function(n){return Eo[n]},Fo=function(n){return zo[n]},No=function(n){return Lr.component(n)};function qo(n){return _o(Bo,n)}function Vo(n){return _o(Fo,n)}function Uo(n){return _o(Ro,n)}function Ho(n){return _o(No,n)}function Go(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(a.a)(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(Ho(e)||!Uo(e)){n.next=5;break}return n.next=3,Uo(e)();case 3:t=n.sent,Lr.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function $o(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var Wo=t(137),Ko=(t(125),t(113),t(79),t(221)),Xo=t.n(Ko),Qo=t(222),Yo=t.n(Qo),Zo={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(Wo.a)(n,1)[0]})).map((function(n){var e=Object(Wo.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(Yo()(n[t]),'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=el(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(Co.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=tl(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Xo()([{name:"description",content:this.$description}],n,this.siteMeta,al)},updateCanonicalLink:function(){nl(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",el(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){tl(null,this.currentMetaTags),nl()}};function nl(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function el(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function tl(n,e){if(e&&Object(Co.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function al(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var a=t[e];if(n.hasOwnProperty(a))return n[a]+a}return JSON.stringify(n)}t(139);var rl=t(152),il={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(rl)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),a=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+a,o=0;o<t.length;o++){var l=t[o],s=t[o+1],c=0===o&&0===a||a>=l.parentElement.offsetTop+10&&(!s||a<s.parentElement.offsetTop-10),u=decodeURIComponent(this.$route.hash);if(c&&u!==decodeURIComponent(l.hash)){var d=l;if(i===r)for(var p=o+1;p<t.length;p++)if(u===decodeURIComponent(t[p].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(d.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},ol=(t(109),t(104)),ll=t.n(ol),sl={mounted:function(){var n=this;ll.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||Lr.component(n.name)||ll.a.start(),t()})),this.$router.afterEach((function(){ll.a.done(),n.isSidebarOpen=!1}))}};t(81),t(42),t(84),t(380);function cl(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(143);function ul(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}function dl(n,e,t){return e&&ul(n.prototype,e),t&&ul(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}t(381);var pl=function(){function n(){cl(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return dl(n,[{key:"show",value:function(n){var e=this,t=n.text,a=void 0===t?"":t,r=n.duration,i=void 0===r?3e3:r,o=document.createElement("div");o.className="message move-in",o.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(a,"</div>\n    "),this.containerEl.appendChild(o),i>0&&setTimeout((function(){e.close(o)}),i)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),ml={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(e){document.querySelectorAll(e).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var e=this;if(!n.classList.contains("codecopy-enabled")){var t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Copy to clipboard",t.addEventListener("click",(function(){e.copyToClipboard(n.innerText)})),n.appendChild(t),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),(new pl).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};t(237),t(80),t(138),t(140),t(383);!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&a.firstChild?a.insertBefore(r,a.firstChild):a.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var hl={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},vl={},gl=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},fl=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:hl[n]},bl=function n(e,t,a){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,i=e.children;r.appendChild(n(t,a,i))})),r},yl=function(n,e,t){var a,r=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==r.length||t?r:r[0]},xl=function(n,e){var t,a,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),l={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};l.htmlTpl=gl(l.html),l.jsTpl=(t=l.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),l.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,i=[eval][0](r);return i.template=e,i}(l.js,l.html);var s=fl("vue");return l.jsLib.unshift(s),l},kl=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),o={css:a&&a[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},wl=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function jl(){var n=yl(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=yl(n,"vuepress-plugin-demo-block__code"),t=yl(n,"vuepress-plugin-demo-block__display"),a=yl(n,"vuepress-plugin-demo-block__footer"),r=yl(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),l=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var s=e.querySelector("div").clientHeight,c="react"===l?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(a))(),i={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:wl(n),htmlTpl:gl("")},o=fl("react"),l=fl("reactDOM");return i.jsLib.unshift(o,l),i}(i,o):"vanilla"===l?kl(i,o):xl(i,o),u=bl("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(u),u.addEventListener("click",Sl.bind(null,u,s,e,a)),fl("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=r.concat(i).concat(fl("cssLib")).concat(fl("jsLib")).join(",");return bl("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),fl("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=JSON.stringify({css:e,html:t,js:a,js_external:r.concat(fl("jsLib")).join(";"),css_external:i.concat(fl("cssLib")).join(";"),layout:fl("codepenLayout"),js_pre_processor:fl("codepenJsProcessor"),editors:fl("codepenEditors")});return bl("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:fl("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var d=e.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(c.css&&function(n){if(!vl[n]){var e=bl("style",{innerHTML:n});document.body.appendChild(e),vl[n]=!0}}(c.css),"react"===l)ReactDOM.render(React.createElement(c.js),r);else if("vue"===l){var p=(new(Vue.extend(c.script))).$mount();r.appendChild(p.$el)}else"vanilla"===l&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){jl()}),300)}function Sl(n,e,t,a){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var Tl={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},jl()},updated:function(){jl()}},Il=(t(225),"auto"),Cl="zoom-in",zl="zoom-out",El="grab",Al="move";function Ml(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};a?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function Jl(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Ll(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ol(n,e,t){!function(n){var e=Pl,t=_l;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var a=n.style,r={};for(var i in e)t&&(r[i]=a[i]||""),a[i]=e[i];return r}var Pl="transition",_l="transform",Dl="transform",Rl="transitionend";var Bl=function(){},Fl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Bl,onClose:Bl,onGrab:Bl,onMove:Bl,onRelease:Bl,onBeforeOpen:Bl,onBeforeClose:Bl,onBeforeGrab:Bl,onBeforeRelease:Bl,onImageLoading:Bl,onImageLoaded:Bl},Nl={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Vl(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(r)>=i||Math.abs(a)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(ql(n)&&!Vl(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){ql(n)&&!Vl(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function ql(n){return 0===n.button}function Vl(n){return n.metaKey||n.ctrlKey}var Ul={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ol(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Ml(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ol(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Hl="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Gl=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),$l=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},Wl={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Ll(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?El:zl,transition:Dl+"\n        "+a+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ol(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ol(this.el,{transform:"none"})},grab:function(n,e,t){var a=Kl(),r=a.x-n,i=a.y-e;Ol(this.el,{cursor:Al,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=Kl(),r=a.x-n,i=a.y-e;Ol(this.el,{transition:Dl,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ol(this.el,this.styleClose)},restoreOpenStyle:function(){Ol(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Kl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,r=a.customSize,i=a.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":Hl(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var o=this.rect.width/2,l=this.rect.height/2,s=Kl(),c={x:s.x-o,y:s.y-l},u=c.x/o,d=c.y/l,p=i+Math.min(u,d);if(r&&"string"==typeof r){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,v=parseFloat(r)*m/(100*this.rect.width),g=parseFloat(r)*h/(100*this.rect.height);if(p>v||p>g)return{x:v,y:g}}return{x:p,y:p}}};function Kl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Xl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Ml(n,a,e[a],t)}))}var Ql=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Wl),this.overlay=Object.create(Ul),this.handler=Object.create(Nl),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=$l({},Fl,e),this.overlay.init(this),this.handler.init(this)}return Gl(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Cl,Ml(n,"click",this.handler.click),this.options.preloadImage&&Jl(Ll(n)));return this}},{key:"config",value:function(n){return n?($l(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(a),Jl(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Ml(document,"scroll",this.handler.scroll),Ml(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Ml(window,"resize",this.handler.resizeWindow);var i=function n(){Ml(a,Rl,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Xl(document,e.handler,!0),t(a)};return Ml(a,Rl,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Il,this.overlay.fadeOut(),this.target.zoomOut(),Ml(document,"scroll",this.handler.scroll,!1),Ml(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Ml(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Ml(t,Rl,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Xl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Ml(t,Rl,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var i=function n(){Ml(r,Rl,n,!1),a(r)};return Ml(r,Rl,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Al,this.target.move(n,e,t);var r=this.target.el,i=function n(){Ml(r,Rl,n,!1),a(r)};return Ml(r,Rl,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Il,this.target.restoreOpenStyle();var a=function a(){Ml(t,Rl,a,!1),n.lock=!1,n.released=!0,e(t)};return Ml(t,Rl,a),this}}}]),n}(),Yl=".theme-vdoing-content img:not(.no-zoom)",Zl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ns=Number("500"),es=function(){function n(){cl(this,n),this.instance=new Ql(Zl)}return dl(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Yl;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Yl,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ns;setTimeout((function(){return n.update(e)}),t)}}]),n}(),ts=[Zo,il,sl,ml,Tl,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new es,this.$vuepress.zooming.updateDelay()}}],as={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return $o("layout",n),Lr.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},rs=t(30),is=Object(rs.a)(as,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var a;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(a=n[e]).push.apply(a,Object(Co.a)(t));break;default:throw new Error("Unknown option name.")}}(is,"mixins",ts);var os=[{name:"v-3153b7fc",path:"/pages/9f7bb5/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-3153b7fc").then(t)}},{path:"/pages/9f7bb5/index.html",redirect:"/pages/9f7bb5/"},{path:"/01.基础特性/00.Java开发环境.html",redirect:"/pages/9f7bb5/"},{name:"v-10edfa45",path:"/pages/23333b/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-10edfa45").then(t)}},{path:"/pages/23333b/index.html",redirect:"/pages/23333b/"},{path:"/01.基础特性/01.Java基础语法.html",redirect:"/pages/23333b/"},{name:"v-e5b5cf7c",path:"/pages/2e072a/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-e5b5cf7c").then(t)}},{path:"/pages/2e072a/index.html",redirect:"/pages/2e072a/"},{path:"/01.基础特性/02.Java基本数据类型.html",redirect:"/pages/2e072a/"},{name:"v-3d2ab288",path:"/pages/d6b776/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-3d2ab288").then(t)}},{path:"/pages/d6b776/index.html",redirect:"/pages/d6b776/"},{path:"/01.基础特性/03.Java面向对象.html",redirect:"/pages/d6b776/"},{name:"v-d34be976",path:"/pages/d17f6e/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-d34be976").then(t)}},{path:"/pages/d17f6e/index.html",redirect:"/pages/d17f6e/"},{path:"/01.基础特性/04.Java方法.html",redirect:"/pages/d17f6e/"},{name:"v-7a009923",path:"/pages/33ad31/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-7a009923").then(t)}},{path:"/pages/33ad31/index.html",redirect:"/pages/33ad31/"},{path:"/01.基础特性/05.Java数组.html",redirect:"/pages/33ad31/"},{name:"v-7c6b52a2",path:"/pages/ae8c35/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-7c6b52a2").then(t)}},{path:"/pages/ae8c35/index.html",redirect:"/pages/ae8c35/"},{path:"/01.基础特性/06.Java枚举.html",redirect:"/pages/ae8c35/"},{name:"v-7139151c",path:"/pages/8e828a/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-7139151c").then(t)}},{path:"/pages/8e828a/index.html",redirect:"/pages/8e828a/"},{path:"/01.基础特性/07.Java控制语句.html",redirect:"/pages/8e828a/"},{name:"v-cee742ae",path:"/pages/59fbf8/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-cee742ae").then(t)}},{path:"/pages/59fbf8/index.html",redirect:"/pages/59fbf8/"},{path:"/01.基础特性/08.Java异常.html",redirect:"/pages/59fbf8/"},{name:"v-5587af85",path:"/pages/987cf1/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-5587af85").then(t)}},{path:"/pages/987cf1/index.html",redirect:"/pages/987cf1/"},{path:"/01.基础特性/09.Java泛型.html",redirect:"/pages/987cf1/"},{name:"v-588a32fe",path:"/pages/793a2a/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-588a32fe").then(t)}},{path:"/pages/793a2a/index.html",redirect:"/pages/793a2a/"},{path:"/01.基础特性/10.Java反射.html",redirect:"/pages/793a2a/"},{name:"v-4b2a057d",path:"/pages/66a7ee/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-4b2a057d").then(t)}},{path:"/pages/66a7ee/index.html",redirect:"/pages/66a7ee/"},{path:"/01.基础特性/11.Java注解.html",redirect:"/pages/66a7ee/"},{name:"v-028ab83c",path:"/pages/c29a85/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-028ab83c").then(t)}},{path:"/pages/c29a85/index.html",redirect:"/pages/c29a85/"},{path:"/01.基础特性/41.Java常用工具类.html",redirect:"/pages/c29a85/"},{name:"v-754b2a7f",path:"/pages/0c9e8c/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-754b2a7f").then(t)}},{path:"/pages/0c9e8c/index.html",redirect:"/pages/0c9e8c/"},{path:"/01.基础特性/42.JavaString类型.html",redirect:"/pages/0c9e8c/"},{name:"v-d972a732",path:"/pages/80c858/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-d972a732").then(t)}},{path:"/pages/80c858/index.html",redirect:"/pages/80c858/"},{path:"/01.基础特性/",redirect:"/pages/80c858/"},{name:"v-0488142c",path:"/pages/272038/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-0488142c").then(t)}},{path:"/pages/272038/index.html",redirect:"/pages/272038/"},{path:"/02.高级特性/01.Java正则.html",redirect:"/pages/272038/"},{name:"v-77b9ba0f",path:"/pages/887467/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-77b9ba0f").then(t)}},{path:"/pages/887467/index.html",redirect:"/pages/887467/"},{path:"/02.高级特性/02.Java编码和加密.html",redirect:"/pages/887467/"},{name:"v-2b1eb9dc",path:"/pages/f7bac4/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-2b1eb9dc").then(t)}},{path:"/pages/f7bac4/index.html",redirect:"/pages/f7bac4/"},{path:"/02.高级特性/03.Java本地化.html",redirect:"/pages/f7bac4/"},{name:"v-4d01f884",path:"/pages/8c8dd6/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-4d01f884").then(t)}},{path:"/pages/8c8dd6/index.html",redirect:"/pages/8c8dd6/"},{path:"/02.高级特性/04.JDK8.html",redirect:"/pages/8c8dd6/"},{name:"v-6680f397",path:"/pages/c63b72/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-6680f397").then(t)}},{path:"/pages/c63b72/index.html",redirect:"/pages/c63b72/"},{path:"/02.高级特性/99.Java编程规范.html",redirect:"/pages/c63b72/"},{name:"v-db310efe",path:"/pages/dfadaa/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-db310efe").then(t)}},{path:"/pages/dfadaa/index.html",redirect:"/pages/dfadaa/"},{path:"/02.高级特性/",redirect:"/pages/dfadaa/"},{name:"v-10aec85a",path:"/pages/3b9a57/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-10aec85a").then(t)}},{path:"/pages/3b9a57/index.html",redirect:"/pages/3b9a57/"},{path:"/03.容器/01.Java容器简介.html",redirect:"/pages/3b9a57/"},{name:"v-4a35b4c6",path:"/pages/decaa9/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-4a35b4c6").then(t)}},{path:"/pages/decaa9/index.html",redirect:"/pages/decaa9/"},{path:"/03.容器/02.Java容器之List.html",redirect:"/pages/decaa9/"},{name:"v-25ace197",path:"/pages/6ce173/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-25ace197").then(t)}},{path:"/pages/6ce173/index.html",redirect:"/pages/6ce173/"},{path:"/03.容器/03.Java容器之Map.html",redirect:"/pages/6ce173/"},{name:"v-547c7992",path:"/pages/b12803/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-547c7992").then(t)}},{path:"/pages/b12803/index.html",redirect:"/pages/b12803/"},{path:"/03.容器/04.Java容器之Set.html",redirect:"/pages/b12803/"},{name:"v-3c0b8b37",path:"/pages/3c422d/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-3c0b8b37").then(t)}},{path:"/pages/3c422d/index.html",redirect:"/pages/3c422d/"},{path:"/03.容器/05.Java容器之Queue.html",redirect:"/pages/3c422d/"},{name:"v-ece8b2de",path:"/pages/7d4bd9/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-ece8b2de").then(t)}},{path:"/pages/7d4bd9/index.html",redirect:"/pages/7d4bd9/"},{path:"/03.容器/06.Java容器之Stream.html",redirect:"/pages/7d4bd9/"},{name:"v-66468b6a",path:"/pages/e1abdb/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-66468b6a").then(t)}},{path:"/pages/e1abdb/index.html",redirect:"/pages/e1abdb/"},{path:"/03.容器/",redirect:"/pages/e1abdb/"},{name:"v-894864aa",path:"/pages/99f4f4/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-894864aa").then(t)}},{path:"/pages/99f4f4/index.html",redirect:"/pages/99f4f4/"},{path:"/04.IO/01.JavaIO模型.html",redirect:"/pages/99f4f4/"},{name:"v-52187be7",path:"/pages/ff6965/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-52187be7").then(t)}},{path:"/pages/ff6965/index.html",redirect:"/pages/ff6965/"},{path:"/04.IO/02.JavaNIO.html",redirect:"/pages/ff6965/"},{name:"v-1a226c27",path:"/pages/287e58/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-1a226c27").then(t)}},{path:"/pages/287e58/index.html",redirect:"/pages/287e58/"},{path:"/04.IO/03.Java序列化.html",redirect:"/pages/287e58/"},{name:"v-ca7e680c",path:"/pages/e70be2/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-ca7e680c").then(t)}},{path:"/pages/e70be2/index.html",redirect:"/pages/e70be2/"},{path:"/04.IO/04.Java网络编程.html",redirect:"/pages/e70be2/"},{name:"v-78bf0d7d",path:"/pages/e33faa/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-78bf0d7d").then(t)}},{path:"/pages/e33faa/index.html",redirect:"/pages/e33faa/"},{path:"/04.IO/05.JavaIO工具类.html",redirect:"/pages/e33faa/"},{name:"v-c2d85758",path:"/pages/8826bb/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-c2d85758").then(t)}},{path:"/pages/8826bb/index.html",redirect:"/pages/8826bb/"},{path:"/04.IO/",redirect:"/pages/8826bb/"},{name:"v-01edae99",path:"/pages/b39f82/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-01edae99").then(t)}},{path:"/pages/b39f82/index.html",redirect:"/pages/b39f82/"},{path:"/05.并发/01.Java并发简介.html",redirect:"/pages/b39f82/"},{name:"v-7127b67f",path:"/pages/1f74be/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-7127b67f").then(t)}},{path:"/pages/1f74be/index.html",redirect:"/pages/1f74be/"},{path:"/05.并发/02.Java线程基础.html",redirect:"/pages/1f74be/"},{name:"v-03ec984a",path:"/pages/4a7f19/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-03ec984a").then(t)}},{path:"/pages/4a7f19/index.html",redirect:"/pages/4a7f19/"},{path:"/05.并发/03.Java并发核心机制.html",redirect:"/pages/4a7f19/"},{name:"v-2d65902d",path:"/pages/37bf7b/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-2d65902d").then(t)}},{path:"/pages/37bf7b/index.html",redirect:"/pages/37bf7b/"},{path:"/05.并发/04.Java锁.html",redirect:"/pages/37bf7b/"},{name:"v-04c588a5",path:"/pages/c29e3a/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-04c588a5").then(t)}},{path:"/pages/c29e3a/index.html",redirect:"/pages/c29e3a/"},{path:"/05.并发/05.Java原子类.html",redirect:"/pages/c29e3a/"},{name:"v-3ce16de3",path:"/pages/3038c4/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-3ce16de3").then(t)}},{path:"/pages/3038c4/index.html",redirect:"/pages/3038c4/"},{path:"/05.并发/06.Java并发和容器.html",redirect:"/pages/3038c4/"},{name:"v-2b9ad123",path:"/pages/241a67/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-2b9ad123").then(t)}},{path:"/pages/241a67/index.html",redirect:"/pages/241a67/"},{path:"/05.并发/07.Java线程池.html",redirect:"/pages/241a67/"},{name:"v-4514b826",path:"/pages/2f46ce/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-4514b826").then(t)}},{path:"/pages/2f46ce/index.html",redirect:"/pages/2f46ce/"},{path:"/05.并发/08.Java并发工具类.html",redirect:"/pages/2f46ce/"},{name:"v-44bda162",path:"/pages/80f538/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-44bda162").then(t)}},{path:"/pages/80f538/index.html",redirect:"/pages/80f538/"},{path:"/05.并发/09.Java内存模型.html",redirect:"/pages/80f538/"},{name:"v-39d421ee",path:"/pages/e96ed2/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-39d421ee").then(t)}},{path:"/pages/e96ed2/index.html",redirect:"/pages/e96ed2/"},{path:"/05.并发/10.ForkJoin框架.html",redirect:"/pages/e96ed2/"},{name:"v-43f2d4d3",path:"/pages/560949/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-43f2d4d3").then(t)}},{path:"/pages/560949/index.html",redirect:"/pages/560949/"},{path:"/05.并发/11.Synchronized.html",redirect:"/pages/560949/"},{name:"v-63688c1a",path:"/pages/a5fb25/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-63688c1a").then(t)}},{path:"/pages/a5fb25/index.html",redirect:"/pages/a5fb25/"},{path:"/05.并发/",redirect:"/pages/a5fb25/"},{name:"v-28d2db4f",path:"/pages/e0de21/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-28d2db4f").then(t)}},{path:"/pages/e0de21/index.html",redirect:"/pages/e0de21/"},{path:"/06.JVM/01.JVM体系结构.html",redirect:"/pages/e0de21/"},{name:"v-740dc458",path:"/pages/692f5d/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-740dc458").then(t)}},{path:"/pages/692f5d/index.html",redirect:"/pages/692f5d/"},{path:"/06.JVM/02.JVM内存区域.html",redirect:"/pages/692f5d/"},{name:"v-89b8bfb2",path:"/pages/7fb1c8/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-89b8bfb2").then(t)}},{path:"/pages/7fb1c8/index.html",redirect:"/pages/7fb1c8/"},{path:"/06.JVM/03.JVM垃圾收集.html",redirect:"/pages/7fb1c8/"},{name:"v-15000fa6",path:"/pages/f37148/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-15000fa6").then(t)}},{path:"/pages/f37148/index.html",redirect:"/pages/f37148/"},{path:"/06.JVM/04.JVM字节码.html",redirect:"/pages/f37148/"},{name:"v-9f9ce560",path:"/pages/4aea87/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-9f9ce560").then(t)}},{path:"/pages/4aea87/index.html",redirect:"/pages/4aea87/"},{path:"/06.JVM/05.JVM类加载.html",redirect:"/pages/4aea87/"},{name:"v-7b2d21b6",path:"/pages/f634e5/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-7b2d21b6").then(t)}},{path:"/pages/f634e5/index.html",redirect:"/pages/f634e5/"},{path:"/06.JVM/08.JavaAgent.html",redirect:"/pages/f634e5/"},{name:"v-6d0e3968",path:"/pages/fb1445/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-6d0e3968").then(t)}},{path:"/pages/fb1445/index.html",redirect:"/pages/fb1445/"},{path:"/06.JVM/11.JVM命令行工具.html",redirect:"/pages/fb1445/"},{name:"v-f2b27b04",path:"/pages/08ac9d/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-f2b27b04").then(t)}},{path:"/pages/08ac9d/index.html",redirect:"/pages/08ac9d/"},{path:"/06.JVM/12.JVM_GUI工具.html",redirect:"/pages/08ac9d/"},{name:"v-7c58f187",path:"/pages/e12478/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-7c58f187").then(t)}},{path:"/pages/e12478/index.html",redirect:"/pages/e12478/"},{path:"/06.JVM/21.JVM实战.html",redirect:"/pages/e12478/"},{name:"v-4de46402",path:"/pages/92bd85/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-4de46402").then(t)}},{path:"/pages/92bd85/index.html",redirect:"/pages/92bd85/"},{path:"/06.JVM/22.Java故障诊断.html",redirect:"/pages/92bd85/"},{name:"v-97c6d734",path:"/pages/272f03/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-97c6d734").then(t)}},{path:"/pages/272f03/index.html",redirect:"/pages/272f03/"},{path:"/06.JVM/",redirect:"/pages/272f03/"},{name:"v-4a04eb05",path:"/pages/b98932/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-4a04eb05").then(t)}},{path:"/pages/b98932/index.html",redirect:"/pages/b98932/"},{path:"/06.JVM/jvm-and-java.html",redirect:"/pages/b98932/"},{name:"v-c9acc070",path:"/99.Java%E9%9D%A2%E8%AF%95.html",component:is,beforeEnter:function(n,e,t){Go("Layout","v-c9acc070").then(t)}},{path:"/99.Java面试.html",redirect:"/99.Java%E9%9D%A2%E8%AF%95.html"},{path:"/99.Java面试.html",redirect:"/99.Java%E9%9D%A2%E8%AF%95.html"},{name:"v-3f7bcbb6",path:"/archives/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-3f7bcbb6").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-67a474f6",path:"/categories/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-67a474f6").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-73f01fa5",path:"/tags/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-73f01fa5").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-ceebf0d4",path:"/",component:is,beforeEnter:function(n,e,t){Go("Layout","v-ceebf0d4").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:is}],ls={title:"JAVACORE",description:"☕ JavaCore 是一个 Java 核心技术教程。",base:"/javacore/",headTags:[["link",{rel:"icon",href:"/javacore/img/favicon.ico"}],["meta",{name:"keywords",content:"vuepress,theme,blog,vdoing"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"Java 开发环境",frontmatter:{title:"Java 开发环境",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE"],abbrlink:"3037f135",date:"2018-08-29T17:28:34.000Z",permalink:"/pages/9f7bb5/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/00.Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html",relativePath:"01.基础特性/00.Java开发环境.md",key:"v-3153b7fc",path:"/pages/9f7bb5/",headers:[{level:2,title:"下载",slug:"下载",normalizedTitle:"下载",charIndex:61},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:101},{level:2,title:"环境变量",slug:"环境变量",normalizedTitle:"环境变量",charIndex:48},{level:3,title:"Windows",slug:"windows",normalizedTitle:"windows",charIndex:187},{level:3,title:"Linux",slug:"linux",normalizedTitle:"linux",charIndex:149},{level:2,title:"测试安装成功",slug:"测试安装成功",normalizedTitle:"测试安装成功",charIndex:574},{level:2,title:"开发工具",slug:"开发工具",normalizedTitle:"开发工具",charIndex:631},{level:2,title:"第一个程序：Hello World",slug:"第一个程序-hello-world",normalizedTitle:"第一个程序：hello world",charIndex:1073}],headersStr:"下载 安装 环境变量 Windows Linux 测试安装成功 开发工具 第一个程序：Hello World",content:'# Java 开发环境\n\n> 📌 关键词： JAVA_HOME、CLASSPATH、Path、环境变量、IDE\n\n\n# 下载\n\n进入 JDK 官方下载地址 ，根据自己的环境选择下载所需版本。\n\n\n# 安装\n\nwindows 环境的 jdk 包是 exe 安装文件，启动后根据安装向导安装即可。\n\nLinux 环境的 jdk 包，解压到本地即可。\n\n\n# 环境变量\n\n\n# Windows\n\n计算机 > 属性 > 高级系统设置 > 环境变量\n\n添加以下环境变量：\n\nJAVA_HOME：C:\\Program Files (x86)\\Java\\jdk1.8.0_91 （根据自己的实际路径配置）\n\nCLASSPATH：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; （注意前面有个"."）\n\nPath：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;\n\n\n# Linux\n\n执行 vi /etc/profile ，编辑环境变量文件\n\n添加两行：\n\nexport JAVA_HOME=path/to/java\nexport PATH=JAVA_HOME/bin:JAVA_HOME/jre/bin:\n\n\n执行 source /etc/profile ，立即生效。\n\n\n# 测试安装成功\n\n执行命令 java -version ，如果安装成功，会打印当前 java 的版本信息。\n\n\n# 开发工具\n\n工欲善其事，必先利其器。编写 Java 程序，当然有必要选择一个合适的 IDE。\n\nIDE（Integrated Development Environment，即集成开发环境）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。\n\n常见的 Java IDE 如下：\n\n * Eclipse - 一个开放源代码的、基于 Java 的可扩展开发平台。\n * NetBeans - 开放源码的 Java 集成开发环境，适用于各种客户机和 Web 应用。\n * IntelliJ IDEA - 在代码自动提示、代码分析等方面的具有很好的功能。\n * MyEclipse - 由 Genuitec 公司开发的一款商业化软件，是应用比较广泛的 Java 应用程序集成开发环境。\n * EditPlus - 如果正确配置 Java 的编译器“Javac”以及解释器“Java”后，可直接使用 EditPlus 编译执行 Java 程序。\n\n\n# 第一个程序：Hello World\n\n添加 HelloWorld.java 文件，内容如下：\n\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println("Hello World");\n    }\n}\n\n\n执行后，控制台输出：\n\nHello World\n',normalizedContent:'# java 开发环境\n\n> 📌 关键词： java_home、classpath、path、环境变量、ide\n\n\n# 下载\n\n进入 jdk 官方下载地址 ，根据自己的环境选择下载所需版本。\n\n\n# 安装\n\nwindows 环境的 jdk 包是 exe 安装文件，启动后根据安装向导安装即可。\n\nlinux 环境的 jdk 包，解压到本地即可。\n\n\n# 环境变量\n\n\n# windows\n\n计算机 > 属性 > 高级系统设置 > 环境变量\n\n添加以下环境变量：\n\njava_home：c:\\program files (x86)\\java\\jdk1.8.0_91 （根据自己的实际路径配置）\n\nclasspath：.;%java_home%\\lib\\dt.jar;%java_home%\\lib\\tools.jar; （注意前面有个"."）\n\npath：%java_home%\\bin;%java_home%\\jre\\bin;\n\n\n# linux\n\n执行 vi /etc/profile ，编辑环境变量文件\n\n添加两行：\n\nexport java_home=path/to/java\nexport path=java_home/bin:java_home/jre/bin:\n\n\n执行 source /etc/profile ，立即生效。\n\n\n# 测试安装成功\n\n执行命令 java -version ，如果安装成功，会打印当前 java 的版本信息。\n\n\n# 开发工具\n\n工欲善其事，必先利其器。编写 java 程序，当然有必要选择一个合适的 ide。\n\nide（integrated development environment，即集成开发环境）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。\n\n常见的 java ide 如下：\n\n * eclipse - 一个开放源代码的、基于 java 的可扩展开发平台。\n * netbeans - 开放源码的 java 集成开发环境，适用于各种客户机和 web 应用。\n * intellij idea - 在代码自动提示、代码分析等方面的具有很好的功能。\n * myeclipse - 由 genuitec 公司开发的一款商业化软件，是应用比较广泛的 java 应用程序集成开发环境。\n * editplus - 如果正确配置 java 的编译器“javac”以及解释器“java”后，可直接使用 editplus 编译执行 java 程序。\n\n\n# 第一个程序：hello world\n\n添加 helloworld.java 文件，内容如下：\n\npublic class helloworld {\n    public static void main(string[] args) {\n        system.out.println("hello world");\n    }\n}\n\n\n执行后，控制台输出：\n\nhello world\n',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 基础语法特性",frontmatter:{title:"Java 基础语法特性",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE"],abbrlink:"d3be5ffb",date:"2022-01-25T07:31:16.000Z",permalink:"/pages/23333b/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",relativePath:"01.基础特性/01.Java基础语法.md",key:"v-10edfa45",path:"/pages/23333b/",headers:[{level:2,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:18},{level:2,title:"基本数据类型",slug:"基本数据类型",normalizedTitle:"基本数据类型",charIndex:329},{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:370},{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:2504},{level:2,title:"枚举",slug:"枚举",normalizedTitle:"枚举",charIndex:2537},{level:2,title:"操作符",slug:"操作符",normalizedTitle:"操作符",charIndex:2570},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:401},{level:2,title:"控制语句",slug:"控制语句",normalizedTitle:"控制语句",charIndex:2652},{level:2,title:"异常",slug:"异常",normalizedTitle:"异常",charIndex:2684},{level:2,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:2719},{level:2,title:"反射",slug:"反射",normalizedTitle:"反射",charIndex:2752},{level:2,title:"注解",slug:"注解",normalizedTitle:"注解",charIndex:2792},{level:2,title:"序列化",slug:"序列化",normalizedTitle:"序列化",charIndex:2831}],headersStr:"注释 基本数据类型 变量 数组 枚举 操作符 方法 控制语句 异常 泛型 反射 注解 序列化",content:'# Java 基础语法特性\n\n\n# 注释\n\n空白行，或者注释的内容，都会被 Java 编译器忽略掉。\n\nJava 支持多种注释方式，下面的示例展示了各种注释的使用方式：\n\npublic class HelloWorld {\n    /*\n     * JavaDoc 注释\n     */\n    public static void main(String[] args) {\n        // 单行注释\n        /* 多行注释：\n           1. 注意点a\n           2. 注意点b\n         */\n        System.out.println("Hello World");\n    }\n}\n\n\n\n# 基本数据类型\n\n\n\n> 👉 扩展阅读：深入理解 Java 基本数据类型\n\n\n# 变量\n\nJava 支持的变量类型有：\n\n * 局部变量 - 类方法中的变量。\n * 实例变量（也叫成员变量） - 类方法外的变量，不过没有 static 修饰。\n * 类变量（也叫静态变量） - 类方法外的变量，用 static 修饰。\n\n特性对比：\n\n局部变量                                                            实例变量（也叫成员变量）                                                             类变量（也叫静态变量）\n局部变量声明在方法、构造方法或者语句块中。                                           实例变量声明在方法、构造方法和语句块之外。                                                    类变量声明在方法、构造方法和语句块之外。并且以 static 修饰。\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。                    实例变量在对象创建的时候创建，在对象被销毁的时候销毁。                                              类变量在第一次被访问时创建，在程序结束时销毁。\n局部变量没有默认值，所以必须经过初始化，才可以使用。                                      实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是                      类变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是\n                                                                null。变量的值可以在声明时指定，也可以在构造方法中指定。                                           null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。   实例变量存储在堆。                                                                类变量存储在静态存储区。\n访问修饰符不能用于局部变量。                                                  访问修饰符可以用于实例变量。                                                           访问修饰符可以用于类变量。\n局部变量只在声明它的方法、构造方法或者语句块中可见。                                      实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。        与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n                                                                实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。   静态变量可以通过：ClassName.VariableName 的方式访问。\n                                                                                                                                         无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n                                                                                                                                         类变量除了被声明为常量外很少使用。\n\n变量修饰符\n\n * 访问级别修饰符\n   * 如果变量是实例变量或类变量，可以添加访问级别修饰符（public/protected/private）\n * 静态修饰符\n   * 如果变量是类变量，需要添加 static 修饰\n * final\n   * 如果变量使用 fianl 修饰符，就表示这是一个常量，不能被修改。\n\n\n# 数组\n\n\n\n> 👉 扩展阅读：深入理解 Java 数组\n\n\n# 枚举\n\n\n\n> 👉 扩展阅读：深入理解 Java 数组\n\n\n# 操作符\n\nJava 中支持的操作符类型如下：\n\n\n\n> 👉 扩展阅读：Java 操作符\n\n\n# 方法\n\n\n\n> 👉 扩展阅读：深入理解 Java 方法\n\n\n# 控制语句\n\n\n\n> 👉 扩展阅读：Java 控制语句\n\n\n# 异常\n\n\n\n\n\n> 👉 扩展阅读：深入理解 Java 异常\n\n\n# 泛型\n\n\n\n> 👉 扩展阅读：深入理解 Java 泛型\n\n\n# 反射\n\n\n\n\n\n> 👉 扩展阅读：深入理解 Java 反射和动态代理\n\n\n# 注解\n\n\n\n\n\n\n\n\n\n> 👉 扩展阅读：深入理解 Java 注解\n\n\n# 序列化\n\n\n\n> 👉 扩展阅读：深入理解 Java 序列化',normalizedContent:'# java 基础语法特性\n\n\n# 注释\n\n空白行，或者注释的内容，都会被 java 编译器忽略掉。\n\njava 支持多种注释方式，下面的示例展示了各种注释的使用方式：\n\npublic class helloworld {\n    /*\n     * javadoc 注释\n     */\n    public static void main(string[] args) {\n        // 单行注释\n        /* 多行注释：\n           1. 注意点a\n           2. 注意点b\n         */\n        system.out.println("hello world");\n    }\n}\n\n\n\n# 基本数据类型\n\n\n\n> 👉 扩展阅读：深入理解 java 基本数据类型\n\n\n# 变量\n\njava 支持的变量类型有：\n\n * 局部变量 - 类方法中的变量。\n * 实例变量（也叫成员变量） - 类方法外的变量，不过没有 static 修饰。\n * 类变量（也叫静态变量） - 类方法外的变量，用 static 修饰。\n\n特性对比：\n\n局部变量                                                            实例变量（也叫成员变量）                                                             类变量（也叫静态变量）\n局部变量声明在方法、构造方法或者语句块中。                                           实例变量声明在方法、构造方法和语句块之外。                                                    类变量声明在方法、构造方法和语句块之外。并且以 static 修饰。\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。                    实例变量在对象创建的时候创建，在对象被销毁的时候销毁。                                              类变量在第一次被访问时创建，在程序结束时销毁。\n局部变量没有默认值，所以必须经过初始化，才可以使用。                                      实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是                      类变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是\n                                                                null。变量的值可以在声明时指定，也可以在构造方法中指定。                                           null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。   实例变量存储在堆。                                                                类变量存储在静态存储区。\n访问修饰符不能用于局部变量。                                                  访问修饰符可以用于实例变量。                                                           访问修饰符可以用于类变量。\n局部变量只在声明它的方法、构造方法或者语句块中可见。                                      实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。        与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n                                                                实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：obejectreference.variablename。   静态变量可以通过：classname.variablename 的方式访问。\n                                                                                                                                         无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n                                                                                                                                         类变量除了被声明为常量外很少使用。\n\n变量修饰符\n\n * 访问级别修饰符\n   * 如果变量是实例变量或类变量，可以添加访问级别修饰符（public/protected/private）\n * 静态修饰符\n   * 如果变量是类变量，需要添加 static 修饰\n * final\n   * 如果变量使用 fianl 修饰符，就表示这是一个常量，不能被修改。\n\n\n# 数组\n\n\n\n> 👉 扩展阅读：深入理解 java 数组\n\n\n# 枚举\n\n\n\n> 👉 扩展阅读：深入理解 java 数组\n\n\n# 操作符\n\njava 中支持的操作符类型如下：\n\n\n\n> 👉 扩展阅读：java 操作符\n\n\n# 方法\n\n\n\n> 👉 扩展阅读：深入理解 java 方法\n\n\n# 控制语句\n\n\n\n> 👉 扩展阅读：java 控制语句\n\n\n# 异常\n\n\n\n\n\n> 👉 扩展阅读：深入理解 java 异常\n\n\n# 泛型\n\n\n\n> 👉 扩展阅读：深入理解 java 泛型\n\n\n# 反射\n\n\n\n\n\n> 👉 扩展阅读：深入理解 java 反射和动态代理\n\n\n# 注解\n\n\n\n\n\n\n\n\n\n> 👉 扩展阅读：深入理解 java 注解\n\n\n# 序列化\n\n\n\n> 👉 扩展阅读：深入理解 java 序列化',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"深入理解 Java 基本数据类型",frontmatter:{title:"深入理解 Java 基本数据类型",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE","数据类型"],abbrlink:"98de92a0",date:"2019-05-06T15:02:02.000Z",permalink:"/pages/2e072a/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/02.Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"01.基础特性/02.Java基本数据类型.md",key:"v-e5b5cf7c",path:"/pages/2e072a/",headers:[{level:2,title:"数据类型分类",slug:"数据类型分类",normalizedTitle:"数据类型分类",charIndex:25},{level:3,title:"值类型",slug:"值类型",normalizedTitle:"值类型",charIndex:53},{level:3,title:"值类型和引用类型的区别",slug:"值类型和引用类型的区别",normalizedTitle:"值类型和引用类型的区别",charIndex:893},{level:2,title:"数据转换",slug:"数据转换",normalizedTitle:"数据转换",charIndex:1228},{level:3,title:"自动转换",slug:"自动转换",normalizedTitle:"自动转换",charIndex:1258},{level:3,title:"强制转换",slug:"强制转换",normalizedTitle:"强制转换",charIndex:1266},{level:2,title:"装箱和拆箱",slug:"装箱和拆箱",normalizedTitle:"装箱和拆箱",charIndex:2090},{level:3,title:"包装类、装箱、拆箱",slug:"包装类、装箱、拆箱",normalizedTitle:"包装类、装箱、拆箱",charIndex:2100},{level:3,title:"自动装箱、自动拆箱",slug:"自动装箱、自动拆箱",normalizedTitle:"自动装箱、自动拆箱",charIndex:2520},{level:3,title:"装箱、拆箱的应用和注意点",slug:"装箱、拆箱的应用和注意点",normalizedTitle:"装箱、拆箱的应用和注意点",charIndex:2952},{level:4,title:"装箱、拆箱应用场景",slug:"装箱、拆箱应用场景",normalizedTitle:"装箱、拆箱应用场景",charIndex:2968},{level:4,title:"装箱、拆箱应用注意点",slug:"装箱、拆箱应用注意点",normalizedTitle:"装箱、拆箱应用注意点",charIndex:5123},{level:2,title:"判等问题",slug:"判等问题",normalizedTitle:"判等问题",charIndex:4202},{level:3,title:"包装类的判等",slug:"包装类的判等",normalizedTitle:"包装类的判等",charIndex:5495},{level:3,title:"String 的判等",slug:"string-的判等",normalizedTitle:"string 的判等",charIndex:8128},{level:3,title:"实现 equals",slug:"实现-equals",normalizedTitle:"实现 equals",charIndex:10005},{level:3,title:"hashCode 和 equals 要配对实现",slug:"hashcode-和-equals-要配对实现",normalizedTitle:"hashcode 和 equals 要配对实现",charIndex:10759},{level:3,title:"compareTo 和 equals 的逻辑一致性",slug:"compareto-和-equals-的逻辑一致性",normalizedTitle:"compareto 和 equals 的逻辑一致性",charIndex:11281},{level:3,title:"小心 Lombok 生成代码的“坑”",slug:"小心-lombok-生成代码的-坑",normalizedTitle:"小心 lombok 生成代码的“坑”",charIndex:12633},{level:2,title:"数值计算",slug:"数值计算",normalizedTitle:"数值计算",charIndex:12819},{level:3,title:"浮点数计算问题",slug:"浮点数计算问题",normalizedTitle:"浮点数计算问题",charIndex:12828},{level:3,title:"浮点数精度和格式化",slug:"浮点数精度和格式化",normalizedTitle:"浮点数精度和格式化",charIndex:14202},{level:3,title:"BigDecimal 判等问题",slug:"bigdecimal-判等问题",normalizedTitle:"bigdecimal 判等问题",charIndex:15068},{level:3,title:"数值溢出",slug:"数值溢出",normalizedTitle:"数值溢出",charIndex:16380},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:17151}],headersStr:"数据类型分类 值类型 值类型和引用类型的区别 数据转换 自动转换 强制转换 装箱和拆箱 包装类、装箱、拆箱 自动装箱、自动拆箱 装箱、拆箱的应用和注意点 装箱、拆箱应用场景 装箱、拆箱应用注意点 判等问题 包装类的判等 String 的判等 实现 equals hashCode 和 equals 要配对实现 compareTo 和 equals 的逻辑一致性 小心 Lombok 生成代码的“坑” 数值计算 浮点数计算问题 浮点数精度和格式化 BigDecimal 判等问题 数值溢出 参考资料",content:'# 深入理解 Java 基本数据类型\n\n\n\n\n# 数据类型分类\n\nJava 中的数据类型有两类：\n\n * 值类型（又叫内置数据类型，基本数据类型）\n * 引用类型（除值类型以外，都是引用类型，包括 String、数组）\n\n\n# 值类型\n\nJava 语言提供了 8 种基本类型，大致分为 4 类\n\n基本数据类型    分类    比特数    默认值        取值范围                            说明\nboolean   布尔型   8 位    false      {false, true}                   \nchar      字符型   16 位   \'\\u0000\'   [0, $2^{16} - 1$]               存储 Unicode 码，用单引号赋值\nbyte      整数型   8 位    0          [-$2^7$, $2^7 - 1$]             \nshort     整数型   16 位   0          [-$2^{15}$, $2^{15} - 1$]       \nint       整数型   32 位   0          [-$2^{31}$, $2^{31} - 1$]       \nlong      整数型   64 位   0L         [-$2^{63}$, $2^{63} - 1$]       赋值时一般在数字后加上 l 或 L\nfloat     浮点型   32 位   +0.0F      [$2^{-149}$, $2^{128} - 1$]     赋值时必须在数字后加上 f 或 F\ndouble    浮点型   64 位   +0.0D      [$2^{-1074}$, $2^{1024} - 1$]   赋值时一般在数字后加 d 或 D\n\n尽管各种数据类型的默认值看起来不一样，但在内存中都是 0。\n\n在这些基本类型中，boolean 和 char 是唯二的无符号类型。\n\n\n# 值类型和引用类型的区别\n\n * 从概念方面来说\n   * 基本类型：变量名指向具体的数值。\n   * 引用类型：变量名指向存数据对象的内存地址。\n * 从内存方面来说\n   * 基本类型：变量在声明之后，Java 就会立刻分配给他内存空间。\n   * 引用类型：它以特殊的方式（类似 C 指针）向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。\n * 从使用方面来说\n   * 基本类型：使用时需要赋具体值,判断时使用 == 号。\n   * 引用类型：使用时可以赋 null，判断时使用 equals 方法。\n\n> 👉 扩展阅读：Java 基本数据类型和引用类型\n> \n> 这篇文章对于基本数据类型和引用类型的内存存储讲述比较生动。\n\n\n# 数据转换\n\nJava 中，数据类型转换有两种方式：\n\n * 自动转换\n * 强制转换\n\n\n# 自动转换\n\n一般情况下，定义了某数据类型的变量，就不能再随意转换。但是 JAVA 允许用户对基本类型做有限度的类型转换。\n\n如果符合以下条件，则 JAVA 将会自动做类型转换：\n\n * 由小数据转换为大数据\n   \n   显而易见的是，“小”数据类型的数值表示范围小于“大”数据类型的数值表示范围，即精度小于“大”数据类型。\n   \n   所以，如果“大”数据向“小”数据转换，会丢失数据精度。比如：long 转为 int，则超出 int 表示范围的数据将会丢失，导致结果的不确定性。\n   \n   反之，“小”数据向“大”数据转换，则不会存在数据丢失情况。由于这个原因，这种类型转换也称为扩大转换。\n   \n   这些类型由“小”到“大”分别为：(byte，short，char) < int < long < float < double。\n   \n   这里我们所说的“大”与“小”，并不是指占用字节的多少，而是指表示值的范围的大小。\n\n * 转换前后的数据类型要兼容\n   \n   由于 boolean 类型只能存放 true 或 false，这与整数或字符是不兼容的，因此不可以做类型转换。\n\n * 整型类型和浮点型进行计算后，结果会转为浮点类型\n\n示例：\n\nlong x = 30;\nfloat y = 14.3f;\nSystem.out.println("x/y = " + x/y);\n\n\n输出：\n\nx/y = 1.9607843\n\n\n可见 long 虽然精度大于 float 类型，但是结果为浮点数类型。\n\n\n# 强制转换\n\n在不符合自动转换条件时或者根据用户的需要，可以对数据类型做强制的转换。\n\n强制转换使用括号 () 。\n\n引用类型也可以使用强制转换。\n\n示例：\n\nfloat f = 25.5f;\nint x = (int)f;\nSystem.out.println("x = " + x);\n\n\n\n# 装箱和拆箱\n\n\n# 包装类、装箱、拆箱\n\nJava 中为每一种基本数据类型提供了相应的包装类，如下：\n\nByte <-> byte\nShort <-> short\nInteger <-> int\nLong <-> long\nFloat <-> float\nDouble <-> double\nCharacter <-> char\nBoolean <-> boolean\n\n\n引入包装类的目的就是：提供一种机制，使得基本数据类型可以与引用类型互相转换。\n\n基本数据类型与包装类的转换被称为装箱和拆箱。\n\n * 装箱（boxing）是将值类型转换为引用类型。例如：int 转 Integer\n   * 装箱过程是通过调用包装类的 valueOf 方法实现的。\n * 拆箱（unboxing）是将引用类型转换为值类型。例如：Integer 转 int\n   * 拆箱过程是通过调用包装类的 xxxValue 方法实现的。（xxx 代表对应的基本数据类型）。\n\n\n# 自动装箱、自动拆箱\n\n基本数据（Primitive）型的自动装箱（boxing）拆箱（unboxing）自 JDK 5 开始提供的功能。\n\n自动装箱与拆箱的机制可以让我们在 Java 的变量赋值或者是方法调用等情况下使用原始类型或者对象类型更加简单直接。 因为自动装箱会隐式地创建对象，如果在一个循环体中，会创建无用的中间对象，这样会增加 GC 压力，拉低程序的性能。所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作。\n\nJDK 5 之前的形式：\n\nInteger i1 = new Integer(10); // 非自动装箱\n\n\nJDK 5 之后：\n\nInteger i2 = 10; // 自动装箱\n\n\nJava 对于自动装箱和拆箱的设计，依赖于一种叫做享元模式的设计模式（有兴趣的朋友可以去了解一下源码，这里不对设计模式展开详述）。\n\n> 👉 扩展阅读：深入剖析 Java 中的装箱和拆箱\n> \n> 结合示例，一步步阐述装箱和拆箱原理。\n\n\n# 装箱、拆箱的应用和注意点\n\n# 装箱、拆箱应用场景\n\n * 一种最普通的场景是：调用一个含类型为 Object 参数的方法，该 Object 可支持任意类型（因为 Object 是所有类的父类），以便通用。当你需要将一个值类型（如 int）传入时，需要使用 Integer 装箱。\n * 另一种用法是：一个非泛型的容器，同样是为了保证通用，而将元素类型定义为 Object。于是，要将值类型数据加入容器时，需要装箱。\n * 当 == 运算符的两个操作，一个操作数是包装类，另一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。\n\n【示例】装箱、拆箱示例\n\nInteger i1 = 10; // 自动装箱\nInteger i2 = new Integer(10); // 非自动装箱\nInteger i3 = Integer.valueOf(10); // 非自动装箱\nint i4 = new Integer(10); // 自动拆箱\nint i5 = i2.intValue(); // 非自动拆箱\nSystem.out.println("i1 = [" + i1 + "]");\nSystem.out.println("i2 = [" + i2 + "]");\nSystem.out.println("i3 = [" + i3 + "]");\nSystem.out.println("i4 = [" + i4 + "]");\nSystem.out.println("i5 = [" + i5 + "]");\nSystem.out.println("i1 == i2 is [" + (i1 == i2) + "]");\nSystem.out.println("i1 == i4 is [" + (i1 == i4) + "]"); // 自动拆箱\n// Output:\n// i1 = [10]\n// i2 = [10]\n// i3 = [10]\n// i4 = [10]\n// i5 = [10]\n// i1 == i2 is [false]\n// i1 == i4 is [true]\n\n\n【说明】\n\n上面的例子，虽然简单，但却隐藏了自动装箱、拆箱和非自动装箱、拆箱的应用。从例子中可以看到，明明所有变量都初始化为数值 10 了，但为何会出现 i1 == i2 is [false 而 i1 == i4 is [true] ？\n\n原因在于：\n\n * i1、i2 都是包装类，使用 == 时，Java 将它们当做两个对象，而非两个 int 值来比较，所以两个对象自然是不相等的。正确的比较操作应该使用 equals 方法。\n * i1 是包装类，i4 是基础数据类型，使用 == 时，Java 会将两个 i1 这个包装类对象自动拆箱为一个 int 值，再代入到 == 运算表达式中计算；最终，相当于两个 int 进行比较，由于值相同，所以结果相等。\n\n【示例】包装类判等问题\n\nInteger a = 127; //Integer.valueOf(127)\nInteger b = 127; //Integer.valueOf(127)\nlog.info("\\nInteger a = 127;\\nInteger b = 127;\\na == b ? {}", a == b);    // true\n\nInteger c = 128; //Integer.valueOf(128)\nInteger d = 128; //Integer.valueOf(128)\nlog.info("\\nInteger c = 128;\\nInteger d = 128;\\nc == d ? {}", c == d);   //false\n//设置-XX:AutoBoxCacheMax=1000再试试\n\nInteger e = 127; //Integer.valueOf(127)\nInteger f = new Integer(127); //new instance\nlog.info("\\nInteger e = 127;\\nInteger f = new Integer(127);\\ne == f ? {}", e == f);   //false\n\nInteger g = new Integer(127); //new instance\nInteger h = new Integer(127); //new instance\nlog.info("\\nInteger g = new Integer(127);\\nInteger h = new Integer(127);\\ng == h ? {}", g == h);  //false\n\nInteger i = 128; //unbox\nint j = 128;\nlog.info("\\nInteger i = 128;\\nint j = 128;\\ni == j ? {}", i == j); //true\n\n\n通过运行结果可以看到，虽然看起来永远是在对 127 和 127、128 和 128 判等，但 == 却并非总是返回 true。\n\n# 装箱、拆箱应用注意点\n\n 1. 装箱操作会创建对象，频繁的装箱操作会造成不必要的内存消耗，影响性能。所以应该尽量避免装箱。\n 2. 基础数据类型的比较操作使用 ==，包装类的比较操作使用 equals 方法。\n\n\n# 判等问题\n\nJava 中，通常使用 equals 或 == 进行判等操作。equals 是方法而 == 是操作符。此外，二者使用也是有区别的：\n\n * 对基本类型，比如 int、long，进行判等，只能使用 ==，比较的是字面值。因为基本类型的值就是其数值。\n * 对引用类型，比如 Integer、Long 和 String，进行判等，需要使用 equals 进行内容判等。因为引用类型的直接值是指针，使用 == 的话，比较的是指针，也就是两个对象在内存中的地址，即比较它们是不是同一个对象，而不是比较对象的内容。\n\n\n# 包装类的判等\n\n我们通过一个示例来深入研究一下判等问题。\n\n【示例】包装类的判等\n\nInteger a = 127; //Integer.valueOf(127)\nInteger b = 127; //Integer.valueOf(127)\nlog.info("\\nInteger a = 127;\\nInteger b = 127;\\na == b ? {}", a == b);    // true\n\nInteger c = 128; //Integer.valueOf(128)\nInteger d = 128; //Integer.valueOf(128)\nlog.info("\\nInteger c = 128;\\nInteger d = 128;\\nc == d ? {}", c == d);   //false\n//设置-XX:AutoBoxCacheMax=1000再试试\n\nInteger e = 127; //Integer.valueOf(127)\nInteger f = new Integer(127); //new instance\nlog.info("\\nInteger e = 127;\\nInteger f = new Integer(127);\\ne == f ? {}", e == f);   //false\n\nInteger g = new Integer(127); //new instance\nInteger h = new Integer(127); //new instance\nlog.info("\\nInteger g = new Integer(127);\\nInteger h = new Integer(127);\\ng == h ? {}", g == h);  //false\n\nInteger i = 128; //unbox\nint j = 128;\nlog.info("\\nInteger i = 128;\\nint j = 128;\\ni == j ? {}", i == j); //true\n\n\n第一个案例中，编译器会把 Integer a = 127 转换为 Integer.valueOf(127)。查看源码可以发现，这个转换在内部其实做了缓存，使得两个 Integer 指向同一个对象，所以 == 返回 true。\n\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n\n\n第二个案例中，之所以同样的代码 128 就返回 false 的原因是，默认情况下会缓存[-128,127]的数值，而 128 处于这个区间之外。设置 JVM 参数加上 -XX:AutoBoxCacheMax=1000 再试试，是不是就返回 true 了呢？\n\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n\n\n第三和第四个案例中，New 出来的 Integer 始终是不走缓存的新对象。比较两个新对象，或者比较一个新对象和一个来自缓存的对象，结果肯定不是相同的对象，因此返回 false。\n\n第五个案例中，我们把装箱的 Integer 和基本类型 int 比较，前者会先拆箱再比较，比较的肯定是数值而不是引用，因此返回 true。\n\n> 【总结】综上，我们可以得出结论：包装类需要使用 equals 进行内容判等，而不能使用 ==。\n\n\n# String 的判等\n\nString a = "1";\nString b = "1";\nlog.info("\\nString a = \\"1\\";\\nString b = \\"1\\";\\na == b ? {}", a == b); //true\n\nString c = new String("2");\nString d = new String("2");\nlog.info("\\nString c = new String(\\"2\\");\\nString d = new String(\\"2\\");\\nc == d ? {}", c == d); //false\n\nString e = new String("3").intern();\nString f = new String("3").intern();\nlog.info("\\nString e = new String(\\"3\\").intern();\\nString f = new String(\\"3\\").intern();\\ne == f ? {}", e == f); //true\n\nString g = new String("4");\nString h = new String("4");\nlog.info("\\nString g = new String(\\"4\\");\\nString h = new String(\\"4\\");\\ng == h ? {}", g.equals(h)); //true\n\n\n在 JVM 中，当代码中出现双引号形式创建字符串对象时，JVM 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。这种机制，就是字符串驻留或池化。\n\n第一个案例返回 true，因为 Java 的字符串驻留机制，直接使用双引号声明出来的两个 String 对象指向常量池中的相同字符串。\n\n第二个案例，new 出来的两个 String 是不同对象，引用当然不同，所以得到 false 的结果。\n\n第三个案例，使用 String 提供的 intern 方法也会走常量池机制，所以同样能得到 true。\n\n第四个案例，通过 equals 对值内容判等，是正确的处理方式，当然会得到 true。\n\n虽然使用 new 声明的字符串调用 intern 方法，也可以让字符串进行驻留，但在业务代码中滥用 intern，可能会产生性能问题。\n\n【示例】String#intern 性能测试\n\n//-XX:+PrintStringTableStatistics\n//-XX:StringTableSize=10000000\nList<String> list = new ArrayList<>();\nlong begin = System.currentTimeMillis();\nlist = IntStream.rangeClosed(1, 10000000)\n    .mapToObj(i -> String.valueOf(i).intern())\n    .collect(Collectors.toList());\nSystem.out.println("size:" + list.size());\nSystem.out.println("time:" + (System.currentTimeMillis() - begin));\n\n\n上面的示例执行时间会比较长。原因在于：字符串常量池是一个固定容量的 Map。如果容量太小（Number of buckets=60013）、字符串太多（1000 万个字符串），那么每一个桶中的字符串数量会非常多，所以搜索起来就很慢。输出结果中的 Average bucket size=167，代表了 Map 中桶的平均长度是 167。\n\n解决方法是：设置 JVM 参数 -XX:StringTableSize=10000000，指定更多的桶。\n\n为了方便观察，可以在启动程序时设置 JVM 参数 -XX:+PrintStringTableStatistic，程序退出时可以打印出字符串常量表的统计信息。\n\n执行结果比不设置 -XX:StringTableSize 要快很多。\n\n> 【总结】没事别轻易用 intern，如果要用一定要注意控制驻留的字符串的数量，并留意常量表的各项指标。\n\n\n# 实现 equals\n\n如果看过 Object 类源码，你可能就知道，equals 的实现其实是比较对象引用\n\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n\n\n之所以 Integer 或 String 能通过 equals 实现内容判等，是因为它们都覆写了这个方法。\n\n对于自定义类型，如果不覆写 equals 的话，默认就是使用 Object 基类的按引用的比较方式。\n\n实现一个更好的 equals 应该注意的点：\n\n * 考虑到性能，可以先进行指针判等，如果对象是同一个那么直接返回 true；\n * 需要对另一方进行判空，空对象和自身进行比较，结果一定是 fasle；\n * 需要判断两个对象的类型，如果类型都不同，那么直接返回 false；\n * 确保类型相同的情况下再进行类型强制转换，然后逐一判断所有字段。\n\n【示例】自定义 equals 示例\n\n自定义类：\n\nclass Point {\n    private final int x;\n    private final int y;\n    private final String desc;\n}\n\n\n自定义 equals：\n\n@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Point that = (Point) o;\n    return x == that.x && y == that.y;\n}\n\n\n\n# hashCode 和 equals 要配对实现\n\nPoint p1 = new Point(1, 2, "a");\nPoint p2 = new Point(1, 2, "b");\n\nHashSet<PointWrong> points = new HashSet<>();\npoints.add(p1);\nlog.info("points.contains(p2) ? {}", points.contains(p2));\n\n\n按照改进后的 equals 方法，这 2 个对象可以认为是同一个，Set 中已经存在了 p1 就应该包含 p2，但结果却是 false。\n\n出现这个 Bug 的原因是，散列表需要使用 hashCode 来定位元素放到哪个桶。如果自定义对象没有实现自定义的 hashCode 方法，就会使用 Object 超类的默认实现，得到的两个 hashCode 是不同的，导致无法满足需求。\n\n要自定义 hashCode，我们可以直接使用 Objects.hash 方法来实现。\n\n@Override\npublic int hashCode() {\n    return Objects.hash(x, y);\n}\n\n\n\n# compareTo 和 equals 的逻辑一致性\n\n【示例】自定义 compareTo 出错示例\n\n@Data\n@AllArgsConstructor\nstatic class Student implements Comparable<Student> {\n\n    private int id;\n    private String name;\n\n    @Override\n    public int compareTo(Student other) {\n        int result = Integer.compare(other.id, id);\n        if (result == 0) { log.info("this {} == other {}", this, other); }\n        return result;\n    }\n\n}\n\n\n调用：\n\nList<Student> list = new ArrayList<>();\nlist.add(new Student(1, "zhang"));\nlist.add(new Student(2, "wang"));\nStudent student = new Student(2, "li");\n\nlog.info("ArrayList.indexOf");\nint index1 = list.indexOf(student);\nCollections.sort(list);\nlog.info("Collections.binarySearch");\nint index2 = Collections.binarySearch(list, student);\n\nlog.info("index1 = " + index1);\nlog.info("index2 = " + index2);\n\n\nbinarySearch 方法内部调用了元素的 compareTo 方法进行比较；\n\n * indexOf 的结果没问题，列表中搜索不到 id 为 2、name 是 li 的学生；\n * binarySearch 返回了索引 1，代表搜索到的结果是 id 为 2，name 是 wang 的学生。\n\n修复方式很简单，确保 compareTo 的比较逻辑和 equals 的实现一致即可。\n\n@Data\n@AllArgsConstructor\nstatic class StudentRight implements Comparable<StudentRight> {\n\n    private int id;\n    private String name;\n\n    @Override\n    public int compareTo(StudentRight other) {\n        return Comparator.comparing(StudentRight::getName)\n            .thenComparingInt(StudentRight::getId)\n            .compare(this, other);\n    }\n\n}\n\n\n\n# 小心 Lombok 生成代码的“坑”\n\nLombok 的 @Data 注解会帮我们实现 equals 和 hashcode 方法，但是有继承关系时， Lombok 自动生成的方法可能就不是我们期望的了。\n\n@EqualsAndHashCode 默认实现没有使用父类属性。为解决这个问题，我们可以手动设置 callSuper 开关为 true，来覆盖这种默认行为。\n\n\n# 数值计算\n\n\n# 浮点数计算问题\n\n计算机是把数值保存在了变量中，不同类型的数值变量能保存的数值范围不同，当数值超过类型能表达的数值上限则会发生溢出问题。\n\nSystem.out.println(0.1 + 0.2); // 0.30000000000000004\nSystem.out.println(1.0 - 0.8); // 0.19999999999999996\nSystem.out.println(4.015 * 100); // 401.49999999999994\nSystem.out.println(123.3 / 100); // 1.2329999999999999\ndouble amount1 = 2.15;\ndouble amount2 = 1.10;\nSystem.out.println(amount1 - amount2); // 1.0499999999999998\n\n\n上面的几个示例，输出结果和我们预期的很不一样。为什么会是这样呢？\n\n出现这种问题的主要原因是，计算机是以二进制存储数值的，浮点数也不例外。Java 采用了 IEEE 754 标准实现浮点数的表达和运算，你可以通过这里查看数值转化为二进制的结果。\n\n比如，0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，再转换为十进制就是 0.1000000000000000055511151231257827021181583404541015625。对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。\n\n浮点数无法精确表达和运算的场景，一定要使用 BigDecimal 类型。\n\n使用 BigDecimal 时，有个细节要格外注意。让我们来看一段代码：\n\nSystem.out.println(new BigDecimal(0.1).add(new BigDecimal(0.2)));\n// Output: 0.3000000000000000166533453693773481063544750213623046875\n\nSystem.out.println(new BigDecimal(1.0).subtract(new BigDecimal(0.8)));\n// Output: 0.1999999999999999555910790149937383830547332763671875\n\nSystem.out.println(new BigDecimal(4.015).multiply(new BigDecimal(100)));\n// Output: 401.49999999999996802557689079549163579940795898437500\n\nSystem.out.println(new BigDecimal(123.3).divide(new BigDecimal(100)));\n// Output: 1.232999999999999971578290569595992565155029296875\n\n\n为什么输出结果仍然不符合预期呢？\n\n使用 BigDecimal 表示和计算浮点数，且务必使用字符串的构造方法来初始化 BigDecimal。\n\n\n# 浮点数精度和格式化\n\n浮点数的字符串格式化也要通过 BigDecimal 进行。\n\nprivate static void wrong1() {\n    double num1 = 3.35;\n    float num2 = 3.35f;\n    System.out.println(String.format("%.1f", num1)); // 3.4\n    System.out.println(String.format("%.1f", num2)); // 3.3\n}\n\nprivate static void wrong2() {\n    double num1 = 3.35;\n    float num2 = 3.35f;\n    DecimalFormat format = new DecimalFormat("#.##");\n    format.setRoundingMode(RoundingMode.DOWN);\n    System.out.println(format.format(num1)); // 3.35\n    format.setRoundingMode(RoundingMode.DOWN);\n    System.out.println(format.format(num2)); // 3.34\n}\n\nprivate static void right() {\n    BigDecimal num1 = new BigDecimal("3.35");\n    BigDecimal num2 = num1.setScale(1, BigDecimal.ROUND_DOWN);\n    System.out.println(num2); // 3.3\n    BigDecimal num3 = num1.setScale(1, BigDecimal.ROUND_HALF_UP);\n    System.out.println(num3); // 3.4\n}\n\n\n\n# BigDecimal 判等问题\n\nprivate static void wrong() {\n    System.out.println(new BigDecimal("1.0").equals(new BigDecimal("1")));\n}\n\nprivate static void right() {\n    System.out.println(new BigDecimal("1.0").compareTo(new BigDecimal("1")) == 0);\n}\n\n\nBigDecimal 的 equals 方法的注释中说明了原因，equals 比较的是 BigDecimal 的 value 和 scale，1.0 的 scale 是 1，1 的 scale 是 0，所以结果一定是 false。\n\n如果我们希望只比较 BigDecimal 的 value，可以使用 compareTo 方法。\n\nBigDecimal 的 equals 和 hashCode 方法会同时考虑 value 和 scale，如果结合 HashSet 或 HashMap 使用的话就可能会出现麻烦。比如，我们把值为 1.0 的 BigDecimal 加入 HashSet，然后判断其是否存在值为 1 的 BigDecimal，得到的结果是 false。\n\nSet<BigDecimal> hashSet1 = new HashSet<>();\nhashSet1.add(new BigDecimal("1.0"));\nSystem.out.println(hashSet1.contains(new BigDecimal("1")));//返回false\n\n\n\n\n解决办法有两个：\n\n第一个方法是，使用 TreeSet 替换 HashSet。TreeSet 不使用 hashCode 方法，也不使用 equals 比较元素，而是使用 compareTo 方法，所以不会有问题。\n\n第二个方法是，把 BigDecimal 存入 HashSet 或 HashMap 前，先使用 stripTrailingZeros 方法去掉尾部的零，比较的时候也去掉尾部的 0，确保 value 相同的 BigDecimal，scale 也是一致的。\n\nSet<BigDecimal> hashSet2 = new HashSet<>();\nhashSet2.add(new BigDecimal("1.0").stripTrailingZeros());\nSystem.out.println(hashSet2.contains(new BigDecimal("1.000").stripTrailingZeros()));//返回true\n\nSet<BigDecimal> treeSet = new TreeSet<>();\ntreeSet.add(new BigDecimal("1.0"));\nSystem.out.println(treeSet.contains(new BigDecimal("1")));//返回true\n\n\n\n# 数值溢出\n\n数值计算还有一个要小心的点是溢出，不管是 int 还是 long，所有的基本数值类型都有超出表达范围的可能性。\n\nlong l = Long.MAX_VALUE;\nSystem.out.println(l + 1); // -9223372036854775808\nSystem.out.println(l + 1 == Long.MIN_VALUE); // true\n\n\n显然这是发生了溢出，而且是默默的溢出，并没有任何异常。这类问题非常容易被忽略，改进方式有下面 2 种。\n\n方法一是，考虑使用 Math 类的 addExact、subtractExact 等 xxExact 方法进行数值运算，这些方法可以在数值溢出时主动抛出异常。\n\ntry {\n    long l = Long.MAX_VALUE;\n    System.out.println(Math.addExact(l, 1));\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\n\n\n方法二是，使用大数类 BigInteger。BigDecimal 是处理浮点数的专家，而 BigInteger 则是对大数进行科学计算的专家。\n\nBigInteger i = new BigInteger(String.valueOf(Long.MAX_VALUE));\nSystem.out.println(i.add(BigInteger.ONE).toString());\n\ntry {\n    long l = i.add(BigInteger.ONE).longValueExact();\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\n\n\n\n# 参考资料\n\n * 《Java 编程思想（Thinking in java）》\n * 《Java 核心技术 卷 I 基础知识》\n * 《Java 业务开发常见错误 100 例》\n * Java 基本数据类型和引用类型\n * 深入剖析 Java 中的装箱和拆箱',normalizedContent:'# 深入理解 java 基本数据类型\n\n\n\n\n# 数据类型分类\n\njava 中的数据类型有两类：\n\n * 值类型（又叫内置数据类型，基本数据类型）\n * 引用类型（除值类型以外，都是引用类型，包括 string、数组）\n\n\n# 值类型\n\njava 语言提供了 8 种基本类型，大致分为 4 类\n\n基本数据类型    分类    比特数    默认值        取值范围                            说明\nboolean   布尔型   8 位    false      {false, true}                   \nchar      字符型   16 位   \'\\u0000\'   [0, $2^{16} - 1$]               存储 unicode 码，用单引号赋值\nbyte      整数型   8 位    0          [-$2^7$, $2^7 - 1$]             \nshort     整数型   16 位   0          [-$2^{15}$, $2^{15} - 1$]       \nint       整数型   32 位   0          [-$2^{31}$, $2^{31} - 1$]       \nlong      整数型   64 位   0l         [-$2^{63}$, $2^{63} - 1$]       赋值时一般在数字后加上 l 或 l\nfloat     浮点型   32 位   +0.0f      [$2^{-149}$, $2^{128} - 1$]     赋值时必须在数字后加上 f 或 f\ndouble    浮点型   64 位   +0.0d      [$2^{-1074}$, $2^{1024} - 1$]   赋值时一般在数字后加 d 或 d\n\n尽管各种数据类型的默认值看起来不一样，但在内存中都是 0。\n\n在这些基本类型中，boolean 和 char 是唯二的无符号类型。\n\n\n# 值类型和引用类型的区别\n\n * 从概念方面来说\n   * 基本类型：变量名指向具体的数值。\n   * 引用类型：变量名指向存数据对象的内存地址。\n * 从内存方面来说\n   * 基本类型：变量在声明之后，java 就会立刻分配给他内存空间。\n   * 引用类型：它以特殊的方式（类似 c 指针）向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。\n * 从使用方面来说\n   * 基本类型：使用时需要赋具体值,判断时使用 == 号。\n   * 引用类型：使用时可以赋 null，判断时使用 equals 方法。\n\n> 👉 扩展阅读：java 基本数据类型和引用类型\n> \n> 这篇文章对于基本数据类型和引用类型的内存存储讲述比较生动。\n\n\n# 数据转换\n\njava 中，数据类型转换有两种方式：\n\n * 自动转换\n * 强制转换\n\n\n# 自动转换\n\n一般情况下，定义了某数据类型的变量，就不能再随意转换。但是 java 允许用户对基本类型做有限度的类型转换。\n\n如果符合以下条件，则 java 将会自动做类型转换：\n\n * 由小数据转换为大数据\n   \n   显而易见的是，“小”数据类型的数值表示范围小于“大”数据类型的数值表示范围，即精度小于“大”数据类型。\n   \n   所以，如果“大”数据向“小”数据转换，会丢失数据精度。比如：long 转为 int，则超出 int 表示范围的数据将会丢失，导致结果的不确定性。\n   \n   反之，“小”数据向“大”数据转换，则不会存在数据丢失情况。由于这个原因，这种类型转换也称为扩大转换。\n   \n   这些类型由“小”到“大”分别为：(byte，short，char) < int < long < float < double。\n   \n   这里我们所说的“大”与“小”，并不是指占用字节的多少，而是指表示值的范围的大小。\n\n * 转换前后的数据类型要兼容\n   \n   由于 boolean 类型只能存放 true 或 false，这与整数或字符是不兼容的，因此不可以做类型转换。\n\n * 整型类型和浮点型进行计算后，结果会转为浮点类型\n\n示例：\n\nlong x = 30;\nfloat y = 14.3f;\nsystem.out.println("x/y = " + x/y);\n\n\n输出：\n\nx/y = 1.9607843\n\n\n可见 long 虽然精度大于 float 类型，但是结果为浮点数类型。\n\n\n# 强制转换\n\n在不符合自动转换条件时或者根据用户的需要，可以对数据类型做强制的转换。\n\n强制转换使用括号 () 。\n\n引用类型也可以使用强制转换。\n\n示例：\n\nfloat f = 25.5f;\nint x = (int)f;\nsystem.out.println("x = " + x);\n\n\n\n# 装箱和拆箱\n\n\n# 包装类、装箱、拆箱\n\njava 中为每一种基本数据类型提供了相应的包装类，如下：\n\nbyte <-> byte\nshort <-> short\ninteger <-> int\nlong <-> long\nfloat <-> float\ndouble <-> double\ncharacter <-> char\nboolean <-> boolean\n\n\n引入包装类的目的就是：提供一种机制，使得基本数据类型可以与引用类型互相转换。\n\n基本数据类型与包装类的转换被称为装箱和拆箱。\n\n * 装箱（boxing）是将值类型转换为引用类型。例如：int 转 integer\n   * 装箱过程是通过调用包装类的 valueof 方法实现的。\n * 拆箱（unboxing）是将引用类型转换为值类型。例如：integer 转 int\n   * 拆箱过程是通过调用包装类的 xxxvalue 方法实现的。（xxx 代表对应的基本数据类型）。\n\n\n# 自动装箱、自动拆箱\n\n基本数据（primitive）型的自动装箱（boxing）拆箱（unboxing）自 jdk 5 开始提供的功能。\n\n自动装箱与拆箱的机制可以让我们在 java 的变量赋值或者是方法调用等情况下使用原始类型或者对象类型更加简单直接。 因为自动装箱会隐式地创建对象，如果在一个循环体中，会创建无用的中间对象，这样会增加 gc 压力，拉低程序的性能。所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作。\n\njdk 5 之前的形式：\n\ninteger i1 = new integer(10); // 非自动装箱\n\n\njdk 5 之后：\n\ninteger i2 = 10; // 自动装箱\n\n\njava 对于自动装箱和拆箱的设计，依赖于一种叫做享元模式的设计模式（有兴趣的朋友可以去了解一下源码，这里不对设计模式展开详述）。\n\n> 👉 扩展阅读：深入剖析 java 中的装箱和拆箱\n> \n> 结合示例，一步步阐述装箱和拆箱原理。\n\n\n# 装箱、拆箱的应用和注意点\n\n# 装箱、拆箱应用场景\n\n * 一种最普通的场景是：调用一个含类型为 object 参数的方法，该 object 可支持任意类型（因为 object 是所有类的父类），以便通用。当你需要将一个值类型（如 int）传入时，需要使用 integer 装箱。\n * 另一种用法是：一个非泛型的容器，同样是为了保证通用，而将元素类型定义为 object。于是，要将值类型数据加入容器时，需要装箱。\n * 当 == 运算符的两个操作，一个操作数是包装类，另一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。\n\n【示例】装箱、拆箱示例\n\ninteger i1 = 10; // 自动装箱\ninteger i2 = new integer(10); // 非自动装箱\ninteger i3 = integer.valueof(10); // 非自动装箱\nint i4 = new integer(10); // 自动拆箱\nint i5 = i2.intvalue(); // 非自动拆箱\nsystem.out.println("i1 = [" + i1 + "]");\nsystem.out.println("i2 = [" + i2 + "]");\nsystem.out.println("i3 = [" + i3 + "]");\nsystem.out.println("i4 = [" + i4 + "]");\nsystem.out.println("i5 = [" + i5 + "]");\nsystem.out.println("i1 == i2 is [" + (i1 == i2) + "]");\nsystem.out.println("i1 == i4 is [" + (i1 == i4) + "]"); // 自动拆箱\n// output:\n// i1 = [10]\n// i2 = [10]\n// i3 = [10]\n// i4 = [10]\n// i5 = [10]\n// i1 == i2 is [false]\n// i1 == i4 is [true]\n\n\n【说明】\n\n上面的例子，虽然简单，但却隐藏了自动装箱、拆箱和非自动装箱、拆箱的应用。从例子中可以看到，明明所有变量都初始化为数值 10 了，但为何会出现 i1 == i2 is [false 而 i1 == i4 is [true] ？\n\n原因在于：\n\n * i1、i2 都是包装类，使用 == 时，java 将它们当做两个对象，而非两个 int 值来比较，所以两个对象自然是不相等的。正确的比较操作应该使用 equals 方法。\n * i1 是包装类，i4 是基础数据类型，使用 == 时，java 会将两个 i1 这个包装类对象自动拆箱为一个 int 值，再代入到 == 运算表达式中计算；最终，相当于两个 int 进行比较，由于值相同，所以结果相等。\n\n【示例】包装类判等问题\n\ninteger a = 127; //integer.valueof(127)\ninteger b = 127; //integer.valueof(127)\nlog.info("\\ninteger a = 127;\\ninteger b = 127;\\na == b ? {}", a == b);    // true\n\ninteger c = 128; //integer.valueof(128)\ninteger d = 128; //integer.valueof(128)\nlog.info("\\ninteger c = 128;\\ninteger d = 128;\\nc == d ? {}", c == d);   //false\n//设置-xx:autoboxcachemax=1000再试试\n\ninteger e = 127; //integer.valueof(127)\ninteger f = new integer(127); //new instance\nlog.info("\\ninteger e = 127;\\ninteger f = new integer(127);\\ne == f ? {}", e == f);   //false\n\ninteger g = new integer(127); //new instance\ninteger h = new integer(127); //new instance\nlog.info("\\ninteger g = new integer(127);\\ninteger h = new integer(127);\\ng == h ? {}", g == h);  //false\n\ninteger i = 128; //unbox\nint j = 128;\nlog.info("\\ninteger i = 128;\\nint j = 128;\\ni == j ? {}", i == j); //true\n\n\n通过运行结果可以看到，虽然看起来永远是在对 127 和 127、128 和 128 判等，但 == 却并非总是返回 true。\n\n# 装箱、拆箱应用注意点\n\n 1. 装箱操作会创建对象，频繁的装箱操作会造成不必要的内存消耗，影响性能。所以应该尽量避免装箱。\n 2. 基础数据类型的比较操作使用 ==，包装类的比较操作使用 equals 方法。\n\n\n# 判等问题\n\njava 中，通常使用 equals 或 == 进行判等操作。equals 是方法而 == 是操作符。此外，二者使用也是有区别的：\n\n * 对基本类型，比如 int、long，进行判等，只能使用 ==，比较的是字面值。因为基本类型的值就是其数值。\n * 对引用类型，比如 integer、long 和 string，进行判等，需要使用 equals 进行内容判等。因为引用类型的直接值是指针，使用 == 的话，比较的是指针，也就是两个对象在内存中的地址，即比较它们是不是同一个对象，而不是比较对象的内容。\n\n\n# 包装类的判等\n\n我们通过一个示例来深入研究一下判等问题。\n\n【示例】包装类的判等\n\ninteger a = 127; //integer.valueof(127)\ninteger b = 127; //integer.valueof(127)\nlog.info("\\ninteger a = 127;\\ninteger b = 127;\\na == b ? {}", a == b);    // true\n\ninteger c = 128; //integer.valueof(128)\ninteger d = 128; //integer.valueof(128)\nlog.info("\\ninteger c = 128;\\ninteger d = 128;\\nc == d ? {}", c == d);   //false\n//设置-xx:autoboxcachemax=1000再试试\n\ninteger e = 127; //integer.valueof(127)\ninteger f = new integer(127); //new instance\nlog.info("\\ninteger e = 127;\\ninteger f = new integer(127);\\ne == f ? {}", e == f);   //false\n\ninteger g = new integer(127); //new instance\ninteger h = new integer(127); //new instance\nlog.info("\\ninteger g = new integer(127);\\ninteger h = new integer(127);\\ng == h ? {}", g == h);  //false\n\ninteger i = 128; //unbox\nint j = 128;\nlog.info("\\ninteger i = 128;\\nint j = 128;\\ni == j ? {}", i == j); //true\n\n\n第一个案例中，编译器会把 integer a = 127 转换为 integer.valueof(127)。查看源码可以发现，这个转换在内部其实做了缓存，使得两个 integer 指向同一个对象，所以 == 返回 true。\n\npublic static integer valueof(int i) {\n    if (i >= integercache.low && i <= integercache.high)\n        return integercache.cache[i + (-integercache.low)];\n    return new integer(i);\n}\n\n\n第二个案例中，之所以同样的代码 128 就返回 false 的原因是，默认情况下会缓存[-128,127]的数值，而 128 处于这个区间之外。设置 jvm 参数加上 -xx:autoboxcachemax=1000 再试试，是不是就返回 true 了呢？\n\nprivate static class integercache {\n    static final int low = -128;\n    static final int high;\n    static final integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        string integercachehighpropvalue =\n            sun.misc.vm.getsavedproperty("java.lang.integer.integercache.high");\n        if (integercachehighpropvalue != null) {\n            try {\n                int i = parseint(integercachehighpropvalue);\n                i = math.max(i, 127);\n                // maximum array size is integer.max_value\n                h = math.min(i, integer.max_value - (-low) -1);\n            } catch( numberformatexception nfe) {\n                // if the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new integer(j++);\n\n        // range [-128, 127] must be interned (jls7 5.1.7)\n        assert integercache.high >= 127;\n    }\n\n    private integercache() {}\n}\n\n\n第三和第四个案例中，new 出来的 integer 始终是不走缓存的新对象。比较两个新对象，或者比较一个新对象和一个来自缓存的对象，结果肯定不是相同的对象，因此返回 false。\n\n第五个案例中，我们把装箱的 integer 和基本类型 int 比较，前者会先拆箱再比较，比较的肯定是数值而不是引用，因此返回 true。\n\n> 【总结】综上，我们可以得出结论：包装类需要使用 equals 进行内容判等，而不能使用 ==。\n\n\n# string 的判等\n\nstring a = "1";\nstring b = "1";\nlog.info("\\nstring a = \\"1\\";\\nstring b = \\"1\\";\\na == b ? {}", a == b); //true\n\nstring c = new string("2");\nstring d = new string("2");\nlog.info("\\nstring c = new string(\\"2\\");\\nstring d = new string(\\"2\\");\\nc == d ? {}", c == d); //false\n\nstring e = new string("3").intern();\nstring f = new string("3").intern();\nlog.info("\\nstring e = new string(\\"3\\").intern();\\nstring f = new string(\\"3\\").intern();\\ne == f ? {}", e == f); //true\n\nstring g = new string("4");\nstring h = new string("4");\nlog.info("\\nstring g = new string(\\"4\\");\\nstring h = new string(\\"4\\");\\ng == h ? {}", g.equals(h)); //true\n\n\n在 jvm 中，当代码中出现双引号形式创建字符串对象时，jvm 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。这种机制，就是字符串驻留或池化。\n\n第一个案例返回 true，因为 java 的字符串驻留机制，直接使用双引号声明出来的两个 string 对象指向常量池中的相同字符串。\n\n第二个案例，new 出来的两个 string 是不同对象，引用当然不同，所以得到 false 的结果。\n\n第三个案例，使用 string 提供的 intern 方法也会走常量池机制，所以同样能得到 true。\n\n第四个案例，通过 equals 对值内容判等，是正确的处理方式，当然会得到 true。\n\n虽然使用 new 声明的字符串调用 intern 方法，也可以让字符串进行驻留，但在业务代码中滥用 intern，可能会产生性能问题。\n\n【示例】string#intern 性能测试\n\n//-xx:+printstringtablestatistics\n//-xx:stringtablesize=10000000\nlist<string> list = new arraylist<>();\nlong begin = system.currenttimemillis();\nlist = intstream.rangeclosed(1, 10000000)\n    .maptoobj(i -> string.valueof(i).intern())\n    .collect(collectors.tolist());\nsystem.out.println("size:" + list.size());\nsystem.out.println("time:" + (system.currenttimemillis() - begin));\n\n\n上面的示例执行时间会比较长。原因在于：字符串常量池是一个固定容量的 map。如果容量太小（number of buckets=60013）、字符串太多（1000 万个字符串），那么每一个桶中的字符串数量会非常多，所以搜索起来就很慢。输出结果中的 average bucket size=167，代表了 map 中桶的平均长度是 167。\n\n解决方法是：设置 jvm 参数 -xx:stringtablesize=10000000，指定更多的桶。\n\n为了方便观察，可以在启动程序时设置 jvm 参数 -xx:+printstringtablestatistic，程序退出时可以打印出字符串常量表的统计信息。\n\n执行结果比不设置 -xx:stringtablesize 要快很多。\n\n> 【总结】没事别轻易用 intern，如果要用一定要注意控制驻留的字符串的数量，并留意常量表的各项指标。\n\n\n# 实现 equals\n\n如果看过 object 类源码，你可能就知道，equals 的实现其实是比较对象引用\n\npublic boolean equals(object obj) {\n    return (this == obj);\n}\n\n\n之所以 integer 或 string 能通过 equals 实现内容判等，是因为它们都覆写了这个方法。\n\n对于自定义类型，如果不覆写 equals 的话，默认就是使用 object 基类的按引用的比较方式。\n\n实现一个更好的 equals 应该注意的点：\n\n * 考虑到性能，可以先进行指针判等，如果对象是同一个那么直接返回 true；\n * 需要对另一方进行判空，空对象和自身进行比较，结果一定是 fasle；\n * 需要判断两个对象的类型，如果类型都不同，那么直接返回 false；\n * 确保类型相同的情况下再进行类型强制转换，然后逐一判断所有字段。\n\n【示例】自定义 equals 示例\n\n自定义类：\n\nclass point {\n    private final int x;\n    private final int y;\n    private final string desc;\n}\n\n\n自定义 equals：\n\n@override\npublic boolean equals(object o) {\n    if (this == o) return true;\n    if (o == null || getclass() != o.getclass()) return false;\n    point that = (point) o;\n    return x == that.x && y == that.y;\n}\n\n\n\n# hashcode 和 equals 要配对实现\n\npoint p1 = new point(1, 2, "a");\npoint p2 = new point(1, 2, "b");\n\nhashset<pointwrong> points = new hashset<>();\npoints.add(p1);\nlog.info("points.contains(p2) ? {}", points.contains(p2));\n\n\n按照改进后的 equals 方法，这 2 个对象可以认为是同一个，set 中已经存在了 p1 就应该包含 p2，但结果却是 false。\n\n出现这个 bug 的原因是，散列表需要使用 hashcode 来定位元素放到哪个桶。如果自定义对象没有实现自定义的 hashcode 方法，就会使用 object 超类的默认实现，得到的两个 hashcode 是不同的，导致无法满足需求。\n\n要自定义 hashcode，我们可以直接使用 objects.hash 方法来实现。\n\n@override\npublic int hashcode() {\n    return objects.hash(x, y);\n}\n\n\n\n# compareto 和 equals 的逻辑一致性\n\n【示例】自定义 compareto 出错示例\n\n@data\n@allargsconstructor\nstatic class student implements comparable<student> {\n\n    private int id;\n    private string name;\n\n    @override\n    public int compareto(student other) {\n        int result = integer.compare(other.id, id);\n        if (result == 0) { log.info("this {} == other {}", this, other); }\n        return result;\n    }\n\n}\n\n\n调用：\n\nlist<student> list = new arraylist<>();\nlist.add(new student(1, "zhang"));\nlist.add(new student(2, "wang"));\nstudent student = new student(2, "li");\n\nlog.info("arraylist.indexof");\nint index1 = list.indexof(student);\ncollections.sort(list);\nlog.info("collections.binarysearch");\nint index2 = collections.binarysearch(list, student);\n\nlog.info("index1 = " + index1);\nlog.info("index2 = " + index2);\n\n\nbinarysearch 方法内部调用了元素的 compareto 方法进行比较；\n\n * indexof 的结果没问题，列表中搜索不到 id 为 2、name 是 li 的学生；\n * binarysearch 返回了索引 1，代表搜索到的结果是 id 为 2，name 是 wang 的学生。\n\n修复方式很简单，确保 compareto 的比较逻辑和 equals 的实现一致即可。\n\n@data\n@allargsconstructor\nstatic class studentright implements comparable<studentright> {\n\n    private int id;\n    private string name;\n\n    @override\n    public int compareto(studentright other) {\n        return comparator.comparing(studentright::getname)\n            .thencomparingint(studentright::getid)\n            .compare(this, other);\n    }\n\n}\n\n\n\n# 小心 lombok 生成代码的“坑”\n\nlombok 的 @data 注解会帮我们实现 equals 和 hashcode 方法，但是有继承关系时， lombok 自动生成的方法可能就不是我们期望的了。\n\n@equalsandhashcode 默认实现没有使用父类属性。为解决这个问题，我们可以手动设置 callsuper 开关为 true，来覆盖这种默认行为。\n\n\n# 数值计算\n\n\n# 浮点数计算问题\n\n计算机是把数值保存在了变量中，不同类型的数值变量能保存的数值范围不同，当数值超过类型能表达的数值上限则会发生溢出问题。\n\nsystem.out.println(0.1 + 0.2); // 0.30000000000000004\nsystem.out.println(1.0 - 0.8); // 0.19999999999999996\nsystem.out.println(4.015 * 100); // 401.49999999999994\nsystem.out.println(123.3 / 100); // 1.2329999999999999\ndouble amount1 = 2.15;\ndouble amount2 = 1.10;\nsystem.out.println(amount1 - amount2); // 1.0499999999999998\n\n\n上面的几个示例，输出结果和我们预期的很不一样。为什么会是这样呢？\n\n出现这种问题的主要原因是，计算机是以二进制存储数值的，浮点数也不例外。java 采用了 ieee 754 标准实现浮点数的表达和运算，你可以通过这里查看数值转化为二进制的结果。\n\n比如，0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，再转换为十进制就是 0.1000000000000000055511151231257827021181583404541015625。对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。\n\n浮点数无法精确表达和运算的场景，一定要使用 bigdecimal 类型。\n\n使用 bigdecimal 时，有个细节要格外注意。让我们来看一段代码：\n\nsystem.out.println(new bigdecimal(0.1).add(new bigdecimal(0.2)));\n// output: 0.3000000000000000166533453693773481063544750213623046875\n\nsystem.out.println(new bigdecimal(1.0).subtract(new bigdecimal(0.8)));\n// output: 0.1999999999999999555910790149937383830547332763671875\n\nsystem.out.println(new bigdecimal(4.015).multiply(new bigdecimal(100)));\n// output: 401.49999999999996802557689079549163579940795898437500\n\nsystem.out.println(new bigdecimal(123.3).divide(new bigdecimal(100)));\n// output: 1.232999999999999971578290569595992565155029296875\n\n\n为什么输出结果仍然不符合预期呢？\n\n使用 bigdecimal 表示和计算浮点数，且务必使用字符串的构造方法来初始化 bigdecimal。\n\n\n# 浮点数精度和格式化\n\n浮点数的字符串格式化也要通过 bigdecimal 进行。\n\nprivate static void wrong1() {\n    double num1 = 3.35;\n    float num2 = 3.35f;\n    system.out.println(string.format("%.1f", num1)); // 3.4\n    system.out.println(string.format("%.1f", num2)); // 3.3\n}\n\nprivate static void wrong2() {\n    double num1 = 3.35;\n    float num2 = 3.35f;\n    decimalformat format = new decimalformat("#.##");\n    format.setroundingmode(roundingmode.down);\n    system.out.println(format.format(num1)); // 3.35\n    format.setroundingmode(roundingmode.down);\n    system.out.println(format.format(num2)); // 3.34\n}\n\nprivate static void right() {\n    bigdecimal num1 = new bigdecimal("3.35");\n    bigdecimal num2 = num1.setscale(1, bigdecimal.round_down);\n    system.out.println(num2); // 3.3\n    bigdecimal num3 = num1.setscale(1, bigdecimal.round_half_up);\n    system.out.println(num3); // 3.4\n}\n\n\n\n# bigdecimal 判等问题\n\nprivate static void wrong() {\n    system.out.println(new bigdecimal("1.0").equals(new bigdecimal("1")));\n}\n\nprivate static void right() {\n    system.out.println(new bigdecimal("1.0").compareto(new bigdecimal("1")) == 0);\n}\n\n\nbigdecimal 的 equals 方法的注释中说明了原因，equals 比较的是 bigdecimal 的 value 和 scale，1.0 的 scale 是 1，1 的 scale 是 0，所以结果一定是 false。\n\n如果我们希望只比较 bigdecimal 的 value，可以使用 compareto 方法。\n\nbigdecimal 的 equals 和 hashcode 方法会同时考虑 value 和 scale，如果结合 hashset 或 hashmap 使用的话就可能会出现麻烦。比如，我们把值为 1.0 的 bigdecimal 加入 hashset，然后判断其是否存在值为 1 的 bigdecimal，得到的结果是 false。\n\nset<bigdecimal> hashset1 = new hashset<>();\nhashset1.add(new bigdecimal("1.0"));\nsystem.out.println(hashset1.contains(new bigdecimal("1")));//返回false\n\n\n\n\n解决办法有两个：\n\n第一个方法是，使用 treeset 替换 hashset。treeset 不使用 hashcode 方法，也不使用 equals 比较元素，而是使用 compareto 方法，所以不会有问题。\n\n第二个方法是，把 bigdecimal 存入 hashset 或 hashmap 前，先使用 striptrailingzeros 方法去掉尾部的零，比较的时候也去掉尾部的 0，确保 value 相同的 bigdecimal，scale 也是一致的。\n\nset<bigdecimal> hashset2 = new hashset<>();\nhashset2.add(new bigdecimal("1.0").striptrailingzeros());\nsystem.out.println(hashset2.contains(new bigdecimal("1.000").striptrailingzeros()));//返回true\n\nset<bigdecimal> treeset = new treeset<>();\ntreeset.add(new bigdecimal("1.0"));\nsystem.out.println(treeset.contains(new bigdecimal("1")));//返回true\n\n\n\n# 数值溢出\n\n数值计算还有一个要小心的点是溢出，不管是 int 还是 long，所有的基本数值类型都有超出表达范围的可能性。\n\nlong l = long.max_value;\nsystem.out.println(l + 1); // -9223372036854775808\nsystem.out.println(l + 1 == long.min_value); // true\n\n\n显然这是发生了溢出，而且是默默的溢出，并没有任何异常。这类问题非常容易被忽略，改进方式有下面 2 种。\n\n方法一是，考虑使用 math 类的 addexact、subtractexact 等 xxexact 方法进行数值运算，这些方法可以在数值溢出时主动抛出异常。\n\ntry {\n    long l = long.max_value;\n    system.out.println(math.addexact(l, 1));\n} catch (exception ex) {\n    ex.printstacktrace();\n}\n\n\n方法二是，使用大数类 biginteger。bigdecimal 是处理浮点数的专家，而 biginteger 则是对大数进行科学计算的专家。\n\nbiginteger i = new biginteger(string.valueof(long.max_value));\nsystem.out.println(i.add(biginteger.one).tostring());\n\ntry {\n    long l = i.add(biginteger.one).longvalueexact();\n} catch (exception ex) {\n    ex.printstacktrace();\n}\n\n\n\n# 参考资料\n\n * 《java 编程思想（thinking in java）》\n * 《java 核心技术 卷 i 基础知识》\n * 《java 业务开发常见错误 100 例》\n * java 基本数据类型和引用类型\n * 深入剖析 java 中的装箱和拆箱',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 面向对象",frontmatter:{title:"Java 面向对象",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE","面向对象"],abbrlink:"e4502010",date:"2020-08-06T18:20:39.000Z",permalink:"/pages/d6b776/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/03.Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"01.基础特性/03.Java面向对象.md",key:"v-3d2ab288",path:"/pages/d6b776/",headers:[{level:2,title:"面向对象",slug:"面向对象",normalizedTitle:"面向对象",charIndex:7},{level:3,title:"封装",slug:"封装",normalizedTitle:"封装",charIndex:708},{level:3,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:343},{level:4,title:"继承类型",slug:"继承类型",normalizedTitle:"继承类型",charIndex:1214},{level:4,title:"继承的特性",slug:"继承的特性",normalizedTitle:"继承的特性",charIndex:1224},{level:4,title:"继承关键字",slug:"继承关键字",normalizedTitle:"继承关键字",charIndex:1497},{level:3,title:"多态",slug:"多态",normalizedTitle:"多态",charIndex:1641},{level:2,title:"类",slug:"类",normalizedTitle:"类",charIndex:25},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:756},{level:3,title:"方法定义",slug:"方法定义",normalizedTitle:"方法定义",charIndex:2304},{level:3,title:"方法调用",slug:"方法调用",normalizedTitle:"方法调用",charIndex:2738},{level:3,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:2997},{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:888},{level:3,title:"变量修饰符",slug:"变量修饰符",normalizedTitle:"变量修饰符",charIndex:5200},{level:3,title:"创建对象",slug:"创建对象",normalizedTitle:"创建对象",charIndex:399},{level:3,title:"访问实例变量和方法",slug:"访问实例变量和方法",normalizedTitle:"访问实例变量和方法",charIndex:5754},{level:2,title:"访问权限控制",slug:"访问权限控制",normalizedTitle:"访问权限控制",charIndex:5907},{level:3,title:"代码组织",slug:"代码组织",normalizedTitle:"代码组织",charIndex:5918},{level:4,title:"package",slug:"package",normalizedTitle:"package",charIndex:6500},{level:4,title:"import",slug:"import",normalizedTitle:"import",charIndex:1625},{level:3,title:"访问权限修饰关键字",slug:"访问权限修饰关键字",normalizedTitle:"访问权限修饰关键字",charIndex:7478},{level:2,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:739},{level:2,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:7984},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8447}],headersStr:"面向对象 封装 继承 继承类型 继承的特性 继承关键字 多态 类 方法 方法定义 方法调用 构造方法 变量 变量修饰符 创建对象 访问实例变量和方法 访问权限控制 代码组织 package import 访问权限修饰关键字 接口 抽象类 参考资料",content:'# Java 面向对象\n\n> 在Java 基本数据类型 中我们了解 Java 中支持的基本数据类型（值类型）。本文开始讲解 Java 中重要的引用类型——类。\n\n\n# 面向对象\n\n每种编程语言，都有自己的操纵内存中元素的方式。\n\nJava 中提供了基本数据类型，但这还不能满足编写程序时，需要抽象更加复杂数据类型的需要。因此，Java 中，允许开发者通过类（类的机制下面会讲到）创建自定义类型。\n\n有了自定义类型，那么数据类型自然会千变万化，所以，必须要有一定的机制，使得它们仍然保持一些必要的、通用的特性。\n\nJava 世界有一句名言：一切皆为对象。这句话，你可能第一天学 Java 时，就听过了。这不仅仅是一句口号，也体现在 Java 的设计上。\n\n * 首先，所有 Java 类都继承自 Object 类（从这个名字，就可见一斑）。\n * 几乎所有 Java 对象初始化时，都要使用 new 创建对象（基本数据类型、String、枚举特殊处理），对象存储在堆中。\n\n// 下面两\nString s = "abc";\nString s = new String("abc");\n\n\n其中，String s 定义了一个名为 s 的引用，它指向一个 String 类型的对象，而实际的对象是 “abc” 字符串。这就像是，使用遥控器（引用）来操纵电视机（对象）。\n\n与 C/C++ 这类语言不同，程序员只需要通过 new 创建一个对象，但不必负责销毁或结束一个对象。负责运行 Java 程序的 Java 虚拟机有一个垃圾回收器，它会监视 new 创建的对象，一旦发现对象不再被引用，则会释放对象的内存空间。\n\n\n# 封装\n\n封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。\n\n封装最主要的作用在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\n\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n\n封装的优点：\n\n * 良好的封装能够减少耦合。\n * 类内部的结构可以自由修改。\n * 可以对成员变量进行更精确的控制。\n * 隐藏信息，实现细节。\n\n实现封装的步骤：\n\n 1. 修改属性的可见性来限制对属性的访问（一般限制为 private）。\n 2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问。\n\n\n# 继承\n\n继承是 java 面向对象编程技术的一块基石，因为它允许创建分等级层次的类。\n\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\n\n现实中的例子：\n\n狗和鸟都是动物。如果将狗、鸟作为类，它们可以继承动物类。\n\n\n\n类的继承形式：\n\nclass 父类 {}\n\nclass 子类 extends 父类 {}\n\n\n# 继承类型\n\n\n\n# 继承的特性\n\n * 子类拥有父类非 private 的属性、方法。\n * 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n * 子类可以用自己的方式实现父类的方法。\n * Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。\n * 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n\n# 继承关键字\n\n继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 object（这个类在 java.lang 包中，所以不需要 import）祖先类。\n\n\n# 多态\n\n刚开始学习面向对象编程时，容易被各种术语弄得云里雾里。所以，很多人会死记硬背书中对于术语的定义。\n\n但是，随着应用和理解的深入，应该会渐渐有更进一步的认识，将其融汇贯通的理解。\n\n学习类之前，先让我们思考一个问题：Java 中为什么要引入类机制，设计的初衷是什么？\n\nJava 中提供的基本数据类型，只能表示单一的数值，这用于数值计算，还 OK。但是，如果要抽象模拟现实中更复杂的事物，则无法做到。\n\n试想，如果要让你抽象狗的数据模型，怎么做？狗有眼耳口鼻等器官，有腿，狗有大小，毛色，这些都是它的状态，狗会跑、会叫、会吃东西，这些是它的行为。\n\n类的引入，就是为了抽象这种相对复杂的事物。\n\n对象是用于计算机语言对问题域中事物的描述。对象通过方法和属性来分别描述事物所具有的行为和状态。\n\n类是用于描述同一类的对象的一个抽象的概念，类中定义了这一类对象所具有的行为和状态。\n\n类可以看成是创建 Java 对象的模板。\n\n什么是方法？扩展阅读：面向对象编程的弊端是什么？ - invalid s 的回答\n\n\n# 类\n\n与大多数面向对象编程语言一样，Java 使用 class （类）关键字来表示自定义类型。自定义类型是为了更容易抽象现实事物。\n\n在一个类中，可以设置一静一动两种元素：属性（静）和方法（动）。\n\n * 属性（有的人喜欢称为成员、字段） - 属性抽象的是事物的状态。类属性可以是任何类型的对象。\n * 方法（有的人喜欢称为函数） - 方法抽象的是事物的行为。\n\n类的形式如下：\n\n\n\n\n# 方法\n\n\n# 方法定义\n\n修饰符 返回值类型 方法名(参数类型 参数名){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n\n\n方法包含一个方法头和一个方法体。下面是一个方法的所有部分：\n\n * **修饰符：**修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。\n * **返回值类型 ：**方法可能有返回值。如果没有返回值，这种情况下，返回值类型应设为 void。\n * **方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。\n * **参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n * **方法体：**方法体包含具体的语句，定义该方法的功能。\n\n示例：\n\npublic static int add(int x, int y) {\n   return x + y;\n}\n\n\n\n# 方法调用\n\nJava 支持两种调用方法的方式，根据方法是否返回值来选择。\n\n当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。\n\n当方法返回一个值的时候，方法调用通常被当做一个值。例如：\n\nint larger = max(30, 40);\n\n\n如果方法返回值是 void，方法调用一定是一条语句。例如，方法 println 返回 void。下面的调用是个语句：\n\nSystem.out.println("Hello World");\n\n\n\n# 构造方法\n\n每个类都有构造方法。如果没有显式地为类定义任何构造方法，Java 编译器将会为该类提供一个默认构造方法。\n\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\n\npublic class Puppy{\n    public Puppy(){\n    }\n\n    public Puppy(String name){\n        // 这个构造器仅有一个参数：name\n    }\n}\n\n\n\n# 变量\n\nJava 支持的变量类型有：\n\n * 局部变量 - 类方法中的变量。\n * 实例变量（也叫成员变量） - 类方法外的变量，不过没有 static 修饰。\n * 类变量（也叫静态变量） - 类方法外的变量，用 static 修饰。\n\n特性对比：\n\n局部变量                                                            实例变量（也叫成员变量）                                                             类变量（也叫静态变量）\n局部变量声明在方法、构造方法或者语句块中。                                           实例变量声明在方法、构造方法和语句块之外。                                                    类变量声明在方法、构造方法和语句块之外。并且以 static 修饰。\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。                    实例变量在对象创建的时候创建，在对象被销毁的时候销毁。                                              类变量在第一次被访问时创建，在程序结束时销毁。\n局部变量没有默认值，所以必须经过初始化，才可以使用。                                      实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是                      类变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是\n                                                                null。变量的值可以在声明时指定，也可以在构造方法中指定。                                           null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。   实例变量存储在堆。                                                                类变量存储在静态存储区。\n访问修饰符不能用于局部变量。                                                  访问修饰符可以用于实例变量。                                                           访问修饰符可以用于类变量。\n局部变量只在声明它的方法、构造方法或者语句块中可见。                                      实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。        与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n                                                                实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。   静态变量可以通过：ClassName.VariableName 的方式访问。\n                                                                                                                                         无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n                                                                                                                                         类变量除了被声明为常量外很少使用。\n\n\n# 变量修饰符\n\n * 访问级别修饰符 - 如果变量是实例变量或类变量，可以添加访问级别修饰符（public/protected/private）\n * 静态修饰符 - 如果变量是类变量，需要添加 static 修饰\n * final - 如果变量使用 fianl 修饰符，就表示这是一个常量，不能被修改。\n\n\n# 创建对象\n\n对象是根据类创建的。在 Java 中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：\n\n * 声明：声明一个对象，包括对象名称和对象类型。\n * 实例化：使用关键字 new 来创建一个对象。\n * 初始化：使用 new 创建对象时，会调用构造方法初始化对象。\n\npublic class Puppy{\n   public Puppy(String name){\n      //这个构造器仅有一个参数：name\n      System.out.println("小狗的名字是 : " + name );\n   }\n   public static void main(String[] args){\n      // 下面的语句将创建一个Puppy对象\n      Puppy myPuppy = new Puppy( "tommy" );\n   }\n}\n\n\n\n# 访问实例变量和方法\n\n/* 实例化对象 */\nObjectReference = new Constructor();\n/* 访问类中的变量 */\nObjectReference.variableName;\n/* 访问类中的方法 */\nObjectReference.methodName();\n\n\n\n# 访问权限控制\n\n\n# 代码组织\n\n当编译一个 .java 文件时，在 .java 文件中的每个类都会输出一个与类同名的 .class 文件。\n\nMultiClassDemo.java 示例：\n\nclass MultiClass1 {}\n\nclass MultiClass2 {}\n\nclass MultiClass3 {}\n\npublic class MultiClassDemo {}\n\n\n执行 javac MultiClassDemo.java 命令，本地会生成 MultiClass1.class、MultiClass2.class、MultiClass3.class、MultiClassDemo.class 四个文件。\n\nJava 可运行程序是由一组 .class 文件打包并压缩成的一个 .jar 文件。Java 解释器负责这些文件的查找、装载和解释。Java 类库实际上是一组类文件（.java 文件）。\n\n * 其中每个文件允许有一个 public 类，以及任意数量的非 public 类。\n * public 类名必须和 .java 文件名完全相同，包括大小写。\n\n程序一般不止一个人编写，会调用系统提供的代码、第三方库中的代码、项目中其他人写的代码等，不同的人因为不同的目的可能定义同样的类名/接口名，这就是命名冲突。\n\nJava 中为了解决命名冲突问题，提供了包（package）和导入（import）机制。\n\n# package\n\n包（package）的原则：\n\n * 包类似于文件夹，文件放在文件夹中，类和接口则放在包中。为了便于组织，文件夹一般是一个有层次的树形结构，包也类似。\n * 包名以逗号 . 分隔，表示层次结构。\n * Java 中命名包名的一个惯例是使用域名作为前缀，因为域名是唯一的，一般按照域名的反序来定义包名，比如，域名是：apache.org，包名就以 org.apache 开头。\n * **包名和文件目录结构必须完全匹配。**Java 解释器运行过程如下：\n   * 找出环境变量 CLASSPATH，作为 .class 文件的根目录。\n   * 从根目录开始，获取包名称，并将逗号 . 替换为文件分隔符（反斜杠 /），通过这个路径名称去查找 Java 类。\n\n# import\n\n同一个包下的类之间互相引用是不需要包名的，可以直接使用。但如果类不在同一个包内，则必须要知道其所在的包，使用有两种方式：\n\n * 通过类的完全限定名\n * 通过 import 将用到的类引入到当前类\n\n通过类的完全限定名示例：\n\npublic class PackageDemo {\n    public static void main (String[]args){\n        System.out.println(new java.util.Date());\n        System.out.println(new java.util.Date());\n    }\n}\n\n\n通过 import 导入其它包的类到当前类：\n\nimport java.util.Date;\n\npublic class PackageDemo2 {\n    public static void main(String[] args) {\n        System.out.println(new Date());\n        System.out.println(new Date());\n    }\n}\n\n\n> 说明：以上两个示例比较起来，显然是 import 方式，代码更加整洁。\n\n> 扩展阅读：https://www.cnblogs.com/swiftma/p/5628762.html\n\n\n# 访问权限修饰关键字\n\n访问权限控制的等级，从最大权限到最小权限依次为：\n\npublic > protected > 包访问权限（没有任何关键字）> private\n\n\n * public - 表示任何类都可以访问；\n * 包访问权限 - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。\n * protected - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。\n * private - 表示其它任何类都无法访问。\n\n\n# 接口\n\n接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。\n\n接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 public static final 的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。\n\nJava 标准类库中，定义了非常多的接口，比如 java.util.List。\n\npublic interface Comparable<T> {\n    public int compareTo(T o);\n}\n\n\n\n# 抽象类\n\n抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。\n\nJava 标准库中，比如 collection 框架，很多通用部分就被抽取成为抽象类，例如 java.util.AbstractList。\n\n 1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。\n 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n 3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。\n 4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。\n 5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。\n\n\n# 参考资料\n\n * 书籍\n   * Java 编程思想\n   * Java 核心技术（卷 1）\n   * Head First Java\n * 文章\n   * 面向对象编程的弊端是什么？ - invalid s 的回答\n   * https://www.cnblogs.com/swiftma/p/5628762.html',normalizedContent:'# java 面向对象\n\n> 在java 基本数据类型 中我们了解 java 中支持的基本数据类型（值类型）。本文开始讲解 java 中重要的引用类型——类。\n\n\n# 面向对象\n\n每种编程语言，都有自己的操纵内存中元素的方式。\n\njava 中提供了基本数据类型，但这还不能满足编写程序时，需要抽象更加复杂数据类型的需要。因此，java 中，允许开发者通过类（类的机制下面会讲到）创建自定义类型。\n\n有了自定义类型，那么数据类型自然会千变万化，所以，必须要有一定的机制，使得它们仍然保持一些必要的、通用的特性。\n\njava 世界有一句名言：一切皆为对象。这句话，你可能第一天学 java 时，就听过了。这不仅仅是一句口号，也体现在 java 的设计上。\n\n * 首先，所有 java 类都继承自 object 类（从这个名字，就可见一斑）。\n * 几乎所有 java 对象初始化时，都要使用 new 创建对象（基本数据类型、string、枚举特殊处理），对象存储在堆中。\n\n// 下面两\nstring s = "abc";\nstring s = new string("abc");\n\n\n其中，string s 定义了一个名为 s 的引用，它指向一个 string 类型的对象，而实际的对象是 “abc” 字符串。这就像是，使用遥控器（引用）来操纵电视机（对象）。\n\n与 c/c++ 这类语言不同，程序员只需要通过 new 创建一个对象，但不必负责销毁或结束一个对象。负责运行 java 程序的 java 虚拟机有一个垃圾回收器，它会监视 new 创建的对象，一旦发现对象不再被引用，则会释放对象的内存空间。\n\n\n# 封装\n\n封装（encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。\n\n封装最主要的作用在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\n\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n\n封装的优点：\n\n * 良好的封装能够减少耦合。\n * 类内部的结构可以自由修改。\n * 可以对成员变量进行更精确的控制。\n * 隐藏信息，实现细节。\n\n实现封装的步骤：\n\n 1. 修改属性的可见性来限制对属性的访问（一般限制为 private）。\n 2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问。\n\n\n# 继承\n\n继承是 java 面向对象编程技术的一块基石，因为它允许创建分等级层次的类。\n\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\n\n现实中的例子：\n\n狗和鸟都是动物。如果将狗、鸟作为类，它们可以继承动物类。\n\n\n\n类的继承形式：\n\nclass 父类 {}\n\nclass 子类 extends 父类 {}\n\n\n# 继承类型\n\n\n\n# 继承的特性\n\n * 子类拥有父类非 private 的属性、方法。\n * 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n * 子类可以用自己的方式实现父类的方法。\n * java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 a 类继承 b 类，b 类继承 c 类，所以按照关系就是 c 类是 b 类的父类，b 类是 a 类的父类，这是 java 继承区别于 c++ 继承的一个特性。\n * 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n\n# 继承关键字\n\n继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.object，当一个类没有继承的两个关键字，则默认继承 object（这个类在 java.lang 包中，所以不需要 import）祖先类。\n\n\n# 多态\n\n刚开始学习面向对象编程时，容易被各种术语弄得云里雾里。所以，很多人会死记硬背书中对于术语的定义。\n\n但是，随着应用和理解的深入，应该会渐渐有更进一步的认识，将其融汇贯通的理解。\n\n学习类之前，先让我们思考一个问题：java 中为什么要引入类机制，设计的初衷是什么？\n\njava 中提供的基本数据类型，只能表示单一的数值，这用于数值计算，还 ok。但是，如果要抽象模拟现实中更复杂的事物，则无法做到。\n\n试想，如果要让你抽象狗的数据模型，怎么做？狗有眼耳口鼻等器官，有腿，狗有大小，毛色，这些都是它的状态，狗会跑、会叫、会吃东西，这些是它的行为。\n\n类的引入，就是为了抽象这种相对复杂的事物。\n\n对象是用于计算机语言对问题域中事物的描述。对象通过方法和属性来分别描述事物所具有的行为和状态。\n\n类是用于描述同一类的对象的一个抽象的概念，类中定义了这一类对象所具有的行为和状态。\n\n类可以看成是创建 java 对象的模板。\n\n什么是方法？扩展阅读：面向对象编程的弊端是什么？ - invalid s 的回答\n\n\n# 类\n\n与大多数面向对象编程语言一样，java 使用 class （类）关键字来表示自定义类型。自定义类型是为了更容易抽象现实事物。\n\n在一个类中，可以设置一静一动两种元素：属性（静）和方法（动）。\n\n * 属性（有的人喜欢称为成员、字段） - 属性抽象的是事物的状态。类属性可以是任何类型的对象。\n * 方法（有的人喜欢称为函数） - 方法抽象的是事物的行为。\n\n类的形式如下：\n\n\n\n\n# 方法\n\n\n# 方法定义\n\n修饰符 返回值类型 方法名(参数类型 参数名){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n\n\n方法包含一个方法头和一个方法体。下面是一个方法的所有部分：\n\n * **修饰符：**修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。\n * **返回值类型 ：**方法可能有返回值。如果没有返回值，这种情况下，返回值类型应设为 void。\n * **方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。\n * **参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n * **方法体：**方法体包含具体的语句，定义该方法的功能。\n\n示例：\n\npublic static int add(int x, int y) {\n   return x + y;\n}\n\n\n\n# 方法调用\n\njava 支持两种调用方法的方式，根据方法是否返回值来选择。\n\n当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。\n\n当方法返回一个值的时候，方法调用通常被当做一个值。例如：\n\nint larger = max(30, 40);\n\n\n如果方法返回值是 void，方法调用一定是一条语句。例如，方法 println 返回 void。下面的调用是个语句：\n\nsystem.out.println("hello world");\n\n\n\n# 构造方法\n\n每个类都有构造方法。如果没有显式地为类定义任何构造方法，java 编译器将会为该类提供一个默认构造方法。\n\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\n\npublic class puppy{\n    public puppy(){\n    }\n\n    public puppy(string name){\n        // 这个构造器仅有一个参数：name\n    }\n}\n\n\n\n# 变量\n\njava 支持的变量类型有：\n\n * 局部变量 - 类方法中的变量。\n * 实例变量（也叫成员变量） - 类方法外的变量，不过没有 static 修饰。\n * 类变量（也叫静态变量） - 类方法外的变量，用 static 修饰。\n\n特性对比：\n\n局部变量                                                            实例变量（也叫成员变量）                                                             类变量（也叫静态变量）\n局部变量声明在方法、构造方法或者语句块中。                                           实例变量声明在方法、构造方法和语句块之外。                                                    类变量声明在方法、构造方法和语句块之外。并且以 static 修饰。\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。                    实例变量在对象创建的时候创建，在对象被销毁的时候销毁。                                              类变量在第一次被访问时创建，在程序结束时销毁。\n局部变量没有默认值，所以必须经过初始化，才可以使用。                                      实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是                      类变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是\n                                                                null。变量的值可以在声明时指定，也可以在构造方法中指定。                                           null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。   实例变量存储在堆。                                                                类变量存储在静态存储区。\n访问修饰符不能用于局部变量。                                                  访问修饰符可以用于实例变量。                                                           访问修饰符可以用于类变量。\n局部变量只在声明它的方法、构造方法或者语句块中可见。                                      实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。        与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n                                                                实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：obejectreference.variablename。   静态变量可以通过：classname.variablename 的方式访问。\n                                                                                                                                         无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n                                                                                                                                         类变量除了被声明为常量外很少使用。\n\n\n# 变量修饰符\n\n * 访问级别修饰符 - 如果变量是实例变量或类变量，可以添加访问级别修饰符（public/protected/private）\n * 静态修饰符 - 如果变量是类变量，需要添加 static 修饰\n * final - 如果变量使用 fianl 修饰符，就表示这是一个常量，不能被修改。\n\n\n# 创建对象\n\n对象是根据类创建的。在 java 中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：\n\n * 声明：声明一个对象，包括对象名称和对象类型。\n * 实例化：使用关键字 new 来创建一个对象。\n * 初始化：使用 new 创建对象时，会调用构造方法初始化对象。\n\npublic class puppy{\n   public puppy(string name){\n      //这个构造器仅有一个参数：name\n      system.out.println("小狗的名字是 : " + name );\n   }\n   public static void main(string[] args){\n      // 下面的语句将创建一个puppy对象\n      puppy mypuppy = new puppy( "tommy" );\n   }\n}\n\n\n\n# 访问实例变量和方法\n\n/* 实例化对象 */\nobjectreference = new constructor();\n/* 访问类中的变量 */\nobjectreference.variablename;\n/* 访问类中的方法 */\nobjectreference.methodname();\n\n\n\n# 访问权限控制\n\n\n# 代码组织\n\n当编译一个 .java 文件时，在 .java 文件中的每个类都会输出一个与类同名的 .class 文件。\n\nmulticlassdemo.java 示例：\n\nclass multiclass1 {}\n\nclass multiclass2 {}\n\nclass multiclass3 {}\n\npublic class multiclassdemo {}\n\n\n执行 javac multiclassdemo.java 命令，本地会生成 multiclass1.class、multiclass2.class、multiclass3.class、multiclassdemo.class 四个文件。\n\njava 可运行程序是由一组 .class 文件打包并压缩成的一个 .jar 文件。java 解释器负责这些文件的查找、装载和解释。java 类库实际上是一组类文件（.java 文件）。\n\n * 其中每个文件允许有一个 public 类，以及任意数量的非 public 类。\n * public 类名必须和 .java 文件名完全相同，包括大小写。\n\n程序一般不止一个人编写，会调用系统提供的代码、第三方库中的代码、项目中其他人写的代码等，不同的人因为不同的目的可能定义同样的类名/接口名，这就是命名冲突。\n\njava 中为了解决命名冲突问题，提供了包（package）和导入（import）机制。\n\n# package\n\n包（package）的原则：\n\n * 包类似于文件夹，文件放在文件夹中，类和接口则放在包中。为了便于组织，文件夹一般是一个有层次的树形结构，包也类似。\n * 包名以逗号 . 分隔，表示层次结构。\n * java 中命名包名的一个惯例是使用域名作为前缀，因为域名是唯一的，一般按照域名的反序来定义包名，比如，域名是：apache.org，包名就以 org.apache 开头。\n * **包名和文件目录结构必须完全匹配。**java 解释器运行过程如下：\n   * 找出环境变量 classpath，作为 .class 文件的根目录。\n   * 从根目录开始，获取包名称，并将逗号 . 替换为文件分隔符（反斜杠 /），通过这个路径名称去查找 java 类。\n\n# import\n\n同一个包下的类之间互相引用是不需要包名的，可以直接使用。但如果类不在同一个包内，则必须要知道其所在的包，使用有两种方式：\n\n * 通过类的完全限定名\n * 通过 import 将用到的类引入到当前类\n\n通过类的完全限定名示例：\n\npublic class packagedemo {\n    public static void main (string[]args){\n        system.out.println(new java.util.date());\n        system.out.println(new java.util.date());\n    }\n}\n\n\n通过 import 导入其它包的类到当前类：\n\nimport java.util.date;\n\npublic class packagedemo2 {\n    public static void main(string[] args) {\n        system.out.println(new date());\n        system.out.println(new date());\n    }\n}\n\n\n> 说明：以上两个示例比较起来，显然是 import 方式，代码更加整洁。\n\n> 扩展阅读：https://www.cnblogs.com/swiftma/p/5628762.html\n\n\n# 访问权限修饰关键字\n\n访问权限控制的等级，从最大权限到最小权限依次为：\n\npublic > protected > 包访问权限（没有任何关键字）> private\n\n\n * public - 表示任何类都可以访问；\n * 包访问权限 - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。\n * protected - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。\n * private - 表示其它任何类都无法访问。\n\n\n# 接口\n\n接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 api 定义和实现分离的目的。\n\n接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 public static final 的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。\n\njava 标准类库中，定义了非常多的接口，比如 java.util.list。\n\npublic interface comparable<t> {\n    public int compareto(t o);\n}\n\n\n\n# 抽象类\n\n抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用。除了不能实例化，形式上和一般的 java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。\n\njava 标准库中，比如 collection 框架，很多通用部分就被抽取成为抽象类，例如 java.util.abstractlist。\n\n 1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。\n 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n 3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。\n 4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。\n 5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。\n\n\n# 参考资料\n\n * 书籍\n   * java 编程思想\n   * java 核心技术（卷 1）\n   * head first java\n * 文章\n   * 面向对象编程的弊端是什么？ - invalid s 的回答\n   * https://www.cnblogs.com/swiftma/p/5628762.html',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"深入理解 Java 方法",frontmatter:{title:"深入理解 Java 方法",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE","方法"],abbrlink:"8dfb0abf",date:"2019-05-06T15:02:02.000Z",permalink:"/pages/d17f6e/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/04.Java%E6%96%B9%E6%B3%95.html",relativePath:"01.基础特性/04.Java方法.md",key:"v-d34be976",path:"/pages/d17f6e/",headers:[{level:2,title:"方法的使用",slug:"方法的使用",normalizedTitle:"方法的使用",charIndex:46},{level:3,title:"方法定义",slug:"方法定义",normalizedTitle:"方法定义",charIndex:56},{level:3,title:"方法的调用",slug:"方法的调用",normalizedTitle:"方法的调用",charIndex:601},{level:4,title:"递归调用",slug:"递归调用",normalizedTitle:"递归调用",charIndex:846},{level:2,title:"方法参数",slug:"方法参数",normalizedTitle:"方法参数",charIndex:1336},{level:2,title:"方法修饰符",slug:"方法修饰符",normalizedTitle:"方法修饰符",charIndex:2559},{level:3,title:"访问控制修饰符",slug:"访问控制修饰符",normalizedTitle:"访问控制修饰符",charIndex:2647},{level:3,title:"static",slug:"static",normalizedTitle:"static",charIndex:158},{level:3,title:"final",slug:"final",normalizedTitle:"final",charIndex:3131},{level:3,title:"default",slug:"default",normalizedTitle:"default",charIndex:3719},{level:3,title:"abstract",slug:"abstract",normalizedTitle:"abstract",charIndex:4424},{level:3,title:"synchronized",slug:"synchronized",normalizedTitle:"synchronized",charIndex:4922},{level:2,title:"特殊方法",slug:"特殊方法",normalizedTitle:"特殊方法",charIndex:5127},{level:3,title:"main 方法",slug:"main-方法",normalizedTitle:"main 方法",charIndex:5167},{level:3,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:5631},{level:3,title:"变参方法",slug:"变参方法",normalizedTitle:"变参方法",charIndex:6358},{level:3,title:"finalize() 方法",slug:"finalize-方法",normalizedTitle:"finalize() 方法",charIndex:7078},{level:2,title:"覆写和重载",slug:"覆写和重载",normalizedTitle:"覆写和重载",charIndex:7549},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:8637},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8646}],headersStr:"方法的使用 方法定义 方法的调用 递归调用 方法参数 方法修饰符 访问控制修饰符 static final default abstract synchronized 特殊方法 main 方法 构造方法 变参方法 finalize() 方法 覆写和重载 小结 参考资料",content:'# 深入理解 Java 方法\n\n> 方法（有的人喜欢叫函数）是一段可重用的代码段。\n\n\n# 方法的使用\n\n\n# 方法定义\n\n方法定义语法格式：\n\n[修饰符] 返回值类型 方法名([参数类型 参数名]){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n\n\n示例：\n\npublic static void main(String[] args) {\n    System.out.println("Hello World");\n}\n\n\n方法包含一个方法头和一个方法体。下面是一个方法的所有部分：\n\n * 修饰符 - 修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。\n * 返回值类型 - 返回值类型表示方法执行结束后，返回结果的数据类型。如果没有返回值，应设为 void。\n * 方法名 - 是方法的实际名称。方法名和参数表共同构成方法签名。\n * 参数类型 - 参数像是一个占位符。当方法被调用时，传递值给参数。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n * 方法体 - 方法体包含具体的语句，定义该方法的功能。\n * return - 必须返回声明方法时返回值类型相同的数据类型。在 void 方法中，return 语句可有可无，如果要写 return，则只能是 return; 这种形式。\n\n\n# 方法的调用\n\n当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。\n\nJava 支持两种调用方法的方式，根据方法是否有返回值来选择。\n\n * 有返回值方法 - 有返回值方法通常被用来给一个变量赋值或代入到运算表达式中进行计算。\n\nint larger = max(30, 40);\n\n\n * 无返回值方法 - 无返回值方法只能是一条语句。\n\nSystem.out.println("Hello World");\n\n\n# 递归调用\n\nJava 支持方法的递归调用（即方法调用自身）。\n\n> 🔔 注意：\n> \n>  * 递归方法必须有明确的结束条件。\n>  * 尽量避免使用递归调用。因为递归调用如果处理不当，可能导致栈溢出。\n\n斐波那契数列（一个典型的递归算法）示例：\n\npublic class RecursionMethodDemo {\n    public static int fib(int num) {\n        if (num == 1 || num == 2) {\n            return 1;\n        } else {\n            return fib(num - 2) + fib(num - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        for (int i = 1; i < 10; i++) {\n            System.out.print(fib(i) + "\\t");\n        }\n    }\n}\n\n\n\n# 方法参数\n\n在 C/C++ 等编程语言中，方法的参数传递一般有两种形式：\n\n * 值传递 - 值传递的参数被称为形参。值传递时，传入的参数，在方法中的修改，不会在方法外部生效。\n * 引用传递 - 引用传递的参数被称为实参。引用传递时，传入的参数，在方法中的修改，会在方法外部生效。\n\n那么，Java 中是怎样的呢？\n\nJava 中只有值传递。\n\n示例一：\n\npublic class MethodParamDemo {\n    public static void method(int value) {\n        value =  value + 1;\n    }\n    public static void main(String[] args) {\n        int num = 0;\n        method(num);\n        System.out.println("num = [" + num + "]");\n        method(num);\n        System.out.println("num = [" + num + "]");\n    }\n}\n// Output:\n// num = [0]\n// num = [0]\n\n\n示例二：\n\npublic class MethodParamDemo2 {\n    public static void method(StringBuilder sb) {\n        sb = new StringBuilder("B");\n    }\n\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder("A");\n        System.out.println("sb = [" + sb.toString() + "]");\n        method(sb);\n        System.out.println("sb = [" + sb.toString() + "]");\n        sb = new StringBuilder("C");\n        System.out.println("sb = [" + sb.toString() + "]");\n    }\n}\n// Output:\n// sb = [A]\n// sb = [A]\n// sb = [C]\n\n\n说明：\n\n以上两个示例，无论向方法中传入的是基础数据类型，还是引用类型，在方法中修改的值，在外部都未生效。\n\nJava 对于基本数据类型，会直接拷贝值传递到方法中；对于引用数据类型，拷贝当前对象的引用地址，然后把该地址传递过去，所以也是值传递。\n\n> 扩展阅读：\n> \n> 图解 Java 中的参数传递\n\n\n# 方法修饰符\n\n前面提到了，Java 方法的修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。\n\nJava 方法有好几个修饰符，让我们一一来认识一下：\n\n\n# 访问控制修饰符\n\n访问权限控制的等级，从最大权限到最小权限依次为：\n\npublic > protected > 包访问权限（没有任何关键字）> private\n\n\n * public - 表示任何类都可以访问；\n * 包访问权限 - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。\n * protected - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。\n * private - 表示其它任何类都无法访问。\n\n\n# static\n\n被 static 修饰的方法被称为静态方法。\n\n静态方法相比于普通的实例方法，主要有以下区别：\n\n * 在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象名.方法名 的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。\n\n * 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。\n\n静态方法常被用于各种工具类、工厂方法类。\n\n\n# final\n\n被 final 修饰的方法不能被子类覆写（Override）。\n\nfinal 方法示例：\n\npublic class FinalMethodDemo {\n    static class Father {\n        protected final void print() {\n            System.out.println("call Father print()");\n        };\n    }\n\n    static class Son extends Father {\n        @Override\n        protected void print() {\n            System.out.println("call print()");\n        }\n    }\n\n    public static void main(String[] args) {\n        Father demo = new Son();\n        demo.print();\n    }\n}\n// 编译时会报错\n\n\n> 说明：\n> \n> 上面示例中，父类 Father 中定义了一个 final 方法 print()，则其子类不能 Override 这个 final 方法，否则会编译报错。\n\n\n# default\n\nJDK8 开始，支持在接口 Interface 中定义 default 方法。default 方法只能出现在接口 Interface 中。\n\n接口中被 default 修饰的方法被称为默认方法，实现此接口的类如果没 Override 此方法，则直接继承这个方法，不再强制必须实现此方法。\n\ndefault 方法语法的出现，是为了既有的成千上万的 Java 类库的类增加新的功能， 且不必对这些类重新进行设计。 举例来说，JDK8 中 Collection 类中有一个非常方便的 stream() 方法，就是被修饰为 default，Collection 的一大堆 List、Set 子类就直接继承了这个方法 I，不必再为每个子类都注意添加这个方法。\n\ndefault 方法示例：\n\npublic class DefaultMethodDemo {\n    interface MyInterface {\n        default void print() {\n            System.out.println("Hello World");\n        }\n    }\n\n\n    static class MyClass implements MyInterface {}\n\n    public static void main(String[] args) {\n        MyInterface obj = new MyClass();\n        obj.print();\n    }\n}\n// Output:\n// Hello World\n\n\n\n# abstract\n\n被 abstract 修饰的方法被称为抽象方法，方法不能有实体。抽象方法只能出现抽象类中。\n\n抽象方法示例：\n\npublic class AbstractMethodDemo {\n    static abstract class AbstractClass {\n        abstract void print();\n    }\n\n    static class ConcreteClass extends AbstractClass {\n        @Override\n        void print() {\n            System.out.println("call print()");\n        }\n    }\n\n    public static void main(String[] args) {\n        AbstractClass demo = new ConcreteClass();\n        demo.print();\n    }\n\n}\n// Outpu:\n// call print()\n\n\n\n# synchronized\n\nsynchronized 用于并发编程。被 synchronized 修饰的方法在一个时刻，只允许一个线程执行。\n\n在 Java 的同步容器（Vector、Stack、HashTable）中，你会见到大量的 synchronized 方法。不过，请记住：在 Java 并发编程中，synchronized 方法并不是一个好的选择，大多数情况下，我们会选择更加轻量级的锁 。\n\n\n# 特殊方法\n\nJava 中，有一些较为特殊的方法，分别使用于特殊的场景。\n\n\n# main 方法\n\nJava 中的 main 方法是一种特殊的静态方法，因为所有的 Java 程序都是由 public static void main(String[] args) 方法开始执行。\n\n有很多新手虽然一直用 main 方法，却不知道 main 方法中的 args 有什么用。实际上，这是用来接收接收命令行输入参数的。\n\n示例：\n\npublic class MainMethodDemo {\n    public static void main(String[] args) {\n        for (String arg : args) {\n            System.out.println("arg = [" + arg + "]");\n        }\n    }\n}\n\n\n依次执行\n\njavac MainMethodDemo.java\njava MainMethodDemo A B C\n\n\n控制台会打印输出参数：\n\narg = [A]\narg = [B]\narg = [C]\n\n\n\n# 构造方法\n\n任何类都有构造方法，构造方法的作用就是在初始化类实例时，设置实例的状态。\n\n每个类都有构造方法。如果没有显式地为类定义任何构造方法，Java 编译器将会为该类提供一个默认构造方法。\n\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\n\npublic class ConstructorMethodDemo {\n\n    static class Person {\n        private String name;\n\n        public Person(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n\n    public static void main(String[] args) {\n        Person person = new Person("jack");\n        System.out.println("person name is " + person.getName());\n    }\n}\n\n\n注意，构造方法除了使用 public，也可以使用 private 修饰，这种情况下，类无法调用此构造方法去实例化对象，这常常用于设计模式中的单例模式。\n\n\n# 变参方法\n\nJDK5 开始，Java 支持传递同类型的可变参数给一个方法。在方法声明中，在指定参数类型后加一个省略号 ...。一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。\n\n变参方法示例：\n\npublic class VarargsDemo {\n    public static void method(String... params) {\n        System.out.println("params.length = " + params.length);\n        for (String param : params) {\n            System.out.println("params = [" + param + "]");\n        }\n    }\n\n    public static void main(String[] args) {\n        method("red");\n        method("red", "yellow");\n        method("red", "yellow", "blue");\n    }\n}\n// Output:\n// params.length = 1\n// params = [red]\n// params.length = 2\n// params = [red]\n// params = [yellow]\n// params.length = 3\n// params = [red]\n// params = [yellow]\n// params = [blue]\n\n\n\n# finalize() 方法\n\nfinalize 在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。\n\nfinalize 是在 java.lang.Object 里定义的，也就是说每一个对象都有这么个方法。这个方法在 GC 启动，该对象被回收的时候被调用。\n\nfinalizer() 通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定、降低性能，以及可移植性问题。\n\n请记住：应该尽量避免使用 finalizer()。千万不要把它当成是 C/C++ 中的析构函数来用。原因是：Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的 CPU 时间较少，因此它永远也赶不上主线程的步伐。所以最后可能会发生 OutOfMemoryError 异常。\n\n> 扩展阅读：\n> \n> 下面两篇文章比较详细的讲述了 finalizer() 可能会造成的问题及原因。\n> \n>  * Java 的 Finalizer 引发的内存溢出\n>  * 重载 Finalize 引发的内存泄露\n\n\n# 覆写和重载\n\n覆写（Override）是指子类定义了与父类中同名的方法，但是在方法覆写时必须考虑到访问权限，子类覆写的方法不能拥有比父类更加严格的访问权限。\n\n子类要覆写的方法如果要访问父类的方法，可以使用 super 关键字。\n\n覆写示例：\n\npublic class MethodOverrideDemo {\n    static class Animal {\n        public void move() {\n            System.out.println("会动");\n        }\n    }\n    static class Dog extends Animal {\n        @Override\n        public void move() {\n            super.move();\n            System.out.println("会跑");\n        }\n    }\n\n    public static void main(String[] args) {\n        Animal dog = new Dog();\n        dog.move();\n    }\n}\n// Output:\n// 会动\n// 会跑\n\n\n方法的重载（Overload）是指方法名称相同，但参数的类型或参数的个数不同。通过传递参数的个数及类型的不同可以完成不同功能的方法调用。\n\n> 🔔 注意：\n> \n> 重载一定是方法的参数不完全相同。如果方法的参数完全相同，仅仅是返回值不同，Java 是无法编译通过的。\n\n重载示例：\n\npublic class MethodOverloadDemo {\n    public static void add(int x, int y) {\n        System.out.println("x + y = " + (x + y));\n    }\n\n    public static void add(double x, double y) {\n        System.out.println("x + y = " + (x + y));\n    }\n\n    public static void main(String[] args) {\n        add(10, 20);\n        add(1.0, 2.0);\n    }\n}\n// Output:\n// x + y = 30\n// x + y = 3.0\n\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * Head First Java\n * 图解 Java 中的参数传递\n * Java 的 Finalizer 引发的内存溢出\n * 重载 Finalize 引发的内存泄露',normalizedContent:'# 深入理解 java 方法\n\n> 方法（有的人喜欢叫函数）是一段可重用的代码段。\n\n\n# 方法的使用\n\n\n# 方法定义\n\n方法定义语法格式：\n\n[修饰符] 返回值类型 方法名([参数类型 参数名]){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n\n\n示例：\n\npublic static void main(string[] args) {\n    system.out.println("hello world");\n}\n\n\n方法包含一个方法头和一个方法体。下面是一个方法的所有部分：\n\n * 修饰符 - 修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。\n * 返回值类型 - 返回值类型表示方法执行结束后，返回结果的数据类型。如果没有返回值，应设为 void。\n * 方法名 - 是方法的实际名称。方法名和参数表共同构成方法签名。\n * 参数类型 - 参数像是一个占位符。当方法被调用时，传递值给参数。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n * 方法体 - 方法体包含具体的语句，定义该方法的功能。\n * return - 必须返回声明方法时返回值类型相同的数据类型。在 void 方法中，return 语句可有可无，如果要写 return，则只能是 return; 这种形式。\n\n\n# 方法的调用\n\n当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。\n\njava 支持两种调用方法的方式，根据方法是否有返回值来选择。\n\n * 有返回值方法 - 有返回值方法通常被用来给一个变量赋值或代入到运算表达式中进行计算。\n\nint larger = max(30, 40);\n\n\n * 无返回值方法 - 无返回值方法只能是一条语句。\n\nsystem.out.println("hello world");\n\n\n# 递归调用\n\njava 支持方法的递归调用（即方法调用自身）。\n\n> 🔔 注意：\n> \n>  * 递归方法必须有明确的结束条件。\n>  * 尽量避免使用递归调用。因为递归调用如果处理不当，可能导致栈溢出。\n\n斐波那契数列（一个典型的递归算法）示例：\n\npublic class recursionmethoddemo {\n    public static int fib(int num) {\n        if (num == 1 || num == 2) {\n            return 1;\n        } else {\n            return fib(num - 2) + fib(num - 1);\n        }\n    }\n\n    public static void main(string[] args) {\n        for (int i = 1; i < 10; i++) {\n            system.out.print(fib(i) + "\\t");\n        }\n    }\n}\n\n\n\n# 方法参数\n\n在 c/c++ 等编程语言中，方法的参数传递一般有两种形式：\n\n * 值传递 - 值传递的参数被称为形参。值传递时，传入的参数，在方法中的修改，不会在方法外部生效。\n * 引用传递 - 引用传递的参数被称为实参。引用传递时，传入的参数，在方法中的修改，会在方法外部生效。\n\n那么，java 中是怎样的呢？\n\njava 中只有值传递。\n\n示例一：\n\npublic class methodparamdemo {\n    public static void method(int value) {\n        value =  value + 1;\n    }\n    public static void main(string[] args) {\n        int num = 0;\n        method(num);\n        system.out.println("num = [" + num + "]");\n        method(num);\n        system.out.println("num = [" + num + "]");\n    }\n}\n// output:\n// num = [0]\n// num = [0]\n\n\n示例二：\n\npublic class methodparamdemo2 {\n    public static void method(stringbuilder sb) {\n        sb = new stringbuilder("b");\n    }\n\n    public static void main(string[] args) {\n        stringbuilder sb = new stringbuilder("a");\n        system.out.println("sb = [" + sb.tostring() + "]");\n        method(sb);\n        system.out.println("sb = [" + sb.tostring() + "]");\n        sb = new stringbuilder("c");\n        system.out.println("sb = [" + sb.tostring() + "]");\n    }\n}\n// output:\n// sb = [a]\n// sb = [a]\n// sb = [c]\n\n\n说明：\n\n以上两个示例，无论向方法中传入的是基础数据类型，还是引用类型，在方法中修改的值，在外部都未生效。\n\njava 对于基本数据类型，会直接拷贝值传递到方法中；对于引用数据类型，拷贝当前对象的引用地址，然后把该地址传递过去，所以也是值传递。\n\n> 扩展阅读：\n> \n> 图解 java 中的参数传递\n\n\n# 方法修饰符\n\n前面提到了，java 方法的修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。\n\njava 方法有好几个修饰符，让我们一一来认识一下：\n\n\n# 访问控制修饰符\n\n访问权限控制的等级，从最大权限到最小权限依次为：\n\npublic > protected > 包访问权限（没有任何关键字）> private\n\n\n * public - 表示任何类都可以访问；\n * 包访问权限 - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。\n * protected - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。\n * private - 表示其它任何类都无法访问。\n\n\n# static\n\n被 static 修饰的方法被称为静态方法。\n\n静态方法相比于普通的实例方法，主要有以下区别：\n\n * 在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象名.方法名 的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。\n\n * 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。\n\n静态方法常被用于各种工具类、工厂方法类。\n\n\n# final\n\n被 final 修饰的方法不能被子类覆写（override）。\n\nfinal 方法示例：\n\npublic class finalmethoddemo {\n    static class father {\n        protected final void print() {\n            system.out.println("call father print()");\n        };\n    }\n\n    static class son extends father {\n        @override\n        protected void print() {\n            system.out.println("call print()");\n        }\n    }\n\n    public static void main(string[] args) {\n        father demo = new son();\n        demo.print();\n    }\n}\n// 编译时会报错\n\n\n> 说明：\n> \n> 上面示例中，父类 father 中定义了一个 final 方法 print()，则其子类不能 override 这个 final 方法，否则会编译报错。\n\n\n# default\n\njdk8 开始，支持在接口 interface 中定义 default 方法。default 方法只能出现在接口 interface 中。\n\n接口中被 default 修饰的方法被称为默认方法，实现此接口的类如果没 override 此方法，则直接继承这个方法，不再强制必须实现此方法。\n\ndefault 方法语法的出现，是为了既有的成千上万的 java 类库的类增加新的功能， 且不必对这些类重新进行设计。 举例来说，jdk8 中 collection 类中有一个非常方便的 stream() 方法，就是被修饰为 default，collection 的一大堆 list、set 子类就直接继承了这个方法 i，不必再为每个子类都注意添加这个方法。\n\ndefault 方法示例：\n\npublic class defaultmethoddemo {\n    interface myinterface {\n        default void print() {\n            system.out.println("hello world");\n        }\n    }\n\n\n    static class myclass implements myinterface {}\n\n    public static void main(string[] args) {\n        myinterface obj = new myclass();\n        obj.print();\n    }\n}\n// output:\n// hello world\n\n\n\n# abstract\n\n被 abstract 修饰的方法被称为抽象方法，方法不能有实体。抽象方法只能出现抽象类中。\n\n抽象方法示例：\n\npublic class abstractmethoddemo {\n    static abstract class abstractclass {\n        abstract void print();\n    }\n\n    static class concreteclass extends abstractclass {\n        @override\n        void print() {\n            system.out.println("call print()");\n        }\n    }\n\n    public static void main(string[] args) {\n        abstractclass demo = new concreteclass();\n        demo.print();\n    }\n\n}\n// outpu:\n// call print()\n\n\n\n# synchronized\n\nsynchronized 用于并发编程。被 synchronized 修饰的方法在一个时刻，只允许一个线程执行。\n\n在 java 的同步容器（vector、stack、hashtable）中，你会见到大量的 synchronized 方法。不过，请记住：在 java 并发编程中，synchronized 方法并不是一个好的选择，大多数情况下，我们会选择更加轻量级的锁 。\n\n\n# 特殊方法\n\njava 中，有一些较为特殊的方法，分别使用于特殊的场景。\n\n\n# main 方法\n\njava 中的 main 方法是一种特殊的静态方法，因为所有的 java 程序都是由 public static void main(string[] args) 方法开始执行。\n\n有很多新手虽然一直用 main 方法，却不知道 main 方法中的 args 有什么用。实际上，这是用来接收接收命令行输入参数的。\n\n示例：\n\npublic class mainmethoddemo {\n    public static void main(string[] args) {\n        for (string arg : args) {\n            system.out.println("arg = [" + arg + "]");\n        }\n    }\n}\n\n\n依次执行\n\njavac mainmethoddemo.java\njava mainmethoddemo a b c\n\n\n控制台会打印输出参数：\n\narg = [a]\narg = [b]\narg = [c]\n\n\n\n# 构造方法\n\n任何类都有构造方法，构造方法的作用就是在初始化类实例时，设置实例的状态。\n\n每个类都有构造方法。如果没有显式地为类定义任何构造方法，java 编译器将会为该类提供一个默认构造方法。\n\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\n\npublic class constructormethoddemo {\n\n    static class person {\n        private string name;\n\n        public person(string name) {\n            this.name = name;\n        }\n\n        public string getname() {\n            return name;\n        }\n\n        public void setname(string name) {\n            this.name = name;\n        }\n    }\n\n    public static void main(string[] args) {\n        person person = new person("jack");\n        system.out.println("person name is " + person.getname());\n    }\n}\n\n\n注意，构造方法除了使用 public，也可以使用 private 修饰，这种情况下，类无法调用此构造方法去实例化对象，这常常用于设计模式中的单例模式。\n\n\n# 变参方法\n\njdk5 开始，java 支持传递同类型的可变参数给一个方法。在方法声明中，在指定参数类型后加一个省略号 ...。一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。\n\n变参方法示例：\n\npublic class varargsdemo {\n    public static void method(string... params) {\n        system.out.println("params.length = " + params.length);\n        for (string param : params) {\n            system.out.println("params = [" + param + "]");\n        }\n    }\n\n    public static void main(string[] args) {\n        method("red");\n        method("red", "yellow");\n        method("red", "yellow", "blue");\n    }\n}\n// output:\n// params.length = 1\n// params = [red]\n// params.length = 2\n// params = [red]\n// params = [yellow]\n// params.length = 3\n// params = [red]\n// params = [yellow]\n// params = [blue]\n\n\n\n# finalize() 方法\n\nfinalize 在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。\n\nfinalize 是在 java.lang.object 里定义的，也就是说每一个对象都有这么个方法。这个方法在 gc 启动，该对象被回收的时候被调用。\n\nfinalizer() 通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定、降低性能，以及可移植性问题。\n\n请记住：应该尽量避免使用 finalizer()。千万不要把它当成是 c/c++ 中的析构函数来用。原因是：finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的 cpu 时间较少，因此它永远也赶不上主线程的步伐。所以最后可能会发生 outofmemoryerror 异常。\n\n> 扩展阅读：\n> \n> 下面两篇文章比较详细的讲述了 finalizer() 可能会造成的问题及原因。\n> \n>  * java 的 finalizer 引发的内存溢出\n>  * 重载 finalize 引发的内存泄露\n\n\n# 覆写和重载\n\n覆写（override）是指子类定义了与父类中同名的方法，但是在方法覆写时必须考虑到访问权限，子类覆写的方法不能拥有比父类更加严格的访问权限。\n\n子类要覆写的方法如果要访问父类的方法，可以使用 super 关键字。\n\n覆写示例：\n\npublic class methodoverridedemo {\n    static class animal {\n        public void move() {\n            system.out.println("会动");\n        }\n    }\n    static class dog extends animal {\n        @override\n        public void move() {\n            super.move();\n            system.out.println("会跑");\n        }\n    }\n\n    public static void main(string[] args) {\n        animal dog = new dog();\n        dog.move();\n    }\n}\n// output:\n// 会动\n// 会跑\n\n\n方法的重载（overload）是指方法名称相同，但参数的类型或参数的个数不同。通过传递参数的个数及类型的不同可以完成不同功能的方法调用。\n\n> 🔔 注意：\n> \n> 重载一定是方法的参数不完全相同。如果方法的参数完全相同，仅仅是返回值不同，java 是无法编译通过的。\n\n重载示例：\n\npublic class methodoverloaddemo {\n    public static void add(int x, int y) {\n        system.out.println("x + y = " + (x + y));\n    }\n\n    public static void add(double x, double y) {\n        system.out.println("x + y = " + (x + y));\n    }\n\n    public static void main(string[] args) {\n        add(10, 20);\n        add(1.0, 2.0);\n    }\n}\n// output:\n// x + y = 30\n// x + y = 3.0\n\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * head first java\n * 图解 java 中的参数传递\n * java 的 finalizer 引发的内存溢出\n * 重载 finalize 引发的内存泄露',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"深入理解 Java 数组",frontmatter:{title:"深入理解 Java 数组",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE","数组"],abbrlink:"14f8ff28",date:"2019-05-06T15:02:02.000Z",permalink:"/pages/33ad31/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/05.Java%E6%95%B0%E7%BB%84.html",relativePath:"01.基础特性/05.Java数组.md",key:"v-7a009923",path:"/pages/33ad31/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:19},{level:3,title:"数组的特性",slug:"数组的特性",normalizedTitle:"数组的特性",charIndex:26},{level:3,title:"数组和容器",slug:"数组和容器",normalizedTitle:"数组和容器",charIndex:220},{level:3,title:"Java 数组的本质是对象",slug:"java-数组的本质是对象",normalizedTitle:"java 数组的本质是对象",charIndex:402},{level:3,title:"Java 数组和内存",slug:"java-数组和内存",normalizedTitle:"java 数组和内存",charIndex:608},{level:2,title:"声明数组",slug:"声明数组",normalizedTitle:"声明数组",charIndex:763},{level:2,title:"创建数组",slug:"创建数组",normalizedTitle:"创建数组",charIndex:828},{level:3,title:"数组维度的形式",slug:"数组维度的形式",normalizedTitle:"数组维度的形式",charIndex:2400},{level:3,title:"数组维度的大小",slug:"数组维度的大小",normalizedTitle:"数组维度的大小",charIndex:3469},{level:2,title:"访问数组",slug:"访问数组",normalizedTitle:"访问数组",charIndex:3580},{level:2,title:"数组的引用",slug:"数组的引用",normalizedTitle:"数组的引用",charIndex:4026},{level:2,title:"泛型和数组",slug:"泛型和数组",normalizedTitle:"泛型和数组",charIndex:4710},{level:2,title:"多维数组",slug:"多维数组",normalizedTitle:"多维数组",charIndex:5699},{level:2,title:"Arrays 类",slug:"arrays-类",normalizedTitle:"arrays 类",charIndex:6775},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:6998},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7007}],headersStr:"简介 数组的特性 数组和容器 Java 数组的本质是对象 Java 数组和内存 声明数组 创建数组 数组维度的形式 数组维度的大小 访问数组 数组的引用 泛型和数组 多维数组 Arrays 类 小结 参考资料",content:'# 深入理解 Java 数组\n\n\n# 简介\n\n\n# 数组的特性\n\n数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。几乎所有程序设计语言都支持数组。\n\n数组代表一系列对象或者基本数据类型，所有相同的类型都封装到一起，采用一个统一的标识符名称。\n\n数组的定义和使用需要通过方括号 []。\n\n> Java 中，数组是一种引用类型。\n> \n> Java 中，数组是用来存储固定大小的同类型元素。\n\n\n# 数组和容器\n\nJava 中，既然有了强大的容器，是不是就不需要数组了？\n\n答案是不。\n\n诚然，大多数情况下，应该选择容器存储数据。\n\n但是，数组也不是毫无是处：\n\n * Java 中，数组是一种效率最高的存储和随机访问对象引用序列的方式。数组的效率要高于容器（如 ArrayList）。\n * 数组可以持有值类型，而容器则不能（这时，就必须用到包装类）。\n\n\n# Java 数组的本质是对象\n\nJava 数组的本质是对象。它具有 Java 中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。\n\n如果有两个类 A 和 B，如果 B 继承（extends）了 A，那么 A[] 类型的引用就可以指向 B[] 类型的对象。\n\n> 扩展阅读：Java 中数组的特性\n> \n> 如果想要论证 Java 数组本质是对象，不妨一读这篇文章。\n\n\n# Java 数组和内存\n\nJava 数组在内存中的存储是这样的：\n\n数组对象（这里可以看成一个指针）存储在栈中。\n\n数组元素存储在堆中。\n\n如下图所示：只有当 JVM 执行 new String[] 时，才会在堆中开辟相应的内存区域。数组对象 array 可以视为一个指针，指向这块内存的存储地址。\n\n\n\n\n# 声明数组\n\n声明数组变量的语法如下：\n\nint[] arr1; // 推荐风格\nint arr2[]; // 效果相同\n\n\n\n# 创建数组\n\nJava 语言使用 new 操作符来创建数组。有两种创建数组方式：\n\n * 指定数组维度\n   * 为数组开辟指定大小的数组维度。\n   * 如果数组元素是基础数据类型，会将每个元素设为默认值；如果是引用类型，元素值为 null。\n * 不指定数组维度\n   * 用花括号中的实际元素初始化数组，数组大小与元素数相同。\n\n示例 1：\n\npublic class ArrayDemo {\n    public static void main(String[] args) {\n        int[] array1 = new int[2]; // 指定数组维度\n        int[] array2 = new int[] { 1, 2 }; // 不指定数组维度\n\n        System.out.println("array1 size is " + array1.length);\n        for (int item : array1) {\n            System.out.println(item);\n        }\n\n        System.out.println("array2 size is " + array1.length);\n        for (int item : array2) {\n            System.out.println(item);\n        }\n    }\n}\n// Output:\n// array1 size is 2\n// 0\n// 0\n// array2 size is 2\n// 1\n// 2\n\n\n> 💡 说明 请注意数组 array1 中的元素虽然没有初始化，但是 length 和指定的数组维度是一样的。这表明指定数组维度后，无论后面是否初始化数组中的元素，数组都已经开辟了相应的内存。\n> \n> 数组 array1 中的元素都被设为默认值。\n\n示例 2：\n\npublic class ArrayDemo2 {\n    static class User {}\n\n    public static void main(String[] args) {\n        User[] array1 = new User[2]; // 指定数组维度\n        User[] array2 = new User[] {new User(), new User()}; // 不指定数组维度\n\n        System.out.println("array1: ");\n        for (User item : array1) {\n            System.out.println(item);\n        }\n\n        System.out.println("array2: ");\n        for (User item : array2) {\n            System.out.println(item);\n        }\n    }\n}\n// Output:\n// array1:\n// null\n// null\n// array2:\n// io.github.dunwu.javacore.array.ArrayDemo2$User@4141d797\n// io.github.dunwu.javacore.array.ArrayDemo2$User@68f7aae2\n\n\n> 💡 说明\n> \n> 请将本例与示例 1 比较，可以发现：如果使用指定数组维度方式创建数组，且数组元素为引用类型，则数组中的元素元素值为 null。\n\n\n# 数组维度的形式\n\n创建数组时，指定的数组维度可以有多种形式：\n\n * 数组维度可以是整数、字符。\n * 数组维度可以是整数型、字符型变量。\n * 数组维度可以是计算结果为整数或字符的表达式。\n\n示例：\n\npublic class ArrayDemo3 {\n    public static void main(String[] args) {\n        int length = 3;\n        // 放开被注掉的代码，编译器会报错\n        // int[] array = new int[4.0];\n        // int[] array2 = new int["test"];\n        int[] array3 = new int[\'a\'];\n        int[] array4 = new int[length];\n        int[] array5 = new int[length + 2];\n        int[] array6 = new int[\'a\' + 2];\n        // int[] array7 = new int[length + 2.1];\n        System.out.println("array3.length = [" + array3.length + "]");\n        System.out.println("array4.length = [" + array4.length + "]");\n        System.out.println("array5.length = [" + array5.length + "]");\n        System.out.println("array6.length = [" + array6.length + "]");\n    }\n}\n// Output:\n// array3.length = [97]\n// array4.length = [3]\n// array5.length = [5]\n// array6.length = [99]\n\n\n> 💡 说明\n> \n> 当指定的数组维度是字符时，Java 会将其转为整数。如字符 a 的 ASCII 码是 97。\n> \n> 综上，Java 数组的数组维度可以是常量、变量、表达式，只要转换为整数即可。\n> \n> 请留意，有些编程语言则不支持这点，如 C/C++ 语言，只允许数组维度是常量。\n\n\n# 数组维度的大小\n\n数组维度并非没有上限的，如果数值过大，编译时会报错。\n\nint[] array = new int[6553612431]; // 数组维度过大，编译报错\n\n\n此外，数组过大，可能会导致栈溢出。\n\n\n# 访问数组\n\nJava 中，可以通过在 [] 中指定下标，访问数组元素，下标位置从 0 开始。\n\npublic class ArrayDemo4 {\n    public static void main(String[] args) {\n        int[] array = {1, 2, 3};\n        for (int i = 0; i < array.length; i++) {\n            array[i]++;\n            System.out.println(String.format("array[%d] = %d", i, array[i]));\n        }\n    }\n}\n// Output:\n// array[0] = 2\n// array[1] = 3\n// array[2] = 4\n\n\n> 💡 说明\n> \n> 上面的示例中，从 0 开始，使用下标遍历数组 array 的所有元素，为每个元素值加 1 。\n\n\n# 数组的引用\n\nJava 中，数组类型是一种引用类型。\n\n因此，它可以作为引用，被 Java 函数作为函数入参或返回值。\n\n数组作为函数入参的示例：\n\npublic class ArrayRefDemo {\n    private static void fun(int[] array) {\n        for (int i : array) {\n            System.out.print(i + "\\t");\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] array = new int[] {1, 3, 5};\n        fun(array);\n    }\n}\n// Output:\n// 1\t3\t5\n\n\n数组作为函数返回值的示例：\n\npublic class ArrayRefDemo2 {\n    /**\n     * 返回一个数组\n     */\n    private static int[] fun() {\n        return new int[] {1, 3, 5};\n    }\n\n    public static void main(String[] args) {\n        int[] array = fun();\n        System.out.println(Arrays.toString(array));\n    }\n}\n// Output:\n// [1, 3, 5]\n\n\n\n# 泛型和数组\n\n通常，数组和泛型不能很好地结合。你不能实例化具有参数化类型的数组。\n\nPeel<Banana>[] peels = new Pell<Banana>[10]; // 这行代码非法\n\n\nJava 中不允许直接创建泛型数组。但是，可以通过创建一个类型擦除的数组，然后转型的方式来创建泛型数组。\n\npublic class GenericArrayDemo<T> {\n\n    static class GenericArray<T> {\n        private T[] array;\n\n        public GenericArray(int num) {\n            array = (T[]) new Object[num];\n        }\n\n        public void put(int index, T item) {\n            array[index] = item;\n        }\n\n        public T get(int index) { return array[index]; }\n\n        public T[] array() { return array; }\n    }\n\n\n\n    public static void main(String[] args) {\n        GenericArray<Integer> genericArray = new GenericArray<Integer>(4);\n        genericArray.put(0, 0);\n        genericArray.put(1, 1);\n        Object[] array = genericArray.array();\n        System.out.println(Arrays.deepToString(array));\n    }\n}\n// Output:\n// [0, 1, null, null]\n\n\n> 扩展阅读：https://www.cnblogs.com/jiangzhaowei/p/7399522.html\n> \n> 我认为，对于泛型数组的理解，点到为止即可。实际上，真的需要存储泛型，还是使用容器更合适。\n\n\n# 多维数组\n\n多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。\n\nJava 可以支持二维数组、三维数组、四维数组、五维数组。。。\n\n但是，以正常人的理解能力，一般也就最多能理解三维数组。所以，请不要做反人类的事，去定义过多维度的数组。\n\n多维数组使用示例：\n\npublic class MultiArrayDemo {\n    public static void main(String[] args) {\n        Integer[][] a1 = { // 自动装箱\n            {1, 2, 3,},\n            {4, 5, 6,},\n        };\n        Double[][][] a2 = { // 自动装箱\n            { {1.1, 2.2}, {3.3, 4.4} },\n            { {5.5, 6.6}, {7.7, 8.8} },\n            { {9.9, 1.2}, {2.3, 3.4} },\n        };\n        String[][] a3 = {\n            {"The", "Quick", "Sly", "Fox"},\n            {"Jumped", "Over"},\n            {"The", "Lazy", "Brown", "Dog", "and", "friend"},\n        };\n        System.out.println("a1: " + Arrays.deepToString(a1));\n        System.out.println("a2: " + Arrays.deepToString(a2));\n        System.out.println("a3: " + Arrays.deepToString(a3));\n    }\n}\n// Output:\n// a1: [[1, 2, 3], [4, 5, 6]]\n// a2: [[[1.1, 2.2], [3.3, 4.4]], [[5.5, 6.6], [7.7, 8.8]], [[9.9, 1.2], [2.3, 3.4]]]\n// a3: [[The, Quick, Sly, Fox], [Jumped, Over], [The, Lazy, Brown, Dog, and, friend]]\n\n\n\n# Arrays 类\n\nJava 中，提供了一个很有用的数组工具类：Arrays。\n\n它提供的主要操作有：\n\n * sort - 排序\n * binarySearch - 查找\n * equals - 比较\n * fill - 填充\n * asList - 转列表\n * hash - 哈希\n * toString - 转字符串\n\n> 扩展阅读：https://juejin.im/post/5a6ade5c518825733e60acb8\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * Java 中数组的特性\n * https://juejin.im/post/59cae3de6fb9a00a4551915b\n * https://www.cnblogs.com/jiangzhaowei/p/7399522.html\n * https://juejin.im/post/5a6ade5c518825733e60acb8',normalizedContent:'# 深入理解 java 数组\n\n\n# 简介\n\n\n# 数组的特性\n\n数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。几乎所有程序设计语言都支持数组。\n\n数组代表一系列对象或者基本数据类型，所有相同的类型都封装到一起，采用一个统一的标识符名称。\n\n数组的定义和使用需要通过方括号 []。\n\n> java 中，数组是一种引用类型。\n> \n> java 中，数组是用来存储固定大小的同类型元素。\n\n\n# 数组和容器\n\njava 中，既然有了强大的容器，是不是就不需要数组了？\n\n答案是不。\n\n诚然，大多数情况下，应该选择容器存储数据。\n\n但是，数组也不是毫无是处：\n\n * java 中，数组是一种效率最高的存储和随机访问对象引用序列的方式。数组的效率要高于容器（如 arraylist）。\n * 数组可以持有值类型，而容器则不能（这时，就必须用到包装类）。\n\n\n# java 数组的本质是对象\n\njava 数组的本质是对象。它具有 java 中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。\n\n如果有两个类 a 和 b，如果 b 继承（extends）了 a，那么 a[] 类型的引用就可以指向 b[] 类型的对象。\n\n> 扩展阅读：java 中数组的特性\n> \n> 如果想要论证 java 数组本质是对象，不妨一读这篇文章。\n\n\n# java 数组和内存\n\njava 数组在内存中的存储是这样的：\n\n数组对象（这里可以看成一个指针）存储在栈中。\n\n数组元素存储在堆中。\n\n如下图所示：只有当 jvm 执行 new string[] 时，才会在堆中开辟相应的内存区域。数组对象 array 可以视为一个指针，指向这块内存的存储地址。\n\n\n\n\n# 声明数组\n\n声明数组变量的语法如下：\n\nint[] arr1; // 推荐风格\nint arr2[]; // 效果相同\n\n\n\n# 创建数组\n\njava 语言使用 new 操作符来创建数组。有两种创建数组方式：\n\n * 指定数组维度\n   * 为数组开辟指定大小的数组维度。\n   * 如果数组元素是基础数据类型，会将每个元素设为默认值；如果是引用类型，元素值为 null。\n * 不指定数组维度\n   * 用花括号中的实际元素初始化数组，数组大小与元素数相同。\n\n示例 1：\n\npublic class arraydemo {\n    public static void main(string[] args) {\n        int[] array1 = new int[2]; // 指定数组维度\n        int[] array2 = new int[] { 1, 2 }; // 不指定数组维度\n\n        system.out.println("array1 size is " + array1.length);\n        for (int item : array1) {\n            system.out.println(item);\n        }\n\n        system.out.println("array2 size is " + array1.length);\n        for (int item : array2) {\n            system.out.println(item);\n        }\n    }\n}\n// output:\n// array1 size is 2\n// 0\n// 0\n// array2 size is 2\n// 1\n// 2\n\n\n> 💡 说明 请注意数组 array1 中的元素虽然没有初始化，但是 length 和指定的数组维度是一样的。这表明指定数组维度后，无论后面是否初始化数组中的元素，数组都已经开辟了相应的内存。\n> \n> 数组 array1 中的元素都被设为默认值。\n\n示例 2：\n\npublic class arraydemo2 {\n    static class user {}\n\n    public static void main(string[] args) {\n        user[] array1 = new user[2]; // 指定数组维度\n        user[] array2 = new user[] {new user(), new user()}; // 不指定数组维度\n\n        system.out.println("array1: ");\n        for (user item : array1) {\n            system.out.println(item);\n        }\n\n        system.out.println("array2: ");\n        for (user item : array2) {\n            system.out.println(item);\n        }\n    }\n}\n// output:\n// array1:\n// null\n// null\n// array2:\n// io.github.dunwu.javacore.array.arraydemo2$user@4141d797\n// io.github.dunwu.javacore.array.arraydemo2$user@68f7aae2\n\n\n> 💡 说明\n> \n> 请将本例与示例 1 比较，可以发现：如果使用指定数组维度方式创建数组，且数组元素为引用类型，则数组中的元素元素值为 null。\n\n\n# 数组维度的形式\n\n创建数组时，指定的数组维度可以有多种形式：\n\n * 数组维度可以是整数、字符。\n * 数组维度可以是整数型、字符型变量。\n * 数组维度可以是计算结果为整数或字符的表达式。\n\n示例：\n\npublic class arraydemo3 {\n    public static void main(string[] args) {\n        int length = 3;\n        // 放开被注掉的代码，编译器会报错\n        // int[] array = new int[4.0];\n        // int[] array2 = new int["test"];\n        int[] array3 = new int[\'a\'];\n        int[] array4 = new int[length];\n        int[] array5 = new int[length + 2];\n        int[] array6 = new int[\'a\' + 2];\n        // int[] array7 = new int[length + 2.1];\n        system.out.println("array3.length = [" + array3.length + "]");\n        system.out.println("array4.length = [" + array4.length + "]");\n        system.out.println("array5.length = [" + array5.length + "]");\n        system.out.println("array6.length = [" + array6.length + "]");\n    }\n}\n// output:\n// array3.length = [97]\n// array4.length = [3]\n// array5.length = [5]\n// array6.length = [99]\n\n\n> 💡 说明\n> \n> 当指定的数组维度是字符时，java 会将其转为整数。如字符 a 的 ascii 码是 97。\n> \n> 综上，java 数组的数组维度可以是常量、变量、表达式，只要转换为整数即可。\n> \n> 请留意，有些编程语言则不支持这点，如 c/c++ 语言，只允许数组维度是常量。\n\n\n# 数组维度的大小\n\n数组维度并非没有上限的，如果数值过大，编译时会报错。\n\nint[] array = new int[6553612431]; // 数组维度过大，编译报错\n\n\n此外，数组过大，可能会导致栈溢出。\n\n\n# 访问数组\n\njava 中，可以通过在 [] 中指定下标，访问数组元素，下标位置从 0 开始。\n\npublic class arraydemo4 {\n    public static void main(string[] args) {\n        int[] array = {1, 2, 3};\n        for (int i = 0; i < array.length; i++) {\n            array[i]++;\n            system.out.println(string.format("array[%d] = %d", i, array[i]));\n        }\n    }\n}\n// output:\n// array[0] = 2\n// array[1] = 3\n// array[2] = 4\n\n\n> 💡 说明\n> \n> 上面的示例中，从 0 开始，使用下标遍历数组 array 的所有元素，为每个元素值加 1 。\n\n\n# 数组的引用\n\njava 中，数组类型是一种引用类型。\n\n因此，它可以作为引用，被 java 函数作为函数入参或返回值。\n\n数组作为函数入参的示例：\n\npublic class arrayrefdemo {\n    private static void fun(int[] array) {\n        for (int i : array) {\n            system.out.print(i + "\\t");\n        }\n    }\n\n    public static void main(string[] args) {\n        int[] array = new int[] {1, 3, 5};\n        fun(array);\n    }\n}\n// output:\n// 1\t3\t5\n\n\n数组作为函数返回值的示例：\n\npublic class arrayrefdemo2 {\n    /**\n     * 返回一个数组\n     */\n    private static int[] fun() {\n        return new int[] {1, 3, 5};\n    }\n\n    public static void main(string[] args) {\n        int[] array = fun();\n        system.out.println(arrays.tostring(array));\n    }\n}\n// output:\n// [1, 3, 5]\n\n\n\n# 泛型和数组\n\n通常，数组和泛型不能很好地结合。你不能实例化具有参数化类型的数组。\n\npeel<banana>[] peels = new pell<banana>[10]; // 这行代码非法\n\n\njava 中不允许直接创建泛型数组。但是，可以通过创建一个类型擦除的数组，然后转型的方式来创建泛型数组。\n\npublic class genericarraydemo<t> {\n\n    static class genericarray<t> {\n        private t[] array;\n\n        public genericarray(int num) {\n            array = (t[]) new object[num];\n        }\n\n        public void put(int index, t item) {\n            array[index] = item;\n        }\n\n        public t get(int index) { return array[index]; }\n\n        public t[] array() { return array; }\n    }\n\n\n\n    public static void main(string[] args) {\n        genericarray<integer> genericarray = new genericarray<integer>(4);\n        genericarray.put(0, 0);\n        genericarray.put(1, 1);\n        object[] array = genericarray.array();\n        system.out.println(arrays.deeptostring(array));\n    }\n}\n// output:\n// [0, 1, null, null]\n\n\n> 扩展阅读：https://www.cnblogs.com/jiangzhaowei/p/7399522.html\n> \n> 我认为，对于泛型数组的理解，点到为止即可。实际上，真的需要存储泛型，还是使用容器更合适。\n\n\n# 多维数组\n\n多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。\n\njava 可以支持二维数组、三维数组、四维数组、五维数组。。。\n\n但是，以正常人的理解能力，一般也就最多能理解三维数组。所以，请不要做反人类的事，去定义过多维度的数组。\n\n多维数组使用示例：\n\npublic class multiarraydemo {\n    public static void main(string[] args) {\n        integer[][] a1 = { // 自动装箱\n            {1, 2, 3,},\n            {4, 5, 6,},\n        };\n        double[][][] a2 = { // 自动装箱\n            { {1.1, 2.2}, {3.3, 4.4} },\n            { {5.5, 6.6}, {7.7, 8.8} },\n            { {9.9, 1.2}, {2.3, 3.4} },\n        };\n        string[][] a3 = {\n            {"the", "quick", "sly", "fox"},\n            {"jumped", "over"},\n            {"the", "lazy", "brown", "dog", "and", "friend"},\n        };\n        system.out.println("a1: " + arrays.deeptostring(a1));\n        system.out.println("a2: " + arrays.deeptostring(a2));\n        system.out.println("a3: " + arrays.deeptostring(a3));\n    }\n}\n// output:\n// a1: [[1, 2, 3], [4, 5, 6]]\n// a2: [[[1.1, 2.2], [3.3, 4.4]], [[5.5, 6.6], [7.7, 8.8]], [[9.9, 1.2], [2.3, 3.4]]]\n// a3: [[the, quick, sly, fox], [jumped, over], [the, lazy, brown, dog, and, friend]]\n\n\n\n# arrays 类\n\njava 中，提供了一个很有用的数组工具类：arrays。\n\n它提供的主要操作有：\n\n * sort - 排序\n * binarysearch - 查找\n * equals - 比较\n * fill - 填充\n * aslist - 转列表\n * hash - 哈希\n * tostring - 转字符串\n\n> 扩展阅读：https://juejin.im/post/5a6ade5c518825733e60acb8\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * java 中数组的特性\n * https://juejin.im/post/59cae3de6fb9a00a4551915b\n * https://www.cnblogs.com/jiangzhaowei/p/7399522.html\n * https://juejin.im/post/5a6ade5c518825733e60acb8',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"深入理解 Java 枚举",frontmatter:{title:"深入理解 Java 枚举",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE","枚举"],abbrlink:"43c0b54b",date:"2019-05-06T15:02:02.000Z",permalink:"/pages/ae8c35/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/06.Java%E6%9E%9A%E4%B8%BE.html",relativePath:"01.基础特性/06.Java枚举.md",key:"v-7c6b52a2",path:"/pages/ae8c35/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:19},{level:2,title:"枚举的本质",slug:"枚举的本质",normalizedTitle:"枚举的本质",charIndex:185},{level:2,title:"枚举的方法",slug:"枚举的方法",normalizedTitle:"枚举的方法",charIndex:1295},{level:2,title:"枚举的特性",slug:"枚举的特性",normalizedTitle:"枚举的特性",charIndex:3237},{level:3,title:"基本特性",slug:"基本特性",normalizedTitle:"基本特性",charIndex:3320},{level:3,title:"枚举可以添加方法",slug:"枚举可以添加方法",normalizedTitle:"枚举可以添加方法",charIndex:3446},{level:3,title:"枚举可以实现接口",slug:"枚举可以实现接口",normalizedTitle:"枚举可以实现接口",charIndex:5006},{level:3,title:"枚举不可以继承",slug:"枚举不可以继承",normalizedTitle:"枚举不可以继承",charIndex:5613},{level:2,title:"枚举的应用",slug:"枚举的应用",normalizedTitle:"枚举的应用",charIndex:5744},{level:3,title:"组织常量",slug:"组织常量",normalizedTitle:"组织常量",charIndex:5754},{level:3,title:"switch 状态机",slug:"switch-状态机",normalizedTitle:"switch 状态机",charIndex:5986},{level:3,title:"错误码",slug:"错误码",normalizedTitle:"错误码",charIndex:171},{level:3,title:"组织枚举",slug:"组织枚举",normalizedTitle:"组织枚举",charIndex:8136},{level:3,title:"策略枚举",slug:"策略枚举",normalizedTitle:"策略枚举",charIndex:10264},{level:3,title:"枚举实现单例模式",slug:"枚举实现单例模式",normalizedTitle:"枚举实现单例模式",charIndex:11727},{level:2,title:"枚举工具类",slug:"枚举工具类",normalizedTitle:"枚举工具类",charIndex:12386},{level:3,title:"EnumSet",slug:"enumset",normalizedTitle:"enumset",charIndex:12420},{level:3,title:"EnumMap",slug:"enummap",normalizedTitle:"enummap",charIndex:12430},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:14158},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:14167}],headersStr:"简介 枚举的本质 枚举的方法 枚举的特性 基本特性 枚举可以添加方法 枚举可以实现接口 枚举不可以继承 枚举的应用 组织常量 switch 状态机 错误码 组织枚举 策略枚举 枚举实现单例模式 枚举工具类 EnumSet EnumMap 小结 参考资料",content:'# 深入理解 Java 枚举\n\n\n# 简介\n\nenum 的全称为 enumeration， 是 JDK5 中引入的特性。\n\n在 Java 中，被 enum 关键字修饰的类型就是枚举类型。形式如下：\n\nenum ColorEn { RED, GREEN, BLUE }\n\n\n枚举的好处：可以将常量组织起来，统一进行管理。\n\n枚举的典型应用场景：错误码、状态机等。\n\n\n# 枚举的本质\n\njava.lang.Enum类声明\n\npublic abstract class Enum<E extends Enum<E>>\n        implements Comparable<E>, Serializable { ... }\n\n\n新建一个 ColorEn.java 文件，内容如下：\n\npackage io.github.dunwu.javacore.enumeration;\n\npublic enum ColorEn {\n    RED,YELLOW,BLUE\n}\n\n\n执行 javac ColorEn.java 命令，生成 ColorEn.class 文件。\n\n然后执行 javap ColorEn.class 命令，输出如下内容：\n\nCompiled from "ColorEn.java"\npublic final class io.github.dunwu.javacore.enumeration.ColorEn extends java.lang.Enum<io.github.dunwu.javacore.enumeration.ColorEn> {\n  public static final io.github.dunwu.javacore.enumeration.ColorEn RED;\n  public static final io.github.dunwu.javacore.enumeration.ColorEn YELLOW;\n  public static final io.github.dunwu.javacore.enumeration.ColorEn BLUE;\n  public static io.github.dunwu.javacore.enumeration.ColorEn[] values();\n  public static io.github.dunwu.javacore.enumeration.ColorEn valueOf(java.lang.String);\n  static {};\n}\n\n\n> 💡 说明：\n> \n> 从上面的例子可以看出：\n> \n> 枚举的本质是 java.lang.Enum 的子类。\n> \n> 尽管 enum 看起来像是一种新的数据类型，事实上，enum 是一种受限制的类，并且具有自己的方法。枚举这种特殊的类因为被修饰为 final，所以不能继承其他类。\n> \n> 定义的枚举值，会被默认修饰为 public static final ，从修饰关键字，即可看出枚举值本质上是静态常量。\n\n\n# 枚举的方法\n\n在 enum 中，提供了一些基本方法：\n\n * values()：返回 enum 实例的数组，而且该数组中的元素严格保持在 enum 中声明时的顺序。\n * name()：返回实例名。\n * ordinal()：返回实例声明时的次序，从 0 开始。\n * getDeclaringClass()：返回实例所属的 enum 类型。\n * equals() ：判断是否为同一个对象。\n\n可以使用 == 来比较enum实例。\n\n此外，java.lang.Enum实现了Comparable和 Serializable 接口，所以也提供 compareTo() 方法。\n\n例：展示 enum 的基本方法\n\npublic class EnumMethodDemo {\n    enum Color {RED, GREEN, BLUE;}\n    enum Size {BIG, MIDDLE, SMALL;}\n    public static void main(String args[]) {\n        System.out.println("=========== Print all Color ===========");\n        for (Color c : Color.values()) {\n            System.out.println(c + " ordinal: " + c.ordinal());\n        }\n        System.out.println("=========== Print all Size ===========");\n        for (Size s : Size.values()) {\n            System.out.println(s + " ordinal: " + s.ordinal());\n        }\n\n        Color green = Color.GREEN;\n        System.out.println("green name(): " + green.name());\n        System.out.println("green getDeclaringClass(): " + green.getDeclaringClass());\n        System.out.println("green hashCode(): " + green.hashCode());\n        System.out.println("green compareTo Color.GREEN: " + green.compareTo(Color.GREEN));\n        System.out.println("green equals Color.GREEN: " + green.equals(Color.GREEN));\n        System.out.println("green equals Size.MIDDLE: " + green.equals(Size.MIDDLE));\n        System.out.println("green equals 1: " + green.equals(1));\n        System.out.format("green == Color.BLUE: %b\\n", green == Color.BLUE);\n    }\n}\n\n\n输出\n\n=========== Print all Color ===========\nRED ordinal: 0\nGREEN ordinal: 1\nBLUE ordinal: 2\n=========== Print all Size ===========\nBIG ordinal: 0\nMIDDLE ordinal: 1\nSMALL ordinal: 2\ngreen name(): GREEN\ngreen getDeclaringClass(): class org.zp.javase.enumeration.EnumDemo$Color\ngreen hashCode(): 460141958\ngreen compareTo Color.GREEN: 0\ngreen equals Color.GREEN: true\ngreen equals Size.MIDDLE: false\ngreen equals 1: false\ngreen == Color.BLUE: false\n\n\n\n# 枚举的特性\n\n枚举的特性，归结起来就是一句话：\n\n> 除了不能继承，基本上可以将 enum 看做一个常规的类。\n\n但是这句话需要拆分去理解，让我们细细道来。\n\n\n# 基本特性\n\n如果枚举中没有定义方法，也可以在最后一个实例后面加逗号、分号或什么都不加。\n\n如果枚举中没有定义方法，枚举值默认为从 0 开始的有序数值。以 Color 枚举类型举例，它的枚举常量依次为 RED：0，GREEN：1，BLUE：2。\n\n\n# 枚举可以添加方法\n\n在概念章节提到了，枚举值默认为从 0 开始的有序数值 。那么问题来了：如何为枚举显式的赋值。\n\n（1）Java 不允许使用 = 为枚举常量赋值\n\n如果你接触过 C/C++，你肯定会很自然的想到赋值符号 = 。在 C/C++语言中的 enum，可以用赋值符号=显式的为枚举常量赋值；但是 ，很遗憾，Java 语法中却不允许使用赋值符号 = 为枚举常量赋值。\n\n例：C/C++ 语言中的枚举声明\n\ntypedef enum {\n    ONE = 1,\n    TWO,\n    THREE = 3,\n    TEN = 10\n} Number;\n\n\n（2）枚举可以添加普通方法、静态方法、抽象方法、构造方法\n\nJava 虽然不能直接为实例赋值，但是它有更优秀的解决方案：为 enum 添加方法来间接实现显式赋值。\n\n创建 enum 时，可以为其添加多种方法，甚至可以为其添加构造方法。\n\n注意一个细节：如果要为 enum 定义方法，那么必须在 enum 的最后一个实例尾部添加一个分号。此外，在 enum 中，必须先定义实例，不能将字段或方法定义在实例前面。否则，编译器会报错。\n\n例：全面展示如何在枚举中定义普通方法、静态方法、抽象方法、构造方法\n\npublic enum ErrorCodeEn {\n    OK(0) {\n        @Override\n        public String getDescription() {\n            return "成功";\n        }\n    },\n    ERROR_A(100) {\n        @Override\n        public String getDescription() {\n            return "错误A";\n        }\n    },\n    ERROR_B(200) {\n        @Override\n        public String getDescription() {\n            return "错误B";\n        }\n    };\n\n    private int code;\n\n    // 构造方法：enum的构造方法只能被声明为private权限或不声明权限\n    private ErrorCodeEn(int number) { // 构造方法\n        this.code = number;\n    }\n\n    public int getCode() { // 普通方法\n        return code;\n    } // 普通方法\n\n    public abstract String getDescription(); // 抽象方法\n\n    public static void main(String args[]) { // 静态方法\n        for (ErrorCodeEn s : ErrorCodeEn.values()) {\n            System.out.println("code: " + s.getCode() + ", description: " + s.getDescription());\n        }\n    }\n}\n// Output:\n// code: 0, description: 成功\n// code: 100, description: 错误A\n// code: 200, description: 错误B\n\n\n注：上面的例子并不可取，仅仅是为了展示枚举支持定义各种方法。正确的例子情况错误码示例\n\n\n# 枚举可以实现接口\n\nenum 可以像一般类一样实现接口。\n\n同样是实现上一节中的错误码枚举类，通过实现接口，可以约束它的方法。\n\npublic interface INumberEnum {\n    int getCode();\n    String getDescription();\n}\n\npublic enum ErrorCodeEn2 implements INumberEnum {\n    OK(0, "成功"),\n    ERROR_A(100, "错误A"),\n    ERROR_B(200, "错误B");\n\n    ErrorCodeEn2(int number, String description) {\n        this.code = number;\n        this.description = description;\n    }\n\n    private int code;\n    private String description;\n\n    @Override\n    public int getCode() {\n        return code;\n    }\n\n    @Override\n    public String getDescription() {\n        return description;\n    }\n}\n\n\n\n# 枚举不可以继承\n\nenum 不可以继承另外一个类，当然，也不能继承另一个 enum 。\n\n因为 enum 实际上都继承自 java.lang.Enum 类，而 Java 不支持多重继承，所以 enum 不能再继承其他类，当然也不能继承另一个 enum。\n\n\n# 枚举的应用\n\n\n# 组织常量\n\n在 JDK5 之前，在 Java 中定义常量都是public static final TYPE a; 这样的形式。有了枚举，你可以将有关联关系的常量组织起来，使代码更加易读、安全，并且还可以使用枚举提供的方法。\n\n下面三种声明方式是等价的：\n\nenum Color { RED, GREEN, BLUE }\nenum Color { RED, GREEN, BLUE, }\nenum Color { RED, GREEN, BLUE; }\n\n\n\n# switch 状态机\n\n我们经常使用 switch 语句来写状态机。JDK7 以后，switch 已经支持 int、char、String、enum 类型的参数。这几种类型的参数比较起来，使用枚举的 switch 代码更具有可读性。\n\npublic class StateMachineDemo {\n    public enum Signal {\n        GREEN, YELLOW, RED\n    }\n\n    public static String getTrafficInstruct(Signal signal) {\n        String instruct = "信号灯故障";\n        switch (signal) {\n            case RED:\n                instruct = "红灯停";\n                break;\n            case YELLOW:\n                instruct = "黄灯请注意";\n                break;\n            case GREEN:\n                instruct = "绿灯行";\n                break;\n            default:\n                break;\n        }\n        return instruct;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(getTrafficInstruct(Signal.RED));\n    }\n}\n// Output:\n// 红灯停\n\n\n\n# 错误码\n\n枚举常被用于定义程序错误码。下面是一个简单示例：\n\npublic class ErrorCodeEnumDemo {\n    enum ErrorCodeEn {\n        OK(0, "成功"),\n        ERROR_A(100, "错误A"),\n        ERROR_B(200, "错误B");\n\n        ErrorCodeEn(int number, String msg) {\n            this.code = number;\n            this.msg = msg;\n        }\n\n        private int code;\n        private String msg;\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getMsg() {\n            return msg;\n        }\n\n        @Override\n        public String toString() {\n            return "ErrorCodeEn{" + "code=" + code + ", msg=\'" + msg + \'\\\'\' + \'}\';\n        }\n\n        public static String toStringAll() {\n            StringBuilder sb = new StringBuilder();\n            sb.append("ErrorCodeEn All Elements: [");\n            for (ErrorCodeEn code : ErrorCodeEn.values()) {\n                sb.append(code.getCode()).append(", ");\n            }\n            sb.append("]");\n            return sb.toString();\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(ErrorCodeEn.toStringAll());\n        for (ErrorCodeEn s : ErrorCodeEn.values()) {\n            System.out.println(s);\n        }\n    }\n}\n// Output:\n// ErrorCodeEn All Elements: [0, 100, 200, ]\n// ErrorCodeEn{code=0, msg=\'成功\'}\n// ErrorCodeEn{code=100, msg=\'错误A\'}\n// ErrorCodeEn{code=200, msg=\'错误B\'}\n\n\n\n# 组织枚举\n\n可以将类型相近的枚举通过接口或类组织起来，但是一般用接口方式进行组织。\n\n原因是：Java 接口在编译时会自动为 enum 类型加上public static修饰符；Java 类在编译时会自动为 enum 类型加上 static 修饰符。看出差异了吗？没错，就是说，在类中组织 enum，如果你不给它修饰为 public，那么只能在本包中进行访问。\n\n例：在接口中组织 enum\n\npublic class EnumInInterfaceDemo {\n    public interface INumberEnum {\n        int getCode();\n        String getDescription();\n    }\n\n\n    public interface Plant {\n        enum Vegetable implements INumberEnum {\n            POTATO(0, "土豆"),\n            TOMATO(0, "西红柿");\n\n            Vegetable(int number, String description) {\n                this.code = number;\n                this.description = description;\n            }\n\n            private int code;\n            private String description;\n\n            @Override\n            public int getCode() {\n                return this.code;\n            }\n\n            @Override\n            public String getDescription() {\n                return this.description;\n            }\n        }\n\n\n        enum Fruit implements INumberEnum {\n            APPLE(0, "苹果"),\n            ORANGE(0, "桔子"),\n            BANANA(0, "香蕉");\n\n            Fruit(int number, String description) {\n                this.code = number;\n                this.description = description;\n            }\n\n            private int code;\n            private String description;\n\n            @Override\n            public int getCode() {\n                return this.code;\n            }\n\n            @Override\n            public String getDescription() {\n                return this.description;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        for (Plant.Fruit f : Plant.Fruit.values()) {\n            System.out.println(f.getDescription());\n        }\n    }\n}\n// Output:\n// 苹果\n// 桔子\n// 香蕉\n\n\n例：在类中组织 enum\n\n本例和上例效果相同。\n\npublic class EnumInClassDemo {\n    public interface INumberEnum {\n        int getCode();\n        String getDescription();\n    }\n\n    public static class Plant2 {\n        enum Vegetable implements INumberEnum {\n            // 略，与上面完全相同\n        }\n        enum Fruit implements INumberEnum {\n            // 略，与上面完全相同\n        }\n    }\n\n    // 略\n}\n// Output:\n// 土豆\n// 西红柿\n\n\n\n# 策略枚举\n\nEffective Java 中展示了一种策略枚举。这种枚举通过枚举嵌套枚举的方式，将枚举常量分类处理。\n\n这种做法虽然没有 switch 语句简洁，但是更加安全、灵活。\n\n例：EffectvieJava 中的策略枚举范例\n\nenum PayrollDay {\n    MONDAY(PayType.WEEKDAY), TUESDAY(PayType.WEEKDAY), WEDNESDAY(\n            PayType.WEEKDAY), THURSDAY(PayType.WEEKDAY), FRIDAY(PayType.WEEKDAY), SATURDAY(\n            PayType.WEEKEND), SUNDAY(PayType.WEEKEND);\n\n    private final PayType payType;\n\n    PayrollDay(PayType payType) {\n        this.payType = payType;\n    }\n\n    double pay(double hoursWorked, double payRate) {\n        return payType.pay(hoursWorked, payRate);\n    }\n\n    // 策略枚举\n    private enum PayType {\n        WEEKDAY {\n            double overtimePay(double hours, double payRate) {\n                return hours <= HOURS_PER_SHIFT ? 0 : (hours - HOURS_PER_SHIFT)\n                        * payRate / 2;\n            }\n        },\n        WEEKEND {\n            double overtimePay(double hours, double payRate) {\n                return hours * payRate / 2;\n            }\n        };\n        private static final int HOURS_PER_SHIFT = 8;\n\n        abstract double overtimePay(double hrs, double payRate);\n\n        double pay(double hoursWorked, double payRate) {\n            double basePay = hoursWorked * payRate;\n            return basePay + overtimePay(hoursWorked, payRate);\n        }\n    }\n}\n\n\n测试\n\nSystem.out.println("时薪100的人在周五工作8小时的收入：" + PayrollDay.FRIDAY.pay(8.0, 100));\nSystem.out.println("时薪100的人在周六工作8小时的收入：" + PayrollDay.SATURDAY.pay(8.0, 100));\n\n\n\n# 枚举实现单例模式\n\n单例模式是最常用的设计模式。\n\n单例模式在并发环境下存在线程安全问题。\n\n为了线程安全问题，传统做法有以下几种：\n\n * 饿汉式加载\n * 懒汉式 synchronize 和双重检查\n * 利用 java 的静态加载机制\n\n相比上述的方法，使用枚举也可以实现单例，而且还更加简单：\n\npublic class SingleEnumDemo {\n    public enum SingleEn {\n\n        INSTANCE;\n\n        private String name;\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n\n    public static void main(String[] args) {\n        SingleEn.INSTANCE.setName("zp");\n        System.out.println(SingleEn.INSTANCE.getName());\n    }\n}\n\n\n> 扩展阅读：深入理解 Java 枚举类型(enum)\n> \n> 这篇文章对于 Java 枚举的特性讲解很仔细，其中对于枚举实现单例和传统单例实现方式说的尤为细致。\n\n\n# 枚举工具类\n\nJava 中提供了两个方便操作 enum 的工具类——EnumSet 和 EnumMap。\n\n\n# EnumSet\n\nEnumSet 是枚举类型的高性能 Set 实现。它要求放入它的枚举常量必须属于同一枚举类型。\n\n主要接口：\n\n * noneOf - 创建一个具有指定元素类型的空 EnumSet\n * allOf - 创建一个指定元素类型并包含所有枚举值的 EnumSet\n * range - 创建一个包括枚举值中指定范围元素的 EnumSet\n * complementOf - 初始集合包括指定集合的补集\n * of - 创建一个包括参数中所有元素的 EnumSet\n * copyOf - 创建一个包含参数容器中的所有元素的 EnumSet\n\n示例：\n\npublic class EnumSetDemo {\n    public static void main(String[] args) {\n        System.out.println("EnumSet展示");\n        EnumSet<ErrorCodeEn> errSet = EnumSet.allOf(ErrorCodeEn.class);\n        for (ErrorCodeEn e : errSet) {\n            System.out.println(e.name() + " : " + e.ordinal());\n        }\n    }\n}\n\n\n\n# EnumMap\n\nEnumMap 是专门为枚举类型量身定做的 Map 实现。虽然使用其它的 Map 实现（如 HashMap）也能完成枚举类型实例到值得映射，但是使用 EnumMap 会更加高效：它只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用数组来存放与枚举类型对应的值。这使得 EnumMap 的效率非常高。\n\n主要接口：\n\n * size - 返回键值对数\n * containsValue - 是否存在指定的 value\n * containsKey - 是否存在指定的 key\n * get - 根据指定 key 获取 value\n * put - 取出指定的键值对\n * remove - 删除指定 key\n * putAll - 批量取出键值对\n * clear - 清除数据\n * keySet - 获取 key 集合\n * values - 返回所有\n\n示例：\n\npublic class EnumMapDemo {\n    public enum Signal {\n        GREEN, YELLOW, RED\n    }\n\n    public static void main(String[] args) {\n        System.out.println("EnumMap展示");\n        EnumMap<Signal, String> errMap = new EnumMap(Signal.class);\n        errMap.put(Signal.RED, "红灯");\n        errMap.put(Signal.YELLOW, "黄灯");\n        errMap.put(Signal.GREEN, "绿灯");\n        for (Iterator<Map.Entry<Signal, String>> iter = errMap.entrySet().iterator(); iter.hasNext();) {\n            Map.Entry<Signal, String> entry = iter.next();\n            System.out.println(entry.getKey().name() + " : " + entry.getValue());\n        }\n    }\n}\n\n\n> 扩展阅读：深入理解 Java 枚举类型(enum)\n> \n> 这篇文章中对 EnumSet 和 EnumMap 原理做了较为详细的介绍。\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * Effective java\n * 深入理解 Java 枚举类型(enum)\n * https://droidyue.com/blog/2016/11/29/dive-into-enum/',normalizedContent:'# 深入理解 java 枚举\n\n\n# 简介\n\nenum 的全称为 enumeration， 是 jdk5 中引入的特性。\n\n在 java 中，被 enum 关键字修饰的类型就是枚举类型。形式如下：\n\nenum coloren { red, green, blue }\n\n\n枚举的好处：可以将常量组织起来，统一进行管理。\n\n枚举的典型应用场景：错误码、状态机等。\n\n\n# 枚举的本质\n\njava.lang.enum类声明\n\npublic abstract class enum<e extends enum<e>>\n        implements comparable<e>, serializable { ... }\n\n\n新建一个 coloren.java 文件，内容如下：\n\npackage io.github.dunwu.javacore.enumeration;\n\npublic enum coloren {\n    red,yellow,blue\n}\n\n\n执行 javac coloren.java 命令，生成 coloren.class 文件。\n\n然后执行 javap coloren.class 命令，输出如下内容：\n\ncompiled from "coloren.java"\npublic final class io.github.dunwu.javacore.enumeration.coloren extends java.lang.enum<io.github.dunwu.javacore.enumeration.coloren> {\n  public static final io.github.dunwu.javacore.enumeration.coloren red;\n  public static final io.github.dunwu.javacore.enumeration.coloren yellow;\n  public static final io.github.dunwu.javacore.enumeration.coloren blue;\n  public static io.github.dunwu.javacore.enumeration.coloren[] values();\n  public static io.github.dunwu.javacore.enumeration.coloren valueof(java.lang.string);\n  static {};\n}\n\n\n> 💡 说明：\n> \n> 从上面的例子可以看出：\n> \n> 枚举的本质是 java.lang.enum 的子类。\n> \n> 尽管 enum 看起来像是一种新的数据类型，事实上，enum 是一种受限制的类，并且具有自己的方法。枚举这种特殊的类因为被修饰为 final，所以不能继承其他类。\n> \n> 定义的枚举值，会被默认修饰为 public static final ，从修饰关键字，即可看出枚举值本质上是静态常量。\n\n\n# 枚举的方法\n\n在 enum 中，提供了一些基本方法：\n\n * values()：返回 enum 实例的数组，而且该数组中的元素严格保持在 enum 中声明时的顺序。\n * name()：返回实例名。\n * ordinal()：返回实例声明时的次序，从 0 开始。\n * getdeclaringclass()：返回实例所属的 enum 类型。\n * equals() ：判断是否为同一个对象。\n\n可以使用 == 来比较enum实例。\n\n此外，java.lang.enum实现了comparable和 serializable 接口，所以也提供 compareto() 方法。\n\n例：展示 enum 的基本方法\n\npublic class enummethoddemo {\n    enum color {red, green, blue;}\n    enum size {big, middle, small;}\n    public static void main(string args[]) {\n        system.out.println("=========== print all color ===========");\n        for (color c : color.values()) {\n            system.out.println(c + " ordinal: " + c.ordinal());\n        }\n        system.out.println("=========== print all size ===========");\n        for (size s : size.values()) {\n            system.out.println(s + " ordinal: " + s.ordinal());\n        }\n\n        color green = color.green;\n        system.out.println("green name(): " + green.name());\n        system.out.println("green getdeclaringclass(): " + green.getdeclaringclass());\n        system.out.println("green hashcode(): " + green.hashcode());\n        system.out.println("green compareto color.green: " + green.compareto(color.green));\n        system.out.println("green equals color.green: " + green.equals(color.green));\n        system.out.println("green equals size.middle: " + green.equals(size.middle));\n        system.out.println("green equals 1: " + green.equals(1));\n        system.out.format("green == color.blue: %b\\n", green == color.blue);\n    }\n}\n\n\n输出\n\n=========== print all color ===========\nred ordinal: 0\ngreen ordinal: 1\nblue ordinal: 2\n=========== print all size ===========\nbig ordinal: 0\nmiddle ordinal: 1\nsmall ordinal: 2\ngreen name(): green\ngreen getdeclaringclass(): class org.zp.javase.enumeration.enumdemo$color\ngreen hashcode(): 460141958\ngreen compareto color.green: 0\ngreen equals color.green: true\ngreen equals size.middle: false\ngreen equals 1: false\ngreen == color.blue: false\n\n\n\n# 枚举的特性\n\n枚举的特性，归结起来就是一句话：\n\n> 除了不能继承，基本上可以将 enum 看做一个常规的类。\n\n但是这句话需要拆分去理解，让我们细细道来。\n\n\n# 基本特性\n\n如果枚举中没有定义方法，也可以在最后一个实例后面加逗号、分号或什么都不加。\n\n如果枚举中没有定义方法，枚举值默认为从 0 开始的有序数值。以 color 枚举类型举例，它的枚举常量依次为 red：0，green：1，blue：2。\n\n\n# 枚举可以添加方法\n\n在概念章节提到了，枚举值默认为从 0 开始的有序数值 。那么问题来了：如何为枚举显式的赋值。\n\n（1）java 不允许使用 = 为枚举常量赋值\n\n如果你接触过 c/c++，你肯定会很自然的想到赋值符号 = 。在 c/c++语言中的 enum，可以用赋值符号=显式的为枚举常量赋值；但是 ，很遗憾，java 语法中却不允许使用赋值符号 = 为枚举常量赋值。\n\n例：c/c++ 语言中的枚举声明\n\ntypedef enum {\n    one = 1,\n    two,\n    three = 3,\n    ten = 10\n} number;\n\n\n（2）枚举可以添加普通方法、静态方法、抽象方法、构造方法\n\njava 虽然不能直接为实例赋值，但是它有更优秀的解决方案：为 enum 添加方法来间接实现显式赋值。\n\n创建 enum 时，可以为其添加多种方法，甚至可以为其添加构造方法。\n\n注意一个细节：如果要为 enum 定义方法，那么必须在 enum 的最后一个实例尾部添加一个分号。此外，在 enum 中，必须先定义实例，不能将字段或方法定义在实例前面。否则，编译器会报错。\n\n例：全面展示如何在枚举中定义普通方法、静态方法、抽象方法、构造方法\n\npublic enum errorcodeen {\n    ok(0) {\n        @override\n        public string getdescription() {\n            return "成功";\n        }\n    },\n    error_a(100) {\n        @override\n        public string getdescription() {\n            return "错误a";\n        }\n    },\n    error_b(200) {\n        @override\n        public string getdescription() {\n            return "错误b";\n        }\n    };\n\n    private int code;\n\n    // 构造方法：enum的构造方法只能被声明为private权限或不声明权限\n    private errorcodeen(int number) { // 构造方法\n        this.code = number;\n    }\n\n    public int getcode() { // 普通方法\n        return code;\n    } // 普通方法\n\n    public abstract string getdescription(); // 抽象方法\n\n    public static void main(string args[]) { // 静态方法\n        for (errorcodeen s : errorcodeen.values()) {\n            system.out.println("code: " + s.getcode() + ", description: " + s.getdescription());\n        }\n    }\n}\n// output:\n// code: 0, description: 成功\n// code: 100, description: 错误a\n// code: 200, description: 错误b\n\n\n注：上面的例子并不可取，仅仅是为了展示枚举支持定义各种方法。正确的例子情况错误码示例\n\n\n# 枚举可以实现接口\n\nenum 可以像一般类一样实现接口。\n\n同样是实现上一节中的错误码枚举类，通过实现接口，可以约束它的方法。\n\npublic interface inumberenum {\n    int getcode();\n    string getdescription();\n}\n\npublic enum errorcodeen2 implements inumberenum {\n    ok(0, "成功"),\n    error_a(100, "错误a"),\n    error_b(200, "错误b");\n\n    errorcodeen2(int number, string description) {\n        this.code = number;\n        this.description = description;\n    }\n\n    private int code;\n    private string description;\n\n    @override\n    public int getcode() {\n        return code;\n    }\n\n    @override\n    public string getdescription() {\n        return description;\n    }\n}\n\n\n\n# 枚举不可以继承\n\nenum 不可以继承另外一个类，当然，也不能继承另一个 enum 。\n\n因为 enum 实际上都继承自 java.lang.enum 类，而 java 不支持多重继承，所以 enum 不能再继承其他类，当然也不能继承另一个 enum。\n\n\n# 枚举的应用\n\n\n# 组织常量\n\n在 jdk5 之前，在 java 中定义常量都是public static final type a; 这样的形式。有了枚举，你可以将有关联关系的常量组织起来，使代码更加易读、安全，并且还可以使用枚举提供的方法。\n\n下面三种声明方式是等价的：\n\nenum color { red, green, blue }\nenum color { red, green, blue, }\nenum color { red, green, blue; }\n\n\n\n# switch 状态机\n\n我们经常使用 switch 语句来写状态机。jdk7 以后，switch 已经支持 int、char、string、enum 类型的参数。这几种类型的参数比较起来，使用枚举的 switch 代码更具有可读性。\n\npublic class statemachinedemo {\n    public enum signal {\n        green, yellow, red\n    }\n\n    public static string gettrafficinstruct(signal signal) {\n        string instruct = "信号灯故障";\n        switch (signal) {\n            case red:\n                instruct = "红灯停";\n                break;\n            case yellow:\n                instruct = "黄灯请注意";\n                break;\n            case green:\n                instruct = "绿灯行";\n                break;\n            default:\n                break;\n        }\n        return instruct;\n    }\n\n    public static void main(string[] args) {\n        system.out.println(gettrafficinstruct(signal.red));\n    }\n}\n// output:\n// 红灯停\n\n\n\n# 错误码\n\n枚举常被用于定义程序错误码。下面是一个简单示例：\n\npublic class errorcodeenumdemo {\n    enum errorcodeen {\n        ok(0, "成功"),\n        error_a(100, "错误a"),\n        error_b(200, "错误b");\n\n        errorcodeen(int number, string msg) {\n            this.code = number;\n            this.msg = msg;\n        }\n\n        private int code;\n        private string msg;\n\n        public int getcode() {\n            return code;\n        }\n\n        public string getmsg() {\n            return msg;\n        }\n\n        @override\n        public string tostring() {\n            return "errorcodeen{" + "code=" + code + ", msg=\'" + msg + \'\\\'\' + \'}\';\n        }\n\n        public static string tostringall() {\n            stringbuilder sb = new stringbuilder();\n            sb.append("errorcodeen all elements: [");\n            for (errorcodeen code : errorcodeen.values()) {\n                sb.append(code.getcode()).append(", ");\n            }\n            sb.append("]");\n            return sb.tostring();\n        }\n    }\n\n    public static void main(string[] args) {\n        system.out.println(errorcodeen.tostringall());\n        for (errorcodeen s : errorcodeen.values()) {\n            system.out.println(s);\n        }\n    }\n}\n// output:\n// errorcodeen all elements: [0, 100, 200, ]\n// errorcodeen{code=0, msg=\'成功\'}\n// errorcodeen{code=100, msg=\'错误a\'}\n// errorcodeen{code=200, msg=\'错误b\'}\n\n\n\n# 组织枚举\n\n可以将类型相近的枚举通过接口或类组织起来，但是一般用接口方式进行组织。\n\n原因是：java 接口在编译时会自动为 enum 类型加上public static修饰符；java 类在编译时会自动为 enum 类型加上 static 修饰符。看出差异了吗？没错，就是说，在类中组织 enum，如果你不给它修饰为 public，那么只能在本包中进行访问。\n\n例：在接口中组织 enum\n\npublic class enumininterfacedemo {\n    public interface inumberenum {\n        int getcode();\n        string getdescription();\n    }\n\n\n    public interface plant {\n        enum vegetable implements inumberenum {\n            potato(0, "土豆"),\n            tomato(0, "西红柿");\n\n            vegetable(int number, string description) {\n                this.code = number;\n                this.description = description;\n            }\n\n            private int code;\n            private string description;\n\n            @override\n            public int getcode() {\n                return this.code;\n            }\n\n            @override\n            public string getdescription() {\n                return this.description;\n            }\n        }\n\n\n        enum fruit implements inumberenum {\n            apple(0, "苹果"),\n            orange(0, "桔子"),\n            banana(0, "香蕉");\n\n            fruit(int number, string description) {\n                this.code = number;\n                this.description = description;\n            }\n\n            private int code;\n            private string description;\n\n            @override\n            public int getcode() {\n                return this.code;\n            }\n\n            @override\n            public string getdescription() {\n                return this.description;\n            }\n        }\n    }\n\n    public static void main(string[] args) {\n        for (plant.fruit f : plant.fruit.values()) {\n            system.out.println(f.getdescription());\n        }\n    }\n}\n// output:\n// 苹果\n// 桔子\n// 香蕉\n\n\n例：在类中组织 enum\n\n本例和上例效果相同。\n\npublic class enuminclassdemo {\n    public interface inumberenum {\n        int getcode();\n        string getdescription();\n    }\n\n    public static class plant2 {\n        enum vegetable implements inumberenum {\n            // 略，与上面完全相同\n        }\n        enum fruit implements inumberenum {\n            // 略，与上面完全相同\n        }\n    }\n\n    // 略\n}\n// output:\n// 土豆\n// 西红柿\n\n\n\n# 策略枚举\n\neffective java 中展示了一种策略枚举。这种枚举通过枚举嵌套枚举的方式，将枚举常量分类处理。\n\n这种做法虽然没有 switch 语句简洁，但是更加安全、灵活。\n\n例：effectviejava 中的策略枚举范例\n\nenum payrollday {\n    monday(paytype.weekday), tuesday(paytype.weekday), wednesday(\n            paytype.weekday), thursday(paytype.weekday), friday(paytype.weekday), saturday(\n            paytype.weekend), sunday(paytype.weekend);\n\n    private final paytype paytype;\n\n    payrollday(paytype paytype) {\n        this.paytype = paytype;\n    }\n\n    double pay(double hoursworked, double payrate) {\n        return paytype.pay(hoursworked, payrate);\n    }\n\n    // 策略枚举\n    private enum paytype {\n        weekday {\n            double overtimepay(double hours, double payrate) {\n                return hours <= hours_per_shift ? 0 : (hours - hours_per_shift)\n                        * payrate / 2;\n            }\n        },\n        weekend {\n            double overtimepay(double hours, double payrate) {\n                return hours * payrate / 2;\n            }\n        };\n        private static final int hours_per_shift = 8;\n\n        abstract double overtimepay(double hrs, double payrate);\n\n        double pay(double hoursworked, double payrate) {\n            double basepay = hoursworked * payrate;\n            return basepay + overtimepay(hoursworked, payrate);\n        }\n    }\n}\n\n\n测试\n\nsystem.out.println("时薪100的人在周五工作8小时的收入：" + payrollday.friday.pay(8.0, 100));\nsystem.out.println("时薪100的人在周六工作8小时的收入：" + payrollday.saturday.pay(8.0, 100));\n\n\n\n# 枚举实现单例模式\n\n单例模式是最常用的设计模式。\n\n单例模式在并发环境下存在线程安全问题。\n\n为了线程安全问题，传统做法有以下几种：\n\n * 饿汉式加载\n * 懒汉式 synchronize 和双重检查\n * 利用 java 的静态加载机制\n\n相比上述的方法，使用枚举也可以实现单例，而且还更加简单：\n\npublic class singleenumdemo {\n    public enum singleen {\n\n        instance;\n\n        private string name;\n\n        public string getname() {\n            return name;\n        }\n\n        public void setname(string name) {\n            this.name = name;\n        }\n    }\n\n    public static void main(string[] args) {\n        singleen.instance.setname("zp");\n        system.out.println(singleen.instance.getname());\n    }\n}\n\n\n> 扩展阅读：深入理解 java 枚举类型(enum)\n> \n> 这篇文章对于 java 枚举的特性讲解很仔细，其中对于枚举实现单例和传统单例实现方式说的尤为细致。\n\n\n# 枚举工具类\n\njava 中提供了两个方便操作 enum 的工具类——enumset 和 enummap。\n\n\n# enumset\n\nenumset 是枚举类型的高性能 set 实现。它要求放入它的枚举常量必须属于同一枚举类型。\n\n主要接口：\n\n * noneof - 创建一个具有指定元素类型的空 enumset\n * allof - 创建一个指定元素类型并包含所有枚举值的 enumset\n * range - 创建一个包括枚举值中指定范围元素的 enumset\n * complementof - 初始集合包括指定集合的补集\n * of - 创建一个包括参数中所有元素的 enumset\n * copyof - 创建一个包含参数容器中的所有元素的 enumset\n\n示例：\n\npublic class enumsetdemo {\n    public static void main(string[] args) {\n        system.out.println("enumset展示");\n        enumset<errorcodeen> errset = enumset.allof(errorcodeen.class);\n        for (errorcodeen e : errset) {\n            system.out.println(e.name() + " : " + e.ordinal());\n        }\n    }\n}\n\n\n\n# enummap\n\nenummap 是专门为枚举类型量身定做的 map 实现。虽然使用其它的 map 实现（如 hashmap）也能完成枚举类型实例到值得映射，但是使用 enummap 会更加高效：它只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 enummap 使用数组来存放与枚举类型对应的值。这使得 enummap 的效率非常高。\n\n主要接口：\n\n * size - 返回键值对数\n * containsvalue - 是否存在指定的 value\n * containskey - 是否存在指定的 key\n * get - 根据指定 key 获取 value\n * put - 取出指定的键值对\n * remove - 删除指定 key\n * putall - 批量取出键值对\n * clear - 清除数据\n * keyset - 获取 key 集合\n * values - 返回所有\n\n示例：\n\npublic class enummapdemo {\n    public enum signal {\n        green, yellow, red\n    }\n\n    public static void main(string[] args) {\n        system.out.println("enummap展示");\n        enummap<signal, string> errmap = new enummap(signal.class);\n        errmap.put(signal.red, "红灯");\n        errmap.put(signal.yellow, "黄灯");\n        errmap.put(signal.green, "绿灯");\n        for (iterator<map.entry<signal, string>> iter = errmap.entryset().iterator(); iter.hasnext();) {\n            map.entry<signal, string> entry = iter.next();\n            system.out.println(entry.getkey().name() + " : " + entry.getvalue());\n        }\n    }\n}\n\n\n> 扩展阅读：深入理解 java 枚举类型(enum)\n> \n> 这篇文章中对 enumset 和 enummap 原理做了较为详细的介绍。\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * effective java\n * 深入理解 java 枚举类型(enum)\n * https://droidyue.com/blog/2016/11/29/dive-into-enum/',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 控制语句",frontmatter:{title:"Java 控制语句",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE","控制语句"],abbrlink:"cf286442",date:"2020-10-17T19:13:25.000Z",permalink:"/pages/8e828a/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/07.Java%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html",relativePath:"01.基础特性/07.Java控制语句.md",key:"v-7139151c",path:"/pages/8e828a/",headers:[{level:2,title:"选择语句",slug:"选择语句",normalizedTitle:"选择语句",charIndex:42},{level:3,title:"if 语句",slug:"if-语句",normalizedTitle:"if 语句",charIndex:219},{level:3,title:"if...else 语句",slug:"if-else-语句",normalizedTitle:"if...else 语句",charIndex:523},{level:3,title:"if...else if...else 语句",slug:"if-else-if-else-语句",normalizedTitle:"if...else if...else 语句",charIndex:933},{level:3,title:"嵌套的 if…else 语句",slug:"嵌套的-if-else-语句",normalizedTitle:"嵌套的 if…else 语句",charIndex:1744},{level:3,title:"switch 语句",slug:"switch-语句",normalizedTitle:"switch 语句",charIndex:2227},{level:2,title:"循环语句",slug:"循环语句",normalizedTitle:"循环语句",charIndex:91},{level:3,title:"while 循环",slug:"while-循环",normalizedTitle:"while 循环",charIndex:3635},{level:3,title:"do while 循环",slug:"do-while-循环",normalizedTitle:"do while 循环",charIndex:4161},{level:3,title:"for 循环",slug:"for-循环",normalizedTitle:"for 循环",charIndex:4832},{level:3,title:"foreach 循环",slug:"foreach-循环",normalizedTitle:"foreach 循环",charIndex:5564},{level:2,title:"中断语句",slug:"中断语句",normalizedTitle:"中断语句",charIndex:158},{level:3,title:"break 关键字",slug:"break-关键字",normalizedTitle:"break 关键字",charIndex:6263},{level:3,title:"continue 关键字",slug:"continue-关键字",normalizedTitle:"continue 关键字",charIndex:6737},{level:3,title:"return 关键字",slug:"return-关键字",normalizedTitle:"return 关键字",charIndex:7223},{level:2,title:"最佳实践",slug:"最佳实践",normalizedTitle:"最佳实践",charIndex:7675},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7876}],headersStr:"选择语句 if 语句 if...else 语句 if...else if...else 语句 嵌套的 if…else 语句 switch 语句 循环语句 while 循环 do while 循环 for 循环 foreach 循环 中断语句 break 关键字 continue 关键字 return 关键字 最佳实践 参考资料",content:'# Java 控制语句\n\n> Java 控制语句大致可分为三大类：\n> \n>  * 选择语句\n>    * if, else-if, else\n>    * switch\n>  * 循环语句\n>    * while\n>    * do...while\n>    * for\n>    * foreach\n>  * 中断语句\n>    * break\n>    * continue\n>    * return\n\n\n# 选择语句\n\n\n# if 语句\n\nif 语句会判断括号中的条件是否成立，如果成立则执行 if 语句中的代码块，否则跳过代码块继续执行。\n\n语法\n\nif(布尔表达式) {\n   //如果布尔表达式为true将执行的语句\n}\n\n\n示例\n\npublic class IfDemo {\n    public static void main(String args[]) {\n        int x = 10;\n        if (x < 20) {\n            System.out.print("这是 if 语句");\n        }\n    }\n}\n// output:\n// 这是 if 语句\n\n\n\n# if...else 语句\n\nif 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。\n\n语法\n\nif(布尔表达式) {\n   //如果布尔表达式的值为true\n} else {\n   //如果布尔表达式的值为false\n}\n\n\n示例\n\npublic class IfElseDemo {\n    public static void main(String args[]) {\n        int x = 30;\n        if (x < 20) {\n            System.out.print("这是 if 语句");\n        } else {\n            System.out.print("这是 else 语句");\n        }\n    }\n}\n// output:\n// 这是 else 语句\n\n\n\n# if...else if...else 语句\n\n * if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。\n * If 语句可以有若干个 else if 语句，它们必须在 else 语句之前。\n * 一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。\n\n语法\n\nif (布尔表达式 1) {\n   //如果布尔表达式 1的值为true执行代码\n} else if (布尔表达式 2) {\n   //如果布尔表达式 2的值为true执行代码\n} else if (布尔表达式 3) {\n   //如果布尔表达式 3的值为true执行代码\n} else {\n   //如果以上布尔表达式都不为true执行代码\n}\n\n\n示例\n\npublic class IfElseifElseDemo {\n    public static void main(String args[]) {\n        int x = 3;\n\n        if (x == 1) {\n            System.out.print("Value of X is 1");\n        } else if (x == 2) {\n            System.out.print("Value of X is 2");\n        } else if (x == 3) {\n            System.out.print("Value of X is 3");\n        } else {\n            System.out.print("This is else statement");\n        }\n    }\n}\n// output:\n// Value of X is 3\n\n\n\n# 嵌套的 if…else 语句\n\n使用嵌套的 if else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。\n\n语法\n\nif (布尔表达式 1) {\n   ////如果布尔表达式 1的值为true执行代码\n   if (布尔表达式 2) {\n      ////如果布尔表达式 2的值为true执行代码\n   }\n}\n\n\n示例\n\npublic class IfNestDemo {\n    public static void main(String args[]) {\n        int x = 30;\n        int y = 10;\n\n        if (x == 30) {\n            if (y == 10) {\n                System.out.print("X = 30 and Y = 10");\n            }\n        }\n    }\n}\n// output:\n// X = 30 and Y = 10\n\n\n\n# switch 语句\n\nswitch 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。\n\nswitch 语句有如下规则：\n\n * switch 语句中的变量类型只能为 byte、short、int、char 或者 String。\n * switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。\n * case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。\n * 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。\n * 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。\n * switch 语句可以包含一个 default 分支，该分支必须是 switch 语句的最后一个分支。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。\n\n语法\n\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n       break; //可选，但一般建议加上\n}\n\n\n示例\n\npublic class SwitchDemo {\n    public static void main(String args[]) {\n        char grade = \'C\';\n\n        switch (grade) {\n        case \'A\':\n            System.out.println("Excellent!");\n            break;\n        case \'B\':\n        case \'C\':\n            System.out.println("Well done");\n            break;\n        case \'D\':\n            System.out.println("You passed");\n        case \'F\':\n            System.out.println("Better try again");\n            break;\n        default:\n            System.out.println("Invalid grade");\n            break;\n        }\n        System.out.println("Your grade is " + grade);\n    }\n}\n// output:\n// Well done\n// Your grade is C\n\n\n\n# 循环语句\n\n\n# while 循环\n\n只要布尔表达式为 true，while 循环体会一直执行下去。\n\n语法\n\nwhile( 布尔表达式 ) {\n    //循环内容\n}\n\n\n示例\n\npublic class WhileDemo {\n    public static void main(String args[]) {\n        int x = 10;\n        while (x < 20) {\n            System.out.print("value of x : " + x);\n            x++;\n            System.out.print("\\n");\n        }\n    }\n}\n// output:\n// value of x : 10\n// value of x : 11\n// value of x : 12\n// value of x : 13\n// value of x : 14\n// value of x : 15\n// value of x : 16\n// value of x : 17\n// value of x : 18\n// value of x : 19\n\n\n\n# do while 循环\n\n对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。\n\ndo while 循环和 while 循环相似，不同的是，do while 循环至少会执行一次。\n\n语法\n\ndo {\n    //代码语句\n} while (布尔表达式);\n\n\n布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。\n\n示例\n\npublic class DoWhileDemo {\n    public static void main(String args[]) {\n        int x = 10;\n\n        do {\n            System.out.print("value of x : " + x);\n            x++;\n            System.out.print("\\n");\n        } while (x < 20);\n    }\n}\n// output:\n// value of x:10\n// value of x:11\n// value of x:12\n// value of x:13\n// value of x:14\n// value of x:15\n// value of x:16\n// value of x:17\n// value of x:18\n// value of x:19\n\n\n\n# for 循环\n\n虽然所有循环结构都可以用 while 或者 do while 表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。 for 循环执行的次数是在执行前就确定的。\n\n语法\n\nfor (初始化; 布尔表达式; 更新) {\n    //代码语句\n}\n\n\n * 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。\n * 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为 false，循环终止，开始执行循环体后面的语句。\n * 执行一次循环后，更新循环控制变量。\n * 再次检测布尔表达式。循环执行上面的过程。\n\n示例\n\npublic class ForDemo {\n    public static void main(String args[]) {\n        for (int x = 10; x < 20; x = x + 1) {\n            System.out.print("value of x : " + x);\n            System.out.print("\\n");\n        }\n    }\n}\n// output:\n// value of x : 10\n// value of x : 11\n// value of x : 12\n// value of x : 13\n// value of x : 14\n// value of x : 15\n// value of x : 16\n// value of x : 17\n// value of x : 18\n// value of x : 19\n\n\n\n# foreach 循环\n\nJava5 引入了一种主要用于数组的增强型 for 循环。\n\n语法\n\nfor (声明语句 : 表达式) {\n    //代码句子\n}\n\n\n声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n\n表达式：表达式是要访问的数组名，或者是返回值为数组的方法。\n\n示例\n\npublic class ForeachDemo {\n    public static void main(String args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            System.out.print(x);\n            System.out.print(",");\n        }\n\n        System.out.print("\\n");\n        String[] names = { "James", "Larry", "Tom", "Lacy" };\n\n        for (String name : names) {\n            System.out.print(name);\n            System.out.print(",");\n        }\n    }\n}\n// output:\n// 10,20,30,40,50,\n// James,Larry,Tom,Lacy,\n\n\n\n# 中断语句\n\n\n# break 关键字\n\nbreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\n\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\n\n示例\n\npublic class BreakDemo {\n    public static void main(String args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            if (x == 30) {\n                break;\n            }\n            System.out.print(x);\n            System.out.print("\\n");\n        }\n\n        System.out.println("break 示例结束");\n    }\n}\n// output:\n// 10\n// 20\n// break 示例结束\n\n\n\n# continue 关键字\n\ncontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 for 循环中，continue 语句使程序立即跳转到更新语句。在 while 或者 do while 循环中，程序立即跳转到布尔表达式的判断语句。\n\n示例\n\npublic class ContinueDemo {\n    public static void main(String args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            if (x == 30) {\n                continue;\n            }\n            System.out.print(x);\n            System.out.print("\\n");\n        }\n    }\n}\n// output:\n// 10\n// 20\n// 40\n// 50\n\n\n\n# return 关键字\n\n跳出整个函数体，函数体后面的部分不再执行。\n\n示例\n\npublic class ReturnDemo {\n    public static void main(String args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            if (x == 30) {\n                return;\n            }\n            System.out.print(x);\n            System.out.print("\\n");\n        }\n\n        System.out.println("return 示例结束");\n    }\n}\n// output:\n// 10\n// 20\n\n\n> 🔔 注意：请仔细体会一下 return 和 break 的区别。\n\n\n# 最佳实践\n\n * 选择分支特别多的情况下，switch 语句优于 if...else if...else 语句。\n * switch 语句不要吝啬使用 default。\n * switch 语句中的 default 要放在最后。\n * foreach 循环优先于传统的 for 循环\n * 不要循环遍历容器元素，然后删除特定元素。正确姿势应该是遍历容器的迭代器（Iterator），删除元素。\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）',normalizedContent:'# java 控制语句\n\n> java 控制语句大致可分为三大类：\n> \n>  * 选择语句\n>    * if, else-if, else\n>    * switch\n>  * 循环语句\n>    * while\n>    * do...while\n>    * for\n>    * foreach\n>  * 中断语句\n>    * break\n>    * continue\n>    * return\n\n\n# 选择语句\n\n\n# if 语句\n\nif 语句会判断括号中的条件是否成立，如果成立则执行 if 语句中的代码块，否则跳过代码块继续执行。\n\n语法\n\nif(布尔表达式) {\n   //如果布尔表达式为true将执行的语句\n}\n\n\n示例\n\npublic class ifdemo {\n    public static void main(string args[]) {\n        int x = 10;\n        if (x < 20) {\n            system.out.print("这是 if 语句");\n        }\n    }\n}\n// output:\n// 这是 if 语句\n\n\n\n# if...else 语句\n\nif 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。\n\n语法\n\nif(布尔表达式) {\n   //如果布尔表达式的值为true\n} else {\n   //如果布尔表达式的值为false\n}\n\n\n示例\n\npublic class ifelsedemo {\n    public static void main(string args[]) {\n        int x = 30;\n        if (x < 20) {\n            system.out.print("这是 if 语句");\n        } else {\n            system.out.print("这是 else 语句");\n        }\n    }\n}\n// output:\n// 这是 else 语句\n\n\n\n# if...else if...else 语句\n\n * if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。\n * if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。\n * 一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。\n\n语法\n\nif (布尔表达式 1) {\n   //如果布尔表达式 1的值为true执行代码\n} else if (布尔表达式 2) {\n   //如果布尔表达式 2的值为true执行代码\n} else if (布尔表达式 3) {\n   //如果布尔表达式 3的值为true执行代码\n} else {\n   //如果以上布尔表达式都不为true执行代码\n}\n\n\n示例\n\npublic class ifelseifelsedemo {\n    public static void main(string args[]) {\n        int x = 3;\n\n        if (x == 1) {\n            system.out.print("value of x is 1");\n        } else if (x == 2) {\n            system.out.print("value of x is 2");\n        } else if (x == 3) {\n            system.out.print("value of x is 3");\n        } else {\n            system.out.print("this is else statement");\n        }\n    }\n}\n// output:\n// value of x is 3\n\n\n\n# 嵌套的 if…else 语句\n\n使用嵌套的 if else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。\n\n语法\n\nif (布尔表达式 1) {\n   ////如果布尔表达式 1的值为true执行代码\n   if (布尔表达式 2) {\n      ////如果布尔表达式 2的值为true执行代码\n   }\n}\n\n\n示例\n\npublic class ifnestdemo {\n    public static void main(string args[]) {\n        int x = 30;\n        int y = 10;\n\n        if (x == 30) {\n            if (y == 10) {\n                system.out.print("x = 30 and y = 10");\n            }\n        }\n    }\n}\n// output:\n// x = 30 and y = 10\n\n\n\n# switch 语句\n\nswitch 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。\n\nswitch 语句有如下规则：\n\n * switch 语句中的变量类型只能为 byte、short、int、char 或者 string。\n * switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。\n * case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。\n * 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。\n * 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。\n * switch 语句可以包含一个 default 分支，该分支必须是 switch 语句的最后一个分支。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。\n\n语法\n\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n       break; //可选，但一般建议加上\n}\n\n\n示例\n\npublic class switchdemo {\n    public static void main(string args[]) {\n        char grade = \'c\';\n\n        switch (grade) {\n        case \'a\':\n            system.out.println("excellent!");\n            break;\n        case \'b\':\n        case \'c\':\n            system.out.println("well done");\n            break;\n        case \'d\':\n            system.out.println("you passed");\n        case \'f\':\n            system.out.println("better try again");\n            break;\n        default:\n            system.out.println("invalid grade");\n            break;\n        }\n        system.out.println("your grade is " + grade);\n    }\n}\n// output:\n// well done\n// your grade is c\n\n\n\n# 循环语句\n\n\n# while 循环\n\n只要布尔表达式为 true，while 循环体会一直执行下去。\n\n语法\n\nwhile( 布尔表达式 ) {\n    //循环内容\n}\n\n\n示例\n\npublic class whiledemo {\n    public static void main(string args[]) {\n        int x = 10;\n        while (x < 20) {\n            system.out.print("value of x : " + x);\n            x++;\n            system.out.print("\\n");\n        }\n    }\n}\n// output:\n// value of x : 10\n// value of x : 11\n// value of x : 12\n// value of x : 13\n// value of x : 14\n// value of x : 15\n// value of x : 16\n// value of x : 17\n// value of x : 18\n// value of x : 19\n\n\n\n# do while 循环\n\n对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。\n\ndo while 循环和 while 循环相似，不同的是，do while 循环至少会执行一次。\n\n语法\n\ndo {\n    //代码语句\n} while (布尔表达式);\n\n\n布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。\n\n示例\n\npublic class dowhiledemo {\n    public static void main(string args[]) {\n        int x = 10;\n\n        do {\n            system.out.print("value of x : " + x);\n            x++;\n            system.out.print("\\n");\n        } while (x < 20);\n    }\n}\n// output:\n// value of x:10\n// value of x:11\n// value of x:12\n// value of x:13\n// value of x:14\n// value of x:15\n// value of x:16\n// value of x:17\n// value of x:18\n// value of x:19\n\n\n\n# for 循环\n\n虽然所有循环结构都可以用 while 或者 do while 表示，但 java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。 for 循环执行的次数是在执行前就确定的。\n\n语法\n\nfor (初始化; 布尔表达式; 更新) {\n    //代码语句\n}\n\n\n * 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。\n * 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为 false，循环终止，开始执行循环体后面的语句。\n * 执行一次循环后，更新循环控制变量。\n * 再次检测布尔表达式。循环执行上面的过程。\n\n示例\n\npublic class fordemo {\n    public static void main(string args[]) {\n        for (int x = 10; x < 20; x = x + 1) {\n            system.out.print("value of x : " + x);\n            system.out.print("\\n");\n        }\n    }\n}\n// output:\n// value of x : 10\n// value of x : 11\n// value of x : 12\n// value of x : 13\n// value of x : 14\n// value of x : 15\n// value of x : 16\n// value of x : 17\n// value of x : 18\n// value of x : 19\n\n\n\n# foreach 循环\n\njava5 引入了一种主要用于数组的增强型 for 循环。\n\n语法\n\nfor (声明语句 : 表达式) {\n    //代码句子\n}\n\n\n声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n\n表达式：表达式是要访问的数组名，或者是返回值为数组的方法。\n\n示例\n\npublic class foreachdemo {\n    public static void main(string args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            system.out.print(x);\n            system.out.print(",");\n        }\n\n        system.out.print("\\n");\n        string[] names = { "james", "larry", "tom", "lacy" };\n\n        for (string name : names) {\n            system.out.print(name);\n            system.out.print(",");\n        }\n    }\n}\n// output:\n// 10,20,30,40,50,\n// james,larry,tom,lacy,\n\n\n\n# 中断语句\n\n\n# break 关键字\n\nbreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\n\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\n\n示例\n\npublic class breakdemo {\n    public static void main(string args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            if (x == 30) {\n                break;\n            }\n            system.out.print(x);\n            system.out.print("\\n");\n        }\n\n        system.out.println("break 示例结束");\n    }\n}\n// output:\n// 10\n// 20\n// break 示例结束\n\n\n\n# continue 关键字\n\ncontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 for 循环中，continue 语句使程序立即跳转到更新语句。在 while 或者 do while 循环中，程序立即跳转到布尔表达式的判断语句。\n\n示例\n\npublic class continuedemo {\n    public static void main(string args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            if (x == 30) {\n                continue;\n            }\n            system.out.print(x);\n            system.out.print("\\n");\n        }\n    }\n}\n// output:\n// 10\n// 20\n// 40\n// 50\n\n\n\n# return 关键字\n\n跳出整个函数体，函数体后面的部分不再执行。\n\n示例\n\npublic class returndemo {\n    public static void main(string args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            if (x == 30) {\n                return;\n            }\n            system.out.print(x);\n            system.out.print("\\n");\n        }\n\n        system.out.println("return 示例结束");\n    }\n}\n// output:\n// 10\n// 20\n\n\n> 🔔 注意：请仔细体会一下 return 和 break 的区别。\n\n\n# 最佳实践\n\n * 选择分支特别多的情况下，switch 语句优于 if...else if...else 语句。\n * switch 语句不要吝啬使用 default。\n * switch 语句中的 default 要放在最后。\n * foreach 循环优先于传统的 for 循环\n * 不要循环遍历容器元素，然后删除特定元素。正确姿势应该是遍历容器的迭代器（iterator），删除元素。\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"深入理解 Java 异常",frontmatter:{title:"深入理解 Java 异常",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE","异常"],abbrlink:"3590bf3",date:"2019-05-06T15:02:02.000Z",permalink:"/pages/59fbf8/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/08.Java%E5%BC%82%E5%B8%B8.html",relativePath:"01.基础特性/08.Java异常.md",key:"v-cee742ae",path:"/pages/59fbf8/",headers:[{level:2,title:"异常框架",slug:"异常框架",normalizedTitle:"异常框架",charIndex:21},{level:3,title:"Throwable",slug:"throwable",normalizedTitle:"throwable",charIndex:30},{level:3,title:"Error",slug:"error",normalizedTitle:"error",charIndex:68},{level:3,title:"Exception",slug:"exception",normalizedTitle:"exception",charIndex:78},{level:3,title:"RuntimeException",slug:"runtimeexception",normalizedTitle:"runtimeexception",charIndex:1915},{level:2,title:"自定义异常",slug:"自定义异常",normalizedTitle:"自定义异常",charIndex:3479},{level:2,title:"抛出异常",slug:"抛出异常",normalizedTitle:"抛出异常",charIndex:4005},{level:2,title:"捕获异常",slug:"捕获异常",normalizedTitle:"捕获异常",charIndex:5730},{level:2,title:"异常链",slug:"异常链",normalizedTitle:"异常链",charIndex:7145},{level:2,title:"异常注意事项",slug:"异常注意事项",normalizedTitle:"异常注意事项",charIndex:8814},{level:3,title:"finally 覆盖异常",slug:"finally-覆盖异常",normalizedTitle:"finally 覆盖异常",charIndex:8825},{level:3,title:"覆盖抛出异常的方法",slug:"覆盖抛出异常的方法",normalizedTitle:"覆盖抛出异常的方法",charIndex:9472},{level:3,title:"异常和线程",slug:"异常和线程",normalizedTitle:"异常和线程",charIndex:10315},{level:2,title:"最佳实践",slug:"最佳实践",normalizedTitle:"最佳实践",charIndex:10411},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:11058}],headersStr:"异常框架 Throwable Error Exception RuntimeException 自定义异常 抛出异常 捕获异常 异常链 异常注意事项 finally 覆盖异常 覆盖抛出异常的方法 异常和线程 最佳实践 参考资料",content:'# 深入理解 Java 异常\n\n\n\n\n# 异常框架\n\n\n# Throwable\n\n**Throwable 是 Java 语言中所有错误（Error）和异常（Exception）的超类。**在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。\n\nThrowable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。\n\n主要方法：\n\n * fillInStackTrace - 用当前的调用栈层次填充 Throwable 对象栈层次，添加到栈层次任何先前信息中。\n * getMessage - 返回关于发生的异常的详细信息。这个消息在 Throwable 类的构造函数中初始化了。\n * getCause - 返回一个 Throwable 对象代表异常原因。\n * getStackTrace - 返回一个包含堆栈层次的数组。下标为 0 的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。\n * printStackTrace - 打印 toString() 结果和栈层次到 System.err，即错误输出流。\n * toString - 使用 getMessage 的结果返回代表 Throwable 对象的字符串。\n\n\n# Error\n\nError 是 Throwable 的一个子类。Error 表示正常情况下，不大可能出现的严重问题。编译器不会检查 Error。绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。\n\n常见 Error：\n\n * AssertionError - 断言错误。\n * VirtualMachineError - 虚拟机错误。\n * UnsupportedClassVersionError - Java 类版本错误。\n * StackOverflowError - 栈溢出错误。\n * OutOfMemoryError - 内存溢出错误。\n\n\n# Exception\n\nException 是 Throwable 的一个子类。**Exception 表示合理的应用程序可能想要捕获的条件。**Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。\n\nException 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。\n\n**编译器会检查 Exception 异常。**此类异常，要么通过 throws 进行声明抛出，要么通过 try catch 进行捕获处理，否则不能通过编译。\n\n常见 Exception：\n\n * ClassNotFoundException - 应用程序试图加载类时，找不到相应的类，抛出该异常。\n * CloneNotSupportedException - 当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。\n * IllegalAccessException - 拒绝访问一个类的时候，抛出该异常。\n * InstantiationException - 当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。\n * InterruptedException - 一个线程被另一个线程中断，抛出该异常。\n * NoSuchFieldException - 请求的变量不存在。\n * NoSuchMethodException - 请求的方法不存在。\n\n示例：\n\npublic class ExceptionDemo {\n    public static void main(String[] args) {\n        Method method = String.class.getMethod("toString", int.class);\n    }\n};\n\n\n试图编译运行时会报错：\n\nError:(7, 47) java: 未报告的异常错误java.lang.NoSuchMethodException; 必须对其进行捕获或声明以便抛出\n\n\n\n# RuntimeException\n\nRuntimeException 是 Exception 的一个子类。RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。\n\n**编译器不会检查 RuntimeException 异常。**当程序中可能出现这类异常时，倘若既没有通过 throws 声明抛出它，也没有用 try catch 语句捕获它，程序还是会编译通过。\n\n示例：\n\npublic class RuntimeExceptionDemo {\n    public static void main(String[] args) {\n        // 此处产生了异常\n        int result = 10 / 0;\n        System.out.println("两个数字相除的结果：" + result);\n        System.out.println("----------------------------");\n    }\n};\n\n\n运行时输出：\n\nException in thread "main" java.lang.ArithmeticException: / by zero\n\tat io.github.dunwu.javacore.exception.RumtimeExceptionDemo01.main(RumtimeExceptionDemo01.java:6)\n\n\n常见 RuntimeException：\n\n * ArrayIndexOutOfBoundsException - 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。\n * ArrayStoreException - 试图将错误类型的对象存储到一个对象数组时抛出的异常。\n * ClassCastException - 当试图将对象强制转换为不是实例的子类时，抛出该异常。\n * IllegalArgumentException - 抛出的异常表明向方法传递了一个不合法或不正确的参数。\n * IllegalMonitorStateException - 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。\n * IllegalStateException - 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。\n * IllegalThreadStateException - 线程没有处于请求操作所要求的适当状态时抛出的异常。\n * IndexOutOfBoundsException - 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。\n * NegativeArraySizeException - 如果应用程序试图创建大小为负的数组，则抛出该异常。\n * NullPointerException - 当应用程序试图在需要对象的地方使用 null 时，抛出该异常\n * NumberFormatException - 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。\n * SecurityException - 由安全管理器抛出的异常，指示存在安全侵犯。\n * StringIndexOutOfBoundsException - 此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。\n * UnsupportedOperationException - 当不支持请求的操作时，抛出该异常。\n\n\n# 自定义异常\n\n\n\n自定义一个异常类，只需要继承 Exception 或 RuntimeException 即可。\n\n示例：\n\npublic class MyExceptionDemo {\n    public static void main(String[] args) {\n        throw new MyException("自定义异常");\n    }\n\n    static class MyException extends RuntimeException {\n        public MyException(String message) {\n            super(message);\n        }\n    }\n}\n\n\n输出：\n\nException in thread "main" io.github.dunwu.javacore.exception.MyExceptionDemo$MyException: 自定义异常\n\tat io.github.dunwu.javacore.exception.MyExceptionDemo.main(MyExceptionDemo.java:9)\n\n\n\n# 抛出异常\n\n如果想在程序中明确地抛出异常，需要用到 throw 和 throws 。\n\n如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。\n\nthrow 示例：\n\npublic class ThrowDemo {\n    public static void f() {\n        try {\n            throw new RuntimeException("抛出一个异常");\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    public static void main(String[] args) {\n        f();\n    }\n};\n\n\n输出：\n\njava.lang.RuntimeException: 抛出一个异常\n\n\n也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。\n\nthrows 示例：\n\npublic class ThrowsDemo {\n    public static void f1() throws NoSuchMethodException, NoSuchFieldException {\n        Field field = Integer.class.getDeclaredField("digits");\n        if (field != null) {\n            System.out.println("反射获取 digits 方法成功");\n        }\n        Method method = String.class.getMethod("toString", int.class);\n        if (method != null) {\n            System.out.println("反射获取 toString 方法成功");\n        }\n    }\n\n    public static void f2() {\n        try {\n            // 调用 f1 处，如果不用 try catch ，编译时会报错\n            f1();\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (NoSuchFieldException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        f2();\n    }\n};\n\n\n输出：\n\n反射获取 digits 方法成功\njava.lang.NoSuchMethodException: java.lang.String.toString(int)\n\tat java.lang.Class.getMethod(Class.java:1786)\n\tat io.github.dunwu.javacore.exception.ThrowsDemo.f1(ThrowsDemo.java:12)\n\tat io.github.dunwu.javacore.exception.ThrowsDemo.f2(ThrowsDemo.java:21)\n\tat io.github.dunwu.javacore.exception.ThrowsDemo.main(ThrowsDemo.java:30)\n\n\nthrow 和 throws 的区别：\n\n * throws 使用在函数上，throw 使用在函数内。\n * throws 后面跟异常类，可以跟多个，用逗号区别；throw 后面跟的是异常对象。\n\n\n# 捕获异常\n\n使用 try 和 catch 关键字可以捕获异常。try catch 代码块放在异常可能发生的地方。\n\n它的语法形式如下：\n\ntry {\n    // 可能会发生异常的代码块\n} catch (Exception e1) {\n    // 捕获并处理try抛出的异常类型Exception\n} catch (Exception2 e2) {\n    // 捕获并处理try抛出的异常类型Exception2\n} finally {\n    // 无论是否发生异常，都将执行的代码块\n}\n\n\n此外，JDK7 以后，catch 多种异常时，也可以像下面这样简化代码：\n\ntry {\n    // 可能会发生异常的代码块\n} catch (Exception | Exception2 e) {\n    // 捕获并处理try抛出的异常类型\n} finally {\n    // 无论是否发生异常，都将执行的代码块\n}\n\n\n * try - try 语句用于监听。将要被监听的代码(可能抛出异常的代码)放在 try 语句块之内，当 try 语句块内发生异常时，异常就被抛出。\n * catch - catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。\n * finally - finally 语句块总是会被执行，无论是否出现异常。try catch 语句后不一定非要finally 语句。finally 常用于这样的场景：由于finally 语句块总是会被执行，所以那些在 try 代码块中打开的，并且必须回收的物理资源(如数据库连接、网络连接和文件)，一般会放在finally 语句块中释放资源。\n * try、catch、finally 三个代码块中的局部变量不可共享使用。\n * catch 块尝试捕获异常时，是按照 catch 块的声明顺序从上往下寻找的，一旦匹配，就不会再向下执行。因此，如果同一个 try 块下的多个 catch 异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面。\n\n示例：\n\npublic class TryCatchFinallyDemo {\n    public static void main(String[] args) {\n        try {\n            // 此处产生了异常\n            int temp = 10 / 0;\n            System.out.println("两个数字相除的结果：" + temp);\n            System.out.println("----------------------------");\n        } catch (ArithmeticException e) {\n            System.out.println("出现异常了：" + e);\n        } finally {\n            System.out.println("不管是否出现异常，都执行此代码");\n        }\n    }\n};\n\n\n运行时输出：\n\n出现异常了：java.lang.ArithmeticException: / by zero\n不管是否出现异常，都执行此代码\n\n\n\n# 异常链\n\n异常链是以一个异常对象为参数构造新的异常对象，新的异常对象将包含先前异常的信息。\n\n通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。\n\n我们有两种方式处理异常，一是 throws 抛出交给上级处理，二是 try…catch 做具体处理。try…catch 的 catch 块我们可以不需要做任何处理，仅仅只用 throw 这个关键字将我们封装异常信息主动抛出来。然后在通过关键字 throws 继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。\n\n【示例】\n\npublic class ExceptionChainDemo {\n    static class MyException1 extends Exception {\n        public MyException1(String message) {\n            super(message);\n        }\n    }\n\n    static class MyException2 extends Exception {\n        public MyException2(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n\n    public static void f1() throws MyException1 {\n        throw new MyException1("出现 MyException1");\n    }\n\n    public static void f2() throws MyException2 {\n        try {\n            f1();\n        } catch (MyException1 e) {\n            throw new MyException2("出现 MyException2", e);\n        }\n    }\n\n    public static void main(String[] args) throws MyException2 {\n        f2();\n    }\n}\n\n\n输出：\n\nException in thread "main" io.github.dunwu.javacore.exception.ExceptionChainDemo$MyException2: 出现 MyException2\n\tat io.github.dunwu.javacore.exception.ExceptionChainDemo.f2(ExceptionChainDemo.java:29)\n\tat io.github.dunwu.javacore.exception.ExceptionChainDemo.main(ExceptionChainDemo.java:34)\nCaused by: io.github.dunwu.javacore.exception.ExceptionChainDemo$MyException1: 出现 MyException1\n\tat io.github.dunwu.javacore.exception.ExceptionChainDemo.f1(ExceptionChainDemo.java:22)\n\tat io.github.dunwu.javacore.exception.ExceptionChainDemo.f2(ExceptionChainDemo.java:27)\n\t... 1 more\n\n\n> 扩展阅读：https://juejin.im/post/5b6d61e55188251b38129f9a#heading-10\n> \n> 这篇文章中对于异常链讲解比较详细。\n\n\n# 异常注意事项\n\n\n# finally 覆盖异常\n\nJava 异常处理中 finally 中的 return 会覆盖 catch 代码块中的 return 语句和 throw 语句，所以 Java 不建议在 finally 中使用 return 语句。\n\n此外 finally 中的 throw 语句也会覆盖 catch 代码块中的 return 语句和 throw 语句。\n\n示例：\n\npublic class FinallyOverrideExceptionDemo {\n    static void f() throws Exception {\n        try {\n            throw new Exception("A");\n        } catch (Exception e) {\n            throw new Exception("B");\n        } finally {\n            throw new Exception("C");\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            f();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n\n\n输出：C\n\n\n# 覆盖抛出异常的方法\n\n当子类重写父类带有 throws 声明的函数时，其 throws 声明的异常必须在父类异常的可控范围内——用于处理父类的 throws 方法的异常处理器，必须也适用于子类的这个带 throws 方法 。这是为了支持多态。\n\n示例：\n\npublic class ExceptionOverrideDemo {\n    static class Father {\n        public void start() throws IOException {\n            throw new IOException();\n        }\n    }\n\n    static class Son extends Father {\n        @Override\n        public void start() throws SQLException {\n            throw new SQLException();\n        }\n    }\n\n    public static void main(String[] args) {\n        Father obj1 = new Father();\n        Father obj2 = new Son();\n        try {\n            obj1.start();\n            obj2.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n> 上面的示例编译时会报错，原因在于：\n> \n> 因为 Son 类抛出异常的实质是 SQLException，而 IOException 无法处理它。那么这里的 try catch 就不能处理 Son 中的异常了。多态就不能实现了。\n\n\n# 异常和线程\n\n如果 Java 程序只有一个线程，那么没有被任何代码处理的异常会导致程序终止。如果 Java 程序是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。\n\n\n# 最佳实践\n\n * 对可恢复的情况使用检查性异常（Exception），对编程错误使用运行时异常（RuntimeException）。\n * 优先使用 Java 标准的异常。\n * 抛出与抽象相对应的异常。\n * 在细节消息中包含能捕获失败的信息。\n * 尽可能减少 try 代码块的大小。\n * 尽量缩小异常范围。例如，如果明知尝试捕获的是一个 ArithmeticException，就应该 catch ArithmeticException，而不是 catch 范围较大的 RuntimeException，甚至是 Exception。\n * 尽量不要在 finally 块抛出异常或者返回值。\n * 不要忽略异常，一旦捕获异常，就应该处理，而非丢弃。\n * 异常处理效率很低，所以不要用异常进行业务逻辑处理。\n * 各类异常必须要有单独的日志记录，将异常分级，分类管理，因为有的时候仅仅想给第三方运维看到逻辑异常，而不是更细节的信息。\n * 如何对异常进行分类：\n   * 逻辑异常，这类异常用于描述业务无法按照预期的情况处理下去，属于用户制造的意外。\n   * 代码错误，这类异常用于描述开发的代码错误，例如 NPE，ILLARG，都属于程序员制造的 BUG。\n   * 专有异常，多用于特定业务场景，用于描述指定作业出现意外情况无法预先处理。\n\n> 扩展阅读：\n> \n>  * Effective java 中文版 之 第九章 异常\n>  * 优雅的处理你的 Java 异常\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * Effective java 中文版 之 第九章 异常\n * 优雅的处理你的 Java 异常\n * https://juejin.im/post/5b6d61e55188251b38129f9a#heading-17\n * https://www.cnblogs.com/skywang12345/p/3544168.html\n * http://www.importnew.com/26613.html',normalizedContent:'# 深入理解 java 异常\n\n\n\n\n# 异常框架\n\n\n# throwable\n\n**throwable 是 java 语言中所有错误（error）和异常（exception）的超类。**在 java 中只有 throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。\n\nthrowable 包含了其线程创建时线程执行堆栈的快照，它提供了 printstacktrace() 等接口用于获取堆栈跟踪数据等信息。\n\n主要方法：\n\n * fillinstacktrace - 用当前的调用栈层次填充 throwable 对象栈层次，添加到栈层次任何先前信息中。\n * getmessage - 返回关于发生的异常的详细信息。这个消息在 throwable 类的构造函数中初始化了。\n * getcause - 返回一个 throwable 对象代表异常原因。\n * getstacktrace - 返回一个包含堆栈层次的数组。下标为 0 的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。\n * printstacktrace - 打印 tostring() 结果和栈层次到 system.err，即错误输出流。\n * tostring - 使用 getmessage 的结果返回代表 throwable 对象的字符串。\n\n\n# error\n\nerror 是 throwable 的一个子类。error 表示正常情况下，不大可能出现的严重问题。编译器不会检查 error。绝大部分的 error 都会导致程序（比如 jvm 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 outofmemoryerror 之类，都是 error 的子类。\n\n常见 error：\n\n * assertionerror - 断言错误。\n * virtualmachineerror - 虚拟机错误。\n * unsupportedclassversionerror - java 类版本错误。\n * stackoverflowerror - 栈溢出错误。\n * outofmemoryerror - 内存溢出错误。\n\n\n# exception\n\nexception 是 throwable 的一个子类。**exception 表示合理的应用程序可能想要捕获的条件。**exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。\n\nexception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。\n\n**编译器会检查 exception 异常。**此类异常，要么通过 throws 进行声明抛出，要么通过 try catch 进行捕获处理，否则不能通过编译。\n\n常见 exception：\n\n * classnotfoundexception - 应用程序试图加载类时，找不到相应的类，抛出该异常。\n * clonenotsupportedexception - 当调用 object 类中的 clone 方法克隆对象，但该对象的类无法实现 cloneable 接口时，抛出该异常。\n * illegalaccessexception - 拒绝访问一个类的时候，抛出该异常。\n * instantiationexception - 当试图使用 class 类中的 newinstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。\n * interruptedexception - 一个线程被另一个线程中断，抛出该异常。\n * nosuchfieldexception - 请求的变量不存在。\n * nosuchmethodexception - 请求的方法不存在。\n\n示例：\n\npublic class exceptiondemo {\n    public static void main(string[] args) {\n        method method = string.class.getmethod("tostring", int.class);\n    }\n};\n\n\n试图编译运行时会报错：\n\nerror:(7, 47) java: 未报告的异常错误java.lang.nosuchmethodexception; 必须对其进行捕获或声明以便抛出\n\n\n\n# runtimeexception\n\nruntimeexception 是 exception 的一个子类。runtimeexception 是那些可能在 java 虚拟机正常运行期间抛出的异常的超类。\n\n**编译器不会检查 runtimeexception 异常。**当程序中可能出现这类异常时，倘若既没有通过 throws 声明抛出它，也没有用 try catch 语句捕获它，程序还是会编译通过。\n\n示例：\n\npublic class runtimeexceptiondemo {\n    public static void main(string[] args) {\n        // 此处产生了异常\n        int result = 10 / 0;\n        system.out.println("两个数字相除的结果：" + result);\n        system.out.println("----------------------------");\n    }\n};\n\n\n运行时输出：\n\nexception in thread "main" java.lang.arithmeticexception: / by zero\n\tat io.github.dunwu.javacore.exception.rumtimeexceptiondemo01.main(rumtimeexceptiondemo01.java:6)\n\n\n常见 runtimeexception：\n\n * arrayindexoutofboundsexception - 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。\n * arraystoreexception - 试图将错误类型的对象存储到一个对象数组时抛出的异常。\n * classcastexception - 当试图将对象强制转换为不是实例的子类时，抛出该异常。\n * illegalargumentexception - 抛出的异常表明向方法传递了一个不合法或不正确的参数。\n * illegalmonitorstateexception - 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。\n * illegalstateexception - 在非法或不适当的时间调用方法时产生的信号。换句话说，即 java 环境或 java 应用程序没有处于请求操作所要求的适当状态下。\n * illegalthreadstateexception - 线程没有处于请求操作所要求的适当状态时抛出的异常。\n * indexoutofboundsexception - 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。\n * negativearraysizeexception - 如果应用程序试图创建大小为负的数组，则抛出该异常。\n * nullpointerexception - 当应用程序试图在需要对象的地方使用 null 时，抛出该异常\n * numberformatexception - 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。\n * securityexception - 由安全管理器抛出的异常，指示存在安全侵犯。\n * stringindexoutofboundsexception - 此异常由 string 方法抛出，指示索引或者为负，或者超出字符串的大小。\n * unsupportedoperationexception - 当不支持请求的操作时，抛出该异常。\n\n\n# 自定义异常\n\n\n\n自定义一个异常类，只需要继承 exception 或 runtimeexception 即可。\n\n示例：\n\npublic class myexceptiondemo {\n    public static void main(string[] args) {\n        throw new myexception("自定义异常");\n    }\n\n    static class myexception extends runtimeexception {\n        public myexception(string message) {\n            super(message);\n        }\n    }\n}\n\n\n输出：\n\nexception in thread "main" io.github.dunwu.javacore.exception.myexceptiondemo$myexception: 自定义异常\n\tat io.github.dunwu.javacore.exception.myexceptiondemo.main(myexceptiondemo.java:9)\n\n\n\n# 抛出异常\n\n如果想在程序中明确地抛出异常，需要用到 throw 和 throws 。\n\n如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。\n\nthrow 示例：\n\npublic class throwdemo {\n    public static void f() {\n        try {\n            throw new runtimeexception("抛出一个异常");\n        } catch (exception e) {\n            system.out.println(e);\n        }\n    }\n\n    public static void main(string[] args) {\n        f();\n    }\n};\n\n\n输出：\n\njava.lang.runtimeexception: 抛出一个异常\n\n\n也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。\n\nthrows 示例：\n\npublic class throwsdemo {\n    public static void f1() throws nosuchmethodexception, nosuchfieldexception {\n        field field = integer.class.getdeclaredfield("digits");\n        if (field != null) {\n            system.out.println("反射获取 digits 方法成功");\n        }\n        method method = string.class.getmethod("tostring", int.class);\n        if (method != null) {\n            system.out.println("反射获取 tostring 方法成功");\n        }\n    }\n\n    public static void f2() {\n        try {\n            // 调用 f1 处，如果不用 try catch ，编译时会报错\n            f1();\n        } catch (nosuchmethodexception e) {\n            e.printstacktrace();\n        } catch (nosuchfieldexception e) {\n            e.printstacktrace();\n        }\n    }\n\n    public static void main(string[] args) {\n        f2();\n    }\n};\n\n\n输出：\n\n反射获取 digits 方法成功\njava.lang.nosuchmethodexception: java.lang.string.tostring(int)\n\tat java.lang.class.getmethod(class.java:1786)\n\tat io.github.dunwu.javacore.exception.throwsdemo.f1(throwsdemo.java:12)\n\tat io.github.dunwu.javacore.exception.throwsdemo.f2(throwsdemo.java:21)\n\tat io.github.dunwu.javacore.exception.throwsdemo.main(throwsdemo.java:30)\n\n\nthrow 和 throws 的区别：\n\n * throws 使用在函数上，throw 使用在函数内。\n * throws 后面跟异常类，可以跟多个，用逗号区别；throw 后面跟的是异常对象。\n\n\n# 捕获异常\n\n使用 try 和 catch 关键字可以捕获异常。try catch 代码块放在异常可能发生的地方。\n\n它的语法形式如下：\n\ntry {\n    // 可能会发生异常的代码块\n} catch (exception e1) {\n    // 捕获并处理try抛出的异常类型exception\n} catch (exception2 e2) {\n    // 捕获并处理try抛出的异常类型exception2\n} finally {\n    // 无论是否发生异常，都将执行的代码块\n}\n\n\n此外，jdk7 以后，catch 多种异常时，也可以像下面这样简化代码：\n\ntry {\n    // 可能会发生异常的代码块\n} catch (exception | exception2 e) {\n    // 捕获并处理try抛出的异常类型\n} finally {\n    // 无论是否发生异常，都将执行的代码块\n}\n\n\n * try - try 语句用于监听。将要被监听的代码(可能抛出异常的代码)放在 try 语句块之内，当 try 语句块内发生异常时，异常就被抛出。\n * catch - catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。\n * finally - finally 语句块总是会被执行，无论是否出现异常。try catch 语句后不一定非要finally 语句。finally 常用于这样的场景：由于finally 语句块总是会被执行，所以那些在 try 代码块中打开的，并且必须回收的物理资源(如数据库连接、网络连接和文件)，一般会放在finally 语句块中释放资源。\n * try、catch、finally 三个代码块中的局部变量不可共享使用。\n * catch 块尝试捕获异常时，是按照 catch 块的声明顺序从上往下寻找的，一旦匹配，就不会再向下执行。因此，如果同一个 try 块下的多个 catch 异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面。\n\n示例：\n\npublic class trycatchfinallydemo {\n    public static void main(string[] args) {\n        try {\n            // 此处产生了异常\n            int temp = 10 / 0;\n            system.out.println("两个数字相除的结果：" + temp);\n            system.out.println("----------------------------");\n        } catch (arithmeticexception e) {\n            system.out.println("出现异常了：" + e);\n        } finally {\n            system.out.println("不管是否出现异常，都执行此代码");\n        }\n    }\n};\n\n\n运行时输出：\n\n出现异常了：java.lang.arithmeticexception: / by zero\n不管是否出现异常，都执行此代码\n\n\n\n# 异常链\n\n异常链是以一个异常对象为参数构造新的异常对象，新的异常对象将包含先前异常的信息。\n\n通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。\n\n我们有两种方式处理异常，一是 throws 抛出交给上级处理，二是 try…catch 做具体处理。try…catch 的 catch 块我们可以不需要做任何处理，仅仅只用 throw 这个关键字将我们封装异常信息主动抛出来。然后在通过关键字 throws 继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。\n\n【示例】\n\npublic class exceptionchaindemo {\n    static class myexception1 extends exception {\n        public myexception1(string message) {\n            super(message);\n        }\n    }\n\n    static class myexception2 extends exception {\n        public myexception2(string message, throwable cause) {\n            super(message, cause);\n        }\n    }\n\n    public static void f1() throws myexception1 {\n        throw new myexception1("出现 myexception1");\n    }\n\n    public static void f2() throws myexception2 {\n        try {\n            f1();\n        } catch (myexception1 e) {\n            throw new myexception2("出现 myexception2", e);\n        }\n    }\n\n    public static void main(string[] args) throws myexception2 {\n        f2();\n    }\n}\n\n\n输出：\n\nexception in thread "main" io.github.dunwu.javacore.exception.exceptionchaindemo$myexception2: 出现 myexception2\n\tat io.github.dunwu.javacore.exception.exceptionchaindemo.f2(exceptionchaindemo.java:29)\n\tat io.github.dunwu.javacore.exception.exceptionchaindemo.main(exceptionchaindemo.java:34)\ncaused by: io.github.dunwu.javacore.exception.exceptionchaindemo$myexception1: 出现 myexception1\n\tat io.github.dunwu.javacore.exception.exceptionchaindemo.f1(exceptionchaindemo.java:22)\n\tat io.github.dunwu.javacore.exception.exceptionchaindemo.f2(exceptionchaindemo.java:27)\n\t... 1 more\n\n\n> 扩展阅读：https://juejin.im/post/5b6d61e55188251b38129f9a#heading-10\n> \n> 这篇文章中对于异常链讲解比较详细。\n\n\n# 异常注意事项\n\n\n# finally 覆盖异常\n\njava 异常处理中 finally 中的 return 会覆盖 catch 代码块中的 return 语句和 throw 语句，所以 java 不建议在 finally 中使用 return 语句。\n\n此外 finally 中的 throw 语句也会覆盖 catch 代码块中的 return 语句和 throw 语句。\n\n示例：\n\npublic class finallyoverrideexceptiondemo {\n    static void f() throws exception {\n        try {\n            throw new exception("a");\n        } catch (exception e) {\n            throw new exception("b");\n        } finally {\n            throw new exception("c");\n        }\n    }\n\n    public static void main(string[] args) {\n        try {\n            f();\n        } catch (exception e) {\n            system.out.println(e.getmessage());\n        }\n    }\n}\n\n\n输出：c\n\n\n# 覆盖抛出异常的方法\n\n当子类重写父类带有 throws 声明的函数时，其 throws 声明的异常必须在父类异常的可控范围内——用于处理父类的 throws 方法的异常处理器，必须也适用于子类的这个带 throws 方法 。这是为了支持多态。\n\n示例：\n\npublic class exceptionoverridedemo {\n    static class father {\n        public void start() throws ioexception {\n            throw new ioexception();\n        }\n    }\n\n    static class son extends father {\n        @override\n        public void start() throws sqlexception {\n            throw new sqlexception();\n        }\n    }\n\n    public static void main(string[] args) {\n        father obj1 = new father();\n        father obj2 = new son();\n        try {\n            obj1.start();\n            obj2.start();\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n> 上面的示例编译时会报错，原因在于：\n> \n> 因为 son 类抛出异常的实质是 sqlexception，而 ioexception 无法处理它。那么这里的 try catch 就不能处理 son 中的异常了。多态就不能实现了。\n\n\n# 异常和线程\n\n如果 java 程序只有一个线程，那么没有被任何代码处理的异常会导致程序终止。如果 java 程序是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。\n\n\n# 最佳实践\n\n * 对可恢复的情况使用检查性异常（exception），对编程错误使用运行时异常（runtimeexception）。\n * 优先使用 java 标准的异常。\n * 抛出与抽象相对应的异常。\n * 在细节消息中包含能捕获失败的信息。\n * 尽可能减少 try 代码块的大小。\n * 尽量缩小异常范围。例如，如果明知尝试捕获的是一个 arithmeticexception，就应该 catch arithmeticexception，而不是 catch 范围较大的 runtimeexception，甚至是 exception。\n * 尽量不要在 finally 块抛出异常或者返回值。\n * 不要忽略异常，一旦捕获异常，就应该处理，而非丢弃。\n * 异常处理效率很低，所以不要用异常进行业务逻辑处理。\n * 各类异常必须要有单独的日志记录，将异常分级，分类管理，因为有的时候仅仅想给第三方运维看到逻辑异常，而不是更细节的信息。\n * 如何对异常进行分类：\n   * 逻辑异常，这类异常用于描述业务无法按照预期的情况处理下去，属于用户制造的意外。\n   * 代码错误，这类异常用于描述开发的代码错误，例如 npe，illarg，都属于程序员制造的 bug。\n   * 专有异常，多用于特定业务场景，用于描述指定作业出现意外情况无法预先处理。\n\n> 扩展阅读：\n> \n>  * effective java 中文版 之 第九章 异常\n>  * 优雅的处理你的 java 异常\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * effective java 中文版 之 第九章 异常\n * 优雅的处理你的 java 异常\n * https://juejin.im/post/5b6d61e55188251b38129f9a#heading-17\n * https://www.cnblogs.com/skywang12345/p/3544168.html\n * http://www.importnew.com/26613.html',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"深入理解 Java 泛型",frontmatter:{title:"深入理解 Java 泛型",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE","泛型"],abbrlink:"568214ab",date:"2020-10-17T19:13:25.000Z",permalink:"/pages/987cf1/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/09.Java%E6%B3%9B%E5%9E%8B.html",relativePath:"01.基础特性/09.Java泛型.md",key:"v-5587af85",path:"/pages/987cf1/",headers:[{level:2,title:"为什么需要泛型",slug:"为什么需要泛型",normalizedTitle:"为什么需要泛型",charIndex:19},{level:2,title:"泛型类型",slug:"泛型类型",normalizedTitle:"泛型类型",charIndex:1772},{level:3,title:"泛型类",slug:"泛型类",normalizedTitle:"泛型类",charIndex:1772},{level:3,title:"泛型接口",slug:"泛型接口",normalizedTitle:"泛型接口",charIndex:4111},{level:2,title:"泛型方法",slug:"泛型方法",normalizedTitle:"泛型方法",charIndex:5069},{level:2,title:"类型擦除",slug:"类型擦除",normalizedTitle:"类型擦除",charIndex:6258},{level:2,title:"泛型和继承",slug:"泛型和继承",normalizedTitle:"泛型和继承",charIndex:7203},{level:2,title:"类型边界",slug:"类型边界",normalizedTitle:"类型边界",charIndex:6409},{level:2,title:"类型通配符",slug:"类型通配符",normalizedTitle:"类型通配符",charIndex:9090},{level:3,title:"上界通配符",slug:"上界通配符",normalizedTitle:"上界通配符",charIndex:9191},{level:3,title:"下界通配符",slug:"下界通配符",normalizedTitle:"下界通配符",charIndex:9680},{level:3,title:"无界通配符",slug:"无界通配符",normalizedTitle:"无界通配符",charIndex:10194},{level:3,title:"通配符和向上转型",slug:"通配符和向上转型",normalizedTitle:"通配符和向上转型",charIndex:10754},{level:2,title:"泛型的约束",slug:"泛型的约束",normalizedTitle:"泛型的约束",charIndex:11140},{level:2,title:"泛型最佳实践",slug:"泛型最佳实践",normalizedTitle:"泛型最佳实践",charIndex:12337},{level:3,title:"泛型命名",slug:"泛型命名",normalizedTitle:"泛型命名",charIndex:12348},{level:3,title:"使用泛型的建议",slug:"使用泛型的建议",normalizedTitle:"使用泛型的建议",charIndex:12473},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:12593},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:12602}],headersStr:"为什么需要泛型 泛型类型 泛型类 泛型接口 泛型方法 类型擦除 泛型和继承 类型边界 类型通配符 上界通配符 下界通配符 无界通配符 通配符和向上转型 泛型的约束 泛型最佳实践 泛型命名 使用泛型的建议 小结 参考资料",content:'# 深入理解 Java 泛型\n\n\n# 为什么需要泛型\n\nJDK5 引入了泛型机制。\n\n为什么需要泛型呢？回答这个问题前，先让我们来看一个示例。\n\npublic class NoGenericsDemo {\n    public static void main(String[] args) {\n        List list = new ArrayList<>();\n        list.add("abc");\n        list.add(18);\n        list.add(new double[] {1.0, 2.0});\n        Object obj1 = list.get(0);\n        Object obj2 = list.get(1);\n        Object obj3 = list.get(2);\n        System.out.println("obj1 = [" + obj1 + "]");\n        System.out.println("obj2 = [" + obj2 + "]");\n        System.out.println("obj3 = [" + obj3 + "]");\n\n        int num1 = (int)list.get(0);\n        int num2 = (int)list.get(1);\n        int num3 = (int)list.get(2);\n        System.out.println("num1 = [" + num1 + "]");\n        System.out.println("num2 = [" + num2 + "]");\n        System.out.println("num3 = [" + num3 + "]");\n    }\n}\n// Output:\n// obj1 = [abc]\n// obj2 = [18]\n// obj3 = [[D@47089e5f]\n// Exception in thread "main" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer\n// at io.github.dunwu.javacore.generics.NoGenericsDemo.main(NoGenericsDemo.java:23)\n\n\n> 示例说明：\n> \n> 在上面的示例中，List 容器没有指定存储数据类型，这种情况下，可以向 List 添加任意类型数据，编译器不会做类型检查，而是默默的将所有数据都转为 Object。\n> \n> 假设，最初我们希望向 List 存储的是整形数据，假设，某个家伙不小心存入了其他数据类型。当你试图从容器中取整形数据时，由于 List 当成 Object 类型来存储，你不得不使用类型强制转换。在运行时，才会发现 List 中数据不存储一致的问题，这就为程序运行带来了很大的风险（无形伤害最为致命）。\n\n而泛型的出现，解决了类型安全问题。\n\n泛型具有以下优点：\n\n * 编译时的强类型检查\n\n泛型要求在声明时指定实际数据类型，Java 编译器在编译时会对泛型代码做强类型检查，并在代码违反类型安全时发出告警。早发现，早治理，把隐患扼杀于摇篮，在编译时发现并修复错误所付出的代价远比在运行时小。\n\n * 避免了类型转换\n\n未使用泛型：\n\nList list = new ArrayList();\nlist.add("hello");\nString s = (String) list.get(0);\n\n\n使用泛型：\n\nList<String> list = new ArrayList<String>();\nlist.add("hello");\nString s = list.get(0);   // no cast\n\n\n * 泛型编程可以实现通用算法\n\n通过使用泛型，程序员可以实现通用算法，这些算法可以处理不同类型的集合，可以自定义，并且类型安全且易于阅读。\n\n\n# 泛型类型\n\n泛型类型是被参数化的类或接口。\n\n\n# 泛型类\n\n泛型类的语法形式：\n\nclass name<T1, T2, ..., Tn> { /* ... */ }\n\n\n泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。由尖括号（<>）分隔的类型参数部分跟在类名后面。它指定类型参数（也称为类型变量）T1，T2，...和 Tn。\n\n一般将泛型中的类名称为原型，而将 <> 指定的参数称为类型参数。\n\n * 未应用泛型的类\n\n在泛型出现之前，如果一个类想持有一个可以为任意类型的数据，只能使用 Object 做类型转换。示例如下：\n\npublic class Info {\n\tprivate Object value;\n\n\tpublic Object getValue() {\n\t\treturn value;\n\t}\n\n\tpublic void setValue(Object value) {\n\t\tthis.value = value;\n\t}\n}\n\n\n * 单类型参数的泛型类\n\npublic class Info<T> {\n    private T value;\n\n    public Info() { }\n\n    public Info(T value) {\n        this.value = value;\n    }\n\n    public T getValue() {\n        return value;\n    }\n\n    public void setValue(T value) {\n        this.value = value;\n    }\n\n    @Override\n    public String toString() {\n        return "Info{" + "value=" + value + \'}\';\n    }\n}\n\npublic class GenericsClassDemo01 {\n    public static void main(String[] args) {\n        Info<Integer> info = new Info<>();\n        info.setValue(10);\n        System.out.println(info.getValue());\n\n        Info<String> info2 = new Info<>();\n        info2.setValue("xyz");\n        System.out.println(info2.getValue());\n    }\n}\n// Output:\n// 10\n// xyz\n\n\n在上面的例子中，在初始化一个泛型类时，使用 <> 指定了内部具体类型，在编译时就会根据这个类型做强类型检查。\n\n实际上，不使用 <> 指定内部具体类型，语法上也是支持的（不推荐这么做），如下所示：\n\npublic static void main(String[] args) {\n    Info info = new Info();\n    info.setValue(10);\n    System.out.println(info.getValue());\n    info.setValue("abc");\n    System.out.println(info.getValue());\n}\n\n\n> 示例说明：\n> \n> 上面的例子，不会产生编译错误，也能正常运行。但这样的调用就失去泛型类型的优势。\n\n * 多个类型参数的泛型类\n\npublic class MyMap<K,V> {\n    private K key;\n    private V value;\n\n    public MyMap(K key, V value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    @Override\n    public String toString() {\n        return "MyMap{" + "key=" + key + ", value=" + value + \'}\';\n    }\n}\n\npublic class GenericsClassDemo02 {\n    public static void main(String[] args) {\n        MyMap<Integer, String> map = new MyMap<>(1, "one");\n        System.out.println(map);\n    }\n}\n// Output:\n// MyMap{key=1, value=one}\n\n\n * 泛型类的类型嵌套\n\npublic class GenericsClassDemo03 {\n    public static void main(String[] args) {\n        Info<String> info = new Info("Hello");\n        MyMap<Integer, Info<String>> map = new MyMap<>(1, info);\n        System.out.println(map);\n    }\n}\n// Output:\n// MyMap{key=1, value=Info{value=Hello}}\n\n\n\n# 泛型接口\n\n接口也可以声明泛型。\n\n泛型接口语法形式：\n\npublic interface Content<T> {\n    T text();\n}\n\n\n泛型接口有两种实现方式：\n\n * 实现接口的子类明确声明泛型类型\n\n\n\npublic class GenericsInterfaceDemo01 implements Content<Integer> {\n    private int text;\n\n    public GenericsInterfaceDemo01(int text) {\n        this.text = text;\n    }\n\n    @Override\n    public Integer text() { return text; }\n\n    public static void main(String[] args) {\n        GenericsInterfaceDemo01 demo = new GenericsInterfaceDemo01(10);\n        System.out.print(demo.text());\n    }\n}\n// Output:\n// 10\n\n\n * 实现接口的子类不明确声明泛型类型\n\npublic class GenericsInterfaceDemo02<T> implements Content<T> {\n    private T text;\n\n    public GenericsInterfaceDemo02(T text) {\n        this.text = text;\n    }\n\n    @Override\n    public T text() { return text; }\n\n    public static void main(String[] args) {\n        GenericsInterfaceDemo02<String> gen = new GenericsInterfaceDemo02<>("ABC");\n        System.out.print(gen.text());\n    }\n}\n// Output:\n// ABC\n\n\n\n# 泛型方法\n\n泛型方法是引入其自己的类型参数的方法。泛型方法可以是普通方法、静态方法以及构造方法。\n\n泛型方法语法形式如下：\n\npublic <T> T func(T obj) {}\n\n\n是否拥有泛型方法，与其所在的类是否是泛型没有关系。\n\n泛型方法的语法包括一个类型参数列表，在尖括号内，它出现在方法的返回类型之前。对于静态泛型方法，类型参数部分必须出现在方法的返回类型之前。类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际类型参数的占位符。\n\n使用泛型方法的时候，通常不必指明类型参数，因为编译器会为我们找出具体的类型。这称为类型参数推断（type argument inference）。类型推断只对赋值操作有效，其他时候并不起作用。如果将一个返回类型为 T 的泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行推断。编译器会认为：调用泛型方法后，其返回值被赋给一个 Object 类型的变量。\n\npublic class GenericsMethodDemo01 {\n    public static <T> void printClass(T obj) {\n        System.out.println(obj.getClass().toString());\n    }\n\n    public static void main(String[] args) {\n        printClass("abc");\n        printClass(10);\n    }\n}\n// Output:\n// class java.lang.String\n// class java.lang.Integer\n\n\n泛型方法中也可以使用可变参数列表\n\npublic class GenericVarargsMethodDemo {\n    public static <T> List<T> makeList(T... args) {\n        List<T> result = new ArrayList<T>();\n        Collections.addAll(result, args);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<String> ls = makeList("A");\n        System.out.println(ls);\n        ls = makeList("A", "B", "C");\n        System.out.println(ls);\n    }\n}\n// Output:\n// [A]\n// [A, B, C]\n\n\n\n# 类型擦除\n\nJava 语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程。不同于 C++ 的模板机制，Java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了。\n\n那么，类型擦除做了什么呢？它做了以下工作：\n\n * 把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。\n * 擦除出现的类型声明，即去掉 <> 的内容。比如 T get() 方法声明就变成了 Object get() ；List<String> 就变成了 List。如有必要，插入类型转换以保持类型安全。\n * 生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。\n\n让我们来看一个示例：\n\npublic class GenericsErasureTypeDemo {\n    public static void main(String[] args) {\n        List<Object> list1 = new ArrayList<Object>();\n        List<String> list2 = new ArrayList<String>();\n        System.out.println(list1.getClass());\n        System.out.println(list2.getClass());\n    }\n}\n// Output:\n// class java.util.ArrayList\n// class java.util.ArrayList\n\n\n> 示例说明：\n> \n> 上面的例子中，虽然指定了不同的类型参数，但是 list1 和 list2 的类信息却是一样的。\n> \n> 这是因为：使用泛型时，任何具体的类型信息都被擦除了。这意味着：ArrayList<Object> 和 ArrayList<String> 在运行时，JVM 将它们视为同一类型。\n\nJava 泛型的实现方式不太优雅，但这是因为泛型是在 JDK5 时引入的，为了兼容老代码，必须在设计上做一定的折中。\n\n\n# 泛型和继承\n\n泛型不能用于显式地引用运行时类型的操作之中，例如：转型、instanceof 操作和 new 表达式。因为所有关于参数的类型信息都丢失了。当你在编写泛型代码时，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已。\n\n正是由于泛型时基于类型擦除实现的，所以，泛型类型无法向上转型。\n\n> 向上转型是指用子类实例去初始化父类，这是面向对象中多态的重要表现。\n\n\n\nInteger 继承了 Object；ArrayList 继承了 List；但是 List<Interger> 却并非继承了 List<Object>。\n\n这是因为，泛型类并没有自己独有的 Class 类对象。比如：并不存在 List<Object>.class 或是 List<Interger>.class，Java 编译器会将二者都视为 List.class。\n\nList<Integer> list = new ArrayList<>();\nList<Object> list2 = list; // Erorr\n\n\n\n# 类型边界\n\n有时您可能希望限制可在参数化类型中用作类型参数的类型。类型边界可以对泛型的类型参数设置限制条件。例如，对数字进行操作的方法可能只想接受 Number 或其子类的实例。\n\n要声明有界类型参数，请列出类型参数的名称，然后是 extends 关键字，后跟其限制类或接口。\n\n类型边界的语法形式如下：\n\n<T extends XXX>\n\n\n示例：\n\npublic class GenericsExtendsDemo01 {\n    static <T extends Comparable<T>> T max(T x, T y, T z) {\n        T max = x; // 假设x是初始最大值\n        if (y.compareTo(max) > 0) {\n            max = y; //y 更大\n        }\n        if (z.compareTo(max) > 0) {\n            max = z; // 现在 z 更大\n        }\n        return max; // 返回最大对象\n    }\n\n    public static void main(String[] args) {\n        System.out.println(max(3, 4, 5));\n        System.out.println(max(6.6, 8.8, 7.7));\n        System.out.println(max("pear", "apple", "orange"));\n    }\n}\n// Output:\n// 5\n// 8.8\n// pear\n\n\n> 示例说明：\n> \n> 上面的示例声明了一个泛型方法，类型参数 T extends Comparable<T> 表明传入方法中的类型必须实现了 Comparable 接口。\n\n类型边界可以设置多个，语法形式如下：\n\n<T extends B1 & B2 & B3>\n\n\n> 🔔 注意：extends 关键字后面的第一个类型参数可以是类或接口，其他类型参数只能是接口。\n\n示例：\n\npublic class GenericsExtendsDemo02 {\n    static class A { /* ... */ }\n    interface B { /* ... */ }\n    interface C { /* ... */ }\n    static class D1 <T extends A & B & C> { /* ... */ }\n    static class D2 <T extends B & A & C> { /* ... */ } // 编译报错\n    static class E extends A implements B, C { /* ... */ }\n\n    public static void main(String[] args) {\n        D1<E> demo1 = new D1<>();\n        System.out.println(demo1.getClass().toString());\n        D1<String> demo2 = new D1<>(); // 编译报错\n    }\n}\n\n\n\n# 类型通配符\n\n类型通配符一般是使用 ? 代替具体的类型参数。例如 List<?> 在逻辑上是 List<String> ，List<Integer> 等所有 List<具体类型实参> 的父类。\n\n\n# 上界通配符\n\n可以使用**上界通配符**来缩小类型参数的类型范围。\n\n它的语法形式为：<? extends Number>\n\npublic class GenericsUpperBoundedWildcardDemo {\n    public static double sumOfList(List<? extends Number> list) {\n        double s = 0.0;\n        for (Number n : list) {\n            s += n.doubleValue();\n        }\n        return s;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> li = Arrays.asList(1, 2, 3);\n        System.out.println("sum = " + sumOfList(li));\n    }\n}\n// Output:\n// sum = 6.0\n\n\n\n# 下界通配符\n\n**下界通配符**将未知类型限制为该类型的特定类型或超类类型。\n\n> 🔔 注意：上界通配符和下界通配符不能同时使用。\n\n它的语法形式为：<? super Number>\n\npublic class GenericsLowerBoundedWildcardDemo {\n    public static void addNumbers(List<? super Integer> list) {\n        for (int i = 1; i <= 5; i++) {\n            list.add(i);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        addNumbers(list);\n        System.out.println(Arrays.deepToString(list.toArray()));\n    }\n}\n// Output:\n// [1, 2, 3, 4, 5]\n\n\n\n# 无界通配符\n\n无界通配符有两种应用场景：\n\n * 可以使用 Object 类中提供的功能来实现的方法。\n * 使用不依赖于类型参数的泛型类中的方法。\n\n语法形式：<?>\n\npublic class GenericsUnboundedWildcardDemo {\n    public static void printList(List<?> list) {\n        for (Object elem : list) {\n            System.out.print(elem + " ");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        List<Integer> li = Arrays.asList(1, 2, 3);\n        List<String> ls = Arrays.asList("one", "two", "three");\n        printList(li);\n        printList(ls);\n    }\n}\n// Output:\n// 1 2 3\n// one two three\n\n\n\n# 通配符和向上转型\n\n前面，我们提到：泛型不能向上转型。但是，我们可以通过使用通配符来向上转型。\n\npublic class GenericsWildcardDemo {\n    public static void main(String[] args) {\n        List<Integer> intList = new ArrayList<>();\n        List<Number> numList = intList;  // Error\n\n        List<? extends Integer> intList2 = new ArrayList<>();\n        List<? extends Number> numList2 = intList2;  // OK\n    }\n}\n\n\n> 扩展阅读：Oracle 泛型文档\n\n\n# 泛型的约束\n\n * 泛型类型的类型参数不能是值类型\n\nPair<int, char> p = new Pair<>(8, \'a\');  // 编译错误\n\n\n * 不能创建类型参数的实例\n\npublic static <E> void append(List<E> list) {\n    E elem = new E();  // 编译错误\n    list.add(elem);\n}\n\n\n * 不能声明类型为类型参数的静态成员\n\npublic class MobileDevice<T> {\n    private static T os; // error\n\n    // ...\n}\n\n\n * 类型参数不能使用类型转换或 instanceof\n\npublic static <E> void rtti(List<E> list) {\n    if (list instanceof ArrayList<Integer>) {  // 编译错误\n        // ...\n    }\n}\n\n\nList<Integer> li = new ArrayList<>();\nList<Number>  ln = (List<Number>) li;  // 编译错误\n\n\n * 不能创建类型参数的数组\n\nList<Integer>[] arrayOfLists = new List<Integer>[2];  // 编译错误\n\n\n * 不能创建、catch 或 throw 参数化类型对象\n\n// Extends Throwable indirectly\nclass MathException<T> extends Exception { /* ... */ }    // 编译错误\n\n// Extends Throwable directly\nclass QueueFullException<T> extends Throwable { /* ... */ // 编译错误\n\n\npublic static <T extends Exception, J> void execute(List<J> jobs) {\n    try {\n        for (J job : jobs)\n            // ...\n    } catch (T e) {   // compile-time error\n        // ...\n    }\n}\n\n\n * 仅仅是泛型类相同，而类型参数不同的方法不能重载\n\npublic class Example {\n    public void print(Set<String> strSet) { }\n    public void print(Set<Integer> intSet) { } // 编译错误\n}\n\n\n\n# 泛型最佳实践\n\n\n# 泛型命名\n\n泛型一些约定俗成的命名：\n\n * E - Element\n * K - Key\n * N - Number\n * T - Type\n * V - Value\n * S,U,V etc. - 2nd, 3rd, 4th types\n\n\n# 使用泛型的建议\n\n * 消除类型检查告警\n * List 优先于数组\n * 优先考虑使用泛型来提高代码通用性\n * 优先考虑泛型方法来限定泛型的范围\n * 利用有限制通配符来提升 API 的灵活性\n * 优先考虑类型安全的异构容器\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * Effective java\n * Oracle 泛型文档\n * Java 泛型详解',normalizedContent:'# 深入理解 java 泛型\n\n\n# 为什么需要泛型\n\njdk5 引入了泛型机制。\n\n为什么需要泛型呢？回答这个问题前，先让我们来看一个示例。\n\npublic class nogenericsdemo {\n    public static void main(string[] args) {\n        list list = new arraylist<>();\n        list.add("abc");\n        list.add(18);\n        list.add(new double[] {1.0, 2.0});\n        object obj1 = list.get(0);\n        object obj2 = list.get(1);\n        object obj3 = list.get(2);\n        system.out.println("obj1 = [" + obj1 + "]");\n        system.out.println("obj2 = [" + obj2 + "]");\n        system.out.println("obj3 = [" + obj3 + "]");\n\n        int num1 = (int)list.get(0);\n        int num2 = (int)list.get(1);\n        int num3 = (int)list.get(2);\n        system.out.println("num1 = [" + num1 + "]");\n        system.out.println("num2 = [" + num2 + "]");\n        system.out.println("num3 = [" + num3 + "]");\n    }\n}\n// output:\n// obj1 = [abc]\n// obj2 = [18]\n// obj3 = [[d@47089e5f]\n// exception in thread "main" java.lang.classcastexception: java.lang.string cannot be cast to java.lang.integer\n// at io.github.dunwu.javacore.generics.nogenericsdemo.main(nogenericsdemo.java:23)\n\n\n> 示例说明：\n> \n> 在上面的示例中，list 容器没有指定存储数据类型，这种情况下，可以向 list 添加任意类型数据，编译器不会做类型检查，而是默默的将所有数据都转为 object。\n> \n> 假设，最初我们希望向 list 存储的是整形数据，假设，某个家伙不小心存入了其他数据类型。当你试图从容器中取整形数据时，由于 list 当成 object 类型来存储，你不得不使用类型强制转换。在运行时，才会发现 list 中数据不存储一致的问题，这就为程序运行带来了很大的风险（无形伤害最为致命）。\n\n而泛型的出现，解决了类型安全问题。\n\n泛型具有以下优点：\n\n * 编译时的强类型检查\n\n泛型要求在声明时指定实际数据类型，java 编译器在编译时会对泛型代码做强类型检查，并在代码违反类型安全时发出告警。早发现，早治理，把隐患扼杀于摇篮，在编译时发现并修复错误所付出的代价远比在运行时小。\n\n * 避免了类型转换\n\n未使用泛型：\n\nlist list = new arraylist();\nlist.add("hello");\nstring s = (string) list.get(0);\n\n\n使用泛型：\n\nlist<string> list = new arraylist<string>();\nlist.add("hello");\nstring s = list.get(0);   // no cast\n\n\n * 泛型编程可以实现通用算法\n\n通过使用泛型，程序员可以实现通用算法，这些算法可以处理不同类型的集合，可以自定义，并且类型安全且易于阅读。\n\n\n# 泛型类型\n\n泛型类型是被参数化的类或接口。\n\n\n# 泛型类\n\n泛型类的语法形式：\n\nclass name<t1, t2, ..., tn> { /* ... */ }\n\n\n泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。由尖括号（<>）分隔的类型参数部分跟在类名后面。它指定类型参数（也称为类型变量）t1，t2，...和 tn。\n\n一般将泛型中的类名称为原型，而将 <> 指定的参数称为类型参数。\n\n * 未应用泛型的类\n\n在泛型出现之前，如果一个类想持有一个可以为任意类型的数据，只能使用 object 做类型转换。示例如下：\n\npublic class info {\n\tprivate object value;\n\n\tpublic object getvalue() {\n\t\treturn value;\n\t}\n\n\tpublic void setvalue(object value) {\n\t\tthis.value = value;\n\t}\n}\n\n\n * 单类型参数的泛型类\n\npublic class info<t> {\n    private t value;\n\n    public info() { }\n\n    public info(t value) {\n        this.value = value;\n    }\n\n    public t getvalue() {\n        return value;\n    }\n\n    public void setvalue(t value) {\n        this.value = value;\n    }\n\n    @override\n    public string tostring() {\n        return "info{" + "value=" + value + \'}\';\n    }\n}\n\npublic class genericsclassdemo01 {\n    public static void main(string[] args) {\n        info<integer> info = new info<>();\n        info.setvalue(10);\n        system.out.println(info.getvalue());\n\n        info<string> info2 = new info<>();\n        info2.setvalue("xyz");\n        system.out.println(info2.getvalue());\n    }\n}\n// output:\n// 10\n// xyz\n\n\n在上面的例子中，在初始化一个泛型类时，使用 <> 指定了内部具体类型，在编译时就会根据这个类型做强类型检查。\n\n实际上，不使用 <> 指定内部具体类型，语法上也是支持的（不推荐这么做），如下所示：\n\npublic static void main(string[] args) {\n    info info = new info();\n    info.setvalue(10);\n    system.out.println(info.getvalue());\n    info.setvalue("abc");\n    system.out.println(info.getvalue());\n}\n\n\n> 示例说明：\n> \n> 上面的例子，不会产生编译错误，也能正常运行。但这样的调用就失去泛型类型的优势。\n\n * 多个类型参数的泛型类\n\npublic class mymap<k,v> {\n    private k key;\n    private v value;\n\n    public mymap(k key, v value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    @override\n    public string tostring() {\n        return "mymap{" + "key=" + key + ", value=" + value + \'}\';\n    }\n}\n\npublic class genericsclassdemo02 {\n    public static void main(string[] args) {\n        mymap<integer, string> map = new mymap<>(1, "one");\n        system.out.println(map);\n    }\n}\n// output:\n// mymap{key=1, value=one}\n\n\n * 泛型类的类型嵌套\n\npublic class genericsclassdemo03 {\n    public static void main(string[] args) {\n        info<string> info = new info("hello");\n        mymap<integer, info<string>> map = new mymap<>(1, info);\n        system.out.println(map);\n    }\n}\n// output:\n// mymap{key=1, value=info{value=hello}}\n\n\n\n# 泛型接口\n\n接口也可以声明泛型。\n\n泛型接口语法形式：\n\npublic interface content<t> {\n    t text();\n}\n\n\n泛型接口有两种实现方式：\n\n * 实现接口的子类明确声明泛型类型\n\n\n\npublic class genericsinterfacedemo01 implements content<integer> {\n    private int text;\n\n    public genericsinterfacedemo01(int text) {\n        this.text = text;\n    }\n\n    @override\n    public integer text() { return text; }\n\n    public static void main(string[] args) {\n        genericsinterfacedemo01 demo = new genericsinterfacedemo01(10);\n        system.out.print(demo.text());\n    }\n}\n// output:\n// 10\n\n\n * 实现接口的子类不明确声明泛型类型\n\npublic class genericsinterfacedemo02<t> implements content<t> {\n    private t text;\n\n    public genericsinterfacedemo02(t text) {\n        this.text = text;\n    }\n\n    @override\n    public t text() { return text; }\n\n    public static void main(string[] args) {\n        genericsinterfacedemo02<string> gen = new genericsinterfacedemo02<>("abc");\n        system.out.print(gen.text());\n    }\n}\n// output:\n// abc\n\n\n\n# 泛型方法\n\n泛型方法是引入其自己的类型参数的方法。泛型方法可以是普通方法、静态方法以及构造方法。\n\n泛型方法语法形式如下：\n\npublic <t> t func(t obj) {}\n\n\n是否拥有泛型方法，与其所在的类是否是泛型没有关系。\n\n泛型方法的语法包括一个类型参数列表，在尖括号内，它出现在方法的返回类型之前。对于静态泛型方法，类型参数部分必须出现在方法的返回类型之前。类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际类型参数的占位符。\n\n使用泛型方法的时候，通常不必指明类型参数，因为编译器会为我们找出具体的类型。这称为类型参数推断（type argument inference）。类型推断只对赋值操作有效，其他时候并不起作用。如果将一个返回类型为 t 的泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行推断。编译器会认为：调用泛型方法后，其返回值被赋给一个 object 类型的变量。\n\npublic class genericsmethoddemo01 {\n    public static <t> void printclass(t obj) {\n        system.out.println(obj.getclass().tostring());\n    }\n\n    public static void main(string[] args) {\n        printclass("abc");\n        printclass(10);\n    }\n}\n// output:\n// class java.lang.string\n// class java.lang.integer\n\n\n泛型方法中也可以使用可变参数列表\n\npublic class genericvarargsmethoddemo {\n    public static <t> list<t> makelist(t... args) {\n        list<t> result = new arraylist<t>();\n        collections.addall(result, args);\n        return result;\n    }\n\n    public static void main(string[] args) {\n        list<string> ls = makelist("a");\n        system.out.println(ls);\n        ls = makelist("a", "b", "c");\n        system.out.println(ls);\n    }\n}\n// output:\n// [a]\n// [a, b, c]\n\n\n\n# 类型擦除\n\njava 语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程。不同于 c++ 的模板机制，java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了。\n\n那么，类型擦除做了什么呢？它做了以下工作：\n\n * 把泛型中的所有类型参数替换为 object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。\n * 擦除出现的类型声明，即去掉 <> 的内容。比如 t get() 方法声明就变成了 object get() ；list<string> 就变成了 list。如有必要，插入类型转换以保持类型安全。\n * 生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。\n\n让我们来看一个示例：\n\npublic class genericserasuretypedemo {\n    public static void main(string[] args) {\n        list<object> list1 = new arraylist<object>();\n        list<string> list2 = new arraylist<string>();\n        system.out.println(list1.getclass());\n        system.out.println(list2.getclass());\n    }\n}\n// output:\n// class java.util.arraylist\n// class java.util.arraylist\n\n\n> 示例说明：\n> \n> 上面的例子中，虽然指定了不同的类型参数，但是 list1 和 list2 的类信息却是一样的。\n> \n> 这是因为：使用泛型时，任何具体的类型信息都被擦除了。这意味着：arraylist<object> 和 arraylist<string> 在运行时，jvm 将它们视为同一类型。\n\njava 泛型的实现方式不太优雅，但这是因为泛型是在 jdk5 时引入的，为了兼容老代码，必须在设计上做一定的折中。\n\n\n# 泛型和继承\n\n泛型不能用于显式地引用运行时类型的操作之中，例如：转型、instanceof 操作和 new 表达式。因为所有关于参数的类型信息都丢失了。当你在编写泛型代码时，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已。\n\n正是由于泛型时基于类型擦除实现的，所以，泛型类型无法向上转型。\n\n> 向上转型是指用子类实例去初始化父类，这是面向对象中多态的重要表现。\n\n\n\ninteger 继承了 object；arraylist 继承了 list；但是 list<interger> 却并非继承了 list<object>。\n\n这是因为，泛型类并没有自己独有的 class 类对象。比如：并不存在 list<object>.class 或是 list<interger>.class，java 编译器会将二者都视为 list.class。\n\nlist<integer> list = new arraylist<>();\nlist<object> list2 = list; // erorr\n\n\n\n# 类型边界\n\n有时您可能希望限制可在参数化类型中用作类型参数的类型。类型边界可以对泛型的类型参数设置限制条件。例如，对数字进行操作的方法可能只想接受 number 或其子类的实例。\n\n要声明有界类型参数，请列出类型参数的名称，然后是 extends 关键字，后跟其限制类或接口。\n\n类型边界的语法形式如下：\n\n<t extends xxx>\n\n\n示例：\n\npublic class genericsextendsdemo01 {\n    static <t extends comparable<t>> t max(t x, t y, t z) {\n        t max = x; // 假设x是初始最大值\n        if (y.compareto(max) > 0) {\n            max = y; //y 更大\n        }\n        if (z.compareto(max) > 0) {\n            max = z; // 现在 z 更大\n        }\n        return max; // 返回最大对象\n    }\n\n    public static void main(string[] args) {\n        system.out.println(max(3, 4, 5));\n        system.out.println(max(6.6, 8.8, 7.7));\n        system.out.println(max("pear", "apple", "orange"));\n    }\n}\n// output:\n// 5\n// 8.8\n// pear\n\n\n> 示例说明：\n> \n> 上面的示例声明了一个泛型方法，类型参数 t extends comparable<t> 表明传入方法中的类型必须实现了 comparable 接口。\n\n类型边界可以设置多个，语法形式如下：\n\n<t extends b1 & b2 & b3>\n\n\n> 🔔 注意：extends 关键字后面的第一个类型参数可以是类或接口，其他类型参数只能是接口。\n\n示例：\n\npublic class genericsextendsdemo02 {\n    static class a { /* ... */ }\n    interface b { /* ... */ }\n    interface c { /* ... */ }\n    static class d1 <t extends a & b & c> { /* ... */ }\n    static class d2 <t extends b & a & c> { /* ... */ } // 编译报错\n    static class e extends a implements b, c { /* ... */ }\n\n    public static void main(string[] args) {\n        d1<e> demo1 = new d1<>();\n        system.out.println(demo1.getclass().tostring());\n        d1<string> demo2 = new d1<>(); // 编译报错\n    }\n}\n\n\n\n# 类型通配符\n\n类型通配符一般是使用 ? 代替具体的类型参数。例如 list<?> 在逻辑上是 list<string> ，list<integer> 等所有 list<具体类型实参> 的父类。\n\n\n# 上界通配符\n\n可以使用**上界通配符**来缩小类型参数的类型范围。\n\n它的语法形式为：<? extends number>\n\npublic class genericsupperboundedwildcarddemo {\n    public static double sumoflist(list<? extends number> list) {\n        double s = 0.0;\n        for (number n : list) {\n            s += n.doublevalue();\n        }\n        return s;\n    }\n\n    public static void main(string[] args) {\n        list<integer> li = arrays.aslist(1, 2, 3);\n        system.out.println("sum = " + sumoflist(li));\n    }\n}\n// output:\n// sum = 6.0\n\n\n\n# 下界通配符\n\n**下界通配符**将未知类型限制为该类型的特定类型或超类类型。\n\n> 🔔 注意：上界通配符和下界通配符不能同时使用。\n\n它的语法形式为：<? super number>\n\npublic class genericslowerboundedwildcarddemo {\n    public static void addnumbers(list<? super integer> list) {\n        for (int i = 1; i <= 5; i++) {\n            list.add(i);\n        }\n    }\n\n    public static void main(string[] args) {\n        list<integer> list = new arraylist<>();\n        addnumbers(list);\n        system.out.println(arrays.deeptostring(list.toarray()));\n    }\n}\n// output:\n// [1, 2, 3, 4, 5]\n\n\n\n# 无界通配符\n\n无界通配符有两种应用场景：\n\n * 可以使用 object 类中提供的功能来实现的方法。\n * 使用不依赖于类型参数的泛型类中的方法。\n\n语法形式：<?>\n\npublic class genericsunboundedwildcarddemo {\n    public static void printlist(list<?> list) {\n        for (object elem : list) {\n            system.out.print(elem + " ");\n        }\n        system.out.println();\n    }\n\n    public static void main(string[] args) {\n        list<integer> li = arrays.aslist(1, 2, 3);\n        list<string> ls = arrays.aslist("one", "two", "three");\n        printlist(li);\n        printlist(ls);\n    }\n}\n// output:\n// 1 2 3\n// one two three\n\n\n\n# 通配符和向上转型\n\n前面，我们提到：泛型不能向上转型。但是，我们可以通过使用通配符来向上转型。\n\npublic class genericswildcarddemo {\n    public static void main(string[] args) {\n        list<integer> intlist = new arraylist<>();\n        list<number> numlist = intlist;  // error\n\n        list<? extends integer> intlist2 = new arraylist<>();\n        list<? extends number> numlist2 = intlist2;  // ok\n    }\n}\n\n\n> 扩展阅读：oracle 泛型文档\n\n\n# 泛型的约束\n\n * 泛型类型的类型参数不能是值类型\n\npair<int, char> p = new pair<>(8, \'a\');  // 编译错误\n\n\n * 不能创建类型参数的实例\n\npublic static <e> void append(list<e> list) {\n    e elem = new e();  // 编译错误\n    list.add(elem);\n}\n\n\n * 不能声明类型为类型参数的静态成员\n\npublic class mobiledevice<t> {\n    private static t os; // error\n\n    // ...\n}\n\n\n * 类型参数不能使用类型转换或 instanceof\n\npublic static <e> void rtti(list<e> list) {\n    if (list instanceof arraylist<integer>) {  // 编译错误\n        // ...\n    }\n}\n\n\nlist<integer> li = new arraylist<>();\nlist<number>  ln = (list<number>) li;  // 编译错误\n\n\n * 不能创建类型参数的数组\n\nlist<integer>[] arrayoflists = new list<integer>[2];  // 编译错误\n\n\n * 不能创建、catch 或 throw 参数化类型对象\n\n// extends throwable indirectly\nclass mathexception<t> extends exception { /* ... */ }    // 编译错误\n\n// extends throwable directly\nclass queuefullexception<t> extends throwable { /* ... */ // 编译错误\n\n\npublic static <t extends exception, j> void execute(list<j> jobs) {\n    try {\n        for (j job : jobs)\n            // ...\n    } catch (t e) {   // compile-time error\n        // ...\n    }\n}\n\n\n * 仅仅是泛型类相同，而类型参数不同的方法不能重载\n\npublic class example {\n    public void print(set<string> strset) { }\n    public void print(set<integer> intset) { } // 编译错误\n}\n\n\n\n# 泛型最佳实践\n\n\n# 泛型命名\n\n泛型一些约定俗成的命名：\n\n * e - element\n * k - key\n * n - number\n * t - type\n * v - value\n * s,u,v etc. - 2nd, 3rd, 4th types\n\n\n# 使用泛型的建议\n\n * 消除类型检查告警\n * list 优先于数组\n * 优先考虑使用泛型来提高代码通用性\n * 优先考虑泛型方法来限定泛型的范围\n * 利用有限制通配符来提升 api 的灵活性\n * 优先考虑类型安全的异构容器\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * effective java\n * oracle 泛型文档\n * java 泛型详解',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"深入理解 Java 反射和动态代理",frontmatter:{title:"深入理解 Java 反射和动态代理",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE","反射","动态代理"],abbrlink:"38019de5",date:"2020-06-04T13:51:01.000Z",permalink:"/pages/793a2a/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/10.Java%E5%8F%8D%E5%B0%84.html",relativePath:"01.基础特性/10.Java反射.md",key:"v-588a32fe",path:"/pages/793a2a/",headers:[{level:2,title:"反射简介",slug:"反射简介",normalizedTitle:"反射简介",charIndex:24},{level:3,title:"什么是反射",slug:"什么是反射",normalizedTitle:"什么是反射",charIndex:35},{level:3,title:"反射的应用场景",slug:"反射的应用场景",normalizedTitle:"反射的应用场景",charIndex:157},{level:3,title:"反射的缺点",slug:"反射的缺点",normalizedTitle:"反射的缺点",charIndex:524},{level:2,title:"反射机制",slug:"反射机制",normalizedTitle:"反射机制",charIndex:118},{level:3,title:"类加载过程",slug:"类加载过程",normalizedTitle:"类加载过程",charIndex:800},{level:3,title:"Class 对象",slug:"class-对象",normalizedTitle:"class 对象",charIndex:1044},{level:3,title:"方法的反射调用",slug:"方法的反射调用",normalizedTitle:"方法的反射调用",charIndex:1555},{level:3,title:"反射调用的开销",slug:"反射调用的开销",normalizedTitle:"反射调用的开销",charIndex:6818},{level:2,title:"使用反射",slug:"使用反射",normalizedTitle:"使用反射",charIndex:1126},{level:3,title:"java.lang.reflect 包",slug:"java-lang-reflect-包",normalizedTitle:"java.lang.reflect 包",charIndex:7484},{level:3,title:"获取 Class 对象",slug:"获取-class-对象",normalizedTitle:"获取 class 对象",charIndex:7884},{level:3,title:"判断是否为某个类的实例",slug:"判断是否为某个类的实例",normalizedTitle:"判断是否为某个类的实例",charIndex:10050},{level:3,title:"创建实例",slug:"创建实例",normalizedTitle:"创建实例",charIndex:10556},{level:3,title:"创建数组实例",slug:"创建数组实例",normalizedTitle:"创建数组实例",charIndex:11340},{level:3,title:"Field",slug:"field",normalizedTitle:"field",charIndex:7654},{level:3,title:"Method",slug:"method",normalizedTitle:"method",charIndex:1576},{level:3,title:"Constructor",slug:"constructor",normalizedTitle:"constructor",charIndex:7723},{level:3,title:"绕开访问限制",slug:"绕开访问限制",normalizedTitle:"绕开访问限制",charIndex:15997},{level:2,title:"动态代理",slug:"动态代理",normalizedTitle:"动态代理",charIndex:15},{level:3,title:"静态代理",slug:"静态代理",normalizedTitle:"静态代理",charIndex:16299},{level:3,title:"JDK 动态代理",slug:"jdk-动态代理",normalizedTitle:"jdk 动态代理",charIndex:17108},{level:4,title:"InvocationHandler 接口",slug:"invocationhandler-接口",normalizedTitle:"invocationhandler 接口",charIndex:17796},{level:4,title:"Proxy 类",slug:"proxy-类",normalizedTitle:"proxy 类",charIndex:7851},{level:4,title:"JDK 动态代理实例",slug:"jdk-动态代理实例",normalizedTitle:"jdk 动态代理实例",charIndex:18952},{level:4,title:"JDK 动态代理小结",slug:"jdk-动态代理小结",normalizedTitle:"jdk 动态代理小结",charIndex:22967},{level:3,title:"CGLIB 动态代理",slug:"cglib-动态代理",normalizedTitle:"cglib 动态代理",charIndex:23156},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:23531}],headersStr:"反射简介 什么是反射 反射的应用场景 反射的缺点 反射机制 类加载过程 Class 对象 方法的反射调用 反射调用的开销 使用反射 java.lang.reflect 包 获取 Class 对象 判断是否为某个类的实例 创建实例 创建数组实例 Field Method Constructor 绕开访问限制 动态代理 静态代理 JDK 动态代理 InvocationHandler 接口 Proxy 类 JDK 动态代理实例 JDK 动态代理小结 CGLIB 动态代理 参考资料",content:'# 深入理解 Java 反射和动态代理\n\n\n# 反射简介\n\n\n\n\n# 什么是反射\n\n反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。\n\n通过反射机制，可以在运行时访问 Java 对象的属性，方法，构造方法等。\n\n\n# 反射的应用场景\n\n反射的主要应用场景有：\n\n * 开发通用框架 - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。\n * 动态代理 - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。\n * 注解 - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。\n * 可扩展性功能 - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。\n\n\n# 反射的缺点\n\n * 性能开销 - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。\n * 破坏封装性 - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。\n * 内部曝光 - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。\n\n\n# 反射机制\n\n\n# 类加载过程\n\n\n\n类加载的完整过程如下：\n\n 1. 在编译时，Java 编译器编译好 .java 文件之后，在磁盘中产生 .class 文件。.class 文件是二进制文件，内容是只有 JVM 能够识别的机器码。\n 2. JVM 中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息。类加载器会根据类的全限定名来获取此类的二进制字节流；然后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的 java.lang.Class 对象。\n 3. 加载结束后，JVM 开始进行连接阶段（包含验证、准备、初始化）。经过这一系列操作，类的变量会被初始化。\n\n\n# Class 对象\n\n要想使用反射，首先需要获得待操作的类所对应的 Class 对象。Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。这个 Class 对象是由 JVM 生成的，通过它能够获悉整个类的结构。所以，java.lang.Class 可以视为所有反射 API 的入口点。\n\n反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。\n\n举例来说，假如定义了以下代码：\n\nUser user = new User();\n\n\n步骤说明：\n\n 1. JVM 加载方法的时候，遇到 new User()，JVM 会根据 User 的全限定名去加载 User.class 。\n 2. JVM 会去本地磁盘查找 User.class 文件并加载 JVM 内存中。\n 3. JVM 通过调用类加载器自动创建这个类对应的 Class 对象，并且存储在 JVM 的方法区。注意：一个类有且只有一个 Class 对象。\n\n\n# 方法的反射调用\n\n方法的反射调用，也就是 Method.invoke 方法。\n\nMethod.invoke 方法源码：\n\npublic final class Method extends Executable {\n  ...\n  public Object invoke(Object obj, Object... args) throws ... {\n    ... // 权限检查\n    MethodAccessor ma = methodAccessor;\n    if (ma == null) {\n      ma = acquireMethodAccessor();\n    }\n    return ma.invoke(obj, args);\n  }\n}\n\n\nMethod.invoke 方法实际上委派给 MethodAccessor 接口来处理。它有两个已有的具体实现：\n\n * NativeMethodAccessorImpl：本地方法来实现反射调用\n * DelegatingMethodAccessorImpl：委派模式来实现反射调用\n\n每个 Method 实例的第一次反射调用都会生成一个委派实现（DelegatingMethodAccessorImpl），它所委派的具体实现便是一个本地实现（NativeMethodAccessorImpl）。本地实现非常容易理解。当进入了 Java 虚拟机内部之后，我们便拥有了 Method 实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。\n\n【示例】通过抛出异常方式 打印 Method.invoke 调用轨迹\n\npublic class MethodDemo01 {\n\n    public static void target(int i) {\n        new Exception("#" + i).printStackTrace();\n    }\n\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName("io.github.dunwu.javacore.reflect.MethodDemo01");\n        Method method = clazz.getMethod("target", int.class);\n        method.invoke(null, 0);\n    }\n\n}\n// Output:\n// java.lang.Exception: #0\n//     at io.github.dunwu.javacore.reflect.MethodDemo01.target(MethodDemo01.java:12)\n//     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n//     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\n\n先调用 DelegatingMethodAccessorImpl；然后调用 NativeMethodAccessorImpl，最后调用实际方法。\n\n为什么反射调用DelegatingMethodAccessorImpl 作为中间层，而不是直接交给本地实现？\n\n其实，Java 的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。动态实现和本地实现相比，其运行效率要快上 20 倍。这是因为动态实现无需经过 Java 到 C++ 再到 Java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4 倍。\n\n考虑到许多反射调用仅会执行一次，Java 虚拟机设置了一个阈值 15（可以通过 -Dsun.reflect.inflationThreshold 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Inflation。\n\n【示例】执行 java -verbose:class MethodDemo02 启动\n\npublic class MethodDemo02 {\n\n    public static void target(int i) {\n        new Exception("#" + i).printStackTrace();\n    }\n\n    public static void main(String[] args) throws Exception {\n        Class<?> klass = Class.forName("io.github.dunwu.javacore.reflect.MethodDemo02");\n        Method method = klass.getMethod("target", int.class);\n        for (int i = 0; i < 20; i++) {\n            method.invoke(null, i);\n        }\n    }\n\n}\n\n\n输出内容：\n\n// ...省略\njava.lang.Exception: #14\n        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:13)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:498)\n        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:20)\n[Loaded sun.reflect.ClassFileConstants from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.AccessorGenerator from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.MethodAccessorGenerator from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.ByteVectorFactory from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.ByteVector from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.ByteVectorImpl from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.ClassFileAssembler from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.UTF8 from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.Label from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.Label$PatchInfo from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded java.util.ArrayList$Itr from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.MethodAccessorGenerator$1 from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.ClassDefiner from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.ClassDefiner$1 from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.GeneratedMethodAccessor1 from __JVM_DefineClass__]\njava.lang.Exception: #15\n        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:13)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:498)\n        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:20)\n[Loaded java.util.concurrent.ConcurrentHashMap$ForwardingNode from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\njava.lang.Exception: #16\n        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:13)\n        at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:498)\n        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:20)\n// ...省略\n\n\n可以看到，从第 16 次开始后，都是使用 DelegatingMethodAccessorImpl ，不再使用本地实现 NativeMethodAccessorImpl。\n\n\n# 反射调用的开销\n\n方法的反射调用会带来不少性能开销，原因主要有三个：\n\n * 变长参数方法导致的 Object 数组\n * 基本类型的自动装箱、拆箱\n * 还有最重要的方法内联\n\nClass.forName 会调用本地方法，Class.getMethod 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。\n\n> 注意，以 getMethod 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 Method 数组的 getMethods 或者 getDeclaredMethods 方法，以减少不必要的堆空间消耗。在实践中，我们往往会在应用程序中缓存 Class.forName 和 Class.getMethod 的结果。\n\n下面只关注反射调用本身的性能开销。\n\n第一，由于 Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组（感兴趣的同学私下可以用 javap 查看）。Java 编译器会在方法调用处生成一个长度为传入参数数量的 Object 数组，并将传入参数一一存储进该数组中。\n\n第二，由于 Object 数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱。\n\n这两个操作除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。（如果你感兴趣的话，可以用虚拟机参数 -XX:+PrintGC 试试。）那么，如何消除这部分开销呢？\n\n\n# 使用反射\n\n\n# java.lang.reflect 包\n\nJava 中的 java.lang.reflect 包提供了反射功能。java.lang.reflect 包中的类都没有 public 构造方法。\n\njava.lang.reflect 包的核心接口和类如下：\n\n * Member 接口：反映关于单个成员(字段或方法)或构造函数的标识信息。\n * Field 类：提供一个类的域的信息以及访问类的域的接口。\n * Method 类：提供一个类的方法的信息以及访问类的方法的接口。\n * Constructor 类：提供一个类的构造函数的信息以及访问类的构造函数的接口。\n * Array 类：该类提供动态地生成和访问 JAVA 数组的方法。\n * Modifier 类：提供了 static 方法和常量，对类和成员访问修饰符进行解码。\n * Proxy 类：提供动态地生成代理类和类实例的静态方法。\n\n\n# 获取 Class 对象\n\n获取 Class 对象的三种方法：\n\n（1）Class.forName 静态方法\n\n【示例】使用 Class.forName 静态方法获取 Class 对象\n\npackage io.github.dunwu.javacore.reflect;\n\npublic class ReflectClassDemo01 {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Class c1 = Class.forName("io.github.dunwu.javacore.reflect.ReflectClassDemo01");\n        System.out.println(c1.getCanonicalName());\n\n        Class c2 = Class.forName("[D");\n        System.out.println(c2.getCanonicalName());\n\n        Class c3 = Class.forName("[[Ljava.lang.String;");\n        System.out.println(c3.getCanonicalName());\n    }\n}\n//Output:\n//io.github.dunwu.javacore.reflect.ReflectClassDemo01\n//double[]\n//java.lang.String[][]\n\n\n使用类的完全限定名来反射对象的类。常见的应用场景为：在 JDBC 开发中常用此方法加载数据库驱动。\n\n（2）类名 + .class\n\n【示例】直接用类名 + .class 获取 Class 对象\n\npublic class ReflectClassDemo02 {\n    public static void main(String[] args) {\n        boolean b;\n        // Class c = b.getClass(); // 编译错误\n        Class c1 = boolean.class;\n        System.out.println(c1.getCanonicalName());\n\n        Class c2 = java.io.PrintStream.class;\n        System.out.println(c2.getCanonicalName());\n\n        Class c3 = int[][][].class;\n        System.out.println(c3.getCanonicalName());\n    }\n}\n//Output:\n//boolean\n//java.io.PrintStream\n//int[][][]\n\n\n（3）Object 的 getClass 方法\n\nObject 类中有 getClass 方法，因为所有类都继承 Object 类。从而调用 Object 类来获取 Class 对象。\n\n【示例】Object 的 getClass 方法获取 Class 对象\n\npackage io.github.dunwu.javacore.reflect;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class ReflectClassDemo03 {\n    enum E {A, B}\n\n    public static void main(String[] args) {\n        Class c = "foo".getClass();\n        System.out.println(c.getCanonicalName());\n\n        Class c2 = ReflectClassDemo03.E.A.getClass();\n        System.out.println(c2.getCanonicalName());\n\n        byte[] bytes = new byte[1024];\n        Class c3 = bytes.getClass();\n        System.out.println(c3.getCanonicalName());\n\n        Set<String> set = new HashSet<>();\n        Class c4 = set.getClass();\n        System.out.println(c4.getCanonicalName());\n    }\n}\n//Output:\n//java.lang.String\n//io.github.dunwu.javacore.reflect.ReflectClassDemo.E\n//byte[]\n//java.util.HashSet\n\n\n\n# 判断是否为某个类的实例\n\n判断是否为某个类的实例有两种方式：\n\n 1. 用 instanceof 关键字\n 2. 用 Class 对象的 isInstance 方法（它是一个 Native 方法）\n\n【示例】\n\npublic class InstanceofDemo {\n    public static void main(String[] args) {\n        ArrayList arrayList = new ArrayList();\n        if (arrayList instanceof List) {\n            System.out.println("ArrayList is List");\n        }\n        if (List.class.isInstance(arrayList)) {\n            System.out.println("ArrayList is List");\n        }\n    }\n}\n//Output:\n//ArrayList is List\n//ArrayList is List\n\n\n\n# 创建实例\n\n通过反射来创建实例对象主要有两种方式：\n\n * 用 Class 对象的 newInstance 方法。\n * 用 Constructor 对象的 newInstance 方法。\n\n【示例】\n\npublic class NewInstanceDemo {\n    public static void main(String[] args)\n        throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n        Class<?> c1 = StringBuilder.class;\n        StringBuilder sb = (StringBuilder) c1.newInstance();\n        sb.append("aaa");\n        System.out.println(sb.toString());\n\n        //获取String所对应的Class对象\n        Class<?> c2 = String.class;\n        //获取String类带一个String参数的构造器\n        Constructor constructor = c2.getConstructor(String.class);\n        //根据构造器创建实例\n        String str2 = (String) constructor.newInstance("bbb");\n        System.out.println(str2);\n    }\n}\n//Output:\n//aaa\n//bbb\n\n\n\n# 创建数组实例\n\n数组在 Java 里是比较特殊的一种类型，它可以赋值给一个对象引用。Java 中，通过 Array.newInstance 创建数组的实例。\n\n【示例】利用反射创建数组\n\npublic class ReflectArrayDemo {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Class<?> cls = Class.forName("java.lang.String");\n        Object array = Array.newInstance(cls, 25);\n        //往数组里添加内容\n        Array.set(array, 0, "Scala");\n        Array.set(array, 1, "Java");\n        Array.set(array, 2, "Groovy");\n        Array.set(array, 3, "Scala");\n        Array.set(array, 4, "Clojure");\n        //获取某一项的内容\n        System.out.println(Array.get(array, 3));\n    }\n}\n//Output:\n//Scala\n\n\n其中的 Array 类为 java.lang.reflect.Array 类。我们Array.newInstance 的原型是：\n\npublic static Object newInstance(Class<?> componentType, int length)\n    throws NegativeArraySizeException {\n    return newArray(componentType, length);\n}\n\n\n\n# Field\n\nClass 对象提供以下方法获取对象的成员（Field）：\n\n * getFiled - 根据名称获取公有的（public）类成员。\n * getDeclaredField - 根据名称获取已声明的类成员。但不能得到其父类的类成员。\n * getFields - 获取所有公有的（public）类成员。\n * getDeclaredFields - 获取所有已声明的类成员。\n\n示例如下：\n\npublic class ReflectFieldDemo {\n    class FieldSpy<T> {\n        public boolean[][] b = { {false, false}, {true, true} };\n        public String name = "Alice";\n        public List<Integer> list;\n        public T val;\n    }\n\n    public static void main(String[] args) throws NoSuchFieldException {\n        Field f1 = FieldSpy.class.getField("b");\n        System.out.format("Type: %s%n", f1.getType());\n\n        Field f2 = FieldSpy.class.getField("name");\n        System.out.format("Type: %s%n", f2.getType());\n\n        Field f3 = FieldSpy.class.getField("list");\n        System.out.format("Type: %s%n", f3.getType());\n\n        Field f4 = FieldSpy.class.getField("val");\n        System.out.format("Type: %s%n", f4.getType());\n    }\n}\n//Output:\n//Type: class [[Z\n//Type: class java.lang.String\n//Type: interface java.util.List\n//Type: class java.lang.Object\n\n\n\n# Method\n\nClass 对象提供以下方法获取对象的方法（Method）：\n\n * getMethod - 返回类或接口的特定方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。\n * getDeclaredMethod - 返回类或接口的特定声明方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。\n * getMethods - 返回类或接口的所有 public 方法，包括其父类的 public 方法。\n * getDeclaredMethods - 返回类或接口声明的所有方法，包括 public、protected、默认（包）访问和 private 方法，但不包括继承的方法。\n\n获取一个 Method 对象后，可以用 invoke 方法来调用这个方法。\n\ninvoke 方法的原型为:\n\npublic Object invoke(Object obj, Object... args)\n        throws IllegalAccessException, IllegalArgumentException,\n           InvocationTargetException\n\n\n【示例】\n\npublic class ReflectMethodDemo {\n    public static void main(String[] args)\n        throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n\n        // 返回所有方法\n        Method[] methods1 = System.class.getDeclaredMethods();\n        System.out.println("System getDeclaredMethods 清单（数量 = " + methods1.length + "）：");\n        for (Method m : methods1) {\n            System.out.println(m);\n        }\n\n        // 返回所有 public 方法\n        Method[] methods2 = System.class.getMethods();\n        System.out.println("System getMethods 清单（数量 = " + methods2.length + "）：");\n        for (Method m : methods2) {\n            System.out.println(m);\n        }\n\n        // 利用 Method 的 invoke 方法调用 System.currentTimeMillis()\n        Method method = System.class.getMethod("currentTimeMillis");\n        System.out.println(method);\n        System.out.println(method.invoke(null));\n    }\n}\n\n\n\n# Constructor\n\nClass 对象提供以下方法获取对象的构造方法（Constructor）：\n\n * getConstructor - 返回类的特定 public 构造方法。参数为方法参数对应 Class 的对象。\n * getDeclaredConstructor - 返回类的特定构造方法。参数为方法参数对应 Class 的对象。\n * getConstructors - 返回类的所有 public 构造方法。\n * getDeclaredConstructors - 返回类的所有构造方法。\n\n获取一个 Constructor 对象后，可以用 newInstance 方法来创建类实例。\n\n【示例】\n\npublic class ReflectMethodConstructorDemo {\n    public static void main(String[] args)\n        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        Constructor<?>[] constructors1 = String.class.getDeclaredConstructors();\n        System.out.println("String getDeclaredConstructors 清单（数量 = " + constructors1.length + "）：");\n        for (Constructor c : constructors1) {\n            System.out.println(c);\n        }\n\n        Constructor<?>[] constructors2 = String.class.getConstructors();\n        System.out.println("String getConstructors 清单（数量 = " + constructors2.length + "）：");\n        for (Constructor c : constructors2) {\n            System.out.println(c);\n        }\n\n        System.out.println("====================");\n        Constructor constructor = String.class.getConstructor(String.class);\n        System.out.println(constructor);\n        String str = (String) constructor.newInstance("bbb");\n        System.out.println(str);\n    }\n}\n\n\n\n# 绕开访问限制\n\n有时候，我们需要通过反射访问私有成员、方法。可以使用 Constructor/Field/Method.setAccessible(true) 来绕开 Java 语言的访问限制。\n\n\n# 动态代理\n\n动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。\n\n实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。\n\n\n\n\n# 静态代理\n\n> 静态代理其实就是指设计模式中的代理模式。\n> \n> 代理模式为其他对象提供一种代理以控制对这个对象的访问。\n\n\n\nSubject 定义了 RealSubject 和 Proxy 的公共接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy 。\n\nabstract class Subject {\n    public abstract void Request();\n}\n\n\nRealSubject 定义 Proxy 所代表的真实实体。\n\nclass RealSubject extends Subject {\n    @Override\n    public void Request() {\n        System.out.println("真实的请求");\n    }\n}\n\n\nProxy 保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。\n\nclass Proxy extends Subject {\n    private RealSubject real;\n\n    @Override\n    public void Request() {\n        if (null == real) {\n            real = new RealSubject();\n        }\n        real.Request();\n    }\n}\n\n\n> 说明：\n> \n> 静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 Proxy 和 RealSubject 的功能本质上是相同的，Proxy 只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。\n\n\n# JDK 动态代理\n\n为了解决静态代理的问题，就有了创建动态代理的想法：\n\n在运行状态中，需要代理的地方，根据 Subject 和 RealSubject，动态地创建一个 Proxy，用完之后，就会销毁，这样就可以避免了 Proxy 角色的 class 在系统中冗杂的问题了。\n\n\n\nJava 动态代理基于经典代理模式，引入了一个 InvocationHandler，InvocationHandler 负责统一管理所有的方法调用。\n\n动态代理步骤：\n\n 1. 获取 RealSubject 上的所有接口列表；\n 2. 确定要生成的代理类的类名，默认为：com.sun.proxy.$ProxyXXXX；\n 3. 根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；\n 4. 将对应的字节码转换为对应的 class 对象；\n 5. 创建 InvocationHandler 实例 handler，用来处理 Proxy 所有方法调用；\n 6. Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。\n\n从上面可以看出，JDK 动态代理的实现是基于实现接口的方式，使得 Proxy 和 RealSubject 具有相同的功能。\n\n但其实还有一种思路：通过继承。即：让 Proxy 继承 RealSubject，这样二者同样具有相同的功能，Proxy 还可以通过重写 RealSubject 中的方法，来实现多态。CGLIB 就是基于这种思路设计的。\n\n在 Java 的动态代理机制中，有两个重要的类（接口），一个是 InvocationHandler 接口、另一个则是 Proxy 类，这一个类和一个接口是实现我们动态代理所必须用到的。\n\n# InvocationHandler 接口\n\nInvocationHandler 接口定义：\n\npublic interface InvocationHandler {\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n}\n\n\n每一个动态代理类都必须要实现 InvocationHandler 这个接口，并且每个代理类的实例都关联到了一个 Handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 InvocationHandler 这个接口的 invoke 方法来进行调用。\n\n我们来看看 InvocationHandler 这个接口的唯一一个方法 invoke 方法：\n\nObject invoke(Object proxy, Method method, Object[] args) throws Throwable\n\n\n参数说明：\n\n * proxy - 代理的真实对象。\n * method - 所要调用真实对象的某个方法的 Method 对象\n * args - 所要调用真实对象某个方法时接受的参数\n\n如果不是很明白，等下通过一个实例会对这几个参数进行更深的讲解。\n\n# Proxy 类\n\nProxy 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法：\n\npublic static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,  InvocationHandler h)  throws IllegalArgumentException\n\n\n这个方法的作用就是得到一个动态的代理对象。\n\n参数说明：\n\n * loader - 一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载。\n * interfaces - 一个 Class<?> 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了\n * h - 一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上\n\n# JDK 动态代理实例\n\n上面的内容介绍完这两个接口(类)以后，我们来通过一个实例来看看我们的动态代理模式是什么样的：\n\n首先我们定义了一个 Subject 类型的接口，为其声明了两个方法：\n\npublic interface Subject {\n\n    void hello(String str);\n\n    String bye();\n}\n\n\n接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject 类：\n\npublic class RealSubject implements Subject {\n\n    @Override\n    public void hello(String str) {\n        System.out.println("Hello  " + str);\n    }\n\n    @Override\n    public String bye() {\n        System.out.println("Goodbye");\n        return "Over";\n    }\n}\n\n\n下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外：\n\npublic class InvocationHandlerDemo implements InvocationHandler {\n    // 这个就是我们要代理的真实对象\n    private Object subject;\n\n    // 构造方法，给我们要代理的真实对象赋初值\n    public InvocationHandlerDemo(Object subject) {\n        this.subject = subject;\n    }\n\n    @Override\n    public Object invoke(Object object, Method method, Object[] args)\n        throws Throwable {\n        // 在代理真实对象前我们可以添加一些自己的操作\n        System.out.println("Before method");\n\n        System.out.println("Call Method: " + method);\n\n        // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用\n        Object obj = method.invoke(subject, args);\n\n        // 在代理真实对象后我们也可以添加一些自己的操作\n        System.out.println("After method");\n        System.out.println();\n\n        return obj;\n    }\n}\n\n\n最后，来看看我们的 Client 类：\n\npublic class Client {\n    public static void main(String[] args) {\n        // 我们要代理的真实对象\n        Subject realSubject = new RealSubject();\n\n        // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的\n        InvocationHandler handler = new InvocationHandlerDemo(realSubject);\n\n        /*\n         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数\n         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象\n         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了\n         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上\n         */\n        Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject\n                .getClass().getInterfaces(), handler);\n\n        System.out.println(subject.getClass().getName());\n        subject.hello("World");\n        String result = subject.bye();\n        System.out.println("Result is: " + result);\n    }\n}\n\n\n我们先来看看控制台的输出：\n\ncom.sun.proxy.$Proxy0\nBefore method\nCall Method: public abstract void io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)\nHello  World\nAfter method\n\nBefore method\nCall Method: public abstract java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()\nGoodbye\nAfter method\n\nResult is: Over\n\n\n我们首先来看看 com.sun.proxy.$Proxy0 这东西，我们看到，这个东西是由 System.out.println(subject.getClass().getName()); 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？\n\nSubject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject\n                .getClass().getInterfaces(), handler);\n\n\n可能我以为返回的这个代理对象会是 Subject 类型的对象，或者是 InvocationHandler 的对象，结果却不是，首先我们解释一下为什么我们这里可以将其转化为 Subject 类型的对象？\n\n原因就是：在 newProxyInstance 这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是 Subject 类型，所以就可以将其转化为 Subject 类型了。\n\n同时我们一定要记住，通过 Proxy.newProxyInstance 创建的代理对象是在 jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy 为中，最后一个数字表示对象的标号。\n\n接着我们来看看这两句\n\nsubject.hello("World");\nString result = subject.bye();\n\n\n这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的 invoke 方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject 类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的 invoke 方法去执行。\n\n我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：\n\npublic abstract void io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)\npublic abstract java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()\n\n\n正好就是我们的 Subject 接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的 invoke 方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。\n\n# JDK 动态代理小结\n\n代理类与委托类实现同一接口，主要是通过代理类实现 InvocationHandler 并重写 invoke 方法来进行动态代理的，在 invoke 方法中将对方法进行处理。\n\nJDK 动态代理特点：\n\n * 优点：相对于静态代理模式，不需要硬编码接口，代码复用率高。\n\n * 缺点：强制要求代理类实现 InvocationHandler 接口。\n\n\n# CGLIB 动态代理\n\nCGLIB 提供了与 JDK 动态代理不同的方案。很多框架，例如 Spring AOP 中，就使用了 CGLIB 动态代理。\n\nCGLIB 底层，其实是借助了 ASM 这个强大的 Java 字节码框架去进行字节码增强操作。\n\nCGLIB 动态代理的工作步骤：\n\n * 生成代理类的二进制字节码文件；\n * 加载二进制字节码，生成 Class 对象( 例如使用 Class.forName() 方法 )；\n * 通过反射机制获得实例构造，并创建代理类对象。\n\nCGLIB 动态代理特点：\n\n优点：使用字节码增强，比 JDK 动态代理方式性能高。可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口。\n\n缺点：不能对 final 类以及 final 方法进行代理。\n\n> 参考：深入理解 CGLIB 动态代理机制\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * 深入拆解 Java 虚拟机\n * 深入解析 Java 反射（1） - 基础\n * Java 基础之—反射（非常重要）\n * 官方 Reflection API 文档\n * Java 的动态代理机制详解\n * Java 动态代理机制详解（JDK 和 CGLIB，Javassist，ASM）\n * 深入理解 JDK 动态代理机制\n * 深入理解 CGLIB 动态代理机制',normalizedContent:'# 深入理解 java 反射和动态代理\n\n\n# 反射简介\n\n\n\n\n# 什么是反射\n\n反射(reflection)是 java 程序开发语言的特征之一，它允许运行中的 java 程序获取自身的信息，并且可以操作类或对象的内部属性。\n\n通过反射机制，可以在运行时访问 java 对象的属性，方法，构造方法等。\n\n\n# 反射的应用场景\n\n反射的主要应用场景有：\n\n * 开发通用框架 - 反射最重要的用途就是开发各种通用框架。很多框架（比如 spring）都是配置化的（比如通过 xml 文件配置 javabean、filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。\n * 动态代理 - 在切面编程（aop）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。\n * 注解 - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。\n * 可扩展性功能 - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。\n\n\n# 反射的缺点\n\n * 性能开销 - 由于反射涉及动态解析的类型，因此无法执行某些 java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。\n * 破坏封装性 - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。\n * 内部曝光 - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。\n\n\n# 反射机制\n\n\n# 类加载过程\n\n\n\n类加载的完整过程如下：\n\n 1. 在编译时，java 编译器编译好 .java 文件之后，在磁盘中产生 .class 文件。.class 文件是二进制文件，内容是只有 jvm 能够识别的机器码。\n 2. jvm 中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息。类加载器会根据类的全限定名来获取此类的二进制字节流；然后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的 java.lang.class 对象。\n 3. 加载结束后，jvm 开始进行连接阶段（包含验证、准备、初始化）。经过这一系列操作，类的变量会被初始化。\n\n\n# class 对象\n\n要想使用反射，首先需要获得待操作的类所对应的 class 对象。java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 class 对象。这个 class 对象是由 jvm 生成的，通过它能够获悉整个类的结构。所以，java.lang.class 可以视为所有反射 api 的入口点。\n\n反射的本质就是：在运行时，把 java 类中的各种成分映射成一个个的 java 对象。\n\n举例来说，假如定义了以下代码：\n\nuser user = new user();\n\n\n步骤说明：\n\n 1. jvm 加载方法的时候，遇到 new user()，jvm 会根据 user 的全限定名去加载 user.class 。\n 2. jvm 会去本地磁盘查找 user.class 文件并加载 jvm 内存中。\n 3. jvm 通过调用类加载器自动创建这个类对应的 class 对象，并且存储在 jvm 的方法区。注意：一个类有且只有一个 class 对象。\n\n\n# 方法的反射调用\n\n方法的反射调用，也就是 method.invoke 方法。\n\nmethod.invoke 方法源码：\n\npublic final class method extends executable {\n  ...\n  public object invoke(object obj, object... args) throws ... {\n    ... // 权限检查\n    methodaccessor ma = methodaccessor;\n    if (ma == null) {\n      ma = acquiremethodaccessor();\n    }\n    return ma.invoke(obj, args);\n  }\n}\n\n\nmethod.invoke 方法实际上委派给 methodaccessor 接口来处理。它有两个已有的具体实现：\n\n * nativemethodaccessorimpl：本地方法来实现反射调用\n * delegatingmethodaccessorimpl：委派模式来实现反射调用\n\n每个 method 实例的第一次反射调用都会生成一个委派实现（delegatingmethodaccessorimpl），它所委派的具体实现便是一个本地实现（nativemethodaccessorimpl）。本地实现非常容易理解。当进入了 java 虚拟机内部之后，我们便拥有了 method 实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。\n\n【示例】通过抛出异常方式 打印 method.invoke 调用轨迹\n\npublic class methoddemo01 {\n\n    public static void target(int i) {\n        new exception("#" + i).printstacktrace();\n    }\n\n    public static void main(string[] args) throws exception {\n        class<?> clazz = class.forname("io.github.dunwu.javacore.reflect.methoddemo01");\n        method method = clazz.getmethod("target", int.class);\n        method.invoke(null, 0);\n    }\n\n}\n// output:\n// java.lang.exception: #0\n//     at io.github.dunwu.javacore.reflect.methoddemo01.target(methoddemo01.java:12)\n//     at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\n//     at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\n\n\n先调用 delegatingmethodaccessorimpl；然后调用 nativemethodaccessorimpl，最后调用实际方法。\n\n为什么反射调用delegatingmethodaccessorimpl 作为中间层，而不是直接交给本地实现？\n\n其实，java 的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。动态实现和本地实现相比，其运行效率要快上 20 倍。这是因为动态实现无需经过 java 到 c++ 再到 java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4 倍。\n\n考虑到许多反射调用仅会执行一次，java 虚拟机设置了一个阈值 15（可以通过 -dsun.reflect.inflationthreshold 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 inflation。\n\n【示例】执行 java -verbose:class methoddemo02 启动\n\npublic class methoddemo02 {\n\n    public static void target(int i) {\n        new exception("#" + i).printstacktrace();\n    }\n\n    public static void main(string[] args) throws exception {\n        class<?> klass = class.forname("io.github.dunwu.javacore.reflect.methoddemo02");\n        method method = klass.getmethod("target", int.class);\n        for (int i = 0; i < 20; i++) {\n            method.invoke(null, i);\n        }\n    }\n\n}\n\n\n输出内容：\n\n// ...省略\njava.lang.exception: #14\n        at io.github.dunwu.javacore.reflect.methoddemo02.target(methoddemo02.java:13)\n        at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\n        at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\n        at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\n        at java.lang.reflect.method.invoke(method.java:498)\n        at io.github.dunwu.javacore.reflect.methoddemo02.main(methoddemo02.java:20)\n[loaded sun.reflect.classfileconstants from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.accessorgenerator from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.methodaccessorgenerator from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.bytevectorfactory from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.bytevector from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.bytevectorimpl from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.classfileassembler from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.utf8 from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.label from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.label$patchinfo from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded java.util.arraylist$itr from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.methodaccessorgenerator$1 from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.classdefiner from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.classdefiner$1 from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.generatedmethodaccessor1 from __jvm_defineclass__]\njava.lang.exception: #15\n        at io.github.dunwu.javacore.reflect.methoddemo02.target(methoddemo02.java:13)\n        at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\n        at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\n        at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\n        at java.lang.reflect.method.invoke(method.java:498)\n        at io.github.dunwu.javacore.reflect.methoddemo02.main(methoddemo02.java:20)\n[loaded java.util.concurrent.concurrenthashmap$forwardingnode from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\njava.lang.exception: #16\n        at io.github.dunwu.javacore.reflect.methoddemo02.target(methoddemo02.java:13)\n        at sun.reflect.generatedmethodaccessor1.invoke(unknown source)\n        at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\n        at java.lang.reflect.method.invoke(method.java:498)\n        at io.github.dunwu.javacore.reflect.methoddemo02.main(methoddemo02.java:20)\n// ...省略\n\n\n可以看到，从第 16 次开始后，都是使用 delegatingmethodaccessorimpl ，不再使用本地实现 nativemethodaccessorimpl。\n\n\n# 反射调用的开销\n\n方法的反射调用会带来不少性能开销，原因主要有三个：\n\n * 变长参数方法导致的 object 数组\n * 基本类型的自动装箱、拆箱\n * 还有最重要的方法内联\n\nclass.forname 会调用本地方法，class.getmethod 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。\n\n> 注意，以 getmethod 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 method 数组的 getmethods 或者 getdeclaredmethods 方法，以减少不必要的堆空间消耗。在实践中，我们往往会在应用程序中缓存 class.forname 和 class.getmethod 的结果。\n\n下面只关注反射调用本身的性能开销。\n\n第一，由于 method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 object 数组（感兴趣的同学私下可以用 javap 查看）。java 编译器会在方法调用处生成一个长度为传入参数数量的 object 数组，并将传入参数一一存储进该数组中。\n\n第二，由于 object 数组不能存储基本类型，java 编译器会对传入的基本类型参数进行自动装箱。\n\n这两个操作除了带来性能开销外，还可能占用堆内存，使得 gc 更加频繁。（如果你感兴趣的话，可以用虚拟机参数 -xx:+printgc 试试。）那么，如何消除这部分开销呢？\n\n\n# 使用反射\n\n\n# java.lang.reflect 包\n\njava 中的 java.lang.reflect 包提供了反射功能。java.lang.reflect 包中的类都没有 public 构造方法。\n\njava.lang.reflect 包的核心接口和类如下：\n\n * member 接口：反映关于单个成员(字段或方法)或构造函数的标识信息。\n * field 类：提供一个类的域的信息以及访问类的域的接口。\n * method 类：提供一个类的方法的信息以及访问类的方法的接口。\n * constructor 类：提供一个类的构造函数的信息以及访问类的构造函数的接口。\n * array 类：该类提供动态地生成和访问 java 数组的方法。\n * modifier 类：提供了 static 方法和常量，对类和成员访问修饰符进行解码。\n * proxy 类：提供动态地生成代理类和类实例的静态方法。\n\n\n# 获取 class 对象\n\n获取 class 对象的三种方法：\n\n（1）class.forname 静态方法\n\n【示例】使用 class.forname 静态方法获取 class 对象\n\npackage io.github.dunwu.javacore.reflect;\n\npublic class reflectclassdemo01 {\n    public static void main(string[] args) throws classnotfoundexception {\n        class c1 = class.forname("io.github.dunwu.javacore.reflect.reflectclassdemo01");\n        system.out.println(c1.getcanonicalname());\n\n        class c2 = class.forname("[d");\n        system.out.println(c2.getcanonicalname());\n\n        class c3 = class.forname("[[ljava.lang.string;");\n        system.out.println(c3.getcanonicalname());\n    }\n}\n//output:\n//io.github.dunwu.javacore.reflect.reflectclassdemo01\n//double[]\n//java.lang.string[][]\n\n\n使用类的完全限定名来反射对象的类。常见的应用场景为：在 jdbc 开发中常用此方法加载数据库驱动。\n\n（2）类名 + .class\n\n【示例】直接用类名 + .class 获取 class 对象\n\npublic class reflectclassdemo02 {\n    public static void main(string[] args) {\n        boolean b;\n        // class c = b.getclass(); // 编译错误\n        class c1 = boolean.class;\n        system.out.println(c1.getcanonicalname());\n\n        class c2 = java.io.printstream.class;\n        system.out.println(c2.getcanonicalname());\n\n        class c3 = int[][][].class;\n        system.out.println(c3.getcanonicalname());\n    }\n}\n//output:\n//boolean\n//java.io.printstream\n//int[][][]\n\n\n（3）object 的 getclass 方法\n\nobject 类中有 getclass 方法，因为所有类都继承 object 类。从而调用 object 类来获取 class 对象。\n\n【示例】object 的 getclass 方法获取 class 对象\n\npackage io.github.dunwu.javacore.reflect;\n\nimport java.util.hashset;\nimport java.util.set;\n\npublic class reflectclassdemo03 {\n    enum e {a, b}\n\n    public static void main(string[] args) {\n        class c = "foo".getclass();\n        system.out.println(c.getcanonicalname());\n\n        class c2 = reflectclassdemo03.e.a.getclass();\n        system.out.println(c2.getcanonicalname());\n\n        byte[] bytes = new byte[1024];\n        class c3 = bytes.getclass();\n        system.out.println(c3.getcanonicalname());\n\n        set<string> set = new hashset<>();\n        class c4 = set.getclass();\n        system.out.println(c4.getcanonicalname());\n    }\n}\n//output:\n//java.lang.string\n//io.github.dunwu.javacore.reflect.reflectclassdemo.e\n//byte[]\n//java.util.hashset\n\n\n\n# 判断是否为某个类的实例\n\n判断是否为某个类的实例有两种方式：\n\n 1. 用 instanceof 关键字\n 2. 用 class 对象的 isinstance 方法（它是一个 native 方法）\n\n【示例】\n\npublic class instanceofdemo {\n    public static void main(string[] args) {\n        arraylist arraylist = new arraylist();\n        if (arraylist instanceof list) {\n            system.out.println("arraylist is list");\n        }\n        if (list.class.isinstance(arraylist)) {\n            system.out.println("arraylist is list");\n        }\n    }\n}\n//output:\n//arraylist is list\n//arraylist is list\n\n\n\n# 创建实例\n\n通过反射来创建实例对象主要有两种方式：\n\n * 用 class 对象的 newinstance 方法。\n * 用 constructor 对象的 newinstance 方法。\n\n【示例】\n\npublic class newinstancedemo {\n    public static void main(string[] args)\n        throws illegalaccessexception, instantiationexception, nosuchmethodexception, invocationtargetexception {\n        class<?> c1 = stringbuilder.class;\n        stringbuilder sb = (stringbuilder) c1.newinstance();\n        sb.append("aaa");\n        system.out.println(sb.tostring());\n\n        //获取string所对应的class对象\n        class<?> c2 = string.class;\n        //获取string类带一个string参数的构造器\n        constructor constructor = c2.getconstructor(string.class);\n        //根据构造器创建实例\n        string str2 = (string) constructor.newinstance("bbb");\n        system.out.println(str2);\n    }\n}\n//output:\n//aaa\n//bbb\n\n\n\n# 创建数组实例\n\n数组在 java 里是比较特殊的一种类型，它可以赋值给一个对象引用。java 中，通过 array.newinstance 创建数组的实例。\n\n【示例】利用反射创建数组\n\npublic class reflectarraydemo {\n    public static void main(string[] args) throws classnotfoundexception {\n        class<?> cls = class.forname("java.lang.string");\n        object array = array.newinstance(cls, 25);\n        //往数组里添加内容\n        array.set(array, 0, "scala");\n        array.set(array, 1, "java");\n        array.set(array, 2, "groovy");\n        array.set(array, 3, "scala");\n        array.set(array, 4, "clojure");\n        //获取某一项的内容\n        system.out.println(array.get(array, 3));\n    }\n}\n//output:\n//scala\n\n\n其中的 array 类为 java.lang.reflect.array 类。我们array.newinstance 的原型是：\n\npublic static object newinstance(class<?> componenttype, int length)\n    throws negativearraysizeexception {\n    return newarray(componenttype, length);\n}\n\n\n\n# field\n\nclass 对象提供以下方法获取对象的成员（field）：\n\n * getfiled - 根据名称获取公有的（public）类成员。\n * getdeclaredfield - 根据名称获取已声明的类成员。但不能得到其父类的类成员。\n * getfields - 获取所有公有的（public）类成员。\n * getdeclaredfields - 获取所有已声明的类成员。\n\n示例如下：\n\npublic class reflectfielddemo {\n    class fieldspy<t> {\n        public boolean[][] b = { {false, false}, {true, true} };\n        public string name = "alice";\n        public list<integer> list;\n        public t val;\n    }\n\n    public static void main(string[] args) throws nosuchfieldexception {\n        field f1 = fieldspy.class.getfield("b");\n        system.out.format("type: %s%n", f1.gettype());\n\n        field f2 = fieldspy.class.getfield("name");\n        system.out.format("type: %s%n", f2.gettype());\n\n        field f3 = fieldspy.class.getfield("list");\n        system.out.format("type: %s%n", f3.gettype());\n\n        field f4 = fieldspy.class.getfield("val");\n        system.out.format("type: %s%n", f4.gettype());\n    }\n}\n//output:\n//type: class [[z\n//type: class java.lang.string\n//type: interface java.util.list\n//type: class java.lang.object\n\n\n\n# method\n\nclass 对象提供以下方法获取对象的方法（method）：\n\n * getmethod - 返回类或接口的特定方法。其中第一个参数为方法名称，后面的参数为方法参数对应 class 的对象。\n * getdeclaredmethod - 返回类或接口的特定声明方法。其中第一个参数为方法名称，后面的参数为方法参数对应 class 的对象。\n * getmethods - 返回类或接口的所有 public 方法，包括其父类的 public 方法。\n * getdeclaredmethods - 返回类或接口声明的所有方法，包括 public、protected、默认（包）访问和 private 方法，但不包括继承的方法。\n\n获取一个 method 对象后，可以用 invoke 方法来调用这个方法。\n\ninvoke 方法的原型为:\n\npublic object invoke(object obj, object... args)\n        throws illegalaccessexception, illegalargumentexception,\n           invocationtargetexception\n\n\n【示例】\n\npublic class reflectmethoddemo {\n    public static void main(string[] args)\n        throws nosuchmethodexception, invocationtargetexception, illegalaccessexception {\n\n        // 返回所有方法\n        method[] methods1 = system.class.getdeclaredmethods();\n        system.out.println("system getdeclaredmethods 清单（数量 = " + methods1.length + "）：");\n        for (method m : methods1) {\n            system.out.println(m);\n        }\n\n        // 返回所有 public 方法\n        method[] methods2 = system.class.getmethods();\n        system.out.println("system getmethods 清单（数量 = " + methods2.length + "）：");\n        for (method m : methods2) {\n            system.out.println(m);\n        }\n\n        // 利用 method 的 invoke 方法调用 system.currenttimemillis()\n        method method = system.class.getmethod("currenttimemillis");\n        system.out.println(method);\n        system.out.println(method.invoke(null));\n    }\n}\n\n\n\n# constructor\n\nclass 对象提供以下方法获取对象的构造方法（constructor）：\n\n * getconstructor - 返回类的特定 public 构造方法。参数为方法参数对应 class 的对象。\n * getdeclaredconstructor - 返回类的特定构造方法。参数为方法参数对应 class 的对象。\n * getconstructors - 返回类的所有 public 构造方法。\n * getdeclaredconstructors - 返回类的所有构造方法。\n\n获取一个 constructor 对象后，可以用 newinstance 方法来创建类实例。\n\n【示例】\n\npublic class reflectmethodconstructordemo {\n    public static void main(string[] args)\n        throws nosuchmethodexception, illegalaccessexception, invocationtargetexception, instantiationexception {\n        constructor<?>[] constructors1 = string.class.getdeclaredconstructors();\n        system.out.println("string getdeclaredconstructors 清单（数量 = " + constructors1.length + "）：");\n        for (constructor c : constructors1) {\n            system.out.println(c);\n        }\n\n        constructor<?>[] constructors2 = string.class.getconstructors();\n        system.out.println("string getconstructors 清单（数量 = " + constructors2.length + "）：");\n        for (constructor c : constructors2) {\n            system.out.println(c);\n        }\n\n        system.out.println("====================");\n        constructor constructor = string.class.getconstructor(string.class);\n        system.out.println(constructor);\n        string str = (string) constructor.newinstance("bbb");\n        system.out.println(str);\n    }\n}\n\n\n\n# 绕开访问限制\n\n有时候，我们需要通过反射访问私有成员、方法。可以使用 constructor/field/method.setaccessible(true) 来绕开 java 语言的访问限制。\n\n\n# 动态代理\n\n动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 rpc 调用、面向切面的编程（aop）。\n\n实现动态代理的方式很多，比如 jdk 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 asm、cglib（基于 asm）、javassist 等。\n\n\n\n\n# 静态代理\n\n> 静态代理其实就是指设计模式中的代理模式。\n> \n> 代理模式为其他对象提供一种代理以控制对这个对象的访问。\n\n\n\nsubject 定义了 realsubject 和 proxy 的公共接口，这样就在任何使用 realsubject 的地方都可以使用 proxy 。\n\nabstract class subject {\n    public abstract void request();\n}\n\n\nrealsubject 定义 proxy 所代表的真实实体。\n\nclass realsubject extends subject {\n    @override\n    public void request() {\n        system.out.println("真实的请求");\n    }\n}\n\n\nproxy 保存一个引用使得代理可以访问实体，并提供一个与 subject 的接口相同的接口，这样代理就可以用来替代实体。\n\nclass proxy extends subject {\n    private realsubject real;\n\n    @override\n    public void request() {\n        if (null == real) {\n            real = new realsubject();\n        }\n        real.request();\n    }\n}\n\n\n> 说明：\n> \n> 静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 proxy 和 realsubject 的功能本质上是相同的，proxy 只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。\n\n\n# jdk 动态代理\n\n为了解决静态代理的问题，就有了创建动态代理的想法：\n\n在运行状态中，需要代理的地方，根据 subject 和 realsubject，动态地创建一个 proxy，用完之后，就会销毁，这样就可以避免了 proxy 角色的 class 在系统中冗杂的问题了。\n\n\n\njava 动态代理基于经典代理模式，引入了一个 invocationhandler，invocationhandler 负责统一管理所有的方法调用。\n\n动态代理步骤：\n\n 1. 获取 realsubject 上的所有接口列表；\n 2. 确定要生成的代理类的类名，默认为：com.sun.proxy.$proxyxxxx；\n 3. 根据需要实现的接口信息，在代码中动态创建 该 proxy 类的字节码；\n 4. 将对应的字节码转换为对应的 class 对象；\n 5. 创建 invocationhandler 实例 handler，用来处理 proxy 所有方法调用；\n 6. proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。\n\n从上面可以看出，jdk 动态代理的实现是基于实现接口的方式，使得 proxy 和 realsubject 具有相同的功能。\n\n但其实还有一种思路：通过继承。即：让 proxy 继承 realsubject，这样二者同样具有相同的功能，proxy 还可以通过重写 realsubject 中的方法，来实现多态。cglib 就是基于这种思路设计的。\n\n在 java 的动态代理机制中，有两个重要的类（接口），一个是 invocationhandler 接口、另一个则是 proxy 类，这一个类和一个接口是实现我们动态代理所必须用到的。\n\n# invocationhandler 接口\n\ninvocationhandler 接口定义：\n\npublic interface invocationhandler {\n    public object invoke(object proxy, method method, object[] args)\n        throws throwable;\n}\n\n\n每一个动态代理类都必须要实现 invocationhandler 这个接口，并且每个代理类的实例都关联到了一个 handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 invocationhandler 这个接口的 invoke 方法来进行调用。\n\n我们来看看 invocationhandler 这个接口的唯一一个方法 invoke 方法：\n\nobject invoke(object proxy, method method, object[] args) throws throwable\n\n\n参数说明：\n\n * proxy - 代理的真实对象。\n * method - 所要调用真实对象的某个方法的 method 对象\n * args - 所要调用真实对象某个方法时接受的参数\n\n如果不是很明白，等下通过一个实例会对这几个参数进行更深的讲解。\n\n# proxy 类\n\nproxy 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newproxyinstance 这个方法：\n\npublic static object newproxyinstance(classloader loader, class<?>[] interfaces,  invocationhandler h)  throws illegalargumentexception\n\n\n这个方法的作用就是得到一个动态的代理对象。\n\n参数说明：\n\n * loader - 一个 classloader 对象，定义了由哪个 classloader 对象来对生成的代理对象进行加载。\n * interfaces - 一个 class<?> 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了\n * h - 一个 invocationhandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 invocationhandler 对象上\n\n# jdk 动态代理实例\n\n上面的内容介绍完这两个接口(类)以后，我们来通过一个实例来看看我们的动态代理模式是什么样的：\n\n首先我们定义了一个 subject 类型的接口，为其声明了两个方法：\n\npublic interface subject {\n\n    void hello(string str);\n\n    string bye();\n}\n\n\n接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，realsubject 类：\n\npublic class realsubject implements subject {\n\n    @override\n    public void hello(string str) {\n        system.out.println("hello  " + str);\n    }\n\n    @override\n    public string bye() {\n        system.out.println("goodbye");\n        return "over";\n    }\n}\n\n\n下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 invocationhandler 这个接口，因此我们这个动态代理类也不例外：\n\npublic class invocationhandlerdemo implements invocationhandler {\n    // 这个就是我们要代理的真实对象\n    private object subject;\n\n    // 构造方法，给我们要代理的真实对象赋初值\n    public invocationhandlerdemo(object subject) {\n        this.subject = subject;\n    }\n\n    @override\n    public object invoke(object object, method method, object[] args)\n        throws throwable {\n        // 在代理真实对象前我们可以添加一些自己的操作\n        system.out.println("before method");\n\n        system.out.println("call method: " + method);\n\n        // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用\n        object obj = method.invoke(subject, args);\n\n        // 在代理真实对象后我们也可以添加一些自己的操作\n        system.out.println("after method");\n        system.out.println();\n\n        return obj;\n    }\n}\n\n\n最后，来看看我们的 client 类：\n\npublic class client {\n    public static void main(string[] args) {\n        // 我们要代理的真实对象\n        subject realsubject = new realsubject();\n\n        // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的\n        invocationhandler handler = new invocationhandlerdemo(realsubject);\n\n        /*\n         * 通过proxy的newproxyinstance方法来创建我们的代理对象，我们来看看其三个参数\n         * 第一个参数 handler.getclass().getclassloader() ，我们这里使用handler这个类的classloader对象来加载我们的代理对象\n         * 第二个参数realsubject.getclass().getinterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了\n         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 invocationhandler 这个对象上\n         */\n        subject subject = (subject)proxy.newproxyinstance(handler.getclass().getclassloader(), realsubject\n                .getclass().getinterfaces(), handler);\n\n        system.out.println(subject.getclass().getname());\n        subject.hello("world");\n        string result = subject.bye();\n        system.out.println("result is: " + result);\n    }\n}\n\n\n我们先来看看控制台的输出：\n\ncom.sun.proxy.$proxy0\nbefore method\ncall method: public abstract void io.github.dunwu.javacore.reflect.invocationhandlerdemo$subject.hello(java.lang.string)\nhello  world\nafter method\n\nbefore method\ncall method: public abstract java.lang.string io.github.dunwu.javacore.reflect.invocationhandlerdemo$subject.bye()\ngoodbye\nafter method\n\nresult is: over\n\n\n我们首先来看看 com.sun.proxy.$proxy0 这东西，我们看到，这个东西是由 system.out.println(subject.getclass().getname()); 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？\n\nsubject subject = (subject)proxy.newproxyinstance(handler.getclass().getclassloader(), realsubject\n                .getclass().getinterfaces(), handler);\n\n\n可能我以为返回的这个代理对象会是 subject 类型的对象，或者是 invocationhandler 的对象，结果却不是，首先我们解释一下为什么我们这里可以将其转化为 subject 类型的对象？\n\n原因就是：在 newproxyinstance 这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是 subject 类型，所以就可以将其转化为 subject 类型了。\n\n同时我们一定要记住，通过 proxy.newproxyinstance 创建的代理对象是在 jvm 运行时动态生成的一个对象，它并不是我们的 invocationhandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy 为中，最后一个数字表示对象的标号。\n\n接着我们来看看这两句\n\nsubject.hello("world");\nstring result = subject.bye();\n\n\n这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的 invoke 方法去执行，而我们的这个 handler 对象又接受了一个 realsubject 类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的 invoke 方法去执行。\n\n我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：\n\npublic abstract void io.github.dunwu.javacore.reflect.invocationhandlerdemo$subject.hello(java.lang.string)\npublic abstract java.lang.string io.github.dunwu.javacore.reflect.invocationhandlerdemo$subject.bye()\n\n\n正好就是我们的 subject 接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的 invoke 方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。\n\n# jdk 动态代理小结\n\n代理类与委托类实现同一接口，主要是通过代理类实现 invocationhandler 并重写 invoke 方法来进行动态代理的，在 invoke 方法中将对方法进行处理。\n\njdk 动态代理特点：\n\n * 优点：相对于静态代理模式，不需要硬编码接口，代码复用率高。\n\n * 缺点：强制要求代理类实现 invocationhandler 接口。\n\n\n# cglib 动态代理\n\ncglib 提供了与 jdk 动态代理不同的方案。很多框架，例如 spring aop 中，就使用了 cglib 动态代理。\n\ncglib 底层，其实是借助了 asm 这个强大的 java 字节码框架去进行字节码增强操作。\n\ncglib 动态代理的工作步骤：\n\n * 生成代理类的二进制字节码文件；\n * 加载二进制字节码，生成 class 对象( 例如使用 class.forname() 方法 )；\n * 通过反射机制获得实例构造，并创建代理类对象。\n\ncglib 动态代理特点：\n\n优点：使用字节码增强，比 jdk 动态代理方式性能高。可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口。\n\n缺点：不能对 final 类以及 final 方法进行代理。\n\n> 参考：深入理解 cglib 动态代理机制\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * 深入拆解 java 虚拟机\n * 深入解析 java 反射（1） - 基础\n * java 基础之—反射（非常重要）\n * 官方 reflection api 文档\n * java 的动态代理机制详解\n * java 动态代理机制详解（jdk 和 cglib，javassist，asm）\n * 深入理解 jdk 动态代理机制\n * 深入理解 cglib 动态代理机制',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"深入理解 Java 注解",frontmatter:{title:"深入理解 Java 注解",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE","注解"],abbrlink:"87f5f5f7",date:"2019-05-06T15:02:02.000Z",permalink:"/pages/66a7ee/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/11.Java%E6%B3%A8%E8%A7%A3.html",relativePath:"01.基础特性/11.Java注解.md",key:"v-4b2a057d",path:"/pages/66a7ee/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:96},{level:3,title:"注解的形式",slug:"注解的形式",normalizedTitle:"注解的形式",charIndex:103},{level:3,title:"什么是注解",slug:"什么是注解",normalizedTitle:"什么是注解",charIndex:419},{level:3,title:"注解的作用",slug:"注解的作用",normalizedTitle:"注解的作用",charIndex:646},{level:3,title:"注解的代价",slug:"注解的代价",normalizedTitle:"注解的代价",charIndex:933},{level:3,title:"注解的应用范围",slug:"注解的应用范围",normalizedTitle:"注解的应用范围",charIndex:1166},{level:2,title:"内置注解",slug:"内置注解",normalizedTitle:"内置注解",charIndex:1487},{level:3,title:"@Override",slug:"override",normalizedTitle:"@override",charIndex:138},{level:3,title:"@Deprecated",slug:"deprecated",normalizedTitle:"@deprecated",charIndex:1524},{level:3,title:"@SuppressWarnnings",slug:"suppresswarnnings",normalizedTitle:"@suppresswarnnings",charIndex:1539},{level:3,title:"@SafeVarargs",slug:"safevarargs",normalizedTitle:"@safevarargs",charIndex:1561},{level:3,title:"@FunctionalInterface",slug:"functionalinterface",normalizedTitle:"@functionalinterface",charIndex:1586},{level:2,title:"元注解",slug:"元注解",normalizedTitle:"元注解",charIndex:7740},{level:3,title:"@Retention",slug:"retention",normalizedTitle:"@retention",charIndex:7851},{level:3,title:"@Documented",slug:"documented",normalizedTitle:"@documented",charIndex:7876},{level:3,title:"@Target",slug:"target",normalizedTitle:"@target",charIndex:7865},{level:3,title:"@Inherited",slug:"inherited",normalizedTitle:"@inherited",charIndex:7891},{level:3,title:"@Repeatable",slug:"repeatable",normalizedTitle:"@repeatable",charIndex:7914},{level:2,title:"自定义注解",slug:"自定义注解",normalizedTitle:"自定义注解",charIndex:614},{level:3,title:"注解的定义",slug:"注解的定义",normalizedTitle:"注解的定义",charIndex:11321},{level:3,title:"注解属性",slug:"注解属性",normalizedTitle:"注解属性",charIndex:11892},{level:3,title:"注解处理器",slug:"注解处理器",normalizedTitle:"注解处理器",charIndex:12408},{level:3,title:"使用注解",slug:"使用注解",normalizedTitle:"使用注解",charIndex:746},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:19110},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:19125}],headersStr:"简介 注解的形式 什么是注解 注解的作用 注解的代价 注解的应用范围 内置注解 @Override @Deprecated @SuppressWarnnings @SafeVarargs @FunctionalInterface 元注解 @Retention @Documented @Target @Inherited @Repeatable 自定义注解 注解的定义 注解属性 注解处理器 使用注解 小结 参考资料",content:'# 深入理解 Java 注解\n\n> 本文内容基于 JDK8。注解是 JDK5 引入的，后续 JDK 版本扩展了一些内容，本文中没有明确指明版本的注解都是 JDK5 就已经支持的注解。\n\n\n# 简介\n\n\n# 注解的形式\n\nJava 中，注解是以 @ 字符开始的修饰符。如下：\n\n@Override\nvoid mySuperMethod() { ... }\n\n\n注解可以包含命名或未命名的属性，并且这些属性有值。\n\n@Author(\n   name = "Benjamin Franklin",\n   date = "3/27/2003"\n)\nclass MyClass() { ... }\n\n\n如果只有一个名为 value 的属性，那么名称可以省略，如：\n\n@SuppressWarnings("unchecked")\nvoid myMethod() { ... }\n\n\n如果注解没有属性，则称为标记注解。如：@Override。\n\n\n# 什么是注解\n\n从本质上来说，注解是一种标签，其实质上可以视为一种特殊的注释，如果没有解析它的代码，它并不比普通注释强。\n\n解析一个注解往往有两种形式：\n\n * 编译期直接的扫描 - 编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。这种情况只适用于 JDK 内置的注解类。\n * 运行期的反射 - 如果要自定义注解，Java 编译器无法识别并处理这个注解，它只能根据该注解的作用范围来选择是否编译进字节码文件。如果要处理注解，必须利用反射技术，识别该注解以及它所携带的信息，然后做相应的处理。\n\n\n# 注解的作用\n\n注解有许多用途：\n\n * 编译器信息 - 编译器可以使用注解来检测错误或抑制警告。\n * 编译时和部署时的处理 - 程序可以处理注解信息以生成代码，XML 文件等。\n * 运行时处理 - 可以在运行时检查某些注解并处理。\n\n作为 Java 程序员，多多少少都曾经历过被各种配置文件（xml、properties）支配的恐惧。过多的配置文件会使得项目难以维护。个人认为，使用注解以减少配置文件或代码，是注解最大的用处。\n\n\n# 注解的代价\n\n凡事有得必有失，注解技术同样如此。使用注解也有一定的代价：\n\n * 显然，它是一种侵入式编程，那么，自然就存在着增加程序耦合度的问题。\n * 自定义注解的处理需要在运行时，通过反射技术来获取属性。如果注解所修饰的元素是类的非 public 成员，也可以通过反射获取。这就违背了面向对象的封装性。\n * 注解所产生的问题，相对而言，更难以 debug 或定位。\n\n但是，正所谓瑕不掩瑜，注解所付出的代价，相较于它提供的功能而言，还是可以接受的。\n\n\n# 注解的应用范围\n\n注解可以应用于类、字段、方法和其他程序元素的声明。\n\nJDK8 开始，注解的应用范围进一步扩大，以下是新的应用范围：\n\n类实例初始化表达式：\n\nnew @Interned MyObject();\n\n\n类型转换：\n\nmyString = (@NonNull String) str;\n\n\n实现接口的声明：\n\nclass UnmodifiableList<T> implements\n    @Readonly List<@Readonly T> {}\n\n\n抛出异常声明：\n\nvoid monitorTemperature()\n    throws @Critical TemperatureException {}\n\n\n\n# 内置注解\n\nJDK 中内置了以下注解：\n\n * @Override\n * @Deprecated\n * @SuppressWarnnings\n * @SafeVarargs（JDK7 引入）\n * @FunctionalInterface（JDK8 引入）\n\n\n# @Override\n\n@Override 用于表明被修饰方法覆写了父类的方法。\n\n如果试图使用 @Override 标记一个实际上并没有覆写父类的方法时，java 编译器会告警。\n\n@Override 示例：\n\npublic class OverrideAnnotationDemo {\n\n    static class Person {\n        public String getName() {\n            return "getName";\n        }\n    }\n\n\n    static class Man extends Person {\n        @Override\n        public String getName() {\n            return "override getName";\n        }\n\n        /**\n         *  放开下面的注释，编译时会告警\n         */\n       /*\n        @Override\n        public String getName2() {\n            return "override getName2";\n        }\n        */\n    }\n\n    public static void main(String[] args) {\n        Person per = new Man();\n        System.out.println(per.getName());\n    }\n}\n\n\n\n# @Deprecated\n\n@Deprecated 用于标明被修饰的类或类成员、类方法已经废弃、过时，不建议使用。\n\n@Deprecated 有一定的延续性：如果我们在代码中通过继承或者覆盖的方式使用了过时的类或类成员，即使子类或子方法没有标记为 @Deprecated，但编译器仍然会告警。\n\n> 🔔 注意： @Deprecated 这个注解类型和 javadoc 中的 @deprecated 这个 tag 是有区别的：前者是 java 编译器识别的；而后者是被 javadoc 工具所识别用来生成文档（包含程序成员为什么已经过时、它应当如何被禁止或者替代的描述）。\n\n@Deprecated 示例：\n\npublic class DeprecatedAnnotationDemo {\n    static class DeprecatedField {\n        @Deprecated\n        public static final String DEPRECATED_FIELD = "DeprecatedField";\n    }\n\n\n    static class DeprecatedMethod {\n        @Deprecated\n        public String print() {\n            return "DeprecatedMethod";\n        }\n    }\n\n\n    @Deprecated\n    static class DeprecatedClass {\n        public String print() {\n            return "DeprecatedClass";\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(DeprecatedField.DEPRECATED_FIELD);\n\n        DeprecatedMethod dm = new DeprecatedMethod();\n        System.out.println(dm.print());\n\n\n        DeprecatedClass dc = new DeprecatedClass();\n        System.out.println(dc.print());\n    }\n}\n//Output:\n//DeprecatedField\n//DeprecatedMethod\n//DeprecatedClass\n\n\n\n# @SuppressWarnnings\n\n@SuppressWarnings 用于关闭对类、方法、成员编译时产生的特定警告。\n\n@SuppressWarning 不是一个标记注解。它有一个类型为 String[] 的数组成员，这个数组中存储的是要关闭的告警类型。对于 javac 编译器来讲，对 -Xlint 选项有效的警告名也同样对 @SuppressWarings 有效，同时编译器会忽略掉无法识别的警告名。\n\n@SuppressWarning 示例：\n\n@SuppressWarnings({"rawtypes", "unchecked"})\npublic class SuppressWarningsAnnotationDemo {\n    static class SuppressDemo<T> {\n        private T value;\n\n        public T getValue() {\n            return this.value;\n        }\n\n        public void setValue(T var) {\n            this.value = var;\n        }\n    }\n\n    @SuppressWarnings({"deprecation"})\n    public static void main(String[] args) {\n        SuppressDemo d = new SuppressDemo();\n        d.setValue("南京");\n        System.out.println("地名：" + d.getValue());\n    }\n}\n\n\n@SuppressWarnings 注解的常见参数值的简单说明：\n\n * deprecation - 使用了不赞成使用的类或方法时的警告；\n * unchecked - 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型;\n * fallthrough - 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;\n * path - 在类路径、源文件路径等中有不存在的路径时的警告;\n * serial - 当在可序列化的类上缺少 serialVersionUID 定义时的警告;\n * finally - 任何 finally 子句不能正常完成时的警告;\n * all - 所有的警告。\n\n@SuppressWarnings({"uncheck", "deprecation"})\npublic class InternalAnnotationDemo {\n\n    /**\n     * @SuppressWarnings 标记消除当前类的告警信息\n     */\n    @SuppressWarnings({"deprecation"})\n    static class A {\n        public void method1() {\n            System.out.println("call method1");\n        }\n\n        /**\n         * @Deprecated 标记当前方法为废弃方法，不建议使用\n         */\n        @Deprecated\n        public void method2() {\n            System.out.println("call method2");\n        }\n    }\n\n    /**\n     * @Deprecated 标记当前类为废弃类，不建议使用\n     */\n    @Deprecated\n    static class B extends A {\n        /**\n         * @Override 标记显示指明当前方法覆写了父类或接口的方法\n         */\n        @Override\n        public void method1() { }\n    }\n\n    public static void main(String[] args) {\n        A obj = new B();\n        obj.method1();\n        obj.method2();\n    }\n}\n\n\n\n# @SafeVarargs\n\n@SafeVarargs 在 JDK7 中引入。\n\n@SafeVarargs 的作用是：告诉编译器，在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用。\n\n简单的说，数组元素的数据类型在编译和运行时都是确定的，而泛型的数据类型只有在运行时才能确定下来。因此，当把一个泛型存储到数组中时，编译器在编译阶段无法确认数据类型是否匹配，因此会给出警告信息；即如果泛型的真实数据类型无法和参数数组的类型匹配，会导致 ClassCastException 异常。\n\n@SafeVarargs 注解使用范围：\n\n * @SafeVarargs 注解可以用于构造方法。\n * @SafeVarargs 注解可以用于 static 或 final 方法。\n\n@SafeVarargs 示例：\n\npublic class SafeVarargsAnnotationDemo {\n    /**\n     * 此方法实际上并不安全，不使用此注解，编译时会告警\n     */\n    @SafeVarargs\n    static void wrongMethod(List<String>... stringLists) {\n        Object[] array = stringLists;\n        List<Integer> tmpList = Arrays.asList(42);\n        array[0] = tmpList; // 语法错误，但是编译不告警\n        String s = stringLists[0].get(0); // 运行时报 ClassCastException\n    }\n\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add("A");\n        list.add("B");\n\n        List<String> list2 = new ArrayList<>();\n        list.add("1");\n        list.add("2");\n\n        wrongMethod(list, list2);\n    }\n}\n\n\n以上代码，如果不使用 @SafeVarargs ，编译时会告警\n\n[WARNING] /D:/Codes/ZP/Java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/SafeVarargsAnnotationDemo.java: 某些输入文件使用了未经检查或不安全的操作。\n[WARNING] /D:/Codes/ZP/Java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/SafeVarargsAnnotationDemo.java: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。\n\n\n\n# @FunctionalInterface\n\n@FunctionalInterface 在 JDK8 引入。\n\n@FunctionalInterface 用于指示被修饰的接口是函数式接口。\n\n需要注意的是，如果一个接口符合"函数式接口"定义，不加 @FunctionalInterface 也没关系；但如果编写的不是函数式接口，却使用 @FunctionInterface，那么编译器会报错。\n\n什么是函数式接口？\n\n函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。\n\n函数式接口的特点：\n\n * 接口有且只能有个一个抽象方法（抽象方法只有方法定义，没有方法体）。\n * 不能在接口中覆写 Object 类中的 public 方法（写了编译器也会报错）。\n * 允许有 default 实现方法。\n\n示例：\n\npublic class FunctionalInterfaceAnnotationDemo {\n\n    @FunctionalInterface\n    public interface Func1<T> {\n        void printMessage(T message);\n    }\n\n    /**\n     * @FunctionalInterface 修饰的接口中定义两个抽象方法，编译时会报错\n     * @param <T>\n     */\n    /*@FunctionalInterface\n    public interface Func2<T> {\n        void printMessage(T message);\n        void printMessage2(T message);\n    }*/\n\n    public static void main(String[] args) {\n        Func1 func1 = message -> System.out.println(message);\n        func1.printMessage("Hello");\n        func1.printMessage(100);\n    }\n}\n\n\n\n# 元注解\n\nJDK 中虽然内置了几个注解，但这远远不能满足开发过程中遇到的千变万化的需求。所以我们需要自定义注解，而这就需要用到元注解。\n\n元注解的作用就是用于定义其它的注解。\n\nJava 中提供了以下元注解类型：\n\n * @Retention\n * @Target\n * @Documented\n * @Inherited（JDK8 引入）\n * @Repeatable（JDK8 引入）\n\n这些类型和它们所支持的类在 java.lang.annotation 包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。\n\n\n# @Retention\n\n@Retention 指明了注解的保留级别。\n\n@Retention 源码：\n\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface Retention {\n    RetentionPolicy value();\n}\n\n\nRetentionPolicy 是一个枚举类型，它定义了被 @Retention 修饰的注解所支持的保留级别：\n\n * RetentionPolicy.SOURCE - 标记的注解仅在源文件中有效，编译器会忽略。\n * RetentionPolicy.CLASS - 标记的注解在 class 文件中有效，JVM 会忽略。\n * RetentionPolicy.RUNTIME - 标记的注解在运行时有效。\n\n@Retention 示例：\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Column {\n    public String name() default "fieldName";\n    public String setFuncName() default "setField";\n    public String getFuncName() default "getField";\n    public boolean defaultDBValue() default false;\n}\n\n\n\n# @Documented\n\n@Documented 表示无论何时使用指定的注解，都应使用 Javadoc（默认情况下，注释不包含在 Javadoc 中）。更多内容可以参考：Javadoc tools page。\n\n@Documented 示例：\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Column {\n    public String name() default "fieldName";\n    public String setFuncName() default "setField";\n    public String getFuncName() default "getField";\n    public boolean defaultDBValue() default false;\n}\n\n\n\n# @Target\n\n@Target 指定注解可以修饰的元素类型。\n\n@Target 源码：\n\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface Target {\n    ElementType[] value();\n}\n\n\nElementType 是一个枚举类型，它定义了被 @Target 修饰的注解可以应用的范围：\n\n * ElementType.ANNOTATION_TYPE - 标记的注解可以应用于注解类型。\n * ElementType.CONSTRUCTOR - 标记的注解可以应用于构造函数。\n * ElementType.FIELD - 标记的注解可以应用于字段或属性。\n * ElementType.LOCAL_VARIABLE - 标记的注解可以应用于局部变量。\n * ElementType.METHOD - 标记的注解可以应用于方法。\n * ElementType.PACKAGE - 标记的注解可以应用于包声明。\n * ElementType.PARAMETER - 标记的注解可以应用于方法的参数。\n * ElementType.TYPE - 标记的注解可以应用于类的任何元素。\n\n@Target 示例：\n\n@Target(ElementType.TYPE)\npublic @interface Table {\n    /**\n     * 数据表名称注解，默认值为类名称\n     * @return\n     */\n    public String tableName() default "className";\n}\n\n@Target(ElementType.FIELD)\npublic @interface NoDBColumn {}\n\n\n\n# @Inherited\n\n@Inherited 表示注解类型可以被继承（默认情况下不是这样）。\n\n表示自动继承注解类型。 如果注解类型声明中存在 @Inherited 元注解，则注解所修饰类的所有子类都将会继承此注解。\n\n> 🔔 注意：@Inherited 注解类型是被标注过的类的子类所继承。类并不从它所实现的接口继承注解，方法并不从它所覆写的方法继承注解。\n> \n> 此外，当 @Inherited 类型标注的注解的 @Retention 是 RetentionPolicy.RUNTIME，则反射 API 增强了这种继承性。如果我们使用 java.lang.reflect 去查询一个 @Inherited 类型的注解时，反射代码检查将展开工作：检查类和其父类，直到发现指定的注解类型被发现，或者到达类继承结构的顶层。\n\n@Inherited\npublic @interface Greeting {\n    public enum FontColor{ BULE,RED,GREEN};\n    String name();\n    FontColor fontColor() default FontColor.GREEN;\n}\n\n\n\n# @Repeatable\n\n@Repeatable 表示注解可以重复使用。\n\n以 Spring @Scheduled 为例：\n\n@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Schedules {\n\tScheduled[] value();\n}\n\n@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Repeatable(Schedules.class)\npublic @interface Scheduled {\n  // ...\n}\n\n\n应用示例：\n\npublic class TaskRunner {\n\n    @Scheduled("0 0/15 * * * ?")\n    @Scheduled("0 0 12 * ?")\n    public void task1() {}\n}\n\n\n\n# 自定义注解\n\n使用 @interface 自定义注解时，自动继承了 java.lang.annotation.Annotation 接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过 default 来声明参数的默认值。\n\n这里，我会通过实现一个名为 RegexValid 的正则校验注解工具来展示自定义注解的全步骤。\n\n\n# 注解的定义\n\n注解的语法格式如下：\n\npublic @interface 注解名 {定义体}\n\n\n我们来定义一个注解：\n\n@Documented\n@Target({ElementType.FIELD, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RegexValid {}\n\n\n> 说明：\n> \n> 通过上一节对于元注解 @Target、@Retention、@Documented 的说明，这里就很容易理解了。\n> \n>  * 上面的代码中定义了一个名为 @RegexValid 的注解。\n>  * @Documented 表示 @RegexValid 应该使用 javadoc。\n>  * @Target({ElementType.FIELD, ElementType.PARAMETER}) 表示 @RegexValid 可以在类成员或方法参数上修饰。\n>  * @Retention(RetentionPolicy.RUNTIME) 表示 @RegexValid 在运行时有效。\n\n此时，我们已经定义了一个没有任何属性的注解，如果到此为止，它仅仅是一个标记注解。作为正则工具，没有属性可什么也做不了。接下来，我们将为它添加注解属性。\n\n\n# 注解属性\n\n注解属性的语法形式如下：\n\n[访问级别修饰符] [数据类型] 名称() default 默认值;\n\n\n例如，我们要定义在注解中定义一个名为 value 的字符串属性，其默认值为空字符串，访问级别为默认级别，那么应该定义如下：\n\nString value() default "";\n\n\n> 🔔 注意：在注解中，我们定义属性时，属性名后面需要加 ()。\n\n定义注解属性有以下要点：\n\n * 注解属性只能使用 public 或默认访问级别（即不指定访问级别修饰符）修饰。\n\n * 注解属性的数据类型有限制要求。支持的数据类型如下：\n   \n   * 所有基本数据类型（byte、char、short、int、long、float、double、boolean）\n   * String 类型\n   * Class 类\n   * enum 类型\n   * Annotation 类型\n   * 以上所有类型的数组\n\n * 注解属性必须有确定的值，建议指定默认值。注解属性只能通过指定默认值或使用注解时指定属性值，相较之下，指定默认值的方式更为可靠。注解属性如果是引用类型，不可以为 null。这个约束使得注解处理器很难判断注解属性是默认值，或是使用注解时所指定的属性值。为此，我们设置默认值时，一般会定义一些特殊的值，例如空字符串或者负数。\n\n * 如果注解中只有一个属性值，最好将其命名为 value。因为，指定属性名为 value，在使用注解时，指定 value 的值可以不指定属性名称。\n\n// 这两种方式效果相同\n@RegexValid("^((\\\\+)?86\\\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\\\d{8}$")\n@RegexValid(value = "^((\\\\+)?86\\\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\\\d{8}$")\n\n\n示例：\n\n了解了注解属性的定义要点，让我们来为 @RegexValid 注解定义几个属性。\n\n@Documented\n@Target({ElementType.FIELD, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RegexValid {\n    enum Policy {\n        // @formatter:off\n        EMPTY(null),\n        DATE("^(?:(?!0000)[0-9]{4}([-/.]?)(?:(?:0?[1-9]|1[0-2])\\\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\\\1"\n            + "(?:29|30)|(?:0?[13578]|1[02])\\\\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|"\n            + "(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\\\\2(?:29))$"),\n        MAIL("^[A-Za-z0-9](([_\\\\.\\\\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\\\\.\\\\-]?[a-zA-Z0-9]+)*)\\\\.([A-Za-z]{2,})$");\n        // @formatter:on\n\n        private String policy;\n\n        Policy(String policy) {\n            this.policy = policy;\n        }\n\n        public String getPolicy() {\n            return policy;\n        }\n    }\n\n    String value() default "";\n    Policy policy() default Policy.EMPTY;\n}\n\n\n> 说明：\n> \n> 在上面的示例代码中，我们定义了两个注解属性：String 类型的 value 属性和 Policy 枚举类型的 policy 属性。Policy 枚举中定义了几个默认的正则表达式，这是为了直接使用这几个常用表达式去正则校验。考虑到，我们可能需要自己传入一些自定义正则表达式去校验其他场景，所以定义了 value 属性，允许使用者传入正则表达式。\n\n至此，@RegexValid 的声明已经结束。但是，程序仍不知道如何处理 @RegexValid 这个注解。我们还需要定义注解处理器。\n\n\n# 注解处理器\n\n如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。JDK5 扩展了反射机制的 API，以帮助程序员快速的构造自定义注解处理器。\n\njava.lang.annotation.Annotation 是一个接口，程序可以通过反射来获取指定程序元素的注解对象，然后通过注解对象来获取注解里面的元数据。\n\nAnnotation 接口源码如下：\n\npublic interface Annotation {\n    boolean equals(Object obj);\n\n    int hashCode();\n\n    String toString();\n\n    Class<? extends Annotation> annotationType();\n}\n\n\n除此之外，Java 中支持注解处理器接口 java.lang.reflect.AnnotatedElement ，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：\n\n * Class - 类定义\n * Constructor - 构造器定义\n * Field - 累的成员变量定义\n * Method - 类的方法定义\n * Package - 类的包定义\n\njava.lang.reflect 包下主要包含一些实现反射功能的工具类。实际上，java.lang.reflect 包所有提供的反射 API 扩充了读取运行时注解信息的能力。当一个注解类型被定义为运行时的注解后，该注解才能是运行时可见，当 class 文件被装载时被保存在 class 文件中的注解才会被虚拟机读取。 AnnotatedElement 接口是所有程序元素（Class、Method 和 Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement 对象之后，程序就可以调用该对象的如下四个个方法来访问注解信息：\n\n * getAnnotation - 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回 null。\n * getAnnotations - 返回该程序元素上存在的所有注解。\n * isAnnotationPresent - 判断该程序元素上是否包含指定类型的注解，存在则返回 true，否则返回 false。\n * getDeclaredAnnotations - 返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。\n\n了解了以上内容，让我们来实现 @RegexValid 的注解处理器：\n\nimport java.lang.reflect.Field;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexValidUtil {\n    public static boolean check(Object obj) throws Exception {\n        boolean result = true;\n        StringBuilder sb = new StringBuilder();\n        Field[] fields = obj.getClass().getDeclaredFields();\n        for (Field field : fields) {\n            // 判断成员是否被 @RegexValid 注解所修饰\n            if (field.isAnnotationPresent(RegexValid.class)) {\n                RegexValid valid = field.getAnnotation(RegexValid.class);\n\n                // 如果 value 为空字符串，说明没有注入自定义正则表达式，改用 policy 属性\n                String value = valid.value();\n                if ("".equals(value)) {\n                    RegexValid.Policy policy = valid.policy();\n                    value = policy.getPolicy();\n                }\n\n                // 通过设置 setAccessible(true) 来访问私有成员\n                field.setAccessible(true);\n                Object fieldObj = null;\n                try {\n                    fieldObj = field.get(obj);\n                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                }\n                if (fieldObj == null) {\n                    sb.append("\\n")\n                        .append(String.format("%s 类中的 %s 字段不能为空！", obj.getClass().getName(), field.getName()));\n                    result = false;\n                } else {\n                    if (fieldObj instanceof String) {\n                        String text = (String) fieldObj;\n                        Pattern p = Pattern.compile(value);\n                        Matcher m = p.matcher(text);\n                        result = m.matches();\n                        if (!result) {\n                            sb.append("\\n").append(String.format("%s 不是合法的 %s ！", text, field.getName()));\n                        }\n                    } else {\n                        sb.append("\\n").append(\n                            String.format("%s 类中的 %s 字段不是字符串类型，不能使用此注解校验！", obj.getClass().getName(), field.getName()));\n                        result = false;\n                    }\n                }\n            }\n        }\n\n        if (sb.length() > 0) {\n            throw new Exception(sb.toString());\n        }\n        return result;\n    }\n}\n\n\n> 说明：\n> \n> 以上示例中的注解处理器，执行步骤如下：\n> \n>  1. 通过 getDeclaredFields 反射方法获取传入对象的所有成员。\n>  2. 遍历成员，使用 isAnnotationPresent 判断成员是否被指定注解所修饰，如果不是，直接跳过。\n>  3. 如果成员被注解所修饰，通过 RegexValid valid = field.getAnnotation(RegexValid.class); 这样的形式获取，注解实例化对象，然后，就可以使用 valid.value() 或 valid.policy() 这样的形式获取注解中设定的属性值。\n>  4. 根据属性值，进行逻辑处理。\n\n\n# 使用注解\n\n完成了以上工作，我们就可以使用自定义注解了，示例如下：\n\npublic class RegexValidDemo {\n    static class User {\n        private String name;\n        @RegexValid(policy = RegexValid.Policy.DATE)\n        private String date;\n        @RegexValid(policy = RegexValid.Policy.MAIL)\n        private String mail;\n        @RegexValid("^((\\\\+)?86\\\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\\\d{8}$")\n        private String phone;\n\n        public User(String name, String date, String mail, String phone) {\n            this.name = name;\n            this.date = date;\n            this.mail = mail;\n            this.phone = phone;\n        }\n\n        @Override\n        public String toString() {\n            return "User{" + "name=\'" + name + \'\\\'\' + ", date=\'" + date + \'\\\'\' + ", mail=\'" + mail + \'\\\'\' + ", phone=\'"\n                + phone + \'\\\'\' + \'}\';\n        }\n    }\n\n    static void printDate(@RegexValid(policy = RegexValid.Policy.DATE) String date){\n        System.out.println(date);\n    }\n\n    public static void main(String[] args) throws Exception {\n        User user = new User("Tom", "1990-01-31", "xxx@163.com", "18612341234");\n        User user2 = new User("Jack", "2019-02-29", "sadhgs", "183xxxxxxxx");\n        if (RegexValidUtil.check(user)) {\n            System.out.println(user + "正则校验通过");\n        }\n        if (RegexValidUtil.check(user2)) {\n            System.out.println(user2 + "正则校验通过");\n        }\n    }\n}\n\n\n\n# 小结\n\n\n\n\n\n\n\n\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * Effective java\n * Oracle 官方文档之注解篇\n * 深入理解 Java：注解（Annotation）自定义注解入门\n * https://blog.csdn.net/briblue/article/details/73824058',normalizedContent:'# 深入理解 java 注解\n\n> 本文内容基于 jdk8。注解是 jdk5 引入的，后续 jdk 版本扩展了一些内容，本文中没有明确指明版本的注解都是 jdk5 就已经支持的注解。\n\n\n# 简介\n\n\n# 注解的形式\n\njava 中，注解是以 @ 字符开始的修饰符。如下：\n\n@override\nvoid mysupermethod() { ... }\n\n\n注解可以包含命名或未命名的属性，并且这些属性有值。\n\n@author(\n   name = "benjamin franklin",\n   date = "3/27/2003"\n)\nclass myclass() { ... }\n\n\n如果只有一个名为 value 的属性，那么名称可以省略，如：\n\n@suppresswarnings("unchecked")\nvoid mymethod() { ... }\n\n\n如果注解没有属性，则称为标记注解。如：@override。\n\n\n# 什么是注解\n\n从本质上来说，注解是一种标签，其实质上可以视为一种特殊的注释，如果没有解析它的代码，它并不比普通注释强。\n\n解析一个注解往往有两种形式：\n\n * 编译期直接的扫描 - 编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。这种情况只适用于 jdk 内置的注解类。\n * 运行期的反射 - 如果要自定义注解，java 编译器无法识别并处理这个注解，它只能根据该注解的作用范围来选择是否编译进字节码文件。如果要处理注解，必须利用反射技术，识别该注解以及它所携带的信息，然后做相应的处理。\n\n\n# 注解的作用\n\n注解有许多用途：\n\n * 编译器信息 - 编译器可以使用注解来检测错误或抑制警告。\n * 编译时和部署时的处理 - 程序可以处理注解信息以生成代码，xml 文件等。\n * 运行时处理 - 可以在运行时检查某些注解并处理。\n\n作为 java 程序员，多多少少都曾经历过被各种配置文件（xml、properties）支配的恐惧。过多的配置文件会使得项目难以维护。个人认为，使用注解以减少配置文件或代码，是注解最大的用处。\n\n\n# 注解的代价\n\n凡事有得必有失，注解技术同样如此。使用注解也有一定的代价：\n\n * 显然，它是一种侵入式编程，那么，自然就存在着增加程序耦合度的问题。\n * 自定义注解的处理需要在运行时，通过反射技术来获取属性。如果注解所修饰的元素是类的非 public 成员，也可以通过反射获取。这就违背了面向对象的封装性。\n * 注解所产生的问题，相对而言，更难以 debug 或定位。\n\n但是，正所谓瑕不掩瑜，注解所付出的代价，相较于它提供的功能而言，还是可以接受的。\n\n\n# 注解的应用范围\n\n注解可以应用于类、字段、方法和其他程序元素的声明。\n\njdk8 开始，注解的应用范围进一步扩大，以下是新的应用范围：\n\n类实例初始化表达式：\n\nnew @interned myobject();\n\n\n类型转换：\n\nmystring = (@nonnull string) str;\n\n\n实现接口的声明：\n\nclass unmodifiablelist<t> implements\n    @readonly list<@readonly t> {}\n\n\n抛出异常声明：\n\nvoid monitortemperature()\n    throws @critical temperatureexception {}\n\n\n\n# 内置注解\n\njdk 中内置了以下注解：\n\n * @override\n * @deprecated\n * @suppresswarnnings\n * @safevarargs（jdk7 引入）\n * @functionalinterface（jdk8 引入）\n\n\n# @override\n\n@override 用于表明被修饰方法覆写了父类的方法。\n\n如果试图使用 @override 标记一个实际上并没有覆写父类的方法时，java 编译器会告警。\n\n@override 示例：\n\npublic class overrideannotationdemo {\n\n    static class person {\n        public string getname() {\n            return "getname";\n        }\n    }\n\n\n    static class man extends person {\n        @override\n        public string getname() {\n            return "override getname";\n        }\n\n        /**\n         *  放开下面的注释，编译时会告警\n         */\n       /*\n        @override\n        public string getname2() {\n            return "override getname2";\n        }\n        */\n    }\n\n    public static void main(string[] args) {\n        person per = new man();\n        system.out.println(per.getname());\n    }\n}\n\n\n\n# @deprecated\n\n@deprecated 用于标明被修饰的类或类成员、类方法已经废弃、过时，不建议使用。\n\n@deprecated 有一定的延续性：如果我们在代码中通过继承或者覆盖的方式使用了过时的类或类成员，即使子类或子方法没有标记为 @deprecated，但编译器仍然会告警。\n\n> 🔔 注意： @deprecated 这个注解类型和 javadoc 中的 @deprecated 这个 tag 是有区别的：前者是 java 编译器识别的；而后者是被 javadoc 工具所识别用来生成文档（包含程序成员为什么已经过时、它应当如何被禁止或者替代的描述）。\n\n@deprecated 示例：\n\npublic class deprecatedannotationdemo {\n    static class deprecatedfield {\n        @deprecated\n        public static final string deprecated_field = "deprecatedfield";\n    }\n\n\n    static class deprecatedmethod {\n        @deprecated\n        public string print() {\n            return "deprecatedmethod";\n        }\n    }\n\n\n    @deprecated\n    static class deprecatedclass {\n        public string print() {\n            return "deprecatedclass";\n        }\n    }\n\n    public static void main(string[] args) {\n        system.out.println(deprecatedfield.deprecated_field);\n\n        deprecatedmethod dm = new deprecatedmethod();\n        system.out.println(dm.print());\n\n\n        deprecatedclass dc = new deprecatedclass();\n        system.out.println(dc.print());\n    }\n}\n//output:\n//deprecatedfield\n//deprecatedmethod\n//deprecatedclass\n\n\n\n# @suppresswarnnings\n\n@suppresswarnings 用于关闭对类、方法、成员编译时产生的特定警告。\n\n@suppresswarning 不是一个标记注解。它有一个类型为 string[] 的数组成员，这个数组中存储的是要关闭的告警类型。对于 javac 编译器来讲，对 -xlint 选项有效的警告名也同样对 @suppresswarings 有效，同时编译器会忽略掉无法识别的警告名。\n\n@suppresswarning 示例：\n\n@suppresswarnings({"rawtypes", "unchecked"})\npublic class suppresswarningsannotationdemo {\n    static class suppressdemo<t> {\n        private t value;\n\n        public t getvalue() {\n            return this.value;\n        }\n\n        public void setvalue(t var) {\n            this.value = var;\n        }\n    }\n\n    @suppresswarnings({"deprecation"})\n    public static void main(string[] args) {\n        suppressdemo d = new suppressdemo();\n        d.setvalue("南京");\n        system.out.println("地名：" + d.getvalue());\n    }\n}\n\n\n@suppresswarnings 注解的常见参数值的简单说明：\n\n * deprecation - 使用了不赞成使用的类或方法时的警告；\n * unchecked - 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (generics) 来指定集合保存的类型;\n * fallthrough - 当 switch 程序块直接通往下一种情况而没有 break 时的警告;\n * path - 在类路径、源文件路径等中有不存在的路径时的警告;\n * serial - 当在可序列化的类上缺少 serialversionuid 定义时的警告;\n * finally - 任何 finally 子句不能正常完成时的警告;\n * all - 所有的警告。\n\n@suppresswarnings({"uncheck", "deprecation"})\npublic class internalannotationdemo {\n\n    /**\n     * @suppresswarnings 标记消除当前类的告警信息\n     */\n    @suppresswarnings({"deprecation"})\n    static class a {\n        public void method1() {\n            system.out.println("call method1");\n        }\n\n        /**\n         * @deprecated 标记当前方法为废弃方法，不建议使用\n         */\n        @deprecated\n        public void method2() {\n            system.out.println("call method2");\n        }\n    }\n\n    /**\n     * @deprecated 标记当前类为废弃类，不建议使用\n     */\n    @deprecated\n    static class b extends a {\n        /**\n         * @override 标记显示指明当前方法覆写了父类或接口的方法\n         */\n        @override\n        public void method1() { }\n    }\n\n    public static void main(string[] args) {\n        a obj = new b();\n        obj.method1();\n        obj.method2();\n    }\n}\n\n\n\n# @safevarargs\n\n@safevarargs 在 jdk7 中引入。\n\n@safevarargs 的作用是：告诉编译器，在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用。\n\n简单的说，数组元素的数据类型在编译和运行时都是确定的，而泛型的数据类型只有在运行时才能确定下来。因此，当把一个泛型存储到数组中时，编译器在编译阶段无法确认数据类型是否匹配，因此会给出警告信息；即如果泛型的真实数据类型无法和参数数组的类型匹配，会导致 classcastexception 异常。\n\n@safevarargs 注解使用范围：\n\n * @safevarargs 注解可以用于构造方法。\n * @safevarargs 注解可以用于 static 或 final 方法。\n\n@safevarargs 示例：\n\npublic class safevarargsannotationdemo {\n    /**\n     * 此方法实际上并不安全，不使用此注解，编译时会告警\n     */\n    @safevarargs\n    static void wrongmethod(list<string>... stringlists) {\n        object[] array = stringlists;\n        list<integer> tmplist = arrays.aslist(42);\n        array[0] = tmplist; // 语法错误，但是编译不告警\n        string s = stringlists[0].get(0); // 运行时报 classcastexception\n    }\n\n    public static void main(string[] args) {\n        list<string> list = new arraylist<>();\n        list.add("a");\n        list.add("b");\n\n        list<string> list2 = new arraylist<>();\n        list.add("1");\n        list.add("2");\n\n        wrongmethod(list, list2);\n    }\n}\n\n\n以上代码，如果不使用 @safevarargs ，编译时会告警\n\n[warning] /d:/codes/zp/java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/safevarargsannotationdemo.java: 某些输入文件使用了未经检查或不安全的操作。\n[warning] /d:/codes/zp/java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/safevarargsannotationdemo.java: 有关详细信息, 请使用 -xlint:unchecked 重新编译。\n\n\n\n# @functionalinterface\n\n@functionalinterface 在 jdk8 引入。\n\n@functionalinterface 用于指示被修饰的接口是函数式接口。\n\n需要注意的是，如果一个接口符合"函数式接口"定义，不加 @functionalinterface 也没关系；但如果编写的不是函数式接口，却使用 @functioninterface，那么编译器会报错。\n\n什么是函数式接口？\n\n函数式接口(functional interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。\n\n函数式接口的特点：\n\n * 接口有且只能有个一个抽象方法（抽象方法只有方法定义，没有方法体）。\n * 不能在接口中覆写 object 类中的 public 方法（写了编译器也会报错）。\n * 允许有 default 实现方法。\n\n示例：\n\npublic class functionalinterfaceannotationdemo {\n\n    @functionalinterface\n    public interface func1<t> {\n        void printmessage(t message);\n    }\n\n    /**\n     * @functionalinterface 修饰的接口中定义两个抽象方法，编译时会报错\n     * @param <t>\n     */\n    /*@functionalinterface\n    public interface func2<t> {\n        void printmessage(t message);\n        void printmessage2(t message);\n    }*/\n\n    public static void main(string[] args) {\n        func1 func1 = message -> system.out.println(message);\n        func1.printmessage("hello");\n        func1.printmessage(100);\n    }\n}\n\n\n\n# 元注解\n\njdk 中虽然内置了几个注解，但这远远不能满足开发过程中遇到的千变万化的需求。所以我们需要自定义注解，而这就需要用到元注解。\n\n元注解的作用就是用于定义其它的注解。\n\njava 中提供了以下元注解类型：\n\n * @retention\n * @target\n * @documented\n * @inherited（jdk8 引入）\n * @repeatable（jdk8 引入）\n\n这些类型和它们所支持的类在 java.lang.annotation 包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。\n\n\n# @retention\n\n@retention 指明了注解的保留级别。\n\n@retention 源码：\n\n@documented\n@retention(retentionpolicy.runtime)\n@target(elementtype.annotation_type)\npublic @interface retention {\n    retentionpolicy value();\n}\n\n\nretentionpolicy 是一个枚举类型，它定义了被 @retention 修饰的注解所支持的保留级别：\n\n * retentionpolicy.source - 标记的注解仅在源文件中有效，编译器会忽略。\n * retentionpolicy.class - 标记的注解在 class 文件中有效，jvm 会忽略。\n * retentionpolicy.runtime - 标记的注解在运行时有效。\n\n@retention 示例：\n\n@target(elementtype.field)\n@retention(retentionpolicy.runtime)\npublic @interface column {\n    public string name() default "fieldname";\n    public string setfuncname() default "setfield";\n    public string getfuncname() default "getfield";\n    public boolean defaultdbvalue() default false;\n}\n\n\n\n# @documented\n\n@documented 表示无论何时使用指定的注解，都应使用 javadoc（默认情况下，注释不包含在 javadoc 中）。更多内容可以参考：javadoc tools page。\n\n@documented 示例：\n\n@target(elementtype.field)\n@retention(retentionpolicy.runtime)\n@documented\npublic @interface column {\n    public string name() default "fieldname";\n    public string setfuncname() default "setfield";\n    public string getfuncname() default "getfield";\n    public boolean defaultdbvalue() default false;\n}\n\n\n\n# @target\n\n@target 指定注解可以修饰的元素类型。\n\n@target 源码：\n\n@documented\n@retention(retentionpolicy.runtime)\n@target(elementtype.annotation_type)\npublic @interface target {\n    elementtype[] value();\n}\n\n\nelementtype 是一个枚举类型，它定义了被 @target 修饰的注解可以应用的范围：\n\n * elementtype.annotation_type - 标记的注解可以应用于注解类型。\n * elementtype.constructor - 标记的注解可以应用于构造函数。\n * elementtype.field - 标记的注解可以应用于字段或属性。\n * elementtype.local_variable - 标记的注解可以应用于局部变量。\n * elementtype.method - 标记的注解可以应用于方法。\n * elementtype.package - 标记的注解可以应用于包声明。\n * elementtype.parameter - 标记的注解可以应用于方法的参数。\n * elementtype.type - 标记的注解可以应用于类的任何元素。\n\n@target 示例：\n\n@target(elementtype.type)\npublic @interface table {\n    /**\n     * 数据表名称注解，默认值为类名称\n     * @return\n     */\n    public string tablename() default "classname";\n}\n\n@target(elementtype.field)\npublic @interface nodbcolumn {}\n\n\n\n# @inherited\n\n@inherited 表示注解类型可以被继承（默认情况下不是这样）。\n\n表示自动继承注解类型。 如果注解类型声明中存在 @inherited 元注解，则注解所修饰类的所有子类都将会继承此注解。\n\n> 🔔 注意：@inherited 注解类型是被标注过的类的子类所继承。类并不从它所实现的接口继承注解，方法并不从它所覆写的方法继承注解。\n> \n> 此外，当 @inherited 类型标注的注解的 @retention 是 retentionpolicy.runtime，则反射 api 增强了这种继承性。如果我们使用 java.lang.reflect 去查询一个 @inherited 类型的注解时，反射代码检查将展开工作：检查类和其父类，直到发现指定的注解类型被发现，或者到达类继承结构的顶层。\n\n@inherited\npublic @interface greeting {\n    public enum fontcolor{ bule,red,green};\n    string name();\n    fontcolor fontcolor() default fontcolor.green;\n}\n\n\n\n# @repeatable\n\n@repeatable 表示注解可以重复使用。\n\n以 spring @scheduled 为例：\n\n@target({elementtype.method, elementtype.annotation_type})\n@retention(retentionpolicy.runtime)\n@documented\npublic @interface schedules {\n\tscheduled[] value();\n}\n\n@target({elementtype.method, elementtype.annotation_type})\n@retention(retentionpolicy.runtime)\n@documented\n@repeatable(schedules.class)\npublic @interface scheduled {\n  // ...\n}\n\n\n应用示例：\n\npublic class taskrunner {\n\n    @scheduled("0 0/15 * * * ?")\n    @scheduled("0 0 12 * ?")\n    public void task1() {}\n}\n\n\n\n# 自定义注解\n\n使用 @interface 自定义注解时，自动继承了 java.lang.annotation.annotation 接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、class、string、enum）。可以通过 default 来声明参数的默认值。\n\n这里，我会通过实现一个名为 regexvalid 的正则校验注解工具来展示自定义注解的全步骤。\n\n\n# 注解的定义\n\n注解的语法格式如下：\n\npublic @interface 注解名 {定义体}\n\n\n我们来定义一个注解：\n\n@documented\n@target({elementtype.field, elementtype.parameter})\n@retention(retentionpolicy.runtime)\npublic @interface regexvalid {}\n\n\n> 说明：\n> \n> 通过上一节对于元注解 @target、@retention、@documented 的说明，这里就很容易理解了。\n> \n>  * 上面的代码中定义了一个名为 @regexvalid 的注解。\n>  * @documented 表示 @regexvalid 应该使用 javadoc。\n>  * @target({elementtype.field, elementtype.parameter}) 表示 @regexvalid 可以在类成员或方法参数上修饰。\n>  * @retention(retentionpolicy.runtime) 表示 @regexvalid 在运行时有效。\n\n此时，我们已经定义了一个没有任何属性的注解，如果到此为止，它仅仅是一个标记注解。作为正则工具，没有属性可什么也做不了。接下来，我们将为它添加注解属性。\n\n\n# 注解属性\n\n注解属性的语法形式如下：\n\n[访问级别修饰符] [数据类型] 名称() default 默认值;\n\n\n例如，我们要定义在注解中定义一个名为 value 的字符串属性，其默认值为空字符串，访问级别为默认级别，那么应该定义如下：\n\nstring value() default "";\n\n\n> 🔔 注意：在注解中，我们定义属性时，属性名后面需要加 ()。\n\n定义注解属性有以下要点：\n\n * 注解属性只能使用 public 或默认访问级别（即不指定访问级别修饰符）修饰。\n\n * 注解属性的数据类型有限制要求。支持的数据类型如下：\n   \n   * 所有基本数据类型（byte、char、short、int、long、float、double、boolean）\n   * string 类型\n   * class 类\n   * enum 类型\n   * annotation 类型\n   * 以上所有类型的数组\n\n * 注解属性必须有确定的值，建议指定默认值。注解属性只能通过指定默认值或使用注解时指定属性值，相较之下，指定默认值的方式更为可靠。注解属性如果是引用类型，不可以为 null。这个约束使得注解处理器很难判断注解属性是默认值，或是使用注解时所指定的属性值。为此，我们设置默认值时，一般会定义一些特殊的值，例如空字符串或者负数。\n\n * 如果注解中只有一个属性值，最好将其命名为 value。因为，指定属性名为 value，在使用注解时，指定 value 的值可以不指定属性名称。\n\n// 这两种方式效果相同\n@regexvalid("^((\\\\+)?86\\\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\\\d{8}$")\n@regexvalid(value = "^((\\\\+)?86\\\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\\\d{8}$")\n\n\n示例：\n\n了解了注解属性的定义要点，让我们来为 @regexvalid 注解定义几个属性。\n\n@documented\n@target({elementtype.field, elementtype.parameter})\n@retention(retentionpolicy.runtime)\npublic @interface regexvalid {\n    enum policy {\n        // @formatter:off\n        empty(null),\n        date("^(?:(?!0000)[0-9]{4}([-/.]?)(?:(?:0?[1-9]|1[0-2])\\\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\\\1"\n            + "(?:29|30)|(?:0?[13578]|1[02])\\\\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|"\n            + "(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\\\\2(?:29))$"),\n        mail("^[a-za-z0-9](([_\\\\.\\\\-]?[a-za-z0-9]+)*)@([a-za-z0-9]+)(([\\\\.\\\\-]?[a-za-z0-9]+)*)\\\\.([a-za-z]{2,})$");\n        // @formatter:on\n\n        private string policy;\n\n        policy(string policy) {\n            this.policy = policy;\n        }\n\n        public string getpolicy() {\n            return policy;\n        }\n    }\n\n    string value() default "";\n    policy policy() default policy.empty;\n}\n\n\n> 说明：\n> \n> 在上面的示例代码中，我们定义了两个注解属性：string 类型的 value 属性和 policy 枚举类型的 policy 属性。policy 枚举中定义了几个默认的正则表达式，这是为了直接使用这几个常用表达式去正则校验。考虑到，我们可能需要自己传入一些自定义正则表达式去校验其他场景，所以定义了 value 属性，允许使用者传入正则表达式。\n\n至此，@regexvalid 的声明已经结束。但是，程序仍不知道如何处理 @regexvalid 这个注解。我们还需要定义注解处理器。\n\n\n# 注解处理器\n\n如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。jdk5 扩展了反射机制的 api，以帮助程序员快速的构造自定义注解处理器。\n\njava.lang.annotation.annotation 是一个接口，程序可以通过反射来获取指定程序元素的注解对象，然后通过注解对象来获取注解里面的元数据。\n\nannotation 接口源码如下：\n\npublic interface annotation {\n    boolean equals(object obj);\n\n    int hashcode();\n\n    string tostring();\n\n    class<? extends annotation> annotationtype();\n}\n\n\n除此之外，java 中支持注解处理器接口 java.lang.reflect.annotatedelement ，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：\n\n * class - 类定义\n * constructor - 构造器定义\n * field - 累的成员变量定义\n * method - 类的方法定义\n * package - 类的包定义\n\njava.lang.reflect 包下主要包含一些实现反射功能的工具类。实际上，java.lang.reflect 包所有提供的反射 api 扩充了读取运行时注解信息的能力。当一个注解类型被定义为运行时的注解后，该注解才能是运行时可见，当 class 文件被装载时被保存在 class 文件中的注解才会被虚拟机读取。 annotatedelement 接口是所有程序元素（class、method 和 constructor）的父接口，所以程序通过反射获取了某个类的annotatedelement 对象之后，程序就可以调用该对象的如下四个个方法来访问注解信息：\n\n * getannotation - 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回 null。\n * getannotations - 返回该程序元素上存在的所有注解。\n * isannotationpresent - 判断该程序元素上是否包含指定类型的注解，存在则返回 true，否则返回 false。\n * getdeclaredannotations - 返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。\n\n了解了以上内容，让我们来实现 @regexvalid 的注解处理器：\n\nimport java.lang.reflect.field;\nimport java.util.regex.matcher;\nimport java.util.regex.pattern;\n\npublic class regexvalidutil {\n    public static boolean check(object obj) throws exception {\n        boolean result = true;\n        stringbuilder sb = new stringbuilder();\n        field[] fields = obj.getclass().getdeclaredfields();\n        for (field field : fields) {\n            // 判断成员是否被 @regexvalid 注解所修饰\n            if (field.isannotationpresent(regexvalid.class)) {\n                regexvalid valid = field.getannotation(regexvalid.class);\n\n                // 如果 value 为空字符串，说明没有注入自定义正则表达式，改用 policy 属性\n                string value = valid.value();\n                if ("".equals(value)) {\n                    regexvalid.policy policy = valid.policy();\n                    value = policy.getpolicy();\n                }\n\n                // 通过设置 setaccessible(true) 来访问私有成员\n                field.setaccessible(true);\n                object fieldobj = null;\n                try {\n                    fieldobj = field.get(obj);\n                } catch (illegalaccessexception e) {\n                    e.printstacktrace();\n                }\n                if (fieldobj == null) {\n                    sb.append("\\n")\n                        .append(string.format("%s 类中的 %s 字段不能为空！", obj.getclass().getname(), field.getname()));\n                    result = false;\n                } else {\n                    if (fieldobj instanceof string) {\n                        string text = (string) fieldobj;\n                        pattern p = pattern.compile(value);\n                        matcher m = p.matcher(text);\n                        result = m.matches();\n                        if (!result) {\n                            sb.append("\\n").append(string.format("%s 不是合法的 %s ！", text, field.getname()));\n                        }\n                    } else {\n                        sb.append("\\n").append(\n                            string.format("%s 类中的 %s 字段不是字符串类型，不能使用此注解校验！", obj.getclass().getname(), field.getname()));\n                        result = false;\n                    }\n                }\n            }\n        }\n\n        if (sb.length() > 0) {\n            throw new exception(sb.tostring());\n        }\n        return result;\n    }\n}\n\n\n> 说明：\n> \n> 以上示例中的注解处理器，执行步骤如下：\n> \n>  1. 通过 getdeclaredfields 反射方法获取传入对象的所有成员。\n>  2. 遍历成员，使用 isannotationpresent 判断成员是否被指定注解所修饰，如果不是，直接跳过。\n>  3. 如果成员被注解所修饰，通过 regexvalid valid = field.getannotation(regexvalid.class); 这样的形式获取，注解实例化对象，然后，就可以使用 valid.value() 或 valid.policy() 这样的形式获取注解中设定的属性值。\n>  4. 根据属性值，进行逻辑处理。\n\n\n# 使用注解\n\n完成了以上工作，我们就可以使用自定义注解了，示例如下：\n\npublic class regexvaliddemo {\n    static class user {\n        private string name;\n        @regexvalid(policy = regexvalid.policy.date)\n        private string date;\n        @regexvalid(policy = regexvalid.policy.mail)\n        private string mail;\n        @regexvalid("^((\\\\+)?86\\\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\\\d{8}$")\n        private string phone;\n\n        public user(string name, string date, string mail, string phone) {\n            this.name = name;\n            this.date = date;\n            this.mail = mail;\n            this.phone = phone;\n        }\n\n        @override\n        public string tostring() {\n            return "user{" + "name=\'" + name + \'\\\'\' + ", date=\'" + date + \'\\\'\' + ", mail=\'" + mail + \'\\\'\' + ", phone=\'"\n                + phone + \'\\\'\' + \'}\';\n        }\n    }\n\n    static void printdate(@regexvalid(policy = regexvalid.policy.date) string date){\n        system.out.println(date);\n    }\n\n    public static void main(string[] args) throws exception {\n        user user = new user("tom", "1990-01-31", "xxx@163.com", "18612341234");\n        user user2 = new user("jack", "2019-02-29", "sadhgs", "183xxxxxxxx");\n        if (regexvalidutil.check(user)) {\n            system.out.println(user + "正则校验通过");\n        }\n        if (regexvalidutil.check(user2)) {\n            system.out.println(user2 + "正则校验通过");\n        }\n    }\n}\n\n\n\n# 小结\n\n\n\n\n\n\n\n\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * effective java\n * oracle 官方文档之注解篇\n * 深入理解 java：注解（annotation）自定义注解入门\n * https://blog.csdn.net/briblue/article/details/73824058',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 常用工具类",frontmatter:{title:"Java 常用工具类",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE","工具类"],abbrlink:"c84bdeb5",date:"2019-12-16T16:59:15.000Z",permalink:"/pages/c29a85/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/41.Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB.html",relativePath:"01.基础特性/41.Java常用工具类.md",key:"v-028ab83c",path:"/pages/c29a85/",headers:[{level:2,title:"字符串",slug:"字符串",normalizedTitle:"字符串",charIndex:52},{level:3,title:"String",slug:"string",normalizedTitle:"string",charIndex:60},{level:3,title:"StringBuffer",slug:"stringbuffer",normalizedTitle:"stringbuffer",charIndex:71},{level:3,title:"StringBuilder",slug:"stringbuilder",normalizedTitle:"stringbuilder",charIndex:88},{level:2,title:"日期时间",slug:"日期时间",normalizedTitle:"日期时间",charIndex:106},{level:3,title:"Date",slug:"date",normalizedTitle:"date",charIndex:115},{level:3,title:"SimpleDateFormat",slug:"simpledateformat",normalizedTitle:"simpledateformat",charIndex:124},{level:3,title:"Calendar",slug:"calendar",normalizedTitle:"calendar",charIndex:145},{level:2,title:"数学",slug:"数学",normalizedTitle:"数学",charIndex:158},{level:3,title:"Number",slug:"number",normalizedTitle:"number",charIndex:165},{level:3,title:"Math",slug:"math",normalizedTitle:"math",charIndex:176},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:185}],headersStr:"字符串 String StringBuffer StringBuilder 日期时间 Date SimpleDateFormat Calendar 数学 Number Math 参考资料",content:"# Java 常用工具类\n\n> 并发、IO、容器的工具类不会在本文提及，后面会有专题一一道来。\n\n\n# 字符串\n\n\n# String\n\n\n# StringBuffer\n\n\n# StringBuilder\n\n\n# 日期时间\n\n\n# Date\n\n\n# SimpleDateFormat\n\n\n# Calendar\n\n\n# 数学\n\n\n# Number\n\n\n# Math\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）",normalizedContent:"# java 常用工具类\n\n> 并发、io、容器的工具类不会在本文提及，后面会有专题一一道来。\n\n\n# 字符串\n\n\n# string\n\n\n# stringbuffer\n\n\n# stringbuilder\n\n\n# 日期时间\n\n\n# date\n\n\n# simpledateformat\n\n\n# calendar\n\n\n# 数学\n\n\n# number\n\n\n# math\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"深入理解 Java String 类型",frontmatter:{title:"深入理解 Java String 类型",categories:["编程","Java","JavaSE","基础特性"],tags:["Java","JavaSE","工具类","字符串"],abbrlink:"a673a8",date:"2020-12-25T18:43:11.000Z",permalink:"/pages/0c9e8c/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/42.JavaString%E7%B1%BB%E5%9E%8B.html",relativePath:"01.基础特性/42.JavaString类型.md",key:"v-754b2a7f",path:"/pages/0c9e8c/",headers:[{level:2,title:"String 的不可变性",slug:"string-的不可变性",normalizedTitle:"string 的不可变性",charIndex:119},{level:2,title:"String 的性能考量",slug:"string-的性能考量",normalizedTitle:"string 的性能考量",charIndex:929},{level:3,title:"字符串拼接",slug:"字符串拼接",normalizedTitle:"字符串拼接",charIndex:946},{level:3,title:"字符串分割",slug:"字符串分割",normalizedTitle:"字符串分割",charIndex:1696},{level:3,title:"String.intern",slug:"string-intern",normalizedTitle:"string.intern",charIndex:1903},{level:2,title:"String、StringBuffer、StringBuilder 有什么区别",slug:"string、stringbuffer、stringbuilder-有什么区别",normalizedTitle:"string、stringbuffer、stringbuilder 有什么区别",charIndex:2668},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3478}],headersStr:"String 的不可变性 String 的性能考量 字符串拼接 字符串分割 String.intern String、StringBuffer、StringBuilder 有什么区别 参考资料",content:'# 深入理解 Java String 类型\n\n> String 类型可能是 Java 中应用最频繁的引用类型，但它的性能问题却常常被忽略。高效的使用字符串，可以提升系统的整体性能。当然，要做到高效使用字符串，需要深入了解其特性。\n\n\n# String 的不可变性\n\n我们先来看下 String 的定义：\n\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n\nString 类被 final 关键字修饰，表示不可继承 String 类。\n\nString 类的数据存储于 char[] 数组，这个数组被 final 关键字修饰，表示 String 对象不可被更改。\n\n为什么 Java 要这样设计？\n\n（1）保证 String 对象安全性。避免 String 被篡改。\n\n（2）保证 hash 值不会频繁变更。\n\n（3）可以实现字符串常量池。通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 String str="abc"; 另一种是字符串变量通过 new 形式的创建，如 String str = new String("abc")。\n\n使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。\n\nString str = new String("abc") 这种方式，首先在编译类文件时，"abc" 常量字符串将会放入到常量结构中，在类加载时，"abc" 将会在常量池中创建；其次，在调用 new 时，JVM 命令将会调用 String 的构造函数，同时引用常量池中的 "abc" 字符串，在堆内存中创建一个 String 对象；最后，str 将引用 String 对象。\n\n\n# String 的性能考量\n\n\n# 字符串拼接\n\n字符串常量的拼接，编译器会将其优化为一个常量字符串。\n\n【示例】字符串常量拼接\n\npublic static void main(String[] args) {\n    // 本行代码在 class 文件中，会被编译器直接优化为：\n    // String str = "abc";\n    String str = "a" + "b" + "c";\n    System.out.println("str = " + str);\n}\n\n\n字符串变量的拼接，编译器会优化成 StringBuilder 的方式。\n\n【示例】字符串变量的拼接\n\npublic static void main(String[] args) {\n    String str = "";\n    for(int i=0; i<1000; i++) {\n        // 本行代码会被编译器优化为：\n        // str = (new StringBuilder(String.valueOf(str))).append(i).toString();\n        str = str + i;\n    }\n}\n\n\n但是，每次循环都会生成一个新的 StringBuilder 实例，同样也会降低系统的性能。\n\n字符串拼接的正确方案：\n\n * 如果需要使用字符串拼接，应该优先考虑 StringBuilder 的 append 方法替代使用 + 号。\n * 如果在并发编程中，String 对象的拼接涉及到线程安全，可以使用 StringBuffer。但是要注意，由于 StringBuffer 是线程安全的，涉及到锁竞争，所以从性能上来说，要比 StringBuilder 差一些。\n\n\n# 字符串分割\n\nString 的 split() 方法使用正则表达式实现其强大的分割功能。而正则表达式的性能是非常不稳定的，使用不恰当会引起回溯问题，很可能导致 CPU 居高不下。\n\n所以，应该慎重使用 split() 方法，可以考虑用 String.indexOf() 方法代替 split() 方法完成字符串的分割。如果实在无法满足需求，你就在使用 Split() 方法时，对回溯问题加以重视就可以了。\n\n\n# String.intern\n\n在每次赋值的时候使用 String 的 intern 方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用，这样一开始的对象就可以被回收掉。\n\n在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用。\n\n如果调用 intern 方法，会去查看字符串常量池中是否有等于该对象的字符串，如果没有，就在常量池中新增该对象，并返回该对象引用；如果有，就返回常量池中的字符串引用。堆内存中原有的对象由于没有引用指向它，将会通过垃圾回收器回收。\n\n【示例】\n\npublic class SharedLocation {\n\n\tprivate String city;\n\tprivate String region;\n\tprivate String countryCode;\n}\n\nSharedLocation sharedLocation = new SharedLocation();\nsharedLocation.setCity(messageInfo.getCity().intern());\t\tsharedLocation.setCountryCode(messageInfo.getRegion().intern());\nsharedLocation.setRegion(messageInfo.getCountryCode().intern());\n\n\n> 使用 intern 方法需要注意：一定要结合实际场景。因为常量池的实现是类似于一个 HashTable 的实现方式，HashTable 存储的数据越大，遍历的时间复杂度就会增加。如果数据过大，会增加整个字符串常量池的负担。\n\n\n# String、StringBuffer、StringBuilder 有什么区别\n\nString 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。\n\nStringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 是一个线程安全的可修改字符序列。StringBuffer 的线程安全是通过在各种修改数据的方法上用 synchronized 关键字修饰实现的。\n\nStringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。\n\nStringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 arraycopy。\n\n除非有线程安全的需要，不然一般都使用 StringBuilder。\n\n\n# 参考资料\n\n * 《Java 编程思想（Thinking in java）》\n * 《Java 核心技术 卷 I 基础知识》\n * 《Java 性能调优实战》\n * 《Java 核心技术面试精讲》\n * Java 基本数据类型和引用类型\n * 深入剖析 Java 中的装箱和拆箱',normalizedContent:'# 深入理解 java string 类型\n\n> string 类型可能是 java 中应用最频繁的引用类型，但它的性能问题却常常被忽略。高效的使用字符串，可以提升系统的整体性能。当然，要做到高效使用字符串，需要深入了解其特性。\n\n\n# string 的不可变性\n\n我们先来看下 string 的定义：\n\npublic final class string\n    implements java.io.serializable, comparable<string>, charsequence {\n    /** the value is used for character storage. */\n    private final char value[];\n\n\nstring 类被 final 关键字修饰，表示不可继承 string 类。\n\nstring 类的数据存储于 char[] 数组，这个数组被 final 关键字修饰，表示 string 对象不可被更改。\n\n为什么 java 要这样设计？\n\n（1）保证 string 对象安全性。避免 string 被篡改。\n\n（2）保证 hash 值不会频繁变更。\n\n（3）可以实现字符串常量池。通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 string str="abc"; 另一种是字符串变量通过 new 形式的创建，如 string str = new string("abc")。\n\n使用第一种方式创建字符串对象时，jvm 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。\n\nstring str = new string("abc") 这种方式，首先在编译类文件时，"abc" 常量字符串将会放入到常量结构中，在类加载时，"abc" 将会在常量池中创建；其次，在调用 new 时，jvm 命令将会调用 string 的构造函数，同时引用常量池中的 "abc" 字符串，在堆内存中创建一个 string 对象；最后，str 将引用 string 对象。\n\n\n# string 的性能考量\n\n\n# 字符串拼接\n\n字符串常量的拼接，编译器会将其优化为一个常量字符串。\n\n【示例】字符串常量拼接\n\npublic static void main(string[] args) {\n    // 本行代码在 class 文件中，会被编译器直接优化为：\n    // string str = "abc";\n    string str = "a" + "b" + "c";\n    system.out.println("str = " + str);\n}\n\n\n字符串变量的拼接，编译器会优化成 stringbuilder 的方式。\n\n【示例】字符串变量的拼接\n\npublic static void main(string[] args) {\n    string str = "";\n    for(int i=0; i<1000; i++) {\n        // 本行代码会被编译器优化为：\n        // str = (new stringbuilder(string.valueof(str))).append(i).tostring();\n        str = str + i;\n    }\n}\n\n\n但是，每次循环都会生成一个新的 stringbuilder 实例，同样也会降低系统的性能。\n\n字符串拼接的正确方案：\n\n * 如果需要使用字符串拼接，应该优先考虑 stringbuilder 的 append 方法替代使用 + 号。\n * 如果在并发编程中，string 对象的拼接涉及到线程安全，可以使用 stringbuffer。但是要注意，由于 stringbuffer 是线程安全的，涉及到锁竞争，所以从性能上来说，要比 stringbuilder 差一些。\n\n\n# 字符串分割\n\nstring 的 split() 方法使用正则表达式实现其强大的分割功能。而正则表达式的性能是非常不稳定的，使用不恰当会引起回溯问题，很可能导致 cpu 居高不下。\n\n所以，应该慎重使用 split() 方法，可以考虑用 string.indexof() 方法代替 split() 方法完成字符串的分割。如果实在无法满足需求，你就在使用 split() 方法时，对回溯问题加以重视就可以了。\n\n\n# string.intern\n\n在每次赋值的时候使用 string 的 intern 方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用，这样一开始的对象就可以被回收掉。\n\n在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用。\n\n如果调用 intern 方法，会去查看字符串常量池中是否有等于该对象的字符串，如果没有，就在常量池中新增该对象，并返回该对象引用；如果有，就返回常量池中的字符串引用。堆内存中原有的对象由于没有引用指向它，将会通过垃圾回收器回收。\n\n【示例】\n\npublic class sharedlocation {\n\n\tprivate string city;\n\tprivate string region;\n\tprivate string countrycode;\n}\n\nsharedlocation sharedlocation = new sharedlocation();\nsharedlocation.setcity(messageinfo.getcity().intern());\t\tsharedlocation.setcountrycode(messageinfo.getregion().intern());\nsharedlocation.setregion(messageinfo.getcountrycode().intern());\n\n\n> 使用 intern 方法需要注意：一定要结合实际场景。因为常量池的实现是类似于一个 hashtable 的实现方式，hashtable 存储的数据越大，遍历的时间复杂度就会增加。如果数据过大，会增加整个字符串常量池的负担。\n\n\n# string、stringbuffer、stringbuilder 有什么区别\n\nstring 是 java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 string 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。\n\nstringbuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。stringbuffer 是一个线程安全的可修改字符序列。stringbuffer 的线程安全是通过在各种修改数据的方法上用 synchronized 关键字修饰实现的。\n\nstringbuilder 是 java 1.5 中新增的，在能力上和 stringbuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。\n\nstringbuffer 和 stringbuilder 底层都是利用可修改的（char，jdk 9 以后是 byte）数组，二者都继承了 abstractstringbuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 arraycopy。\n\n除非有线程安全的需要，不然一般都使用 stringbuilder。\n\n\n# 参考资料\n\n * 《java 编程思想（thinking in java）》\n * 《java 核心技术 卷 i 基础知识》\n * 《java 性能调优实战》\n * 《java 核心技术面试精讲》\n * java 基本数据类型和引用类型\n * 深入剖析 java 中的装箱和拆箱',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 基础特性",frontmatter:{title:"Java 基础特性",categories:["编程","Java","JavaSE"],tags:["Java","JavaSE"],abbrlink:"d9e0d71",date:"2020-06-04T13:51:01.000Z",hidden:!0,permalink:"/pages/80c858/"},regularPath:"/01.%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/",relativePath:"01.基础特性/README.md",key:"v-d972a732",path:"/pages/80c858/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:44},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:219},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:852}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Java 基础特性\n\n> Java 基础篇总结 Java 的一些基础特性。\n\n\n# 📖 内容\n\n * Java 开发环境\n * Java 基础语法特性\n * Java 基本数据类型\n * Java 面向对象\n * Java 方法\n * Java 数组\n * Java 枚举\n * Java 控制语句\n * Java 异常\n * Java 泛型\n * Java 反射\n * Java 注解\n * Java String 类型\n\n\n# 📚 资料\n\n * 书籍\n   * Java 四大名著\n     * 《Java 编程思想（Thinking in java）》\n     * 《Java 核心技术 卷 I 基础知识》\n     * 《Java 核心技术 卷 II 高级特性》\n     * 《Effective Java》\n   * Java 并发\n     * 《Java 并发编程实战》\n     * 《Java 并发编程的艺术》\n   * Java 虚拟机\n     * 《深入理解 Java 虚拟机》\n   * Java 入门\n     * 《O'Reilly：Head First Java》\n     * 《疯狂 Java 讲义》\n   * 其他\n     * 《Head First 设计模式》\n     * 《Java 网络编程》\n     * 《Java 加密与解密的艺术》\n     * 《阿里巴巴 Java 开发手册》\n * 教程、社区\n   * Runoob Java 教程\n   * java-design-patterns\n   * Java\n   * 《Java 核心技术面试精讲》\n   * 《Java 性能调优实战》\n   * 《Java 业务开发常见错误 100 例》\n   * 深入拆解 Java 虚拟机\n   * 《Java 并发编程实战》\n * 面试\n   * CS-Notes\n   * JavaGuide\n   * advanced-java\n\n\n# 🚪 传送\n\n◾ 🏠 JAVACORE 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"# java 基础特性\n\n> java 基础篇总结 java 的一些基础特性。\n\n\n# 📖 内容\n\n * java 开发环境\n * java 基础语法特性\n * java 基本数据类型\n * java 面向对象\n * java 方法\n * java 数组\n * java 枚举\n * java 控制语句\n * java 异常\n * java 泛型\n * java 反射\n * java 注解\n * java string 类型\n\n\n# 📚 资料\n\n * 书籍\n   * java 四大名著\n     * 《java 编程思想（thinking in java）》\n     * 《java 核心技术 卷 i 基础知识》\n     * 《java 核心技术 卷 ii 高级特性》\n     * 《effective java》\n   * java 并发\n     * 《java 并发编程实战》\n     * 《java 并发编程的艺术》\n   * java 虚拟机\n     * 《深入理解 java 虚拟机》\n   * java 入门\n     * 《o'reilly：head first java》\n     * 《疯狂 java 讲义》\n   * 其他\n     * 《head first 设计模式》\n     * 《java 网络编程》\n     * 《java 加密与解密的艺术》\n     * 《阿里巴巴 java 开发手册》\n * 教程、社区\n   * runoob java 教程\n   * java-design-patterns\n   * java\n   * 《java 核心技术面试精讲》\n   * 《java 性能调优实战》\n   * 《java 业务开发常见错误 100 例》\n   * 深入拆解 java 虚拟机\n   * 《java 并发编程实战》\n * 面试\n   * cs-notes\n   * javaguide\n   * advanced-java\n\n\n# 🚪 传送\n\n◾ 🏠 javacore 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 正则从入门到精通",frontmatter:{title:"Java 正则从入门到精通",categories:["编程","Java","JavaSE","高级特性"],tags:["Java","JavaSE","正则"],abbrlink:"fbbad3ed",date:"2020-12-25T18:43:11.000Z",permalink:"/pages/272038/"},regularPath:"/02.%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/01.Java%E6%AD%A3%E5%88%99.html",relativePath:"02.高级特性/01.Java正则.md",key:"v-0488142c",path:"/pages/272038/",headers:[{level:2,title:"正则简介",slug:"正则简介",normalizedTitle:"正则简介",charIndex:78},{level:3,title:"正则表达式是什么",slug:"正则表达式是什么",normalizedTitle:"正则表达式是什么",charIndex:87},{level:3,title:"如何学习正则",slug:"如何学习正则",normalizedTitle:"如何学习正则",charIndex:222},{level:2,title:"正则工具类",slug:"正则工具类",normalizedTitle:"正则工具类",charIndex:534},{level:3,title:"Pattern 类",slug:"pattern-类",normalizedTitle:"pattern 类",charIndex:608},{level:3,title:"Matcher 类",slug:"matcher-类",normalizedTitle:"matcher 类",charIndex:644},{level:4,title:"校验",slug:"校验",normalizedTitle:"校验",charIndex:1187},{level:4,title:"查找",slug:"查找",normalizedTitle:"查找",charIndex:1190},{level:4,title:"替换",slug:"替换",normalizedTitle:"替换",charIndex:1193},{level:2,title:"元字符",slug:"元字符",normalizedTitle:"元字符",charIndex:62},{level:3,title:"基本元字符",slug:"基本元字符",normalizedTitle:"基本元字符",charIndex:8256},{level:4,title:"多选（|）",slug:"多选",normalizedTitle:"多选（|）",charIndex:8372},{level:4,title:"分组（()）",slug:"分组",normalizedTitle:"分组（()）",charIndex:8770},{level:4,title:"指定单字符有效范围（[]）",slug:"指定单字符有效范围",normalizedTitle:"指定单字符有效范围（[]）",charIndex:9243},{level:4,title:"指定单字符无效范围（ [^]）",slug:"指定单字符无效范围",normalizedTitle:"指定单字符无效范围（ [^]）",charIndex:9833},{level:4,title:"限制字符数量（{}）",slug:"限制字符数量",normalizedTitle:"限制字符数量（{}）",charIndex:10461},{level:4,title:"转义字符（/）",slug:"转义字符",normalizedTitle:"转义字符（/）",charIndex:11459},{level:4,title:"指定表达式字符串的开始（^）和结尾（$）",slug:"指定表达式字符串的开始-和结尾",normalizedTitle:"指定表达式字符串的开始（^）和结尾（$）",charIndex:11614},{level:3,title:"等价字符",slug:"等价字符",normalizedTitle:"等价字符",charIndex:8298},{level:4,title:"表示某一类型字符的等价字符",slug:"表示某一类型字符的等价字符",normalizedTitle:"表示某一类型字符的等价字符",charIndex:12306},{level:4,title:"限制字符数量的等价字符",slug:"限制字符数量的等价字符",normalizedTitle:"限制字符数量的等价字符",charIndex:14302},{level:4,title:"元字符优先级顺序",slug:"元字符优先级顺序",normalizedTitle:"元字符优先级顺序",charIndex:15236},{level:2,title:"分组构造",slug:"分组构造",normalizedTitle:"分组构造",charIndex:15569},{level:3,title:"捕获与非捕获",slug:"捕获与非捕获",normalizedTitle:"捕获与非捕获",charIndex:39},{level:3,title:"反向引用",slug:"反向引用",normalizedTitle:"反向引用",charIndex:46},{level:5,title:"带编号的反向引用",slug:"带编号的反向引用",normalizedTitle:"带编号的反向引用",charIndex:15982},{level:4,title:"命名的反向引用",slug:"命名的反向引用",normalizedTitle:"命名的反向引用",charIndex:15772},{level:3,title:"非捕获组",slug:"非捕获组",normalizedTitle:"非捕获组",charIndex:15803},{level:3,title:"零宽断言",slug:"零宽断言",normalizedTitle:"零宽断言",charIndex:51},{level:4,title:"匹配 exp 前面的位置",slug:"匹配-exp-前面的位置",normalizedTitle:"匹配 exp 前面的位置",charIndex:17833},{level:4,title:"匹配 exp 后面的位置",slug:"匹配-exp-后面的位置",normalizedTitle:"匹配 exp 后面的位置",charIndex:17857},{level:4,title:"匹配后面跟的不是 exp 的位置",slug:"匹配后面跟的不是-exp-的位置",normalizedTitle:"匹配后面跟的不是 exp 的位置",charIndex:17881},{level:4,title:"匹配前面不是 exp 的位置",slug:"匹配前面不是-exp-的位置",normalizedTitle:"匹配前面不是 exp 的位置",charIndex:17909},{level:2,title:"贪婪与懒惰",slug:"贪婪与懒惰",normalizedTitle:"贪婪与懒惰",charIndex:56},{level:2,title:"正则附录",slug:"正则附录",normalizedTitle:"正则附录",charIndex:23180},{level:3,title:"匹配正则字符串的方法",slug:"匹配正则字符串的方法",normalizedTitle:"匹配正则字符串的方法",charIndex:23189},{level:3,title:"速查元字符字典",slug:"速查元字符字典",normalizedTitle:"速查元字符字典",charIndex:24442},{level:4,title:"限定符",slug:"限定符",normalizedTitle:"限定符",charIndex:15419},{level:4,title:"定位符",slug:"定位符",normalizedTitle:"定位符",charIndex:25071},{level:4,title:"非打印字符",slug:"非打印字符",normalizedTitle:"非打印字符",charIndex:25276},{level:4,title:"分组",slug:"分组-2",normalizedTitle:"分组",charIndex:8770},{level:4,title:"特殊符号",slug:"特殊符号",normalizedTitle:"特殊符号",charIndex:25906},{level:2,title:"正则实战",slug:"正则实战",normalizedTitle:"正则实战",charIndex:26102},{level:3,title:"最实用的正则",slug:"最实用的正则",normalizedTitle:"最实用的正则",charIndex:26233},{level:4,title:"校验中文",slug:"校验中文",normalizedTitle:"校验中文",charIndex:26243},{level:4,title:"校验身份证号码",slug:"校验身份证号码",normalizedTitle:"校验身份证号码",charIndex:26394},{level:4,title:"校验有效用户名、密码",slug:"校验有效用户名、密码",normalizedTitle:"校验有效用户名、密码",charIndex:27540},{level:4,title:"校验邮箱",slug:"校验邮箱",normalizedTitle:"校验邮箱",charIndex:27758},{level:4,title:"校验 URL",slug:"校验-url",normalizedTitle:"校验 url",charIndex:28164},{level:4,title:"校验时间",slug:"校验时间",normalizedTitle:"校验时间",charIndex:28471},{level:4,title:"校验日期",slug:"校验日期",normalizedTitle:"校验日期",charIndex:28635},{level:4,title:"校验中国手机号码",slug:"校验中国手机号码",normalizedTitle:"校验中国手机号码",charIndex:29183},{level:4,title:"校验中国固话号码",slug:"校验中国固话号码",normalizedTitle:"校验中国固话号码",charIndex:29760},{level:4,title:"校验 IPv4 地址",slug:"校验-ipv4-地址",normalizedTitle:"校验 ipv4 地址",charIndex:30047},{level:4,title:"校验 IPv6 地址",slug:"校验-ipv6-地址",normalizedTitle:"校验 ipv6 地址",charIndex:30392},{level:3,title:"特定字符",slug:"特定字符",normalizedTitle:"特定字符",charIndex:11649},{level:3,title:"特定数字",slug:"特定数字",normalizedTitle:"特定数字",charIndex:31993},{level:2,title:"正则表达式的性能",slug:"正则表达式的性能",normalizedTitle:"正则表达式的性能",charIndex:32199},{level:3,title:"NFA 自动机的回溯",slug:"nfa-自动机的回溯",normalizedTitle:"nfa 自动机的回溯",charIndex:32624},{level:3,title:"如何避免回溯",slug:"如何避免回溯",normalizedTitle:"如何避免回溯",charIndex:33164},{level:4,title:"贪婪模式（Greedy）",slug:"贪婪模式-greedy",normalizedTitle:"贪婪模式（greedy）",charIndex:33174},{level:4,title:"懒惰模式（Reluctant）",slug:"懒惰模式-reluctant",normalizedTitle:"懒惰模式（reluctant）",charIndex:33410},{level:4,title:"独占模式（Possessive）",slug:"独占模式-possessive",normalizedTitle:"独占模式（possessive）",charIndex:33599},{level:3,title:"正则表达式的优化",slug:"正则表达式的优化",normalizedTitle:"正则表达式的优化",charIndex:33809},{level:4,title:"少用贪婪模式，多用独占模式",slug:"少用贪婪模式-多用独占模式",normalizedTitle:"少用贪婪模式，多用独占模式",charIndex:33821},{level:4,title:"减少分支选择",slug:"减少分支选择",normalizedTitle:"减少分支选择",charIndex:33866},{level:4,title:"减少捕获嵌套",slug:"减少捕获嵌套",normalizedTitle:"减少捕获嵌套",charIndex:34172},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:35361}],headersStr:"正则简介 正则表达式是什么 如何学习正则 正则工具类 Pattern 类 Matcher 类 校验 查找 替换 元字符 基本元字符 多选（|） 分组（()） 指定单字符有效范围（[]） 指定单字符无效范围（ [^]） 限制字符数量（{}） 转义字符（/） 指定表达式字符串的开始（^）和结尾（$） 等价字符 表示某一类型字符的等价字符 限制字符数量的等价字符 元字符优先级顺序 分组构造 捕获与非捕获 反向引用 带编号的反向引用 命名的反向引用 非捕获组 零宽断言 匹配 exp 前面的位置 匹配 exp 后面的位置 匹配后面跟的不是 exp 的位置 匹配前面不是 exp 的位置 贪婪与懒惰 正则附录 匹配正则字符串的方法 速查元字符字典 限定符 定位符 非打印字符 分组 特殊符号 正则实战 最实用的正则 校验中文 校验身份证号码 校验有效用户名、密码 校验邮箱 校验 URL 校验时间 校验日期 校验中国手机号码 校验中国固话号码 校验 IPv4 地址 校验 IPv6 地址 特定字符 特定数字 正则表达式的性能 NFA 自动机的回溯 如何避免回溯 贪婪模式（Greedy） 懒惰模式（Reluctant） 独占模式（Possessive） 正则表达式的优化 少用贪婪模式，多用独占模式 减少分支选择 减少捕获嵌套 参考资料",content:'# Java 正则从入门到精通\n\n> 关键词：Pattern、Matcher、捕获与非捕获、反向引用、零宽断言、贪婪与懒惰、元字符、DFA、NFA\n\n\n# 正则简介\n\n\n# 正则表达式是什么\n\n正则表达式（Regular Expression）是一个用正则符号写出的公式，程序对这个公式进行语法分析，建立一个语法分析树，再根据这个分析树结合正则表达式的引擎生成执行程序（这个执行程序我们把它称作状态机，也叫状态自动机），用于字符匹配。\n\n\n# 如何学习正则\n\n正则表达式是一个强大的文本匹配工具，但是它的规则很复杂，理解起来较为困难，容易让人望而生畏。\n\n刚接触正则时，我看了一堆正则的语义说明，但是仍然不明所以。后来，我多接触一些正则的应用实例，渐渐有了感觉，再结合语义说明，终有领悟。我觉得正则表达式和武侠修练武功差不多，应该先练招式，再练心法。如果一开始就直接看正则的规则，保证你会懵逼。当你熟悉基本招式（正则基本使用案例）后，也该修炼修炼心法（正则语法）了。真正的高手不能只靠死记硬背那么几招把式。就像张三丰教张无忌太极拳一样，领悟心法，融会贯通，少侠你就可以无招胜有招，成为传说中的绝世高手。\n\n以上闲话可归纳为一句：学习正则应该从实例去理解规则。\n\n\n# 正则工具类\n\nJDK 中的 java.util.regex 包提供了对正则表达式的支持。\n\njava.util.regex 有三个核心类：\n\n * Pattern 类：Pattern 是一个正则表达式的编译表示。\n * Matcher 类：Matcher 是对输入字符串进行解释和匹配操作的引擎。\n * PatternSyntaxException：PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n\n**注：**需要格外注意一点，在 Java 中使用反斜杠"\\"时必须写成 "\\\\"。所以本文的代码出现形如 String regex = "\\\\$\\\\{.*?\\\\}" 其实就是 \\$\\{.\\*?\\}。\n\n\n# Pattern 类\n\nPattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其静态方法compile，加载正则规则字符串，然后返回一个 Pattern 对象。\n\n与Pattern类一样，Matcher类也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。\n\n【示例】Pattern 和 Matcher 的初始化\n\nPattern p = Pattern.compile(regex);\nMatcher m = p.matcher(content);\n\n\n\n# Matcher 类\n\nMatcher 类可以说是 java.util.regex 中的核心类，它有三类功能：校验、查找、替换。\n\n# 校验\n\n为了校验文本是否与正则规则匹配，Matcher 提供了以下几个返回值为 boolean 的方法。\n\n序号   方法及说明\n1    **public boolean lookingAt() ** 尝试将从区域开头开始的输入序列与该模式匹配。\n2    **public boolean find() **尝试查找与该模式匹配的输入序列的下一个子序列。\n3    **public boolean find(int\n     start）**重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。\n4    **public boolean matches() **尝试将整个区域与模式匹配。\n\n如果你傻傻分不清上面的查找方法有什么区别，那么下面一个例子就可以让你秒懂。\n\n【示例】lookingAt、find、matches\n\npublic static void main(String[] args) {\n\tcheckLookingAt("hello", "helloworld");\n\tcheckLookingAt("world", "helloworld");\n\n\tcheckFind("hello", "helloworld");\n\tcheckFind("world", "helloworld");\n\n\tcheckMatches("hello", "helloworld");\n\tcheckMatches("world", "helloworld");\n\tcheckMatches("helloworld", "helloworld");\n}\n\nprivate static void checkLookingAt(String regex, String content) {\n\tPattern p = Pattern.compile(regex);\n\tMatcher m = p.matcher(content);\n\tif (m.lookingAt()) {\n\t\tSystem.out.println(content + "\\tlookingAt： " + regex);\n\t} else {\n\t\tSystem.out.println(content + "\\tnot lookingAt： " + regex);\n\t}\n}\n\nprivate static void checkFind(String regex, String content) {\n\tPattern p = Pattern.compile(regex);\n\tMatcher m = p.matcher(content);\n\tif (m.find()) {\n\t\tSystem.out.println(content + "\\tfind： " + regex);\n\t} else {\n\t\tSystem.out.println(content + "\\tnot find： " + regex);\n\t}\n}\n\nprivate static void checkMatches(String regex, String content) {\n\tPattern p = Pattern.compile(regex);\n\tMatcher m = p.matcher(content);\n\tif (m.matches()) {\n\t\tSystem.out.println(content + "\\tmatches： " + regex);\n\t} else {\n\t\tSystem.out.println(content + "\\tnot matches： " + regex);\n\t}\n}\n\n\n输出：\n\nhelloworld\tlookingAt： hello\nhelloworld\tnot lookingAt： world\nhelloworld\tfind： hello\nhelloworld\tfind： world\nhelloworld\tnot matches： hello\nhelloworld\tnot matches： world\nhelloworld\tmatches： helloworld\n\n\n说明\n\nregex = "world" 表示的正则规则是以 world 开头的字符串，regex = "hello" 和 regex = "helloworld" 也是同理。\n\n * lookingAt方法从头部开始，检查 content 字符串是否有子字符串于正则规则匹配。\n * find方法检查 content 字符串是否有子字符串于正则规则匹配，不管字符串所在位置。\n * matches方法检查 content 字符串整体是否与正则规则匹配。\n\n# 查找\n\n为了查找文本匹配正则规则的位置，Matcher提供了以下方法：\n\n序号   方法及说明\n1    **public int start() **返回以前匹配的初始索引。\n2    public int start(int group) 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引\n3    **public int end()**返回最后匹配字符之后的偏移量。\n4    **public int end(int\n     group)**返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。\n5    **public String group()**返回前一个符合匹配条件的子序列。\n6    **public String group(int group)**返回指定的符合匹配条件的子序列。\n\n【示例】使用 start()、end()、group() 查找所有匹配正则条件的子序列\n\npublic static void main(String[] args) {\n\tfinal String regex = "world";\n\tfinal String content = "helloworld helloworld";\n\tPattern p = Pattern.compile(regex);\n\tMatcher m = p.matcher(content);\n\tSystem.out.println("content: " + content);\n\n\tint i = 0;\n\twhile (m.find()) {\n\t\ti++;\n\t\tSystem.out.println("[" + i + "th] found");\n\t\tSystem.out.print("start: " + m.start() + ", ");\n\t\tSystem.out.print("end: " + m.end() + ", ");\n\t\tSystem.out.print("group: " + m.group() + "\\n");\n\t}\n}\n\n\n输出\n\ncontent: helloworld helloworld\n[1th] found\nstart: 5, end: 10, group: world\n[2th] found\nstart: 16, end: 21, group: world\n\n\n说明\n\n例子很直白，不言自明了吧。\n\n# 替换\n\n替换方法是替换输入字符串里文本的方法：\n\n序号   方法及说明\n1    **public Matcher appendReplacement(StringBuffer sb, String\n     replacement)**实现非终端添加和替换步骤。\n2    **public StringBuffer appendTail(StringBuffer\n     sb)**实现终端添加和替换步骤。\n3    **public String replaceAll(String replacement) **\n     替换模式与给定替换字符串相匹配的输入序列的每个子序列。\n4    public String replaceFirst(String replacement)\n     替换模式与给定替换字符串匹配的输入序列的第一个子序列。\n5    **public static String quoteReplacement(String\n     s)**返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给 Matcher 类的\n     appendReplacement 方法一个字面字符串一样工作。\n\n【示例】replaceFirst 和 replaceAll\n\npublic static void main(String[] args) {\n\tString regex = "can";\n\tString replace = "can not";\n\tString content = "I can because I think I can.";\n\n\tPattern p = Pattern.compile(regex);\n\tMatcher m = p.matcher(content);\n\n\tSystem.out.println("content: " + content);\n\tSystem.out.println("replaceFirst: " + m.replaceFirst(replace));\n\tSystem.out.println("replaceAll: " + m.replaceAll(replace));\n}\n\n\n输出\n\ncontent: I can because I think I can.\nreplaceFirst: I can not because I think I can.\nreplaceAll: I can not because I think I can not.\n\n\n说明\n\nreplaceFirst：替换第一个匹配正则规则的子序列。\n\nreplaceAll：替换所有匹配正则规则的子序列。\n\n【示例】appendReplacement、appendTail 和 replaceAll\n\npublic static void main(String[] args) {\n\tString regex = "can";\n\tString replace = "can not";\n\tString content = "I can because I think I can.";\n\tStringBuffer sb = new StringBuffer();\n\tStringBuffer sb2 = new StringBuffer();\n\n\tSystem.out.println("content: " + content);\n\tPattern p = Pattern.compile(regex);\n\tMatcher m = p.matcher(content);\n\twhile (m.find()) {\n\t\tm.appendReplacement(sb, replace);\n\t}\n\tSystem.out.println("appendReplacement: " + sb);\n\tm.appendTail(sb);\n\tSystem.out.println("appendTail: " + sb);\n}\n\n\n输出\n\ncontent: I can because I think I can.\nappendReplacement: I can not because I think I can not\nappendTail: I can not because I think I can not.\n\n\n说明\n\n从输出结果可以看出，appendReplacement和appendTail方法组合起来用，功能和replaceAll是一样的。\n\n如果你查看replaceAll的源码，会发现其内部就是使用appendReplacement和appendTail方法组合来实现的。\n\n【示例】quoteReplacement 和 replaceAll，解决特殊字符替换问题\n\npublic static void main(String[] args) {\n\tString regex = "\\\\$\\\\{.*?\\\\}";\n\tString replace = "${product}";\n\tString content = "product is ${productName}.";\n\n\tPattern p = Pattern.compile(regex);\n\tMatcher m = p.matcher(content);\n\tString replaceAll = m.replaceAll(replace);\n\n\tSystem.out.println("content: " + content);\n\tSystem.out.println("replaceAll: " + replaceAll);\n}\n\n\n输出\n\nException in thread "main" java.lang.IllegalArgumentException: No group with name {product}\n\tat java.util.regex.Matcher.appendReplacement(Matcher.java:849)\n\tat java.util.regex.Matcher.replaceAll(Matcher.java:955)\n\tat org.zp.notes.javase.regex.RegexDemo.wrongMethod(RegexDemo.java:42)\n\tat org.zp.notes.javase.regex.RegexDemo.main(RegexDemo.java:18)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\n\n\n说明\n\nString regex = "\\\\$\\\\{.*?\\\\}";表示匹配类似${name}这样的字符串。由于$、{ 、}都是特殊字符，需要用反义字符\\来修饰才能被当做一个字符串字符来处理。\n\n上面的例子是想将 ${productName} 替换为 ${product} ，然而replaceAll方法却将传入的字符串中的$当做特殊字符来处理了。结果产生异常。\n\n如何解决这个问题?\n\nJDK1.5 引入了quoteReplacement方法。它可以用来转换特殊字符。其实源码非常简单，就是判断字符串中如果有\\或$，就为它加一个转义字符\\\n\n我们对上面的代码略作调整：\n\nm.replaceAll(replace)改为m.replaceAll(Matcher.quoteReplacement(replace))，新代码如下：\n\npublic static void main(String[] args) {\n\tString regex = "\\\\$\\\\{.*?\\\\}";\n\tString replace = "${product}";\n\tString content = "product is ${productName}.";\n\n\tPattern p = Pattern.compile(regex);\n\tMatcher m = p.matcher(content);\n\tString replaceAll = m.replaceAll(Matcher.quoteReplacement(replace));\n\n\tSystem.out.println("content: " + content);\n\tSystem.out.println("replaceAll: " + replaceAll);\n}\n\n\n输出\n\ncontent: product is ${productName}.\nreplaceAll: product is ${product}.\n\n\n说明\n\n字符串中如果有\\或$，不能被正常解析的问题解决。\n\n\n# 元字符\n\n元字符(metacharacters)就是正则表达式中具有特殊意义的专用字符。\n\n\n# 基本元字符\n\n正则表达式的元字符难以记忆，很大程度上是因为有很多为了简化表达而出现的等价字符。而实际上最基本的元字符，并没有那么多。对于大部分的场景，基本元字符都可以搞定。让我们从一个个实例出发，由浅入深的去体会正则的奥妙。\n\n# 多选（|）\n\n【示例】匹配一个确定的字符串\n\ncheckMatches("abc", "abc");\n\n\n如果要匹配一个确定的字符串，非常简单，如例 1 所示。但是，如果你不确定要匹配的字符串，希望有多个选择，怎么办？答案是：使用元字符| ，它的含义是或。\n\n【示例】匹配多个可选的字符串\n\n// 测试正则表达式字符：|\nAssert.assertTrue(checkMatches("yes|no", "yes"));\nAssert.assertTrue(checkMatches("yes|no", "no"));\nAssert.assertFalse(checkMatches("yes|no", "right"));\n\n// 输出\n// yes\tmatches： yes|no\n// no\tmatches： yes|no\n// right\tnot matches： yes|no\n\n\n# 分组（()）\n\n如果你希望表达式由多个子表达式组成，你可以使用 ()。\n\n【示例】匹配组合字符串\n\nAssert.assertTrue(checkMatches("(play|end)(ing|ed)", "ended"));\nAssert.assertTrue(checkMatches("(play|end)(ing|ed)", "ending"));\nAssert.assertTrue(checkMatches("(play|end)(ing|ed)", "playing"));\nAssert.assertTrue(checkMatches("(play|end)(ing|ed)", "played"));\n\n// 输出\n// ended\tmatches： (play|end)(ing|ed)\n// ending\tmatches： (play|end)(ing|ed)\n// playing\tmatches： (play|end)(ing|ed)\n// played\tmatches： (play|end)(ing|ed)\n\n\n# 指定单字符有效范围（[]）\n\n前面展示了如何匹配字符串，但是很多时候你需要精确的匹配一个字符，这时可以使用[] 。\n\n【示例】字符在指定范围\n\n// 测试正则表达式字符：[]\nAssert.assertTrue(checkMatches("[abc]", "b"));  // 字符只能是a、b、c\nAssert.assertTrue(checkMatches("[a-z]", "m")); // 字符只能是a - z\nAssert.assertTrue(checkMatches("[A-Z]", "O")); // 字符只能是A - Z\nAssert.assertTrue(checkMatches("[a-zA-Z]", "K")); // 字符只能是a - z和A - Z\nAssert.assertTrue(checkMatches("[a-zA-Z]", "k"));\nAssert.assertTrue(checkMatches("[0-9]", "5")); // 字符只能是0 - 9\n\n// 输出\n// b\tmatches： [abc]\n// m\tmatches： [a-z]\n// O\tmatches： [A-Z]\n// K\tmatches： [a-zA-Z]\n// k\tmatches： [a-zA-Z]\n// 5\tmatches： [0-9]\n\n\n# 指定单字符无效范围（ [^]）\n\n【示例】字符不能在指定范围\n\n如果需要匹配一个字符的逆操作，即字符不能在指定范围，可以使用[^]。\n\n// 测试正则表达式字符：[^]\nAssert.assertFalse(checkMatches("[^abc]", "b")); // 字符不能是a、b、c\nAssert.assertFalse(checkMatches("[^a-z]", "m")); // 字符不能是a - z\nAssert.assertFalse(checkMatches("[^A-Z]", "O")); // 字符不能是A - Z\nAssert.assertFalse(checkMatches("[^a-zA-Z]", "K")); // 字符不能是a - z和A - Z\nAssert.assertFalse(checkMatches("[^a-zA-Z]", "k"));\nAssert.assertFalse(checkMatches("[^0-9]", "5")); // 字符不能是0 - 9\n\n// 输出\n// b\tnot matches： [^abc]\n// m\tnot matches： [^a-z]\n// O\tnot matches： [^A-Z]\n// K\tnot matches： [^a-zA-Z]\n// k\tnot matches： [^a-zA-Z]\n// 5\tnot matches： [^0-9]\n\n\n# 限制字符数量（{}）\n\n如果想要控制字符出现的次数，可以使用 {}。\n\n字符      描述\n{n}     n 是一个非负整数。匹配确定的 n 次。\n{n,}    n 是一个非负整数。至少匹配 n 次。\n{n,m}   m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。\n\n【示例】限制字符出现次数\n\n// {n}: n 是一个非负整数。匹配确定的 n 次。\ncheckMatches("ap{1}", "a");\ncheckMatches("ap{1}", "ap");\ncheckMatches("ap{1}", "app");\ncheckMatches("ap{1}", "apppppppppp");\n\n// {n,}: n 是一个非负整数。至少匹配 n 次。\ncheckMatches("ap{1,}", "a");\ncheckMatches("ap{1,}", "ap");\ncheckMatches("ap{1,}", "app");\ncheckMatches("ap{1,}", "apppppppppp");\n\n// {n,m}: m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。\ncheckMatches("ap{2,5}", "a");\ncheckMatches("ap{2,5}", "ap");\ncheckMatches("ap{2,5}", "app");\ncheckMatches("ap{2,5}", "apppppppppp");\n\n// 输出\n// a\tnot matches： ap{1}\n// ap\tmatches： ap{1}\n// app\tnot matches： ap{1}\n// apppppppppp\tnot matches： ap{1}\n// a\tnot matches： ap{1,}\n// ap\tmatches： ap{1,}\n// app\tmatches： ap{1,}\n// apppppppppp\tmatches： ap{1,}\n// a\tnot matches： ap{2,5}\n// ap\tnot matches： ap{2,5}\n// app\tmatches： ap{2,5}\n// apppppppppp\tnot matches： ap{2,5}\n\n\n# 转义字符（/）\n\n如果想要查找元字符本身，你需要使用转义符，使得正则引擎将其视作一个普通字符，而不是一个元字符去处理。\n\n* 的转义字符：\\*\n+ 的转义字符：\\+\n? 的转义字符：\\?\n^ 的转义字符：\\^\n$ 的转义字符：\\$\n. 的转义字符：\\.\n\n\n如果是转义符 \\ 本身，你需要使用 \\\\ 。\n\n# 指定表达式字符串的开始（^）和结尾（$）\n\n如果希望匹配的字符串必须以特定字符串开头，可以使用 ^ 。\n\n> 注意：请特别留意，这里的 ^ 一定要和 [^] 中的 ^ 区分。\n\n【示例】限制字符串头部\n\nAssert.assertTrue(checkMatches("^app[a-z]{0,}", "apple")); // 字符串必须以app开头\nAssert.assertFalse(checkMatches("^app[a-z]{0,}", "aplause"));\n\n// 输出\n// apple\tmatches： ^app[a-z]{0,}\n// aplause\tnot matches： ^app[a-z]{0,}\n\n\n如果希望匹配的字符串必须以特定字符串结尾，可以使用 $ 。\n\n【示例】限制字符串尾部\n\nAssert.assertTrue(checkMatches("[a-z]{0,}ing$", "playing")); // 字符串必须以ing结尾\nAssert.assertFalse(checkMatches("[a-z]{0,}ing$", "long"));\n\n// 输出\n// playing\tmatches： [a-z]{0,}ing$\n// long\tnot matches： [a-z]{0,}ing$\n\n\n\n# 等价字符\n\n等价字符，顾名思义，就是对于基本元字符表达的一种简化（等价字符的功能都可以通过基本元字符来实现）。\n\n在没有掌握基本元字符之前，可以先不用理会，因为很容易把人绕晕。\n\n等价字符的好处在于简化了基本元字符的写法。\n\n# 表示某一类型字符的等价字符\n\n下表中的等价字符都表示某一类型的字符。\n\n字符   描述\n.    匹配除“\\n”之外的任何单个字符。\n\\d   匹配一个数字字符。等价于[0-9]。\n\\D   匹配一个非数字字符。等价于[^0-9]。\n\\w   匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的单词字符指的是 Unicode 字符集。\n\\W   匹配任何非单词字符。\n\\s   匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。\n\\S   匹配任何可见字符。等价于[ \\f\\n\\r\\t\\v]。\n\n【示例】基本等价字符的用法\n\n// 匹配除“\\n”之外的任何单个字符\nAssert.assertTrue(checkMatches(".{1,}", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"));\nAssert.assertTrue(checkMatches(".{1,}", "~!@#$%^&*()+`-=[]{};:<>,./?|\\\\"));\nAssert.assertFalse(checkMatches(".", "\\n"));\nAssert.assertFalse(checkMatches("[^\\n]", "\\n"));\n\n// 匹配一个数字字符。等价于[0-9]\nAssert.assertTrue(checkMatches("\\\\d{1,}", "0123456789"));\n// 匹配一个非数字字符。等价于[^0-9]\nAssert.assertFalse(checkMatches("\\\\D{1,}", "0123456789"));\n\n// 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的单词字符指的是Unicode字符集\nAssert.assertTrue(checkMatches("\\\\w{1,}", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"));\nAssert.assertFalse(checkMatches("\\\\w{1,}", "~!@#$%^&*()+`-=[]{};:<>,./?|\\\\"));\n// 匹配任何非单词字符\nAssert.assertFalse(checkMatches("\\\\W{1,}", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"));\nAssert.assertTrue(checkMatches("\\\\W{1,}", "~!@#$%^&*()+`-=[]{};:<>,./?|\\\\"));\n\n// 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]\nAssert.assertTrue(checkMatches("\\\\s{1,}", " \\f\\r\\n\\t"));\n// 匹配任何可见字符。等价于[^ \\f\\n\\r\\t\\v]\nAssert.assertFalse(checkMatches("\\\\S{1,}", " \\f\\r\\n\\t"));\n\n// 输出\n// ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\tmatches： .{1,}\n// ~!@#$%^&*()+`-=[]{};:<>,./?|\\\\\tmatches： .{1,}\n// \\n\tnot matches： .\n// \\n\tnot matches： [^\\n]\n// 0123456789\tmatches： \\\\d{1,}\n// 0123456789\tnot matches： \\\\D{1,}\n// ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\tmatches： \\\\w{1,}\n// ~!@#$%^&*()+`-=[]{};:<>,./?|\\\\\tnot matches： \\\\w{1,}\n// ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\tnot matches： \\\\W{1,}\n// ~!@#$%^&*()+`-=[]{};:<>,./?|\\\\\tmatches： \\\\W{1,}\n// \\f\\r\\n\\t\tmatches： \\\\s{1,}\n// \\f\\r\\n\\t\tnot matches： \\\\S{1,}\n\n\n# 限制字符数量的等价字符\n\n在基本元字符章节中，已经介绍了限制字符数量的基本元字符 - {} 。\n\n此外，还有 *、+、? 这个三个为了简化写法而出现的等价字符，我们来认识一下。\n\n字符   描述\n*    匹配前面的子表达式零次或多次。等价于{0,}。\n+    匹配前面的子表达式一次或多次。等价于{1,}。\n?    匹配前面的子表达式零次或一次。等价于 {0,1}。\n\n案例 限制字符数量的等价字符\n\n// *: 匹配前面的子表达式零次或多次。* 等价于{0,}。\ncheckMatches("ap*", "a");\ncheckMatches("ap*", "ap");\ncheckMatches("ap*", "app");\ncheckMatches("ap*", "apppppppppp");\n\n// +: 匹配前面的子表达式一次或多次。+ 等价于 {1,}。\ncheckMatches("ap+", "a");\ncheckMatches("ap+", "ap");\ncheckMatches("ap+", "app");\ncheckMatches("ap+", "apppppppppp");\n\n// ?: 匹配前面的子表达式零次或一次。? 等价于 {0,1}。\ncheckMatches("ap?", "a");\ncheckMatches("ap?", "ap");\ncheckMatches("ap?", "app");\ncheckMatches("ap?", "apppppppppp");\n\n// 输出\n// a\tmatches： ap*\n// ap\tmatches： ap*\n// app\tmatches： ap*\n// apppppppppp\tmatches： ap*\n// a\tnot matches： ap+\n// ap\tmatches： ap+\n// app\tmatches： ap+\n// apppppppppp\tmatches： ap+\n// a\tmatches： ap?\n// ap\tmatches： ap?\n// app\tnot matches： ap?\n// apppppppppp\tnot matches： ap?\n\n\n# 元字符优先级顺序\n\n正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。\n\n下表从最高到最低说明了各种正则表达式运算符的优先级顺序：\n\n运算符                    说明\n\\                      转义符\n()、(?:)、(?=)、[]        括号和中括号\n*、+、?、{n}、{n,}、{n,m}   限定符\n^、$、*任何字符、任何字符*        定位点和序列\n|                      替换\n\n字符具有高于替换运算符的优先级，使得 m|food 匹配 m 或 food 。若要匹配 mood 或 food ，请使用括号创建子表达式，从而产生 (m|f)ood 。\n\n\n# 分组构造\n\n在基本元字符章节，提到了 () 字符可以用来对表达式分组。实际上分组还有更多复杂的用法。\n\n所谓分组构造，是用来描述正则表达式的子表达式，用于捕获字符串中的子字符串。\n\n\n# 捕获与非捕获\n\n下表为分组构造中的捕获和非捕获分类。\n\n表达式            描述           捕获或非捕获\n(exp)          匹配的子表达式      捕获\n(?<name>exp)   命名的反向引用      捕获\n(?:exp)        非捕获组         非捕获\n(?=exp)        零宽度正预测先行断言   非捕获\n(?!exp)        零宽度负预测先行断言   非捕获\n(?<=exp)       零宽度正回顾后发断言   非捕获\n(?<!exp)       零宽度负回顾后发断言   非捕获\n\n> 注：Java 正则引擎不支持平衡组。\n\n\n# 反向引用\n\n# 带编号的反向引用\n\n带编号的反向引用使用以下语法：\\number\n\n其中number 是正则表达式中捕获组的序号位置。 例如，\\4 匹配第四个捕获组的内容。 如果正则表达式模式中未定义number，则将发生分析错误\n\n【示例】匹配重复的单词和紧随每个重复的单词的单词(不命名子表达式)\n\n// (\\w+)\\s\\1\\W(\\w+) 匹配重复的单词和紧随每个重复的单词的单词\nAssert.assertTrue(findAll("(\\\\w+)\\\\s\\\\1\\\\W(\\\\w+)",\n\t\t"He said that that was the the correct answer.") > 0);\n\n// 输出\n// regex = (\\w+)\\s\\1\\W(\\w+), content: He said that that was the the correct answer.\n// [1th] start: 8, end: 21, group: that that was\n// [2th] start: 22, end: 37, group: the the correct\n\n\n说明：\n\n * (\\w+)：匹配一个或多个单词字符。\n * \\s：与空白字符匹配。\n * \\1：匹配第一个组，即(\\w+)。\n * \\W：匹配包括空格和标点符号的一个非单词字符。 这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。\n\n# 命名的反向引用\n\n命名后向引用通过使用下面的语法进行定义：\\k<name >\n\n【示例】匹配重复的单词和紧随每个重复的单词的单词(命名子表达式)\n\n// (?<duplicateWord>\\w+)\\s\\k<duplicateWord>\\W(?<nextWord>\\w+) 匹配重复的单词和紧随每个重复的单词的单词\nAssert.assertTrue(findAll("(?<duplicateWord>\\\\w+)\\\\s\\\\k<duplicateWord>\\\\W(?<nextWord>\\\\w+)",\n\t\t"He said that that was the the correct answer.") > 0);\n\n// 输出\n// regex = (?<duplicateWord>\\w+)\\s\\k<duplicateWord>\\W(?<nextWord>\\w+), content: He said that that was the the correct answer.\n// [1th] start: 8, end: 21, group: that that was\n// [2th] start: 22, end: 37, group: the the correct\n\n\n说明：\n\n * (?<duplicateWord>\\w+)：匹配一个或多个单词字符。 命名此捕获组 duplicateWord。\n * \\s: 与空白字符匹配。\n * \\k<duplicateWord>：匹配名为 duplicateWord 的捕获的组。\n * \\W：匹配包括空格和标点符号的一个非单词字符。 这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。\n * (?<nextWord>\\w+)：匹配一个或多个单词字符。 命名此捕获组 nextWord。\n\n\n# 非捕获组\n\n(?:exp) 表示当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。\n\n【示例】匹配以.结束的语句。\n\n// 匹配由句号终止的语句。\nAssert.assertTrue(findAll("(?:\\\\b(?:\\\\w+)\\\\W*)+\\\\.", "This is a short sentence. Never end") > 0);\n\n// 输出\n// regex = (?:\\b(?:\\w+)\\W*)+\\., content: This is a short sentence. Never end\n// [1th] start: 0, end: 25, group: This is a short sentence.\n\n\n\n# 零宽断言\n\n用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。\n\n表达式        描述\n(?=exp)    匹配 exp 前面的位置\n(?<=exp)   匹配 exp 后面的位置\n(?!exp)    匹配后面跟的不是 exp 的位置\n(?<!exp)   匹配前面不是 exp 的位置\n\n# 匹配 exp 前面的位置\n\n(?=exp) 表示输入字符串必须匹配子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。\n\n// \\b\\w+(?=\\sis\\b) 表示要捕获is之前的单词\nAssert.assertTrue(findAll("\\\\b\\\\w+(?=\\\\sis\\\\b)", "The dog is a Malamute.") > 0);\nAssert.assertFalse(findAll("\\\\b\\\\w+(?=\\\\sis\\\\b)", "The island has beautiful birds.") > 0);\nAssert.assertFalse(findAll("\\\\b\\\\w+(?=\\\\sis\\\\b)", "The pitch missed home plate.") > 0);\nAssert.assertTrue(findAll("\\\\b\\\\w+(?=\\\\sis\\\\b)", "Sunday is a weekend day.") > 0);\n\n// 输出\n// regex = \\b\\w+(?=\\sis\\b), content: The dog is a Malamute.\n// [1th] start: 4, end: 7, group: dog\n// regex = \\b\\w+(?=\\sis\\b), content: The island has beautiful birds.\n// not found\n// regex = \\b\\w+(?=\\sis\\b), content: The pitch missed home plate.\n// not found\n// regex = \\b\\w+(?=\\sis\\b), content: Sunday is a weekend day.\n// [1th] start: 0, end: 6, group: Sunday\n\n\n说明：\n\n * \\b：在单词边界处开始匹配。\n * \\w+：匹配一个或多个单词字符。\n * (?=\\sis\\b)：确定单词字符是否后接空白字符和字符串“is”，其在单词边界处结束。 如果如此，则匹配成功。\n\n# 匹配 exp 后面的位置\n\n(?<=exp) 表示子表达式不得在输入字符串当前位置左侧出现，尽管子表达式未包含在匹配结果中。零宽度正回顾后发断言不会回溯。\n\n// (?<=\\b20)\\d{2}\\b 表示要捕获以20开头的数字的后面部分\nAssert.assertTrue(findAll("(?<=\\\\b20)\\\\d{2}\\\\b", "2010 1999 1861 2140 2009") > 0);\n\n// 输出\n// regex = (?<=\\b20)\\d{2}\\b, content: 2010 1999 1861 2140 2009\n// [1th] start: 2, end: 4, group: 10\n// [2th] start: 22, end: 24, group: 09\n\n\n说明：\n\n * \\d{2}：匹配两个十进制数字。\n * {?<=\\b20)：如果两个十进制数字的字边界以小数位数“20”开头，则继续匹配。\n * \\b：在单词边界处结束匹配。\n\n# 匹配后面跟的不是 exp 的位置\n\n(?!exp) 表示输入字符串不得匹配子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。\n\n【示例】捕获未以“un”开头的单词\n\n// \\b(?!un)\\w+\\b 表示要捕获未以“un”开头的单词\nAssert.assertTrue(findAll("\\\\b(?!un)\\\\w+\\\\b", "unite one unethical ethics use untie ultimate") > 0);\n\n// 输出\n// regex = \\b(?!un)\\w+\\b, content: unite one unethical ethics use untie ultimate\n// [1th] start: 6, end: 9, group: one\n// [2th] start: 20, end: 26, group: ethics\n// [3th] start: 27, end: 30, group: use\n// [4th] start: 37, end: 45, group: ultimate\n\n\n说明：\n\n * \\b：在单词边界处开始匹配。\n * (?!un)：确定接下来的两个的字符是否为“un”。 如果没有，则可能匹配。\n * \\w+：匹配一个或多个单词字符。\n * \\b：在单词边界处结束匹配。\n\n# 匹配前面不是 exp 的位置\n\n(?<!exp) 表示子表达式不得在输入字符串当前位置的左侧出现。 但是，任何不匹配子表达式 的子字符串不包含在匹配结果中。\n\n【示例】捕获任意工作日\n\n// (?<!(Saturday|Sunday) )\\b\\w+ \\d{1,2}, \\d{4}\\b 表示要捕获任意工作日（即周一到周五）\nAssert.assertTrue(findAll("(?<!(Saturday|Sunday) )\\\\b\\\\w+ \\\\d{1,2}, \\\\d{4}\\\\b", "Monday February 1, 2010") > 0);\nAssert.assertTrue(findAll("(?<!(Saturday|Sunday) )\\\\b\\\\w+ \\\\d{1,2}, \\\\d{4}\\\\b", "Wednesday February 3, 2010") > 0);\nAssert.assertFalse(findAll("(?<!(Saturday|Sunday) )\\\\b\\\\w+ \\\\d{1,2}, \\\\d{4}\\\\b", "Saturday February 6, 2010") > 0);\nAssert.assertFalse(findAll("(?<!(Saturday|Sunday) )\\\\b\\\\w+ \\\\d{1,2}, \\\\d{4}\\\\b", "Sunday February 7, 2010") > 0);\nAssert.assertTrue(findAll("(?<!(Saturday|Sunday) )\\\\b\\\\w+ \\\\d{1,2}, \\\\d{4}\\\\b", "Monday, February 8, 2010") > 0);\n\n// 输出\n// regex = (?<!(Saturday|Sunday) )\\b\\w+ \\d{1,2}, \\d{4}\\b, content: Monday February 1, 2010\n// [1th] start: 7, end: 23, group: February 1, 2010\n// regex = (?<!(Saturday|Sunday) )\\b\\w+ \\d{1,2}, \\d{4}\\b, content: Wednesday February 3, 2010\n// [1th] start: 10, end: 26, group: February 3, 2010\n// regex = (?<!(Saturday|Sunday) )\\b\\w+ \\d{1,2}, \\d{4}\\b, content: Saturday February 6, 2010\n// not found\n// regex = (?<!(Saturday|Sunday) )\\b\\w+ \\d{1,2}, \\d{4}\\b, content: Sunday February 7, 2010\n// not found\n// regex = (?<!(Saturday|Sunday) )\\b\\w+ \\d{1,2}, \\d{4}\\b, content: Monday, February 8, 2010\n// [1th] start: 8, end: 24, group: February 8, 2010\n\n\n\n# 贪婪与懒惰\n\n当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以 a 开始，以 b 结束的字符串。如果用它来搜索 aabab 的话，它会匹配整个字符串 aabab。这被称为贪婪匹配。\n\n有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。\n\n表达式      描述\n*?       重复任意次，但尽可能少重复\n+?       重复 1 次或更多次，但尽可能少重复\n??       重复 0 次或 1 次，但尽可能少重复\n{n,m}?   重复 n 到 m 次，但尽可能少重复\n{n,}?    重复 n 次以上，但尽可能少重复\n\n【示例】Java 正则中贪婪与懒惰的示例\n\n// 贪婪匹配\nAssert.assertTrue(findAll("a\\\\w*b", "abaabaaabaaaab") > 0);\n\n// 懒惰匹配\nAssert.assertTrue(findAll("a\\\\w*?b", "abaabaaabaaaab") > 0);\nAssert.assertTrue(findAll("a\\\\w+?b", "abaabaaabaaaab") > 0);\nAssert.assertTrue(findAll("a\\\\w??b", "abaabaaabaaaab") > 0);\nAssert.assertTrue(findAll("a\\\\w{0,4}?b", "abaabaaabaaaab") > 0);\nAssert.assertTrue(findAll("a\\\\w{3,}?b", "abaabaaabaaaab") > 0);\n\n// 输出\n// regex = a\\w*b, content: abaabaaabaaaab\n// [1th] start: 0, end: 14, group: abaabaaabaaaab\n// regex = a\\w*?b, content: abaabaaabaaaab\n// [1th] start: 0, end: 2, group: ab\n// [2th] start: 2, end: 5, group: aab\n// [3th] start: 5, end: 9, group: aaab\n// [4th] start: 9, end: 14, group: aaaab\n// regex = a\\w+?b, content: abaabaaabaaaab\n// [1th] start: 0, end: 5, group: abaab\n// [2th] start: 5, end: 9, group: aaab\n// [3th] start: 9, end: 14, group: aaaab\n// regex = a\\w??b, content: abaabaaabaaaab\n// [1th] start: 0, end: 2, group: ab\n// [2th] start: 2, end: 5, group: aab\n// [3th] start: 6, end: 9, group: aab\n// [4th] start: 11, end: 14, group: aab\n// regex = a\\w{0,4}?b, content: abaabaaabaaaab\n// [1th] start: 0, end: 2, group: ab\n// [2th] start: 2, end: 5, group: aab\n// [3th] start: 5, end: 9, group: aaab\n// [4th] start: 9, end: 14, group: aaaab\n// regex = a\\w{3,}?b, content: abaabaaabaaaab\n// [1th] start: 0, end: 5, group: abaab\n// [2th] start: 5, end: 14, group: aaabaaaab\n\n\n说明：\n\n本例中代码展示的是使用不同贪婪或懒惰策略去查找字符串 abaabaaabaaaab 中匹配以 a 开头，以 b 结尾的所有子字符串。请从输出结果中，细细体味使用不同的贪婪或懒惰策略，对于匹配子字符串有什么影响。\n\n\n# 正则附录\n\n\n# 匹配正则字符串的方法\n\n由于正则表达式中很多元字符本身就是转义字符，在 Java 字符串的规则中不会被显示出来。\n\n为此，可以使用一个工具类org.apache.commons.lang3.StringEscapeUtils来做特殊处理，使得转义字符可以打印。这个工具类提供的都是静态方法，从方法命名大致也可以猜出用法，这里不多做说明。\n\n如果你了解 maven，可以直接引入依赖\n\n<dependency>\n  <groupId>org.apache.commons</groupId>\n  <artifactId>commons-lang3</artifactId>\n  <version>${commons-lang3.version}</version>\n</dependency>\n\n\n【示例】本文为了展示正则匹配规则用到的方法\n\nprivate boolean checkMatches(String regex, String content) {\n\tPattern p = Pattern.compile(regex);\n\tMatcher m = p.matcher(content);\n\tboolean flag = m.matches();\n\tif (m.matches()) {\n\t\tSystem.out.println(StringEscapeUtils.escapeJava(content) + "\\tmatches： " + StringEscapeUtils.escapeJava(regex));\n\t} else {\n\t\tSystem.out.println(StringEscapeUtils.escapeJava(content) + "\\tnot matches： " + StringEscapeUtils.escapeJava(regex));\n\t}\n\treturn flag;\n}\n\npublic int findAll(String regex, String content) {\n\tPattern p = Pattern.compile(regex);\n\tMatcher m = p.matcher(content);\n\tSystem.out.println("regex = " + regex + ", content: " + content);\n\n\tint count = 0;\n\twhile (m.find()) {\n\t\tcount++;\n\t\tSystem.out.println("[" + count + "th] " + "start: " + m.start() + ", end: " + m.end()\n\t\t\t\t+ ", group: " + m.group());\n\t}\n\tif (0 == count) {\n\t\tSystem.out.println("not found");\n\t}\n\treturn count;\n}\n\n\n\n# 速查元字符字典\n\n为了方便快查正则的元字符含义，在本节根据元字符的功能集中罗列正则的各种元字符。\n\n# 限定符\n\n字符      描述\n*       匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。\n+       匹配前面的子表达式一次或多次。例如，\'zo+\' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于\n        {1,}。\n?       匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于\n        {0,1}。\n{n}     n 是一个非负整数。匹配确定的 n 次。例如，\'o{2}\' 不能匹配 "Bob" 中的 \'o\'，但是能匹配 "food"\n        中的两个 o。\n{n,}    n 是一个非负整数。至少匹配 n 次。例如，\'o{2,}\' 不能匹配 "Bob" 中的 \'o\'，但能匹配\n        "foooood" 中的所有 o。\'o{1,}\' 等价于 \'o+\'。\'o{0,}\' 则等价于 \'o*\'。\n{n,m}   m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配\n        "fooooood" 中的前三个 o。\'o{0,1}\' 等价于 \'o?\'。请注意在逗号和两个数之间不能有空格。\n\n# 定位符\n\n字符   描述\n^    匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r\n     之后的位置匹配。\n$    匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r\n     之前的位置匹配。\n\\b   匹配一个字边界，即字与空格间的位置。\n\\B   非字边界匹配。\n\n# 非打印字符\n\n字符    描述\n\\cx   匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z\n      之一。否则，将 c 视为一个原义的 \'c\' 字符。\n\\f    匹配一个换页符。等价于 \\x0c 和 \\cL。\n\\n    匹配一个换行符。等价于 \\x0a 和 \\cJ。\n\\r    匹配一个回车符。等价于 \\x0d 和 \\cM。\n\\s    匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。\n\\S    匹配任何非空白字符。等价于 [ \\f\\n\\r\\t\\v]。\n\\t    匹配一个制表符。等价于 \\x09 和 \\cI。\n\\v    匹配一个垂直制表符。等价于 \\x0b 和 \\cK。\n\n# 分组\n\n表达式            描述\n(exp)          匹配的子表达式。()中的内容就是子表达式。\n(?<name>exp)   命名的子表达式（反向引用）。\n(?:exp)        非捕获组，表示当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。\n(?=exp)        匹配 exp 前面的位置。\n(?<=exp)       匹配 exp 后面的位置。\n(?!exp)        匹配后面跟的不是 exp 的位置。\n(?<!exp)       匹配前面不是 exp 的位置。\n\n# 特殊符号\n\n字符   描述\n\\    将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， \'n\' 匹配字符 \'n\'。\'\\n\'\n     匹配换行符。序列 \'\\\' 匹配 ""，而 \'(\' 则匹配 "("。\n\\|   指明两项之间的一个选择。\n[]   匹配方括号范围内的任意一个字符。形式如：[xyz]、[^xyz]、[a-z]、[^a-z]、[x,y,z]\n\n\n# 正则实战\n\n虽然本系列洋洋洒洒的大谈特谈正则表达式。但是我还是要在这里建议，如果一个正则表达式没有经过充分测试，还是要谨慎使用。\n\n正则是把双刃剑，它可以为你节省大量的代码行。但是由于它不易阅读，维护起来可是头疼的哦（你需要一个字符一个字符的去理解）。\n\n\n# 最实用的正则\n\n# 校验中文\n\n校验字符串中只能有中文字符（不包括中文标点符号）。中文字符的 Unicode 编码范围是 \\u4e00 到 \\u9fa5。\n\n> 如有兴趣，可以参考百度百科-Unicode 。\n\n^[\\u4e00-\\u9fa5]+$\n\n\n * 匹配： 春眠不觉晓\n * **不匹配：**春眠不觉晓，\n\n# 校验身份证号码\n\n身份证为 15 位或 18 位。15 位是第一代身份证。从 1999 年 10 月 1 日起，全国实行公民身份证号码制度，居民身份证编号由原 15 位升至 18 位。\n\n * 15 位身份证：由 15 位数字组成。排列顺序从左至右依次为：六位数字地区码；六位数字出生日期；三位顺序号，其中 15 位男为单数，女为双数。\n * 18 位身份证：由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地区码；八位数字出生日期；三位数字顺序码和一位数字校验码（也可能是 X）。\n\n> 身份证号含义详情请见：百度百科-居民身份证号码\n\n地区码（6 位）\n\n(1[1-5]|2[1-3]|3[1-7]|4[1-3]|5[0-4]|6[1-5])\\d{4}\n\n\n出生日期（8 位）\n\n注：下面的是 18 位身份证的有效出生日期，如果是 15 位身份证，只要将第一个\\d{4}改为\\d{2}即可。\n\n((\\d{4}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)\n\n\n15 位有效身份证\n\n^((1[1-5]|2[1-3]|3[1-7]|4[1-3]|5[0-4]|6[1-5])\\d{4})((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)(\\d{3})$\n\n\n * **匹配：**110001700101031\n\n * **不匹配：**110001701501031\n\n18 位有效身份证\n\n^((1[1-5]|2[1-3]|3[1-7]|4[1-3]|5[0-4]|6[1-5])\\d{4})((\\d{4}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)(\\d{3}(\\d|X))$\n\n\n * **匹配：**110001199001010310 | 11000019900101015X\n\n * **不匹配：**990000199001010310 | 110001199013010310\n\n# 校验有效用户名、密码\n\n**描述：**长度为 6-18 个字符，允许输入字母、数字、下划线，首字符必须为字母。\n\n^[a-zA-Z]\\w{5,17}$\n\n\n * **匹配：**he_llo@worl.d.com | hel.l-o@wor-ld.museum | h1ello@123.com\n\n * **不匹配：**hello@worl_d.com | he&llo@world.co1 | .hello@wor#.co.uk\n\n# 校验邮箱\n\n**描述：**不允许使用 IP 作为域名，如 : hello@154.145.68.12\n\n@符号前的邮箱用户和.符号前的域名(domain)必须满足以下条件：\n\n * 字符只能是英文字母、数字、下划线_、.、- ；\n * 首字符必须为字母或数字；\n * _、.、- 不能连续出现。\n\n域名的根域只能为字母，且至少为两个字符。\n\n^[A-Za-z0-9](([_\\.\\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\\.\\-]?[a-zA-Z0-9]+)*)\\.([A-Za-z]{2,})$\n\n\n * **匹配：**he_llo@worl.d.com | hel.l-o@wor-ld.museum | h1ello@123.com\n * **不匹配：**hello@worl_d.com | he&llo@world.co1 | .hello@wor#.co.uk\n\n# 校验 URL\n\n**描述：**校验 URL。支持 http、https、ftp、ftps。\n\n^(ht|f)(tp|tps)\\://[a-zA-Z0-9\\-\\.]+\\.([a-zA-Z]{2,3})?(/\\S*)?$\n\n\n * **匹配：**http://google.com/help/me | http://www.google.com/help/me/ | https://www.google.com/help.asp | ftp://www.google.com | ftps://google.org\n\n * **不匹配：**http://un/www.google.com/index.asp\n\n# 校验时间\n\n**描述：**校验时间。时、分、秒必须是有效数字，如果数值不是两位数，十位需要补零。\n\n^([0-1][0-9]|[2][0-3]):([0-5][0-9])$\n\n\n * **匹配：**00:00:00 | 23:59:59 | 17:06:30\n\n * **不匹配：**17:6:30 | 24:16:30\n\n# 校验日期\n\n**描述：**校验日期。日期满足以下条件：\n\n * 格式 yyyy-MM-dd 或 yyyy-M-d\n * 连字符可以没有或是“-”、“/”、“.”之一\n * 闰年的二月可以有 29 日；而平年不可以。\n * 一、三、五、七、八、十、十二月为 31 日。四、六、九、十一月为 30 日。\n\n^(?:(?!0000)[0-9]{4}([-/.]?)(?:(?:0?[1-9]|1[0-2])\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\1(?:29|30)|(?:0?[13578]|1[02])\\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\\2(?:29))$\n\n\n * **匹配：**2016/1/1 | 2016/01/01 | 20160101 | 2016-01-01 | 2016.01.01 | 2000-02-29\n * **不匹配：**2001-02-29 | 2016/12/32 | 2016/6/31 | 2016/13/1 | 2016/0/1\n\n# 校验中国手机号码\n\n**描述：**中国手机号码正确格式：11 位数字。\n\n> 移动有 16 个号段：134、135、136、137、138、139、147、150、151、152、157、158、159、182、187、188。其中 147、157、188 是 3G 号段，其他都是 2G 号段。联通有 7 种号段：130、131、132、155、156、185、186。其中 186 是 3G（WCDMA）号段，其余为 2G 号段。电信有 4 个号段：133、153、180、189。其中 189 是 3G 号段（CDMA2000），133 号段主要用作无线网卡号。总结：13 开头手机号 0-9；15 开头手机号 0-3、5-9；18 开头手机号 0、2、5-9。\n> \n> 此外，中国在国际上的区号为 86，所以手机号开头有+86、86 也是合法的。\n> \n> 以上信息来源于 百度百科-手机号\n\n^((\\+)?86\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\d{8}$\n\n\n * 匹配：+86 18012345678 | 86 18012345678 | 15812345678\n\n * **不匹配：**15412345678 | 12912345678 | 180123456789\n\n# 校验中国固话号码\n\n**描述：**固话号码，必须加区号（以 0 开头）。 3 位有效区号：010、020~029，固话位数为 8 位。 4 位有效区号：03xx 开头到 09xx，固话位数为 7。\n\n> 如果想了解更详细的信息，请参考 百度百科-电话区号 。\n\n^(010|02[0-9])(\\s|-)\\d{8}|(0[3-9]\\d{2})(\\s|-)\\d{7}$\n\n\n * **匹配：**010-12345678 | 010 12345678 | 0512-1234567 | 0512 1234567\n\n * **不匹配：**1234567 | 12345678\n\n# 校验 IPv4 地址\n\n**描述：**IP 地址是一个 32 位的二进制数，通常被分割为 4 个“8 位二进制数”（也就是 4 个字节）。IP 地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。\n\n^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])$\n\n\n * **匹配：**0.0.0.0 | 255.255.255.255 | 127.0.0.1\n\n * **不匹配：**10.10.10 | 10.10.10.256\n\n# 校验 IPv6 地址\n\n**描述：**IPv6 的 128 位地址通常写成 8 组，每组为四个十六进制数的形式。\n\nIPv6 地址可以表示为以下形式：\n\n * IPv6 地址\n * 零压缩 IPv6 地址(section 2.2 of rfc5952)\n * 带有本地链接区域索引的 IPv6 地址 (section 11 of rfc4007)\n * 嵌入 IPv4 的 IPv6 地址(section 2 of rfc6052\n * 映射 IPv4 的 IPv6 地址 (section 2.1 of rfc2765)\n * 翻译 IPv4 的 IPv6 地址 (section 2.1 of rfc2765)\n\n> 显然，IPv6 地址的表示方式很复杂。你也可以参考：\n> \n> 百度百科-IPv6\n> \n> Stack overflow 上的 IPv6 正则表达高票答案\n\n(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\n\n\n * **匹配：**1:2:3:4:5:6:7:8 | 1:: | 1::8 | 1::6:7:8 | 1::5:6:7:8 | 1::4:5:6:7:8 | 1::3:4:5:6:7:8 | ::2:3:4:5:6:7:8 | 1:2:3:4:5:6:7:: | 1:2:3:4:5:6::8 | 1:2:3:4:5::8 | 1:2:3:4::8 | 1:2:3::8 | 1:2::8 | 1::8 | ::8 | fe80::7:8%1 | ::255.255.255.255 | 2001:db8:3:4::192.0.2.33 | 64:ff9b::192.0.2.33\n\n * **不匹配：**1.2.3.4.5.6.7.8 | 1::2::3\n\n\n# 特定字符\n\n * 匹配长度为 3 的字符串：^.{3}$。\n * 匹配由 26 个英文字母组成的字符串：^[A-Za-z]+$。\n * 匹配由 26 个大写英文字母组成的字符串：^[A-Z]+$。\n * 匹配由 26 个小写英文字母组成的字符串：^[a-z]+$。\n * 匹配由数字和 26 个英文字母组成的字符串：^[A-Za-z0-9]+$。\n * 匹配由数字、26 个英文字母或者下划线组成的字符串：^\\w+$。\n\n\n# 特定数字\n\n * 匹配正整数：^[1-9]\\d*$\n * 匹配负整数：^-[1-9]\\d*$\n * 匹配整数：^(-?[1-9]\\d*)|0$\n * 匹配正浮点数：^[1-9]\\d*\\.\\d+|0\\.\\d+$\n * 匹配负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$\n * 匹配浮点数：^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$\n\n\n# 正则表达式的性能\n\n目前实现正则表达式引擎的方式有两种：DFA 自动机（Deterministic Final Automata 确定有限状态自动机）和 NFA 自动机（Non deterministic Finite Automaton 非确定有限状态自动机）。对比来看，构造 DFA 自动机的代价远大于 NFA 自动机，但 DFA 自动机的执行效率高于 NFA 自动机。\n\n假设一个字符串的长度是 n，如果用 DFA 自动机作为正则表达式引擎，则匹配的时间复杂度为 O(n)；如果用 NFA 自动机作为正则表达式引擎，由于 NFA 自动机在匹配过程中存在大量的分支和回溯，假设 NFA 的状态数为 s，则该匹配算法的时间复杂度为 O（ns）。\n\nNFA 自动机的优势是支持更多功能。例如，捕获 group、环视、占有优先量词等高级功能。这些功能都是基于子表达式独立进行匹配，因此在编程语言里，使用的正则表达式库都是基于 NFA 实现的。\n\n\n# NFA 自动机的回溯\n\n用 NFA 自动机实现的比较复杂的正则表达式，在匹配过程中经常会引起回溯问题。大量的回溯会长时间地占用 CPU，从而带来系统性能开销。\n\ntext=“abbc”\nregex=“ab{1,3}c”\n\n\n这个例子匹配目的是：匹配以 a 开头，以 c 结尾，中间有 1-3 个 b 字符的字符串。NFA 自动机对其解析的过程是这样的：\n\n * 读取正则表达式第一个匹配符 a 和字符串第一个字符 a 进行比较，a 对 a，匹配。\n * 然后，读取正则表达式第二个匹配符 b{1,3} 和字符串的第二个字符 b 进行比较，匹配。但因为 b{1,3} 表示 1-3 个 b 字符串，NFA 自动机又具有贪婪特性，所以此时不会继续读取正则表达式的下一个匹配符，而是依旧使用 b{1,3} 和字符串的第三个字符 b 进行比较，结果还是匹配。\n * 接着继续使用 b{1,3} 和字符串的第四个字符 c 进行比较，发现不匹配了，此时就会发生回溯，已经读取的字符串第四个字符 c 将被吐出去，指针回到第三个字符 b 的位置。\n * 那么发生回溯以后，匹配过程怎么继续呢？程序会读取正则表达式的下一个匹配符 c，和字符串中的第四个字符 c 进行比较，结果匹配，结束。\n\n\n# 如何避免回溯\n\n# 贪婪模式（Greedy）\n\n顾名思义，就是在数量匹配中，如果单独使用 +、 ? 、* 或{min,max} 等量词，正则表达式会匹配尽可能多的内容。\n\n例如，上边那个例子：\n\ntext=“abbc”\nregex=“ab{1,3}c”\n\n\n就是在贪婪模式下，NFA 自动机读取了最大的匹配范围，即匹配 3 个 b 字符。匹配发生了一次失败，就引起了一次回溯。如果匹配结果是“abbbc”，就会匹配成功。\n\ntext=“abbbc”\nregex=“ab{1,3}c”\n\n\n# 懒惰模式（Reluctant）\n\n在该模式下，正则表达式会尽可能少地重复匹配字符。如果匹配成功，它会继续匹配剩余的字符串。\n\n例如，在上面例子的字符后面加一个“？”，就可以开启懒惰模式。\n\ntext=“abc”\nregex=“ab{1,3}?c”\n\n\n匹配结果是“abc”，该模式下 NFA 自动机首先选择最小的匹配范围，即匹配 1 个 b 字符，因此就避免了回溯问题。\n\n# 独占模式（Possessive）\n\n同贪婪模式一样，独占模式一样会最大限度地匹配更多内容；不同的是，在独占模式下，匹配失败就会结束匹配，不会发生回溯问题。\n\n还是上边的例子，在字符后面加一个“+”，就可以开启独占模式。\n\ntext=“abbc”\nregex=“ab{1,3}+bc”\n\n\n结果是不匹配，结束匹配，不会发生回溯问题。\n\n> 讲到这里，你应该非常清楚了，避免回溯的方法就是：使用懒惰模式和独占模式。\n\n\n# 正则表达式的优化\n\n# 少用贪婪模式，多用独占模式\n\n贪婪模式会引起回溯问题，可以使用独占模式来避免回溯。\n\n# 减少分支选择\n\n分支选择类型 (X|Y|Z) 的正则表达式会降低性能，我们在开发的时候要尽量减少使用。如果一定要用，我们可以通过以下几种方式来优化：\n\n * 首先，我们需要考虑选择的顺序，将比较常用的选择项放在前面，使它们可以较快地被匹配；\n * 其次，我们可以尝试提取共用模式，例如，将 (abcd|abef) 替换为 ab(cd|ef)，后者匹配速度较快，因为 NFA 自动机会尝试匹配 ab，如果没有找到，就不会再尝试任何选项；\n * 最后，如果是简单的分支选择类型，我们可以用三次 index 代替 (X|Y|Z)，如果测试的话，你就会发现三次 index 的效率要比 (X|Y|Z) 高出一些。\n\n# 减少捕获嵌套\n\n * 捕获组是指把正则表达式中，子表达式匹配的内容保存到以数字编号或显式命名的数组中，方便后面引用。一般一个 () 就是一个捕获组，捕获组可以进行嵌套。\n * 非捕获组则是指参与匹配却不进行分组编号的捕获组，其表达式一般由 (?:exp) 组成。\n\n在正则表达式中，每个捕获组都有一个编号，编号 0 代表整个匹配到的内容。我们可以看下面的例子：\n\npublic static void main(String[] args) {\n\tString text = "<input high=\\"20\\" weight=\\"70\\">test</input>";\n\tString reg="(<input.*?>)(.*?)(</input>)";\n\tPattern p = Pattern.compile(reg);\n\tMatcher m = p.matcher(text);\n\twhile(m.find()) {\n\t\tSystem.out.println(m.group(0));// 整个匹配到的内容\n\t\tSystem.out.println(m.group(1));//(<input.*?>)\n\t\tSystem.out.println(m.group(2));//(.*?)\n\t\tSystem.out.println(m.group(3));//(</input>)\n\t}\n}\n\n\n运行结果：\n\n<input high=\\"20\\" weight=\\"70\\">test</input>\n<input high=\\"20\\" weight=\\"70\\">\ntest\n</input>\n\n\n如果你并不需要获取某一个分组内的文本，那么就使用非捕获分组。例如，使用“(?:X)”代替“(X)”，我们再看下面的例子：\n\npublic static void main(String[] args) {\n\tString text = "<input high=\\"20\\" weight=\\"70\\">test</input>";\n\tString reg="(?:<input.*?>)(.*?)(?:</input>)";\n\tPattern p = Pattern.compile(reg);\n\tMatcher m = p.matcher(text);\n\twhile(m.find()) {\n\t\tSystem.out.println(m.group(0));// 整个匹配到的内容\n\t\tSystem.out.println(m.group(1));//(.*?)\n\t}\n}\n\n\n运行结果：\n\n<input high=\\"20\\" weight=\\"70\\">test</input>\ntest\n\n\n综上可知：减少不需要获取的分组，可以提高正则表达式的性能。\n\n\n# 参考资料\n\n * 正则表达式 30 分钟入门教程\n * msdn 正则表达式教程\n * 正则应用之——日期正则表达式\n * http://www.regexlib.com/\n * 《Java 性能调优实战》',normalizedContent:'# java 正则从入门到精通\n\n> 关键词：pattern、matcher、捕获与非捕获、反向引用、零宽断言、贪婪与懒惰、元字符、dfa、nfa\n\n\n# 正则简介\n\n\n# 正则表达式是什么\n\n正则表达式（regular expression）是一个用正则符号写出的公式，程序对这个公式进行语法分析，建立一个语法分析树，再根据这个分析树结合正则表达式的引擎生成执行程序（这个执行程序我们把它称作状态机，也叫状态自动机），用于字符匹配。\n\n\n# 如何学习正则\n\n正则表达式是一个强大的文本匹配工具，但是它的规则很复杂，理解起来较为困难，容易让人望而生畏。\n\n刚接触正则时，我看了一堆正则的语义说明，但是仍然不明所以。后来，我多接触一些正则的应用实例，渐渐有了感觉，再结合语义说明，终有领悟。我觉得正则表达式和武侠修练武功差不多，应该先练招式，再练心法。如果一开始就直接看正则的规则，保证你会懵逼。当你熟悉基本招式（正则基本使用案例）后，也该修炼修炼心法（正则语法）了。真正的高手不能只靠死记硬背那么几招把式。就像张三丰教张无忌太极拳一样，领悟心法，融会贯通，少侠你就可以无招胜有招，成为传说中的绝世高手。\n\n以上闲话可归纳为一句：学习正则应该从实例去理解规则。\n\n\n# 正则工具类\n\njdk 中的 java.util.regex 包提供了对正则表达式的支持。\n\njava.util.regex 有三个核心类：\n\n * pattern 类：pattern 是一个正则表达式的编译表示。\n * matcher 类：matcher 是对输入字符串进行解释和匹配操作的引擎。\n * patternsyntaxexception：patternsyntaxexception 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n\n**注：**需要格外注意一点，在 java 中使用反斜杠"\\"时必须写成 "\\\\"。所以本文的代码出现形如 string regex = "\\\\$\\\\{.*?\\\\}" 其实就是 \\$\\{.\\*?\\}。\n\n\n# pattern 类\n\npattern类没有公共构造方法。要创建一个pattern对象，你必须首先调用其静态方法compile，加载正则规则字符串，然后返回一个 pattern 对象。\n\n与pattern类一样，matcher类也没有公共构造方法。你需要调用pattern对象的matcher方法来获得一个matcher对象。\n\n【示例】pattern 和 matcher 的初始化\n\npattern p = pattern.compile(regex);\nmatcher m = p.matcher(content);\n\n\n\n# matcher 类\n\nmatcher 类可以说是 java.util.regex 中的核心类，它有三类功能：校验、查找、替换。\n\n# 校验\n\n为了校验文本是否与正则规则匹配，matcher 提供了以下几个返回值为 boolean 的方法。\n\n序号   方法及说明\n1    **public boolean lookingat() ** 尝试将从区域开头开始的输入序列与该模式匹配。\n2    **public boolean find() **尝试查找与该模式匹配的输入序列的下一个子序列。\n3    **public boolean find(int\n     start）**重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。\n4    **public boolean matches() **尝试将整个区域与模式匹配。\n\n如果你傻傻分不清上面的查找方法有什么区别，那么下面一个例子就可以让你秒懂。\n\n【示例】lookingat、find、matches\n\npublic static void main(string[] args) {\n\tchecklookingat("hello", "helloworld");\n\tchecklookingat("world", "helloworld");\n\n\tcheckfind("hello", "helloworld");\n\tcheckfind("world", "helloworld");\n\n\tcheckmatches("hello", "helloworld");\n\tcheckmatches("world", "helloworld");\n\tcheckmatches("helloworld", "helloworld");\n}\n\nprivate static void checklookingat(string regex, string content) {\n\tpattern p = pattern.compile(regex);\n\tmatcher m = p.matcher(content);\n\tif (m.lookingat()) {\n\t\tsystem.out.println(content + "\\tlookingat： " + regex);\n\t} else {\n\t\tsystem.out.println(content + "\\tnot lookingat： " + regex);\n\t}\n}\n\nprivate static void checkfind(string regex, string content) {\n\tpattern p = pattern.compile(regex);\n\tmatcher m = p.matcher(content);\n\tif (m.find()) {\n\t\tsystem.out.println(content + "\\tfind： " + regex);\n\t} else {\n\t\tsystem.out.println(content + "\\tnot find： " + regex);\n\t}\n}\n\nprivate static void checkmatches(string regex, string content) {\n\tpattern p = pattern.compile(regex);\n\tmatcher m = p.matcher(content);\n\tif (m.matches()) {\n\t\tsystem.out.println(content + "\\tmatches： " + regex);\n\t} else {\n\t\tsystem.out.println(content + "\\tnot matches： " + regex);\n\t}\n}\n\n\n输出：\n\nhelloworld\tlookingat： hello\nhelloworld\tnot lookingat： world\nhelloworld\tfind： hello\nhelloworld\tfind： world\nhelloworld\tnot matches： hello\nhelloworld\tnot matches： world\nhelloworld\tmatches： helloworld\n\n\n说明\n\nregex = "world" 表示的正则规则是以 world 开头的字符串，regex = "hello" 和 regex = "helloworld" 也是同理。\n\n * lookingat方法从头部开始，检查 content 字符串是否有子字符串于正则规则匹配。\n * find方法检查 content 字符串是否有子字符串于正则规则匹配，不管字符串所在位置。\n * matches方法检查 content 字符串整体是否与正则规则匹配。\n\n# 查找\n\n为了查找文本匹配正则规则的位置，matcher提供了以下方法：\n\n序号   方法及说明\n1    **public int start() **返回以前匹配的初始索引。\n2    public int start(int group) 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引\n3    **public int end()**返回最后匹配字符之后的偏移量。\n4    **public int end(int\n     group)**返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。\n5    **public string group()**返回前一个符合匹配条件的子序列。\n6    **public string group(int group)**返回指定的符合匹配条件的子序列。\n\n【示例】使用 start()、end()、group() 查找所有匹配正则条件的子序列\n\npublic static void main(string[] args) {\n\tfinal string regex = "world";\n\tfinal string content = "helloworld helloworld";\n\tpattern p = pattern.compile(regex);\n\tmatcher m = p.matcher(content);\n\tsystem.out.println("content: " + content);\n\n\tint i = 0;\n\twhile (m.find()) {\n\t\ti++;\n\t\tsystem.out.println("[" + i + "th] found");\n\t\tsystem.out.print("start: " + m.start() + ", ");\n\t\tsystem.out.print("end: " + m.end() + ", ");\n\t\tsystem.out.print("group: " + m.group() + "\\n");\n\t}\n}\n\n\n输出\n\ncontent: helloworld helloworld\n[1th] found\nstart: 5, end: 10, group: world\n[2th] found\nstart: 16, end: 21, group: world\n\n\n说明\n\n例子很直白，不言自明了吧。\n\n# 替换\n\n替换方法是替换输入字符串里文本的方法：\n\n序号   方法及说明\n1    **public matcher appendreplacement(stringbuffer sb, string\n     replacement)**实现非终端添加和替换步骤。\n2    **public stringbuffer appendtail(stringbuffer\n     sb)**实现终端添加和替换步骤。\n3    **public string replaceall(string replacement) **\n     替换模式与给定替换字符串相匹配的输入序列的每个子序列。\n4    public string replacefirst(string replacement)\n     替换模式与给定替换字符串匹配的输入序列的第一个子序列。\n5    **public static string quotereplacement(string\n     s)**返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给 matcher 类的\n     appendreplacement 方法一个字面字符串一样工作。\n\n【示例】replacefirst 和 replaceall\n\npublic static void main(string[] args) {\n\tstring regex = "can";\n\tstring replace = "can not";\n\tstring content = "i can because i think i can.";\n\n\tpattern p = pattern.compile(regex);\n\tmatcher m = p.matcher(content);\n\n\tsystem.out.println("content: " + content);\n\tsystem.out.println("replacefirst: " + m.replacefirst(replace));\n\tsystem.out.println("replaceall: " + m.replaceall(replace));\n}\n\n\n输出\n\ncontent: i can because i think i can.\nreplacefirst: i can not because i think i can.\nreplaceall: i can not because i think i can not.\n\n\n说明\n\nreplacefirst：替换第一个匹配正则规则的子序列。\n\nreplaceall：替换所有匹配正则规则的子序列。\n\n【示例】appendreplacement、appendtail 和 replaceall\n\npublic static void main(string[] args) {\n\tstring regex = "can";\n\tstring replace = "can not";\n\tstring content = "i can because i think i can.";\n\tstringbuffer sb = new stringbuffer();\n\tstringbuffer sb2 = new stringbuffer();\n\n\tsystem.out.println("content: " + content);\n\tpattern p = pattern.compile(regex);\n\tmatcher m = p.matcher(content);\n\twhile (m.find()) {\n\t\tm.appendreplacement(sb, replace);\n\t}\n\tsystem.out.println("appendreplacement: " + sb);\n\tm.appendtail(sb);\n\tsystem.out.println("appendtail: " + sb);\n}\n\n\n输出\n\ncontent: i can because i think i can.\nappendreplacement: i can not because i think i can not\nappendtail: i can not because i think i can not.\n\n\n说明\n\n从输出结果可以看出，appendreplacement和appendtail方法组合起来用，功能和replaceall是一样的。\n\n如果你查看replaceall的源码，会发现其内部就是使用appendreplacement和appendtail方法组合来实现的。\n\n【示例】quotereplacement 和 replaceall，解决特殊字符替换问题\n\npublic static void main(string[] args) {\n\tstring regex = "\\\\$\\\\{.*?\\\\}";\n\tstring replace = "${product}";\n\tstring content = "product is ${productname}.";\n\n\tpattern p = pattern.compile(regex);\n\tmatcher m = p.matcher(content);\n\tstring replaceall = m.replaceall(replace);\n\n\tsystem.out.println("content: " + content);\n\tsystem.out.println("replaceall: " + replaceall);\n}\n\n\n输出\n\nexception in thread "main" java.lang.illegalargumentexception: no group with name {product}\n\tat java.util.regex.matcher.appendreplacement(matcher.java:849)\n\tat java.util.regex.matcher.replaceall(matcher.java:955)\n\tat org.zp.notes.javase.regex.regexdemo.wrongmethod(regexdemo.java:42)\n\tat org.zp.notes.javase.regex.regexdemo.main(regexdemo.java:18)\n\tat sun.reflect.nativemethodaccessorimpl.invoke0(native method)\n\tat sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\n\tat sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\n\tat java.lang.reflect.method.invoke(method.java:498)\n\tat com.intellij.rt.execution.application.appmain.main(appmain.java:147)\n\n\n说明\n\nstring regex = "\\\\$\\\\{.*?\\\\}";表示匹配类似${name}这样的字符串。由于$、{ 、}都是特殊字符，需要用反义字符\\来修饰才能被当做一个字符串字符来处理。\n\n上面的例子是想将 ${productname} 替换为 ${product} ，然而replaceall方法却将传入的字符串中的$当做特殊字符来处理了。结果产生异常。\n\n如何解决这个问题?\n\njdk1.5 引入了quotereplacement方法。它可以用来转换特殊字符。其实源码非常简单，就是判断字符串中如果有\\或$，就为它加一个转义字符\\\n\n我们对上面的代码略作调整：\n\nm.replaceall(replace)改为m.replaceall(matcher.quotereplacement(replace))，新代码如下：\n\npublic static void main(string[] args) {\n\tstring regex = "\\\\$\\\\{.*?\\\\}";\n\tstring replace = "${product}";\n\tstring content = "product is ${productname}.";\n\n\tpattern p = pattern.compile(regex);\n\tmatcher m = p.matcher(content);\n\tstring replaceall = m.replaceall(matcher.quotereplacement(replace));\n\n\tsystem.out.println("content: " + content);\n\tsystem.out.println("replaceall: " + replaceall);\n}\n\n\n输出\n\ncontent: product is ${productname}.\nreplaceall: product is ${product}.\n\n\n说明\n\n字符串中如果有\\或$，不能被正常解析的问题解决。\n\n\n# 元字符\n\n元字符(metacharacters)就是正则表达式中具有特殊意义的专用字符。\n\n\n# 基本元字符\n\n正则表达式的元字符难以记忆，很大程度上是因为有很多为了简化表达而出现的等价字符。而实际上最基本的元字符，并没有那么多。对于大部分的场景，基本元字符都可以搞定。让我们从一个个实例出发，由浅入深的去体会正则的奥妙。\n\n# 多选（|）\n\n【示例】匹配一个确定的字符串\n\ncheckmatches("abc", "abc");\n\n\n如果要匹配一个确定的字符串，非常简单，如例 1 所示。但是，如果你不确定要匹配的字符串，希望有多个选择，怎么办？答案是：使用元字符| ，它的含义是或。\n\n【示例】匹配多个可选的字符串\n\n// 测试正则表达式字符：|\nassert.asserttrue(checkmatches("yes|no", "yes"));\nassert.asserttrue(checkmatches("yes|no", "no"));\nassert.assertfalse(checkmatches("yes|no", "right"));\n\n// 输出\n// yes\tmatches： yes|no\n// no\tmatches： yes|no\n// right\tnot matches： yes|no\n\n\n# 分组（()）\n\n如果你希望表达式由多个子表达式组成，你可以使用 ()。\n\n【示例】匹配组合字符串\n\nassert.asserttrue(checkmatches("(play|end)(ing|ed)", "ended"));\nassert.asserttrue(checkmatches("(play|end)(ing|ed)", "ending"));\nassert.asserttrue(checkmatches("(play|end)(ing|ed)", "playing"));\nassert.asserttrue(checkmatches("(play|end)(ing|ed)", "played"));\n\n// 输出\n// ended\tmatches： (play|end)(ing|ed)\n// ending\tmatches： (play|end)(ing|ed)\n// playing\tmatches： (play|end)(ing|ed)\n// played\tmatches： (play|end)(ing|ed)\n\n\n# 指定单字符有效范围（[]）\n\n前面展示了如何匹配字符串，但是很多时候你需要精确的匹配一个字符，这时可以使用[] 。\n\n【示例】字符在指定范围\n\n// 测试正则表达式字符：[]\nassert.asserttrue(checkmatches("[abc]", "b"));  // 字符只能是a、b、c\nassert.asserttrue(checkmatches("[a-z]", "m")); // 字符只能是a - z\nassert.asserttrue(checkmatches("[a-z]", "o")); // 字符只能是a - z\nassert.asserttrue(checkmatches("[a-za-z]", "k")); // 字符只能是a - z和a - z\nassert.asserttrue(checkmatches("[a-za-z]", "k"));\nassert.asserttrue(checkmatches("[0-9]", "5")); // 字符只能是0 - 9\n\n// 输出\n// b\tmatches： [abc]\n// m\tmatches： [a-z]\n// o\tmatches： [a-z]\n// k\tmatches： [a-za-z]\n// k\tmatches： [a-za-z]\n// 5\tmatches： [0-9]\n\n\n# 指定单字符无效范围（ [^]）\n\n【示例】字符不能在指定范围\n\n如果需要匹配一个字符的逆操作，即字符不能在指定范围，可以使用[^]。\n\n// 测试正则表达式字符：[^]\nassert.assertfalse(checkmatches("[^abc]", "b")); // 字符不能是a、b、c\nassert.assertfalse(checkmatches("[^a-z]", "m")); // 字符不能是a - z\nassert.assertfalse(checkmatches("[^a-z]", "o")); // 字符不能是a - z\nassert.assertfalse(checkmatches("[^a-za-z]", "k")); // 字符不能是a - z和a - z\nassert.assertfalse(checkmatches("[^a-za-z]", "k"));\nassert.assertfalse(checkmatches("[^0-9]", "5")); // 字符不能是0 - 9\n\n// 输出\n// b\tnot matches： [^abc]\n// m\tnot matches： [^a-z]\n// o\tnot matches： [^a-z]\n// k\tnot matches： [^a-za-z]\n// k\tnot matches： [^a-za-z]\n// 5\tnot matches： [^0-9]\n\n\n# 限制字符数量（{}）\n\n如果想要控制字符出现的次数，可以使用 {}。\n\n字符      描述\n{n}     n 是一个非负整数。匹配确定的 n 次。\n{n,}    n 是一个非负整数。至少匹配 n 次。\n{n,m}   m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。\n\n【示例】限制字符出现次数\n\n// {n}: n 是一个非负整数。匹配确定的 n 次。\ncheckmatches("ap{1}", "a");\ncheckmatches("ap{1}", "ap");\ncheckmatches("ap{1}", "app");\ncheckmatches("ap{1}", "apppppppppp");\n\n// {n,}: n 是一个非负整数。至少匹配 n 次。\ncheckmatches("ap{1,}", "a");\ncheckmatches("ap{1,}", "ap");\ncheckmatches("ap{1,}", "app");\ncheckmatches("ap{1,}", "apppppppppp");\n\n// {n,m}: m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。\ncheckmatches("ap{2,5}", "a");\ncheckmatches("ap{2,5}", "ap");\ncheckmatches("ap{2,5}", "app");\ncheckmatches("ap{2,5}", "apppppppppp");\n\n// 输出\n// a\tnot matches： ap{1}\n// ap\tmatches： ap{1}\n// app\tnot matches： ap{1}\n// apppppppppp\tnot matches： ap{1}\n// a\tnot matches： ap{1,}\n// ap\tmatches： ap{1,}\n// app\tmatches： ap{1,}\n// apppppppppp\tmatches： ap{1,}\n// a\tnot matches： ap{2,5}\n// ap\tnot matches： ap{2,5}\n// app\tmatches： ap{2,5}\n// apppppppppp\tnot matches： ap{2,5}\n\n\n# 转义字符（/）\n\n如果想要查找元字符本身，你需要使用转义符，使得正则引擎将其视作一个普通字符，而不是一个元字符去处理。\n\n* 的转义字符：\\*\n+ 的转义字符：\\+\n? 的转义字符：\\?\n^ 的转义字符：\\^\n$ 的转义字符：\\$\n. 的转义字符：\\.\n\n\n如果是转义符 \\ 本身，你需要使用 \\\\ 。\n\n# 指定表达式字符串的开始（^）和结尾（$）\n\n如果希望匹配的字符串必须以特定字符串开头，可以使用 ^ 。\n\n> 注意：请特别留意，这里的 ^ 一定要和 [^] 中的 ^ 区分。\n\n【示例】限制字符串头部\n\nassert.asserttrue(checkmatches("^app[a-z]{0,}", "apple")); // 字符串必须以app开头\nassert.assertfalse(checkmatches("^app[a-z]{0,}", "aplause"));\n\n// 输出\n// apple\tmatches： ^app[a-z]{0,}\n// aplause\tnot matches： ^app[a-z]{0,}\n\n\n如果希望匹配的字符串必须以特定字符串结尾，可以使用 $ 。\n\n【示例】限制字符串尾部\n\nassert.asserttrue(checkmatches("[a-z]{0,}ing$", "playing")); // 字符串必须以ing结尾\nassert.assertfalse(checkmatches("[a-z]{0,}ing$", "long"));\n\n// 输出\n// playing\tmatches： [a-z]{0,}ing$\n// long\tnot matches： [a-z]{0,}ing$\n\n\n\n# 等价字符\n\n等价字符，顾名思义，就是对于基本元字符表达的一种简化（等价字符的功能都可以通过基本元字符来实现）。\n\n在没有掌握基本元字符之前，可以先不用理会，因为很容易把人绕晕。\n\n等价字符的好处在于简化了基本元字符的写法。\n\n# 表示某一类型字符的等价字符\n\n下表中的等价字符都表示某一类型的字符。\n\n字符   描述\n.    匹配除“\\n”之外的任何单个字符。\n\\d   匹配一个数字字符。等价于[0-9]。\n\\d   匹配一个非数字字符。等价于[^0-9]。\n\\w   匹配包括下划线的任何单词字符。类似但不等价于“[a-za-z0-9_]”，这里的单词字符指的是 unicode 字符集。\n\\w   匹配任何非单词字符。\n\\s   匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。\n\\s   匹配任何可见字符。等价于[ \\f\\n\\r\\t\\v]。\n\n【示例】基本等价字符的用法\n\n// 匹配除“\\n”之外的任何单个字符\nassert.asserttrue(checkmatches(".{1,}", "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789_"));\nassert.asserttrue(checkmatches(".{1,}", "~!@#$%^&*()+`-=[]{};:<>,./?|\\\\"));\nassert.assertfalse(checkmatches(".", "\\n"));\nassert.assertfalse(checkmatches("[^\\n]", "\\n"));\n\n// 匹配一个数字字符。等价于[0-9]\nassert.asserttrue(checkmatches("\\\\d{1,}", "0123456789"));\n// 匹配一个非数字字符。等价于[^0-9]\nassert.assertfalse(checkmatches("\\\\d{1,}", "0123456789"));\n\n// 匹配包括下划线的任何单词字符。类似但不等价于“[a-za-z0-9_]”，这里的单词字符指的是unicode字符集\nassert.asserttrue(checkmatches("\\\\w{1,}", "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789_"));\nassert.assertfalse(checkmatches("\\\\w{1,}", "~!@#$%^&*()+`-=[]{};:<>,./?|\\\\"));\n// 匹配任何非单词字符\nassert.assertfalse(checkmatches("\\\\w{1,}", "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789_"));\nassert.asserttrue(checkmatches("\\\\w{1,}", "~!@#$%^&*()+`-=[]{};:<>,./?|\\\\"));\n\n// 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]\nassert.asserttrue(checkmatches("\\\\s{1,}", " \\f\\r\\n\\t"));\n// 匹配任何可见字符。等价于[^ \\f\\n\\r\\t\\v]\nassert.assertfalse(checkmatches("\\\\s{1,}", " \\f\\r\\n\\t"));\n\n// 输出\n// abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789_\tmatches： .{1,}\n// ~!@#$%^&*()+`-=[]{};:<>,./?|\\\\\tmatches： .{1,}\n// \\n\tnot matches： .\n// \\n\tnot matches： [^\\n]\n// 0123456789\tmatches： \\\\d{1,}\n// 0123456789\tnot matches： \\\\d{1,}\n// abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789_\tmatches： \\\\w{1,}\n// ~!@#$%^&*()+`-=[]{};:<>,./?|\\\\\tnot matches： \\\\w{1,}\n// abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789_\tnot matches： \\\\w{1,}\n// ~!@#$%^&*()+`-=[]{};:<>,./?|\\\\\tmatches： \\\\w{1,}\n// \\f\\r\\n\\t\tmatches： \\\\s{1,}\n// \\f\\r\\n\\t\tnot matches： \\\\s{1,}\n\n\n# 限制字符数量的等价字符\n\n在基本元字符章节中，已经介绍了限制字符数量的基本元字符 - {} 。\n\n此外，还有 *、+、? 这个三个为了简化写法而出现的等价字符，我们来认识一下。\n\n字符   描述\n*    匹配前面的子表达式零次或多次。等价于{0,}。\n+    匹配前面的子表达式一次或多次。等价于{1,}。\n?    匹配前面的子表达式零次或一次。等价于 {0,1}。\n\n案例 限制字符数量的等价字符\n\n// *: 匹配前面的子表达式零次或多次。* 等价于{0,}。\ncheckmatches("ap*", "a");\ncheckmatches("ap*", "ap");\ncheckmatches("ap*", "app");\ncheckmatches("ap*", "apppppppppp");\n\n// +: 匹配前面的子表达式一次或多次。+ 等价于 {1,}。\ncheckmatches("ap+", "a");\ncheckmatches("ap+", "ap");\ncheckmatches("ap+", "app");\ncheckmatches("ap+", "apppppppppp");\n\n// ?: 匹配前面的子表达式零次或一次。? 等价于 {0,1}。\ncheckmatches("ap?", "a");\ncheckmatches("ap?", "ap");\ncheckmatches("ap?", "app");\ncheckmatches("ap?", "apppppppppp");\n\n// 输出\n// a\tmatches： ap*\n// ap\tmatches： ap*\n// app\tmatches： ap*\n// apppppppppp\tmatches： ap*\n// a\tnot matches： ap+\n// ap\tmatches： ap+\n// app\tmatches： ap+\n// apppppppppp\tmatches： ap+\n// a\tmatches： ap?\n// ap\tmatches： ap?\n// app\tnot matches： ap?\n// apppppppppp\tnot matches： ap?\n\n\n# 元字符优先级顺序\n\n正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。\n\n下表从最高到最低说明了各种正则表达式运算符的优先级顺序：\n\n运算符                    说明\n\\                      转义符\n()、(?:)、(?=)、[]        括号和中括号\n*、+、?、{n}、{n,}、{n,m}   限定符\n^、$、*任何字符、任何字符*        定位点和序列\n|                      替换\n\n字符具有高于替换运算符的优先级，使得 m|food 匹配 m 或 food 。若要匹配 mood 或 food ，请使用括号创建子表达式，从而产生 (m|f)ood 。\n\n\n# 分组构造\n\n在基本元字符章节，提到了 () 字符可以用来对表达式分组。实际上分组还有更多复杂的用法。\n\n所谓分组构造，是用来描述正则表达式的子表达式，用于捕获字符串中的子字符串。\n\n\n# 捕获与非捕获\n\n下表为分组构造中的捕获和非捕获分类。\n\n表达式            描述           捕获或非捕获\n(exp)          匹配的子表达式      捕获\n(?<name>exp)   命名的反向引用      捕获\n(?:exp)        非捕获组         非捕获\n(?=exp)        零宽度正预测先行断言   非捕获\n(?!exp)        零宽度负预测先行断言   非捕获\n(?<=exp)       零宽度正回顾后发断言   非捕获\n(?<!exp)       零宽度负回顾后发断言   非捕获\n\n> 注：java 正则引擎不支持平衡组。\n\n\n# 反向引用\n\n# 带编号的反向引用\n\n带编号的反向引用使用以下语法：\\number\n\n其中number 是正则表达式中捕获组的序号位置。 例如，\\4 匹配第四个捕获组的内容。 如果正则表达式模式中未定义number，则将发生分析错误\n\n【示例】匹配重复的单词和紧随每个重复的单词的单词(不命名子表达式)\n\n// (\\w+)\\s\\1\\w(\\w+) 匹配重复的单词和紧随每个重复的单词的单词\nassert.asserttrue(findall("(\\\\w+)\\\\s\\\\1\\\\w(\\\\w+)",\n\t\t"he said that that was the the correct answer.") > 0);\n\n// 输出\n// regex = (\\w+)\\s\\1\\w(\\w+), content: he said that that was the the correct answer.\n// [1th] start: 8, end: 21, group: that that was\n// [2th] start: 22, end: 37, group: the the correct\n\n\n说明：\n\n * (\\w+)：匹配一个或多个单词字符。\n * \\s：与空白字符匹配。\n * \\1：匹配第一个组，即(\\w+)。\n * \\w：匹配包括空格和标点符号的一个非单词字符。 这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。\n\n# 命名的反向引用\n\n命名后向引用通过使用下面的语法进行定义：\\k<name >\n\n【示例】匹配重复的单词和紧随每个重复的单词的单词(命名子表达式)\n\n// (?<duplicateword>\\w+)\\s\\k<duplicateword>\\w(?<nextword>\\w+) 匹配重复的单词和紧随每个重复的单词的单词\nassert.asserttrue(findall("(?<duplicateword>\\\\w+)\\\\s\\\\k<duplicateword>\\\\w(?<nextword>\\\\w+)",\n\t\t"he said that that was the the correct answer.") > 0);\n\n// 输出\n// regex = (?<duplicateword>\\w+)\\s\\k<duplicateword>\\w(?<nextword>\\w+), content: he said that that was the the correct answer.\n// [1th] start: 8, end: 21, group: that that was\n// [2th] start: 22, end: 37, group: the the correct\n\n\n说明：\n\n * (?<duplicateword>\\w+)：匹配一个或多个单词字符。 命名此捕获组 duplicateword。\n * \\s: 与空白字符匹配。\n * \\k<duplicateword>：匹配名为 duplicateword 的捕获的组。\n * \\w：匹配包括空格和标点符号的一个非单词字符。 这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。\n * (?<nextword>\\w+)：匹配一个或多个单词字符。 命名此捕获组 nextword。\n\n\n# 非捕获组\n\n(?:exp) 表示当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。\n\n【示例】匹配以.结束的语句。\n\n// 匹配由句号终止的语句。\nassert.asserttrue(findall("(?:\\\\b(?:\\\\w+)\\\\w*)+\\\\.", "this is a short sentence. never end") > 0);\n\n// 输出\n// regex = (?:\\b(?:\\w+)\\w*)+\\., content: this is a short sentence. never end\n// [1th] start: 0, end: 25, group: this is a short sentence.\n\n\n\n# 零宽断言\n\n用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。\n\n表达式        描述\n(?=exp)    匹配 exp 前面的位置\n(?<=exp)   匹配 exp 后面的位置\n(?!exp)    匹配后面跟的不是 exp 的位置\n(?<!exp)   匹配前面不是 exp 的位置\n\n# 匹配 exp 前面的位置\n\n(?=exp) 表示输入字符串必须匹配子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。\n\n// \\b\\w+(?=\\sis\\b) 表示要捕获is之前的单词\nassert.asserttrue(findall("\\\\b\\\\w+(?=\\\\sis\\\\b)", "the dog is a malamute.") > 0);\nassert.assertfalse(findall("\\\\b\\\\w+(?=\\\\sis\\\\b)", "the island has beautiful birds.") > 0);\nassert.assertfalse(findall("\\\\b\\\\w+(?=\\\\sis\\\\b)", "the pitch missed home plate.") > 0);\nassert.asserttrue(findall("\\\\b\\\\w+(?=\\\\sis\\\\b)", "sunday is a weekend day.") > 0);\n\n// 输出\n// regex = \\b\\w+(?=\\sis\\b), content: the dog is a malamute.\n// [1th] start: 4, end: 7, group: dog\n// regex = \\b\\w+(?=\\sis\\b), content: the island has beautiful birds.\n// not found\n// regex = \\b\\w+(?=\\sis\\b), content: the pitch missed home plate.\n// not found\n// regex = \\b\\w+(?=\\sis\\b), content: sunday is a weekend day.\n// [1th] start: 0, end: 6, group: sunday\n\n\n说明：\n\n * \\b：在单词边界处开始匹配。\n * \\w+：匹配一个或多个单词字符。\n * (?=\\sis\\b)：确定单词字符是否后接空白字符和字符串“is”，其在单词边界处结束。 如果如此，则匹配成功。\n\n# 匹配 exp 后面的位置\n\n(?<=exp) 表示子表达式不得在输入字符串当前位置左侧出现，尽管子表达式未包含在匹配结果中。零宽度正回顾后发断言不会回溯。\n\n// (?<=\\b20)\\d{2}\\b 表示要捕获以20开头的数字的后面部分\nassert.asserttrue(findall("(?<=\\\\b20)\\\\d{2}\\\\b", "2010 1999 1861 2140 2009") > 0);\n\n// 输出\n// regex = (?<=\\b20)\\d{2}\\b, content: 2010 1999 1861 2140 2009\n// [1th] start: 2, end: 4, group: 10\n// [2th] start: 22, end: 24, group: 09\n\n\n说明：\n\n * \\d{2}：匹配两个十进制数字。\n * {?<=\\b20)：如果两个十进制数字的字边界以小数位数“20”开头，则继续匹配。\n * \\b：在单词边界处结束匹配。\n\n# 匹配后面跟的不是 exp 的位置\n\n(?!exp) 表示输入字符串不得匹配子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。\n\n【示例】捕获未以“un”开头的单词\n\n// \\b(?!un)\\w+\\b 表示要捕获未以“un”开头的单词\nassert.asserttrue(findall("\\\\b(?!un)\\\\w+\\\\b", "unite one unethical ethics use untie ultimate") > 0);\n\n// 输出\n// regex = \\b(?!un)\\w+\\b, content: unite one unethical ethics use untie ultimate\n// [1th] start: 6, end: 9, group: one\n// [2th] start: 20, end: 26, group: ethics\n// [3th] start: 27, end: 30, group: use\n// [4th] start: 37, end: 45, group: ultimate\n\n\n说明：\n\n * \\b：在单词边界处开始匹配。\n * (?!un)：确定接下来的两个的字符是否为“un”。 如果没有，则可能匹配。\n * \\w+：匹配一个或多个单词字符。\n * \\b：在单词边界处结束匹配。\n\n# 匹配前面不是 exp 的位置\n\n(?<!exp) 表示子表达式不得在输入字符串当前位置的左侧出现。 但是，任何不匹配子表达式 的子字符串不包含在匹配结果中。\n\n【示例】捕获任意工作日\n\n// (?<!(saturday|sunday) )\\b\\w+ \\d{1,2}, \\d{4}\\b 表示要捕获任意工作日（即周一到周五）\nassert.asserttrue(findall("(?<!(saturday|sunday) )\\\\b\\\\w+ \\\\d{1,2}, \\\\d{4}\\\\b", "monday february 1, 2010") > 0);\nassert.asserttrue(findall("(?<!(saturday|sunday) )\\\\b\\\\w+ \\\\d{1,2}, \\\\d{4}\\\\b", "wednesday february 3, 2010") > 0);\nassert.assertfalse(findall("(?<!(saturday|sunday) )\\\\b\\\\w+ \\\\d{1,2}, \\\\d{4}\\\\b", "saturday february 6, 2010") > 0);\nassert.assertfalse(findall("(?<!(saturday|sunday) )\\\\b\\\\w+ \\\\d{1,2}, \\\\d{4}\\\\b", "sunday february 7, 2010") > 0);\nassert.asserttrue(findall("(?<!(saturday|sunday) )\\\\b\\\\w+ \\\\d{1,2}, \\\\d{4}\\\\b", "monday, february 8, 2010") > 0);\n\n// 输出\n// regex = (?<!(saturday|sunday) )\\b\\w+ \\d{1,2}, \\d{4}\\b, content: monday february 1, 2010\n// [1th] start: 7, end: 23, group: february 1, 2010\n// regex = (?<!(saturday|sunday) )\\b\\w+ \\d{1,2}, \\d{4}\\b, content: wednesday february 3, 2010\n// [1th] start: 10, end: 26, group: february 3, 2010\n// regex = (?<!(saturday|sunday) )\\b\\w+ \\d{1,2}, \\d{4}\\b, content: saturday february 6, 2010\n// not found\n// regex = (?<!(saturday|sunday) )\\b\\w+ \\d{1,2}, \\d{4}\\b, content: sunday february 7, 2010\n// not found\n// regex = (?<!(saturday|sunday) )\\b\\w+ \\d{1,2}, \\d{4}\\b, content: monday, february 8, 2010\n// [1th] start: 8, end: 24, group: february 8, 2010\n\n\n\n# 贪婪与懒惰\n\n当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以 a 开始，以 b 结束的字符串。如果用它来搜索 aabab 的话，它会匹配整个字符串 aabab。这被称为贪婪匹配。\n\n有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。\n\n表达式      描述\n*?       重复任意次，但尽可能少重复\n+?       重复 1 次或更多次，但尽可能少重复\n??       重复 0 次或 1 次，但尽可能少重复\n{n,m}?   重复 n 到 m 次，但尽可能少重复\n{n,}?    重复 n 次以上，但尽可能少重复\n\n【示例】java 正则中贪婪与懒惰的示例\n\n// 贪婪匹配\nassert.asserttrue(findall("a\\\\w*b", "abaabaaabaaaab") > 0);\n\n// 懒惰匹配\nassert.asserttrue(findall("a\\\\w*?b", "abaabaaabaaaab") > 0);\nassert.asserttrue(findall("a\\\\w+?b", "abaabaaabaaaab") > 0);\nassert.asserttrue(findall("a\\\\w??b", "abaabaaabaaaab") > 0);\nassert.asserttrue(findall("a\\\\w{0,4}?b", "abaabaaabaaaab") > 0);\nassert.asserttrue(findall("a\\\\w{3,}?b", "abaabaaabaaaab") > 0);\n\n// 输出\n// regex = a\\w*b, content: abaabaaabaaaab\n// [1th] start: 0, end: 14, group: abaabaaabaaaab\n// regex = a\\w*?b, content: abaabaaabaaaab\n// [1th] start: 0, end: 2, group: ab\n// [2th] start: 2, end: 5, group: aab\n// [3th] start: 5, end: 9, group: aaab\n// [4th] start: 9, end: 14, group: aaaab\n// regex = a\\w+?b, content: abaabaaabaaaab\n// [1th] start: 0, end: 5, group: abaab\n// [2th] start: 5, end: 9, group: aaab\n// [3th] start: 9, end: 14, group: aaaab\n// regex = a\\w??b, content: abaabaaabaaaab\n// [1th] start: 0, end: 2, group: ab\n// [2th] start: 2, end: 5, group: aab\n// [3th] start: 6, end: 9, group: aab\n// [4th] start: 11, end: 14, group: aab\n// regex = a\\w{0,4}?b, content: abaabaaabaaaab\n// [1th] start: 0, end: 2, group: ab\n// [2th] start: 2, end: 5, group: aab\n// [3th] start: 5, end: 9, group: aaab\n// [4th] start: 9, end: 14, group: aaaab\n// regex = a\\w{3,}?b, content: abaabaaabaaaab\n// [1th] start: 0, end: 5, group: abaab\n// [2th] start: 5, end: 14, group: aaabaaaab\n\n\n说明：\n\n本例中代码展示的是使用不同贪婪或懒惰策略去查找字符串 abaabaaabaaaab 中匹配以 a 开头，以 b 结尾的所有子字符串。请从输出结果中，细细体味使用不同的贪婪或懒惰策略，对于匹配子字符串有什么影响。\n\n\n# 正则附录\n\n\n# 匹配正则字符串的方法\n\n由于正则表达式中很多元字符本身就是转义字符，在 java 字符串的规则中不会被显示出来。\n\n为此，可以使用一个工具类org.apache.commons.lang3.stringescapeutils来做特殊处理，使得转义字符可以打印。这个工具类提供的都是静态方法，从方法命名大致也可以猜出用法，这里不多做说明。\n\n如果你了解 maven，可以直接引入依赖\n\n<dependency>\n  <groupid>org.apache.commons</groupid>\n  <artifactid>commons-lang3</artifactid>\n  <version>${commons-lang3.version}</version>\n</dependency>\n\n\n【示例】本文为了展示正则匹配规则用到的方法\n\nprivate boolean checkmatches(string regex, string content) {\n\tpattern p = pattern.compile(regex);\n\tmatcher m = p.matcher(content);\n\tboolean flag = m.matches();\n\tif (m.matches()) {\n\t\tsystem.out.println(stringescapeutils.escapejava(content) + "\\tmatches： " + stringescapeutils.escapejava(regex));\n\t} else {\n\t\tsystem.out.println(stringescapeutils.escapejava(content) + "\\tnot matches： " + stringescapeutils.escapejava(regex));\n\t}\n\treturn flag;\n}\n\npublic int findall(string regex, string content) {\n\tpattern p = pattern.compile(regex);\n\tmatcher m = p.matcher(content);\n\tsystem.out.println("regex = " + regex + ", content: " + content);\n\n\tint count = 0;\n\twhile (m.find()) {\n\t\tcount++;\n\t\tsystem.out.println("[" + count + "th] " + "start: " + m.start() + ", end: " + m.end()\n\t\t\t\t+ ", group: " + m.group());\n\t}\n\tif (0 == count) {\n\t\tsystem.out.println("not found");\n\t}\n\treturn count;\n}\n\n\n\n# 速查元字符字典\n\n为了方便快查正则的元字符含义，在本节根据元字符的功能集中罗列正则的各种元字符。\n\n# 限定符\n\n字符      描述\n*       匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。\n+       匹配前面的子表达式一次或多次。例如，\'zo+\' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于\n        {1,}。\n?       匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于\n        {0,1}。\n{n}     n 是一个非负整数。匹配确定的 n 次。例如，\'o{2}\' 不能匹配 "bob" 中的 \'o\'，但是能匹配 "food"\n        中的两个 o。\n{n,}    n 是一个非负整数。至少匹配 n 次。例如，\'o{2,}\' 不能匹配 "bob" 中的 \'o\'，但能匹配\n        "foooood" 中的所有 o。\'o{1,}\' 等价于 \'o+\'。\'o{0,}\' 则等价于 \'o*\'。\n{n,m}   m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配\n        "fooooood" 中的前三个 o。\'o{0,1}\' 等价于 \'o?\'。请注意在逗号和两个数之间不能有空格。\n\n# 定位符\n\n字符   描述\n^    匹配输入字符串开始的位置。如果设置了 regexp 对象的 multiline 属性，^ 还会与 \\n 或 \\r\n     之后的位置匹配。\n$    匹配输入字符串结尾的位置。如果设置了 regexp 对象的 multiline 属性，$ 还会与 \\n 或 \\r\n     之前的位置匹配。\n\\b   匹配一个字边界，即字与空格间的位置。\n\\b   非字边界匹配。\n\n# 非打印字符\n\n字符    描述\n\\cx   匹配由 x 指明的控制字符。例如， \\cm 匹配一个 control-m 或回车符。x 的值必须为 a-z 或 a-z\n      之一。否则，将 c 视为一个原义的 \'c\' 字符。\n\\f    匹配一个换页符。等价于 \\x0c 和 \\cl。\n\\n    匹配一个换行符。等价于 \\x0a 和 \\cj。\n\\r    匹配一个回车符。等价于 \\x0d 和 \\cm。\n\\s    匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。\n\\s    匹配任何非空白字符。等价于 [ \\f\\n\\r\\t\\v]。\n\\t    匹配一个制表符。等价于 \\x09 和 \\ci。\n\\v    匹配一个垂直制表符。等价于 \\x0b 和 \\ck。\n\n# 分组\n\n表达式            描述\n(exp)          匹配的子表达式。()中的内容就是子表达式。\n(?<name>exp)   命名的子表达式（反向引用）。\n(?:exp)        非捕获组，表示当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。\n(?=exp)        匹配 exp 前面的位置。\n(?<=exp)       匹配 exp 后面的位置。\n(?!exp)        匹配后面跟的不是 exp 的位置。\n(?<!exp)       匹配前面不是 exp 的位置。\n\n# 特殊符号\n\n字符   描述\n\\    将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， \'n\' 匹配字符 \'n\'。\'\\n\'\n     匹配换行符。序列 \'\\\' 匹配 ""，而 \'(\' 则匹配 "("。\n\\|   指明两项之间的一个选择。\n[]   匹配方括号范围内的任意一个字符。形式如：[xyz]、[^xyz]、[a-z]、[^a-z]、[x,y,z]\n\n\n# 正则实战\n\n虽然本系列洋洋洒洒的大谈特谈正则表达式。但是我还是要在这里建议，如果一个正则表达式没有经过充分测试，还是要谨慎使用。\n\n正则是把双刃剑，它可以为你节省大量的代码行。但是由于它不易阅读，维护起来可是头疼的哦（你需要一个字符一个字符的去理解）。\n\n\n# 最实用的正则\n\n# 校验中文\n\n校验字符串中只能有中文字符（不包括中文标点符号）。中文字符的 unicode 编码范围是 \\u4e00 到 \\u9fa5。\n\n> 如有兴趣，可以参考百度百科-unicode 。\n\n^[\\u4e00-\\u9fa5]+$\n\n\n * 匹配： 春眠不觉晓\n * **不匹配：**春眠不觉晓，\n\n# 校验身份证号码\n\n身份证为 15 位或 18 位。15 位是第一代身份证。从 1999 年 10 月 1 日起，全国实行公民身份证号码制度，居民身份证编号由原 15 位升至 18 位。\n\n * 15 位身份证：由 15 位数字组成。排列顺序从左至右依次为：六位数字地区码；六位数字出生日期；三位顺序号，其中 15 位男为单数，女为双数。\n * 18 位身份证：由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地区码；八位数字出生日期；三位数字顺序码和一位数字校验码（也可能是 x）。\n\n> 身份证号含义详情请见：百度百科-居民身份证号码\n\n地区码（6 位）\n\n(1[1-5]|2[1-3]|3[1-7]|4[1-3]|5[0-4]|6[1-5])\\d{4}\n\n\n出生日期（8 位）\n\n注：下面的是 18 位身份证的有效出生日期，如果是 15 位身份证，只要将第一个\\d{4}改为\\d{2}即可。\n\n((\\d{4}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)\n\n\n15 位有效身份证\n\n^((1[1-5]|2[1-3]|3[1-7]|4[1-3]|5[0-4]|6[1-5])\\d{4})((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)(\\d{3})$\n\n\n * **匹配：**110001700101031\n\n * **不匹配：**110001701501031\n\n18 位有效身份证\n\n^((1[1-5]|2[1-3]|3[1-7]|4[1-3]|5[0-4]|6[1-5])\\d{4})((\\d{4}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)(\\d{3}(\\d|x))$\n\n\n * **匹配：**110001199001010310 | 11000019900101015x\n\n * **不匹配：**990000199001010310 | 110001199013010310\n\n# 校验有效用户名、密码\n\n**描述：**长度为 6-18 个字符，允许输入字母、数字、下划线，首字符必须为字母。\n\n^[a-za-z]\\w{5,17}$\n\n\n * **匹配：**he_llo@worl.d.com | hel.l-o@wor-ld.museum | h1ello@123.com\n\n * **不匹配：**hello@worl_d.com | he&llo@world.co1 | .hello@wor#.co.uk\n\n# 校验邮箱\n\n**描述：**不允许使用 ip 作为域名，如 : hello@154.145.68.12\n\n@符号前的邮箱用户和.符号前的域名(domain)必须满足以下条件：\n\n * 字符只能是英文字母、数字、下划线_、.、- ；\n * 首字符必须为字母或数字；\n * _、.、- 不能连续出现。\n\n域名的根域只能为字母，且至少为两个字符。\n\n^[a-za-z0-9](([_\\.\\-]?[a-za-z0-9]+)*)@([a-za-z0-9]+)(([\\.\\-]?[a-za-z0-9]+)*)\\.([a-za-z]{2,})$\n\n\n * **匹配：**he_llo@worl.d.com | hel.l-o@wor-ld.museum | h1ello@123.com\n * **不匹配：**hello@worl_d.com | he&llo@world.co1 | .hello@wor#.co.uk\n\n# 校验 url\n\n**描述：**校验 url。支持 http、https、ftp、ftps。\n\n^(ht|f)(tp|tps)\\://[a-za-z0-9\\-\\.]+\\.([a-za-z]{2,3})?(/\\s*)?$\n\n\n * **匹配：**http://google.com/help/me | http://www.google.com/help/me/ | https://www.google.com/help.asp | ftp://www.google.com | ftps://google.org\n\n * **不匹配：**http://un/www.google.com/index.asp\n\n# 校验时间\n\n**描述：**校验时间。时、分、秒必须是有效数字，如果数值不是两位数，十位需要补零。\n\n^([0-1][0-9]|[2][0-3]):([0-5][0-9])$\n\n\n * **匹配：**00:00:00 | 23:59:59 | 17:06:30\n\n * **不匹配：**17:6:30 | 24:16:30\n\n# 校验日期\n\n**描述：**校验日期。日期满足以下条件：\n\n * 格式 yyyy-mm-dd 或 yyyy-m-d\n * 连字符可以没有或是“-”、“/”、“.”之一\n * 闰年的二月可以有 29 日；而平年不可以。\n * 一、三、五、七、八、十、十二月为 31 日。四、六、九、十一月为 30 日。\n\n^(?:(?!0000)[0-9]{4}([-/.]?)(?:(?:0?[1-9]|1[0-2])\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\1(?:29|30)|(?:0?[13578]|1[02])\\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\\2(?:29))$\n\n\n * **匹配：**2016/1/1 | 2016/01/01 | 20160101 | 2016-01-01 | 2016.01.01 | 2000-02-29\n * **不匹配：**2001-02-29 | 2016/12/32 | 2016/6/31 | 2016/13/1 | 2016/0/1\n\n# 校验中国手机号码\n\n**描述：**中国手机号码正确格式：11 位数字。\n\n> 移动有 16 个号段：134、135、136、137、138、139、147、150、151、152、157、158、159、182、187、188。其中 147、157、188 是 3g 号段，其他都是 2g 号段。联通有 7 种号段：130、131、132、155、156、185、186。其中 186 是 3g（wcdma）号段，其余为 2g 号段。电信有 4 个号段：133、153、180、189。其中 189 是 3g 号段（cdma2000），133 号段主要用作无线网卡号。总结：13 开头手机号 0-9；15 开头手机号 0-3、5-9；18 开头手机号 0、2、5-9。\n> \n> 此外，中国在国际上的区号为 86，所以手机号开头有+86、86 也是合法的。\n> \n> 以上信息来源于 百度百科-手机号\n\n^((\\+)?86\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\d{8}$\n\n\n * 匹配：+86 18012345678 | 86 18012345678 | 15812345678\n\n * **不匹配：**15412345678 | 12912345678 | 180123456789\n\n# 校验中国固话号码\n\n**描述：**固话号码，必须加区号（以 0 开头）。 3 位有效区号：010、020~029，固话位数为 8 位。 4 位有效区号：03xx 开头到 09xx，固话位数为 7。\n\n> 如果想了解更详细的信息，请参考 百度百科-电话区号 。\n\n^(010|02[0-9])(\\s|-)\\d{8}|(0[3-9]\\d{2})(\\s|-)\\d{7}$\n\n\n * **匹配：**010-12345678 | 010 12345678 | 0512-1234567 | 0512 1234567\n\n * **不匹配：**1234567 | 12345678\n\n# 校验 ipv4 地址\n\n**描述：**ip 地址是一个 32 位的二进制数，通常被分割为 4 个“8 位二进制数”（也就是 4 个字节）。ip 地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。\n\n^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])$\n\n\n * **匹配：**0.0.0.0 | 255.255.255.255 | 127.0.0.1\n\n * **不匹配：**10.10.10 | 10.10.10.256\n\n# 校验 ipv6 地址\n\n**描述：**ipv6 的 128 位地址通常写成 8 组，每组为四个十六进制数的形式。\n\nipv6 地址可以表示为以下形式：\n\n * ipv6 地址\n * 零压缩 ipv6 地址(section 2.2 of rfc5952)\n * 带有本地链接区域索引的 ipv6 地址 (section 11 of rfc4007)\n * 嵌入 ipv4 的 ipv6 地址(section 2 of rfc6052\n * 映射 ipv4 的 ipv6 地址 (section 2.1 of rfc2765)\n * 翻译 ipv4 的 ipv6 地址 (section 2.1 of rfc2765)\n\n> 显然，ipv6 地址的表示方式很复杂。你也可以参考：\n> \n> 百度百科-ipv6\n> \n> stack overflow 上的 ipv6 正则表达高票答案\n\n(([0-9a-fa-f]{1,4}:){7,7}[0-9a-fa-f]{1,4}|([0-9a-fa-f]{1,4}:){1,7}:|([0-9a-fa-f]{1,4}:){1,6}:[0-9a-fa-f]{1,4}|([0-9a-fa-f]{1,4}:){1,5}(:[0-9a-fa-f]{1,4}){1,2}|([0-9a-fa-f]{1,4}:){1,4}(:[0-9a-fa-f]{1,4}){1,3}|([0-9a-fa-f]{1,4}:){1,3}(:[0-9a-fa-f]{1,4}){1,4}|([0-9a-fa-f]{1,4}:){1,2}(:[0-9a-fa-f]{1,4}){1,5}|[0-9a-fa-f]{1,4}:((:[0-9a-fa-f]{1,4}){1,6})|:((:[0-9a-fa-f]{1,4}){1,7}|:)|fe80:(:[0-9a-fa-f]{0,4}){0,4}%[0-9a-za-z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fa-f]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\n\n\n * **匹配：**1:2:3:4:5:6:7:8 | 1:: | 1::8 | 1::6:7:8 | 1::5:6:7:8 | 1::4:5:6:7:8 | 1::3:4:5:6:7:8 | ::2:3:4:5:6:7:8 | 1:2:3:4:5:6:7:: | 1:2:3:4:5:6::8 | 1:2:3:4:5::8 | 1:2:3:4::8 | 1:2:3::8 | 1:2::8 | 1::8 | ::8 | fe80::7:8%1 | ::255.255.255.255 | 2001:db8:3:4::192.0.2.33 | 64:ff9b::192.0.2.33\n\n * **不匹配：**1.2.3.4.5.6.7.8 | 1::2::3\n\n\n# 特定字符\n\n * 匹配长度为 3 的字符串：^.{3}$。\n * 匹配由 26 个英文字母组成的字符串：^[a-za-z]+$。\n * 匹配由 26 个大写英文字母组成的字符串：^[a-z]+$。\n * 匹配由 26 个小写英文字母组成的字符串：^[a-z]+$。\n * 匹配由数字和 26 个英文字母组成的字符串：^[a-za-z0-9]+$。\n * 匹配由数字、26 个英文字母或者下划线组成的字符串：^\\w+$。\n\n\n# 特定数字\n\n * 匹配正整数：^[1-9]\\d*$\n * 匹配负整数：^-[1-9]\\d*$\n * 匹配整数：^(-?[1-9]\\d*)|0$\n * 匹配正浮点数：^[1-9]\\d*\\.\\d+|0\\.\\d+$\n * 匹配负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$\n * 匹配浮点数：^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$\n\n\n# 正则表达式的性能\n\n目前实现正则表达式引擎的方式有两种：dfa 自动机（deterministic final automata 确定有限状态自动机）和 nfa 自动机（non deterministic finite automaton 非确定有限状态自动机）。对比来看，构造 dfa 自动机的代价远大于 nfa 自动机，但 dfa 自动机的执行效率高于 nfa 自动机。\n\n假设一个字符串的长度是 n，如果用 dfa 自动机作为正则表达式引擎，则匹配的时间复杂度为 o(n)；如果用 nfa 自动机作为正则表达式引擎，由于 nfa 自动机在匹配过程中存在大量的分支和回溯，假设 nfa 的状态数为 s，则该匹配算法的时间复杂度为 o（ns）。\n\nnfa 自动机的优势是支持更多功能。例如，捕获 group、环视、占有优先量词等高级功能。这些功能都是基于子表达式独立进行匹配，因此在编程语言里，使用的正则表达式库都是基于 nfa 实现的。\n\n\n# nfa 自动机的回溯\n\n用 nfa 自动机实现的比较复杂的正则表达式，在匹配过程中经常会引起回溯问题。大量的回溯会长时间地占用 cpu，从而带来系统性能开销。\n\ntext=“abbc”\nregex=“ab{1,3}c”\n\n\n这个例子匹配目的是：匹配以 a 开头，以 c 结尾，中间有 1-3 个 b 字符的字符串。nfa 自动机对其解析的过程是这样的：\n\n * 读取正则表达式第一个匹配符 a 和字符串第一个字符 a 进行比较，a 对 a，匹配。\n * 然后，读取正则表达式第二个匹配符 b{1,3} 和字符串的第二个字符 b 进行比较，匹配。但因为 b{1,3} 表示 1-3 个 b 字符串，nfa 自动机又具有贪婪特性，所以此时不会继续读取正则表达式的下一个匹配符，而是依旧使用 b{1,3} 和字符串的第三个字符 b 进行比较，结果还是匹配。\n * 接着继续使用 b{1,3} 和字符串的第四个字符 c 进行比较，发现不匹配了，此时就会发生回溯，已经读取的字符串第四个字符 c 将被吐出去，指针回到第三个字符 b 的位置。\n * 那么发生回溯以后，匹配过程怎么继续呢？程序会读取正则表达式的下一个匹配符 c，和字符串中的第四个字符 c 进行比较，结果匹配，结束。\n\n\n# 如何避免回溯\n\n# 贪婪模式（greedy）\n\n顾名思义，就是在数量匹配中，如果单独使用 +、 ? 、* 或{min,max} 等量词，正则表达式会匹配尽可能多的内容。\n\n例如，上边那个例子：\n\ntext=“abbc”\nregex=“ab{1,3}c”\n\n\n就是在贪婪模式下，nfa 自动机读取了最大的匹配范围，即匹配 3 个 b 字符。匹配发生了一次失败，就引起了一次回溯。如果匹配结果是“abbbc”，就会匹配成功。\n\ntext=“abbbc”\nregex=“ab{1,3}c”\n\n\n# 懒惰模式（reluctant）\n\n在该模式下，正则表达式会尽可能少地重复匹配字符。如果匹配成功，它会继续匹配剩余的字符串。\n\n例如，在上面例子的字符后面加一个“？”，就可以开启懒惰模式。\n\ntext=“abc”\nregex=“ab{1,3}?c”\n\n\n匹配结果是“abc”，该模式下 nfa 自动机首先选择最小的匹配范围，即匹配 1 个 b 字符，因此就避免了回溯问题。\n\n# 独占模式（possessive）\n\n同贪婪模式一样，独占模式一样会最大限度地匹配更多内容；不同的是，在独占模式下，匹配失败就会结束匹配，不会发生回溯问题。\n\n还是上边的例子，在字符后面加一个“+”，就可以开启独占模式。\n\ntext=“abbc”\nregex=“ab{1,3}+bc”\n\n\n结果是不匹配，结束匹配，不会发生回溯问题。\n\n> 讲到这里，你应该非常清楚了，避免回溯的方法就是：使用懒惰模式和独占模式。\n\n\n# 正则表达式的优化\n\n# 少用贪婪模式，多用独占模式\n\n贪婪模式会引起回溯问题，可以使用独占模式来避免回溯。\n\n# 减少分支选择\n\n分支选择类型 (x|y|z) 的正则表达式会降低性能，我们在开发的时候要尽量减少使用。如果一定要用，我们可以通过以下几种方式来优化：\n\n * 首先，我们需要考虑选择的顺序，将比较常用的选择项放在前面，使它们可以较快地被匹配；\n * 其次，我们可以尝试提取共用模式，例如，将 (abcd|abef) 替换为 ab(cd|ef)，后者匹配速度较快，因为 nfa 自动机会尝试匹配 ab，如果没有找到，就不会再尝试任何选项；\n * 最后，如果是简单的分支选择类型，我们可以用三次 index 代替 (x|y|z)，如果测试的话，你就会发现三次 index 的效率要比 (x|y|z) 高出一些。\n\n# 减少捕获嵌套\n\n * 捕获组是指把正则表达式中，子表达式匹配的内容保存到以数字编号或显式命名的数组中，方便后面引用。一般一个 () 就是一个捕获组，捕获组可以进行嵌套。\n * 非捕获组则是指参与匹配却不进行分组编号的捕获组，其表达式一般由 (?:exp) 组成。\n\n在正则表达式中，每个捕获组都有一个编号，编号 0 代表整个匹配到的内容。我们可以看下面的例子：\n\npublic static void main(string[] args) {\n\tstring text = "<input high=\\"20\\" weight=\\"70\\">test</input>";\n\tstring reg="(<input.*?>)(.*?)(</input>)";\n\tpattern p = pattern.compile(reg);\n\tmatcher m = p.matcher(text);\n\twhile(m.find()) {\n\t\tsystem.out.println(m.group(0));// 整个匹配到的内容\n\t\tsystem.out.println(m.group(1));//(<input.*?>)\n\t\tsystem.out.println(m.group(2));//(.*?)\n\t\tsystem.out.println(m.group(3));//(</input>)\n\t}\n}\n\n\n运行结果：\n\n<input high=\\"20\\" weight=\\"70\\">test</input>\n<input high=\\"20\\" weight=\\"70\\">\ntest\n</input>\n\n\n如果你并不需要获取某一个分组内的文本，那么就使用非捕获分组。例如，使用“(?:x)”代替“(x)”，我们再看下面的例子：\n\npublic static void main(string[] args) {\n\tstring text = "<input high=\\"20\\" weight=\\"70\\">test</input>";\n\tstring reg="(?:<input.*?>)(.*?)(?:</input>)";\n\tpattern p = pattern.compile(reg);\n\tmatcher m = p.matcher(text);\n\twhile(m.find()) {\n\t\tsystem.out.println(m.group(0));// 整个匹配到的内容\n\t\tsystem.out.println(m.group(1));//(.*?)\n\t}\n}\n\n\n运行结果：\n\n<input high=\\"20\\" weight=\\"70\\">test</input>\ntest\n\n\n综上可知：减少不需要获取的分组，可以提高正则表达式的性能。\n\n\n# 参考资料\n\n * 正则表达式 30 分钟入门教程\n * msdn 正则表达式教程\n * 正则应用之——日期正则表达式\n * http://www.regexlib.com/\n * 《java 性能调优实战》',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 编码和加密",frontmatter:{title:"Java 编码和加密",categories:["编程","Java","JavaSE","高级特性"],tags:["Java","JavaSE","编码","加密"],abbrlink:"3082f8d4",date:"2021-05-24T15:41:47.000Z",permalink:"/pages/887467/"},regularPath:"/02.%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/02.Java%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86.html",relativePath:"02.高级特性/02.Java编码和加密.md",key:"v-77b9ba0f",path:"/pages/887467/",headers:[{level:2,title:"Base64 编码",slug:"base64-编码",normalizedTitle:"base64 编码",charIndex:84},{level:3,title:"Base64 原理",slug:"base64-原理",normalizedTitle:"base64 原理",charIndex:98},{level:3,title:"Base64 应用",slug:"base64-应用",normalizedTitle:"base64 应用",charIndex:1499},{level:2,title:"消息摘要",slug:"消息摘要",normalizedTitle:"消息摘要",charIndex:27},{level:3,title:"消息摘要概述",slug:"消息摘要概述",normalizedTitle:"消息摘要概述",charIndex:3341},{level:3,title:"消息摘要特点",slug:"消息摘要特点",normalizedTitle:"消息摘要特点",charIndex:3650},{level:3,title:"消息摘要常用算法",slug:"消息摘要常用算法",normalizedTitle:"消息摘要常用算法",charIndex:3801},{level:3,title:"消息摘要应用",slug:"消息摘要应用",normalizedTitle:"消息摘要应用",charIndex:4046},{level:4,title:"MD5、SHA 的范例",slug:"md5、sha-的范例",normalizedTitle:"md5、sha 的范例",charIndex:4056},{level:4,title:"HMAC 的范例",slug:"hmac-的范例",normalizedTitle:"hmac 的范例",charIndex:6219},{level:2,title:"数字签名",slug:"数字签名",normalizedTitle:"数字签名",charIndex:32},{level:3,title:"数字签名概述",slug:"数字签名概述",normalizedTitle:"数字签名概述",charIndex:8402},{level:3,title:"数字签名算法应用",slug:"数字签名算法应用",normalizedTitle:"数字签名算法应用",charIndex:8635},{level:4,title:"DSA 的范例",slug:"dsa-的范例",normalizedTitle:"dsa 的范例",charIndex:8647},{level:2,title:"对称加密",slug:"对称加密",normalizedTitle:"对称加密",charIndex:37},{level:3,title:"对称加密概述",slug:"对称加密概述",normalizedTitle:"对称加密概述",charIndex:11087},{level:4,title:"对称加密原理",slug:"对称加密原理",normalizedTitle:"对称加密原理",charIndex:11591},{level:4,title:"对称加密工作模式",slug:"对称加密工作模式",normalizedTitle:"对称加密工作模式",charIndex:11829},{level:4,title:"对称加密填充方法",slug:"对称加密填充方法",normalizedTitle:"对称加密填充方法",charIndex:12420},{level:3,title:"对称加密应用",slug:"对称加密应用",normalizedTitle:"对称加密应用",charIndex:12722},{level:4,title:"基于密钥加密的流程（DES、DESede、AES 和 IDEA）",slug:"基于密钥加密的流程-des、desede、aes-和-idea",normalizedTitle:"基于密钥加密的流程（des、desede、aes 和 idea）",charIndex:12732},{level:4,title:"基于口令加密的流程（PBE）",slug:"基于口令加密的流程-pbe",normalizedTitle:"基于口令加密的流程（pbe）",charIndex:17576},{level:2,title:"非对称加密",slug:"非对称加密",normalizedTitle:"非对称加密",charIndex:42},{level:3,title:"非对称加密概述",slug:"非对称加密概述",normalizedTitle:"非对称加密概述",charIndex:21619},{level:3,title:"非对称加密算法应用",slug:"非对称加密算法应用",normalizedTitle:"非对称加密算法应用",charIndex:22105},{level:2,title:"术语",slug:"术语",normalizedTitle:"术语",charIndex:29740},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:30022}],headersStr:"Base64 编码 Base64 原理 Base64 应用 消息摘要 消息摘要概述 消息摘要特点 消息摘要常用算法 消息摘要应用 MD5、SHA 的范例 HMAC 的范例 数字签名 数字签名概述 数字签名算法应用 DSA 的范例 对称加密 对称加密概述 对称加密原理 对称加密工作模式 对称加密填充方法 对称加密应用 基于密钥加密的流程（DES、DESede、AES 和 IDEA） 基于口令加密的流程（PBE） 非对称加密 非对称加密概述 非对称加密算法应用 术语 参考资料",content:'# Java 编码和加密\n\n> 关键词：Base64、消息摘要、数字签名、对称加密、非对称加密、MD5、SHA、HMAC、AES、DES、DESede、RSA\n\n\n# Base64 编码\n\n\n# Base64 原理\n\nBase64 内容传送编码是一种以任意 8 位字节序列组合的描述形式，这种形式不易被人直接识别。\n\nBase64 是一种很常见的编码规范，其作用是将二进制序列转换为人类可读的 ASCII 字符序列，常用在需用通过文本协议（比如 HTTP 和 SMTP）来传输二进制数据的情况下。Base64 并不是加密解密算法，尽管我们有时也听到使用 Base64 来加密解密的说法，但这里所说的加密与解密实际是指**编码（encode）和解码（decode）**的过程，其变换是非常简单的，仅仅能够避免信息被直接识别。\n\nBase64 算法主要是将给定的字符以字符编码(如 ASCII 码，UTF-8 码)对应的十进制数为基准，做编码操作：\n\n 1. 将给定的字符串以字符为单位，转换为对应的字符编码。\n 2. 将获得字符编码转换为二进制\n 3. 对二进制码做分组转换，每 3 个字节为一组，转换为每 4 个 6 位二进制位一组（不足 6 位时低位补 0）。这是一个分组变化的过程，3 个 8 位二进制码和 4 个 6 位二进制码的长度都是 24 位（38 = 46 = 24）。\n 4. 对获得的 4-6 二进制码补位，向 6 位二进制码添加 2 位高位 0，组成 4 个 8 位二进制码。\n 5. 对获得的 4-8 二进制码转换为十进制码。\n 6. 将获得的十进制码转换为 Base64 字符表中对应的字符。\n\nBase64 编码表\n\n索引   对应字符   索引   对应字符   索引   对应字符   索引   对应字符\n0    A      17   R      34   i      51   z\n1    B      18   S      35   j      52   0\n2    C      19   T      36   k      53   1\n3    D      20   U      37   l      54   2\n4    E      21   V      38   m      55   3\n5    F      22   W      39   n      56   4\n6    G      23   X      40   o      57   5\n7    H      24   Y      41   p      58   6\n8    I      25   Z      42   q      59   7\n9    J      26   a      43   r      60   8\n10   K      27   b      44   s      61   9\n11   L      28   c      45   t      62   +\n12   M      29   d      46   u      63   /\n13   N      30   e      47   v           \n14   O      31   f      48   w           \n15   P      32   g      49   x           \n16   Q      33   h      50   y           \n\n\n# Base64 应用\n\nBase64 编码可用于在 HTTP 环境下传递较长的标识信息。在其他应用程序中，也常常需要把二进制数据编码为适合放在 URL(包括隐藏表单域)中的形式。此时，采用 Base64 编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到，算是起到一个加密的作用。\n\n然而，标准的 Base64 并不适合直接放在 URL 里传输，因为 URL 编码器会把标准 Base64 中的 / 和 + 字符变为形如 %XX 的形式，而这些 % 号在存入数据库时还需要再进行转换，因为 ANSI SQL 中已将 % 号用作通配符。\n\n为解决此问题，可采用一种用于 URL 的改进 Base64 编码，它不仅在末尾填充 = 号，并将标准 Base64 中的“+”和“/”分别改成了 - 和 _，这样就免去了在 URL 编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。\n\n另有一种用于正则表达式的改进 Base64 变种，它将 + 和 / 改成了 ! 和 -，因为 +, * 以及前面在 IRCu 中用到的 [ 和 ] 在正则表达式中都可能具有特殊含义。\n\n【示例】java.util.Base64 编码、解码示例\n\nBase64.getEncoder() 和 Base64.getDecoder() 提供了的是标准的 Base64 编码、解码方式；\n\nBase64.getUrlEncoder() 和 Base64.getUrlDecoder() 提供了 URL 安全的 Base64 编码、解码方式（将 + 和 / 替换为 - 和 _）。\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\n\npublic class Base64Demo {\n\n    public static void main(String[] args) {\n        String url = "https://www.baidu.com";\n        System.out.println("url:" + url);\n        // 标准的 Base64 编码、解码\n        byte[] encoded = Base64.getEncoder().encode(url.getBytes(StandardCharsets.UTF_8));\n        byte[] decoded = Base64.getDecoder().decode(encoded);\n        System.out.println("Url Safe Base64 encoded:" + new String(encoded));\n        System.out.println("Url Safe Base64 decoded:" + new String(decoded));\n        // URL 安全的 Base64 编码、解码\n        byte[] encoded2 = Base64.getUrlEncoder().encode(url.getBytes(StandardCharsets.UTF_8));\n        byte[] decoded2 = Base64.getUrlDecoder().decode(encoded2);\n        System.out.println("Base64 encoded:" + new String(encoded2));\n        System.out.println("Base64 decoded:" + new String(decoded2));\n    }\n\n}\n\n\n输出：\n\nurl:https://www.baidu.com\nUrl Safe Base64 encoded:aHR0cHM6Ly93d3cuYmFpZHUuY29t\nUrl Safe Base64 decoded:https://www.baidu.com\nBase64 encoded:aHR0cHM6Ly93d3cuYmFpZHUuY29t\nBase64 decoded:https://www.baidu.com\n\n\n\n# 消息摘要\n\n\n# 消息摘要概述\n\n消息摘要，其实就是将需要摘要的数据作为参数，经过哈希函数(Hash)的计算，得到的散列值。\n\n消息摘要是一个唯一对应一个消息或文本的固定长度的值，它由一个单向 Hash 加密函数对消息进行作用而产生。如果消息在途中改变了，则接收者通过对收到消息的新产生的摘要与原摘要比较，就可知道消息是否被改变了。因此消息摘要保证了消息的完整性。消息摘要采用单向 Hash 函数将需加密的明文"摘要"成一串密文，这一串密文亦称为数字指纹(Finger Print)。它有固定的长度，且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。这样这串摘要便可成为验证明文是否是"真身"的"指纹"了。\n\n\n# 消息摘要特点\n\n * 唯一性：数据只要有一点改变，那么再通过消息摘要算法得到的摘要也会发生变化。虽然理论上有可能会发生碰撞，但是概率极其低。\n * 不可逆：消息摘要算法的密文无法被解密。\n * 不需要密钥，可使用于分布式网络。\n * 无论输入的明文有多长，计算出来的消息摘要的长度总是固定的。\n\n\n# 消息摘要常用算法\n\n消息摘要算法包括MD(Message Digest，消息摘要算法)、SHA(Secure Hash Algorithm，安全散列算法)、**MAC(Message AuthenticationCode，消息认证码算法)**共 3 大系列，常用于验证数据的完整性，是数字签名算法的核心算法。\n\nMD5和SHA1分别是MD、SHA算法系列中最有代表性的算法。\n\n如今，MD5 已被发现有许多漏洞，从而不再安全。SHA 算法比 MD 算法的摘要长度更长，也更加安全。\n\n\n# 消息摘要应用\n\n# MD5、SHA 的范例\n\nJDK 中使用 MD5 和 SHA 这两种消息摘要的方式基本一致，步骤如下：\n\n 1. 初始化 MessageDigest 对象\n 2. 更新要计算的内容\n 3. 生成摘要\n\nimport java.security.MessageDigest;\nimport java.util.Base64;\n\npublic class MessageDigestDemo {\n\n    public static byte[] encode(byte[] input, Type type) throws Exception {\n        // 根据类型，初始化消息摘要对象\n        MessageDigest md5Digest = MessageDigest.getInstance(type.getName());\n\n        // 更新要计算的内容\n        md5Digest.update(input);\n\n        // 完成哈希计算，返回摘要\n        return md5Digest.digest();\n    }\n\n    public static byte[] encodeWithBase64(byte[] input, Type type) throws Exception {\n        return Base64.getUrlEncoder().encode(encode(input, type));\n    }\n\n    public static String encodeWithBase64String(byte[] input, Type type) throws Exception {\n        return Base64.getUrlEncoder().encodeToString(encode(input, type));\n    }\n\n    public enum Type {\n        MD2("MD2"),\n        MD5("MD5"),\n        SHA1("SHA1"),\n        SHA256("SHA-256"),\n        SHA384("SHA-384"),\n        SHA512("SHA-512");\n\n        private String name;\n\n        Type(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return this.name;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        String msg = "Hello World!";\n        System.out.println("MD2: " + encodeWithBase64String(msg.getBytes(), Type.MD2));\n        System.out.println("MD5: " + encodeWithBase64String(msg.getBytes(), Type.MD5));\n        System.out.println("SHA1: " + encodeWithBase64String(msg.getBytes(), Type.SHA1));\n        System.out.println("SHA256: " + encodeWithBase64String(msg.getBytes(), Type.SHA256));\n        System.out.println("SHA384: " + encodeWithBase64String(msg.getBytes(), Type.SHA384));\n        System.out.println("SHA512: " + encodeWithBase64String(msg.getBytes(), Type.SHA512));\n    }\n\n}\n\n\n【输出】\n\nMD2: MV98ZyI_Aft8q0uVEA6HLg==\nMD5: 7Qdih1MuhjZehB6Sv8UNjA==\nSHA1: Lve95gjOVATpfV8EL5X4nxwjKHE=\nSHA256: f4OxZX_x_FO5LcGBSKHWXfwtSx-j1ncoSt3SABJtkGk=\nSHA384: v9dsDrvQBv7lg0EFR8GIewKSvnbVgtlsJC0qeScj4_1v0GH51c_RO4-WE1jmrbpK\nSHA512: hhhE1nBOhXP-w02WfiC8_vPUJM9IvgTm3AjyvVjHKXQzcQFerYkcw88cnTS0kmS1EHUbH_nlN5N7xGtdb_TsyA==\n\n\n# HMAC 的范例\n\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class HmacMessageDigest {\n\n    public static void main(String[] args) throws Exception {\n        String msg = "Hello World!";\n        byte[] salt = "My Salt".getBytes(StandardCharsets.UTF_8);\n        System.out.println("原文: " + msg);\n        System.out.println("HmacMD5: " + encodeWithBase64String(msg.getBytes(), salt, HmacTypeEn.HmacMD5));\n        System.out.println("HmacSHA1: " + encodeWithBase64String(msg.getBytes(), salt, HmacTypeEn.HmacSHA1));\n        System.out.println("HmacSHA256: " + encodeWithBase64String(msg.getBytes(), salt, HmacTypeEn.HmacSHA256));\n        System.out.println("HmacSHA384: " + encodeWithBase64String(msg.getBytes(), salt, HmacTypeEn.HmacSHA384));\n        System.out.println("HmacSHA512: " + encodeWithBase64String(msg.getBytes(), salt, HmacTypeEn.HmacSHA512));\n    }\n\n    public static byte[] encode(byte[] plaintext, byte[] salt, HmacTypeEn type) throws Exception {\n        SecretKeySpec keySpec = new SecretKeySpec(salt, type.name());\n        Mac mac = Mac.getInstance(keySpec.getAlgorithm());\n        mac.init(keySpec);\n        return mac.doFinal(plaintext);\n    }\n\n    public static byte[] encodeWithBase64(byte[] plaintext, byte[] salt, HmacTypeEn type) throws Exception {\n        return Base64.getUrlEncoder().encode(encode(plaintext, salt, type));\n    }\n\n    public static String encodeWithBase64String(byte[] plaintext, byte[] salt, HmacTypeEn type) throws Exception {\n        return Base64.getUrlEncoder().encodeToString(encode(plaintext, salt, type));\n    }\n\n    /**\n     * JDK支持 HmacMD5, HmacSHA1, HmacSHA256, HmacSHA384, HmacSHA512\n     */\n    public enum HmacTypeEn {\n\n        HmacMD5, HmacSHA1, HmacSHA256, HmacSHA384, HmacSHA512;\n    }\n\n}\n\n\n输出\n\n原文: Hello World!\nHmacMD5: re6BLRsB1Q26SfJTwXZUSQ==\nHmacSHA1: CFu8a9H6CbY9C5fo0OmJ2bnuILM=\nHmacSHA256: Z1czUqDWWfYYl7qEDJ2sUH6iieHVI7o83dXMl0JYER0=\nHmacSHA384: 34mKtRQBOYnwwznmQubjrDk_MsLDGqM2PmgcplZUpLsKNrG_cwfz4bLPJCbBW88b\nHmacSHA512: 6n77htTZ_atc04-SsmxhSK3wzh1sAmdudCl0Cb_RZp4DpienG4LZkhXMbq8lcK7XSnz6my_wIpnStDp6PC_-5w==\n\n\n\n# 数字签名\n\n\n# 数字签名概述\n\n数字签名算法可以看做是一种带有密钥的消息摘要算法，并且这种密钥包含了公钥和私钥。也就是说，数字签名算法是非对称加密算法和消息摘要算法的结合体。\n\n数字签名算法要求能够验证数据完整性、认证数据来源，并起到抗否认的作用。\n\n数字签名算法包含签名和验证两项操作，遵循私钥签名，公钥验证的方式。\n\n签名时要使用私钥和待签名数据，验证时则需要公钥、签名值和待签名数据，其核心算法主要是消息摘要算法。\n\n\n\n数字签名常用算法：RSA、DSA、ECDSA\n\n\n# 数字签名算法应用\n\n# DSA 的范例\n\n数字签名有两个流程：签名和验证。\n\n它们的前提都是要有一个公钥、密钥对。\n\n数字签名用私钥为消息计算签名。\n\n【示例】用公钥验证摘要\n\npublic class DsaCoder {\n\n    public static final String KEY_ALGORITHM = "DSA";\n\n    public static final String SIGN_ALGORITHM = "SHA1withDSA";\n\n    /**\n     * DSA密钥长度默认1024位。 密钥长度必须是64的整数倍，范围在512~1024之间\n     */\n    private static final int KEY_SIZE = 1024;\n\n    private KeyPair keyPair;\n\n    public DsaCoder() throws Exception {\n        this.keyPair = initKey();\n    }\n\n    private KeyPair initKey() throws Exception {\n        // 初始化密钥对生成器\n        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(DsaCoder.KEY_ALGORITHM);\n        // 实例化密钥对生成器\n        keyPairGen.initialize(KEY_SIZE);\n        // 实例化密钥对\n        return keyPairGen.genKeyPair();\n    }\n\n    public byte[] signature(byte[] data, byte[] privateKey) throws Exception {\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKey);\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\n        PrivateKey key = keyFactory.generatePrivate(keySpec);\n\n        Signature signature = Signature.getInstance(SIGN_ALGORITHM);\n        signature.initSign(key);\n        signature.update(data);\n        return signature.sign();\n    }\n\n    public byte[] getPrivateKey() {\n        return keyPair.getPrivate().getEncoded();\n    }\n\n    public boolean verify(byte[] data, byte[] publicKey, byte[] sign) throws Exception {\n        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKey);\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\n        PublicKey key = keyFactory.generatePublic(keySpec);\n\n        Signature signature = Signature.getInstance(SIGN_ALGORITHM);\n        signature.initVerify(key);\n        signature.update(data);\n        return signature.verify(sign);\n    }\n\n    public byte[] getPublicKey() {\n        return keyPair.getPublic().getEncoded();\n    }\n\n    public static void main(String[] args) throws Exception {\n        String msg = "Hello World";\n        DsaCoder dsa = new DsaCoder();\n        byte[] sign = dsa.signature(msg.getBytes(), dsa.getPrivateKey());\n        boolean flag = dsa.verify(msg.getBytes(), dsa.getPublicKey(), sign);\n        String result = flag ? "数字签名匹配" : "数字签名不匹配";\n        System.out.println("数字签名：" + Base64.getUrlEncoder().encodeToString(sign));\n        System.out.println("验证结果：" + result);\n    }\n\n}\n\n\n【输出】\n\n数字签名：MCwCFDPUO_VrONl5ST0AWary-MLXJuSCAhRMeMnUVhpizfa2H2M37tne0pUtoA==\n验证结果：数字签名匹配\n\n\n\n# 对称加密\n\n\n# 对称加密概述\n\n对称加密算法主要有 DES、3DES（TripleDES）、AES、IDEA、RC2、RC4、RC5 和 Blowfish 等。\n\n对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发信方将明文（原始数据）和加密密钥（mi yao）一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。\n\n对称加密特点：\n\n * 优点：计算量小、加密速度快、加密效率高。\n * 缺点：算法是公开的，安全性得不到保证。\n\n通信双方每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得通信双方所拥有的密钥数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。\n\n而与公钥、密钥加密算法比起来，对称加密算法能够提供加密和认证却缺乏了签名功能，使得使用范围有所缩小。\n\n# 对称加密原理\n\n对称加密要求加密与解密使用同一个密钥，解密是加密的逆运算。由于加密、解密使用同一个密钥，这要求通信双方必须在通信前商定该密钥，并妥善保存该密钥。\n\n对称加密体制分为两种：\n\n一种是对明文的单个位（或字节）进行运算，称为流密码，也称为序列密码；\n\n一种是把明文信息划分为不同的组（或块）结构，分别对每个组（或块）进行加密、解密，称为分组密码。\n\n\n\n假设甲乙方作为通信双方。假定甲乙双方在消息传递前已商定加密算法，欲完成一次消息传递需要经过如下步骤。\n\n\n\n# 对称加密工作模式\n\n以 DES 算法的工作模式为例，DES 算法根据其加密算法所定义的明文分组的大小（56 位），将数据分割成若干 56 位的加密区块，再以加密区块为单位，分别进行加密处理。如果最后剩下不足一个区块的大小，称之为短块。短块的处理方法有填充法、流密码加密法、密文挪用技术。\n\n根据数据加密时每个加密区块见得关联方式来区分，可以分为以下种工作模式：\n\n(1) 电子密码本模式(Electronic Code Book, ECB)\n\n用途：适合加密密钥，随机数等短数据。例如，安全地传递 DES 密钥，ECB 是最合适的模式。\n\n(2) 密文链接模式(Cipher Booki Chaining, CBC)\n\n用途：可加密任意长度的数据，适用于计算产生检测数据完整性的消息认证 MAC。\n\n(3) 密文反馈模式(Cipher Feed Back, CFB)\n\n用途：因错误传播无界，可以用于检查发现明文密文的篡改。\n\n(4) 输出反馈模式(Output Feed Back, OFB)\n\n用途：使用于加密冗余性较大的数据，比如语音和图像数据。\n\nAES 算法除了以上 4 中模式外，还有一种新的工作模式：\n\n(5) 计数器模式(Counter, CTR)\n\n用途：适用于各种加密应用。\n\n本文对于各种工作模式的原理展开描述。个人认为，作为工程应用，了解其用途即可。\n\n# 对称加密填充方法\n\nJava 中对称加密对于短块的处理，一般是采用填充方式。\n\n常采用的是：NoPadding（不填充）、Zeros 填充（0 填充）、PKCS5Padding 填充。\n\nZerosPadding\n\n方式：全部填充为 0 的字节\n\n结果如下：\n\nF1 F2 F3 F4 F5 F6 F7 F8 //第一块\n\nF9 00 00 00 00 00 00 00 //第二块\n\nPKCS5Padding\n\n方式：每个填充的字节都记录了填充的总字节数\n\n结果如下：\n\nF1 F2 F3 F4 F5 F6 F7 F8 //第一块\n\nF9 07 07 07 07 07 07 07 //第二块\n\n\n# 对称加密应用\n\n# 基于密钥加密的流程（DES、DESede、AES 和 IDEA）\n\nDES、DESede、AES 和 IDEA 等算法都是基于密钥加密的对称加密算法，它们的实现流程也基本一致。步骤如下：\n\n（1）生成密钥\n\nKeyGenerator kg = KeyGenerator.getInstance("DES");\nSecureRandom random = new SecureRandom();\nkg.init(random);\nSecretKey secretKey = kg.generateKey();\n\n\n建议使用随机数来初始化密钥的生成。\n\n（2）初始化密码对象\n\nCipher cipher = Cipher.getInstance("DES/ECB/PKCS5Padding");\ncipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n\nENCRYPT_MODE：加密模式\n\nDECRYPT_MODE：解密模式\n\n（3）执行\n\nString plaintext = "Hello World";\nbyte[] ciphertext = cipher.doFinal(plaintext.getBytes());\n\n\n一个完整的 DES 加密解密范例\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.*;\nimport java.util.Base64;\nimport javax.crypto.*;\nimport javax.crypto.spec.IvParameterSpec;\n\n/**\n * DES安全编码：是经典的对称加密算法。密钥仅56位，且迭代次数偏少。已被视为并不安全的加密算法。\n *\n * @author Zhang Peng\n * @since 2016年7月14日\n */\npublic class DESCoder {\n\n    public static final String KEY_ALGORITHM_DES = "DES";\n\n    public static final String CIPHER_DES_DEFAULT = "DES";\n\n    public static final String CIPHER_DES_ECB_PKCS5PADDING = "DES/ECB/PKCS5Padding"; // 算法/模式/补码方式\n\n    public static final String CIPHER_DES_CBC_PKCS5PADDING = "DES/CBC/PKCS5Padding";\n\n    public static final String CIPHER_DES_CBC_NOPADDING = "DES/CBC/NoPadding";\n\n    private static final String SEED = "%%%today is nice***"; // 用于生成随机数的种子\n\n    private Key key;\n\n    private Cipher cipher;\n\n    private String transformation;\n\n    public DESCoder() throws NoSuchAlgorithmException, NoSuchPaddingException, NoSuchProviderException {\n        this.key = initKey();\n        this.cipher = Cipher.getInstance(CIPHER_DES_DEFAULT);\n        this.transformation = CIPHER_DES_DEFAULT;\n    }\n\n    /**\n     * 根据随机数种子生成一个密钥\n     *\n     * @return Key\n     * @throws NoSuchAlgorithmException\n     * @throws NoSuchProviderException\n     * @author Zhang Peng\n     * @since 2016年7月14日\n     */\n    private Key initKey() throws NoSuchAlgorithmException, NoSuchProviderException {\n        // 根据种子生成一个安全的随机数\n        SecureRandom secureRandom = null;\n        secureRandom = new SecureRandom(SEED.getBytes());\n\n        KeyGenerator keyGen = KeyGenerator.getInstance(KEY_ALGORITHM_DES);\n        keyGen.init(secureRandom);\n        return keyGen.generateKey();\n    }\n\n    public DESCoder(String transformation)\n        throws NoSuchAlgorithmException, NoSuchPaddingException, NoSuchProviderException {\n        this.key = initKey();\n        this.cipher = Cipher.getInstance(transformation);\n        this.transformation = transformation;\n    }\n\n    /**\n     * 加密\n     *\n     * @param input 明文\n     * @return byte[] 密文\n     * @throws InvalidKeyException\n     * @throws IllegalBlockSizeException\n     * @throws BadPaddingException\n     * @throws InvalidAlgorithmParameterException\n     * @author Zhang Peng\n     * @since 2016年7月20日\n     */\n    public byte[] encrypt(byte[] input) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException,\n        InvalidAlgorithmParameterException {\n        if (transformation.equals(CIPHER_DES_CBC_PKCS5PADDING) || transformation.equals(CIPHER_DES_CBC_NOPADDING)) {\n            cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(getIV()));\n        } else {\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n        }\n        return cipher.doFinal(input);\n    }\n\n    /**\n     * 解密\n     *\n     * @param input 密文\n     * @return byte[] 明文\n     * @throws InvalidKeyException\n     * @throws IllegalBlockSizeException\n     * @throws BadPaddingException\n     * @throws InvalidAlgorithmParameterException\n     * @author Zhang Peng\n     * @since 2016年7月20日\n     */\n    public byte[] decrypt(byte[] input) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException,\n        InvalidAlgorithmParameterException {\n        if (transformation.equals(CIPHER_DES_CBC_PKCS5PADDING) || transformation.equals(CIPHER_DES_CBC_NOPADDING)) {\n            cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(getIV()));\n        } else {\n            cipher.init(Cipher.DECRYPT_MODE, key);\n        }\n        return cipher.doFinal(input);\n    }\n\n    private byte[] getIV() {\n        String iv = "01234567"; // IV length: must be 8 bytes long\n        return iv.getBytes();\n    }\n\n    public static void main(String[] args) throws Exception {\n        DESCoder aes = new DESCoder(CIPHER_DES_CBC_PKCS5PADDING);\n\n        String msg = "Hello World!";\n        System.out.println("原文: " + msg);\n        byte[] encoded = aes.encrypt(msg.getBytes(StandardCharsets.UTF_8));\n        String encodedBase64 = Base64.getUrlEncoder().encodeToString(encoded);\n        System.out.println("密文: " + encodedBase64);\n\n        byte[] decodedBase64 = Base64.getUrlDecoder().decode(encodedBase64);\n        byte[] decoded = aes.decrypt(decodedBase64);\n        System.out.println("明文: " + new String(decoded));\n    }\n\n}\n\n\n输出\n\n原文: Hello World!\n密文: TtnEu9ezNQtxFKpmq_37Qw==\n明文: Hello World!\n\n\n# 基于口令加密的流程（PBE）\n\nDES、DESede、AES、IDEA 这几种算法的应用模型几乎如出一辙。\n\n但是，并非所有对称加密算法都是如此。\n\n基于口令加密(Password Based Encryption, PBE)是一种基于口令加密的算法。其特点是：口令由用户自己掌管，采用随机数（这里叫做盐）杂凑多重加密等方法保证数据的安全性。\n\nPBE 没有密钥概念，密钥在其他对称加密算法中是经过计算得出的，PBE 则使用口令替代了密钥。\n\n流程：\n\n\n\n步骤如下：\n\n（1）产生盐\n\nSecureRandom secureRandom = new SecureRandom();\nbyte[] salt = secureRandom.generateSeed(8); // 盐长度必须为8字节\n\n\n（2）根据密码产生 Key\n\nString password = "123456";\nPBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());\nSecretKeyFactory keyFactory = SecretKeyFactory.getInstance(KEY_ALGORITHM);\nSecretKey secretKey = keyFactory.generateSecret(keySpec);\n\n\n（3）初始化加密或解密对象\n\nPBEParameterSpec paramSpec = new PBEParameterSpec(salt, ITERATION_COUNT);\nCipher cipher = Cipher.getInstance(KEY_ALGORITHM);\ncipher.init(Cipher.ENCRYPT_MODE, secretKey, paramSpec);\n\n\n（4）执行\n\nbyte[] plaintext = "Hello World".getBytes();\nbyte[] ciphertext = cipher.doFinal(plaintext);\n\n\n（5）完整 PBE 示例\n\nimport java.security.Key;\nimport java.security.SecureRandom;\nimport java.util.Base64;\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.PBEParameterSpec;\n\n/**\n * 基于口令加密(Password Based Encryption, PBE)，是一种对称加密算法。 其特点是：口令由用户自己掌管，采用随机数（这里叫做盐）杂凑多重加密等方法保证数据的安全性。\n * PBE没有密钥概念，密钥在其他对称加密算法中是经过计算得出的，PBE则使用口令替代了密钥。\n *\n * @author Zhang Peng\n * @since 2016年7月20日\n */\npublic class PBECoder {\n\n    public static final String KEY_ALGORITHM = "PBEWITHMD5andDES";\n\n    public static final int ITERATION_COUNT = 100;\n\n    private Key key;\n\n    private byte[] salt;\n\n    public PBECoder(String password) throws Exception {\n        this.salt = initSalt();\n        this.key = initKey(password);\n    }\n\n    private byte[] initSalt() {\n        SecureRandom secureRandom = new SecureRandom();\n        return secureRandom.generateSeed(8); // 盐长度必须为8字节\n    }\n\n    private Key initKey(String password) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(KEY_ALGORITHM);\n        return keyFactory.generateSecret(keySpec);\n    }\n\n    public byte[] encrypt(byte[] plaintext) throws Exception {\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, ITERATION_COUNT);\n        Cipher cipher = Cipher.getInstance(KEY_ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n        return cipher.doFinal(plaintext);\n    }\n\n    public byte[] decrypt(byte[] ciphertext) throws Exception {\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, ITERATION_COUNT);\n        Cipher cipher = Cipher.getInstance(KEY_ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\n        return cipher.doFinal(ciphertext);\n    }\n\n    public static void test1() throws Exception {\n\n        // 产生盐\n        SecureRandom secureRandom = new SecureRandom();\n        byte[] salt = secureRandom.generateSeed(8); // 盐长度必须为8字节\n\n        // 产生Key\n        String password = "123456";\n        PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(KEY_ALGORITHM);\n        SecretKey secretKey = keyFactory.generateSecret(keySpec);\n\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, ITERATION_COUNT);\n        Cipher cipher = Cipher.getInstance(KEY_ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, paramSpec);\n\n        byte[] plaintext = "Hello World".getBytes();\n        byte[] ciphertext = cipher.doFinal(plaintext);\n        new String(ciphertext);\n    }\n\n    public static void main(String[] args) throws Exception {\n        PBECoder encode = new PBECoder("123456");\n        String message = "Hello World!";\n        byte[] ciphertext = encode.encrypt(message.getBytes());\n        byte[] plaintext = encode.decrypt(ciphertext);\n\n        System.out.println("原文：" + message);\n        System.out.println("密文：" + Base64.getUrlEncoder().encodeToString(ciphertext));\n        System.out.println("明文：" + new String(plaintext));\n    }\n\n}\n\n\n\n# 非对称加密\n\n\n# 非对称加密概述\n\n非对称加密常用算法：DH(Diffie-Hellman，密钥交换算法)、RSA\n\n非对称加密算法和对称加密算法的主要差别在于非对称加密算法用于加密和解密的密钥是不同的。一个公开，称为公钥（public key）；一个保密，称为私钥（private key）。因此，非对称加密算法也称为双钥加密算法或公钥加密算法。\n\n非对称加密特点：\n\n * 优点：非对称加密算法解决了对称加密算法的密钥分配问题，并极大地提高了算法安全性。\n * 缺点：算法比对称算法更复杂，因此加密、解密速度都比对称算法慢很多。\n\n\n\n非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。\n\n另一方面，甲方可以使用乙方的公钥对机密信息进行签名后再发送给乙方；乙方再用自己的私匙对数据进行验证。\n\n甲方只能用其私钥解密，由其公钥加密后的任何信息。 非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要。\n\n\n# 非对称加密算法应用\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.*;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\nimport javax.crypto.Cipher;\n\n/**\n * RSA安全编码：非对称加密算法。它既可以用来加密、解密，也可以用来做数字签名\n *\n * @author Zhang Peng\n * @since 2016年7月20日\n */\npublic class RSACoder {\n\n    public final static String KEY_ALGORITHM = "RSA";\n\n    public final static String SIGN_ALGORITHM = "MD5WithRSA";\n\n    private KeyPair keyPair;\n\n    public RSACoder() throws Exception {\n        this.keyPair = initKeyPair();\n    }\n\n    private KeyPair initKeyPair() throws Exception {\n        // KeyPairGenerator类用于生成公钥和私钥对，基于RSA算法生成对象\n        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM);\n        // 初始化密钥对生成器，密钥大小为1024位\n        keyPairGen.initialize(1024);\n        // 生成一个密钥对\n        return keyPairGen.genKeyPair();\n    }\n\n    public byte[] encryptByPrivateKey(byte[] plaintext, byte[] key) throws Exception {\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(key);\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\n        PrivateKey privateKey = keyFactory.generatePrivate(keySpec);\n        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());\n        cipher.init(Cipher.ENCRYPT_MODE, privateKey);\n        return cipher.doFinal(plaintext);\n    }\n\n    public byte[] decryptByPublicKey(byte[] ciphertext, byte[] key) throws Exception {\n        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(key);\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\n        PublicKey publicKey = keyFactory.generatePublic(keySpec);\n        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());\n        cipher.init(Cipher.DECRYPT_MODE, publicKey);\n        return cipher.doFinal(ciphertext);\n    }\n\n    public byte[] encryptByPublicKey(byte[] plaintext, byte[] key) throws Exception {\n        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(key);\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\n        PublicKey publicKey = keyFactory.generatePublic(keySpec);\n        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());\n        cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n        return cipher.doFinal(plaintext);\n    }\n\n    public byte[] decryptByPrivateKey(byte[] ciphertext, byte[] key) throws Exception {\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(key);\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\n        PrivateKey privateKey = keyFactory.generatePrivate(keySpec);\n        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());\n        cipher.init(Cipher.DECRYPT_MODE, privateKey);\n        return cipher.doFinal(ciphertext);\n    }\n\n    public byte[] signature(byte[] data, byte[] privateKey, RsaSignTypeEn type) throws Exception {\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKey);\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\n        PrivateKey key = keyFactory.generatePrivate(keySpec);\n\n        Signature signature = Signature.getInstance(type.name());\n        signature.initSign(key);\n        signature.update(data);\n        return signature.sign();\n    }\n\n    public byte[] getPrivateKey() {\n        return keyPair.getPrivate().getEncoded();\n    }\n\n    public boolean verify(byte[] data, byte[] publicKey, byte[] sign, RsaSignTypeEn type) throws Exception {\n        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKey);\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\n        PublicKey key = keyFactory.generatePublic(keySpec);\n\n        Signature signature = Signature.getInstance(type.name());\n        signature.initVerify(key);\n        signature.update(data);\n        return signature.verify(sign);\n    }\n\n    public byte[] getPublicKey() {\n        return keyPair.getPublic().getEncoded();\n    }\n\n    public enum RsaSignTypeEn {\n\n        MD2WithRSA,\n        MD5WithRSA,\n        SHA1WithRSA\n    }\n\n    public static void main(String[] args) throws Exception {\n        String msg = "Hello World!";\n        RSACoder coder = new RSACoder();\n        // 私钥加密，公钥解密\n        byte[] ciphertext = coder.encryptByPrivateKey(msg.getBytes(StandardCharsets.UTF_8), coder.keyPair.getPrivate().getEncoded());\n        byte[] plaintext = coder.decryptByPublicKey(ciphertext, coder.keyPair.getPublic().getEncoded());\n\n        // 公钥加密，私钥解密\n        byte[] ciphertext2 = coder.encryptByPublicKey(msg.getBytes(), coder.keyPair.getPublic().getEncoded());\n        byte[] plaintext2 = coder.decryptByPrivateKey(ciphertext2, coder.keyPair.getPrivate().getEncoded());\n\n        byte[] sign = coder.signature(msg.getBytes(), coder.getPrivateKey(), RsaSignTypeEn.SHA1WithRSA);\n        boolean flag = coder.verify(msg.getBytes(), coder.getPublicKey(), sign, RsaSignTypeEn.SHA1WithRSA);\n        String result = flag ? "数字签名匹配" : "数字签名不匹配";\n\n        System.out.println("原文：" + msg);\n        System.out.println("公钥：" + Base64.getUrlEncoder().encodeToString(coder.keyPair.getPublic().getEncoded()));\n        System.out.println("私钥：" + Base64.getUrlEncoder().encodeToString(coder.keyPair.getPrivate().getEncoded()));\n\n        System.out.println("============== 私钥加密，公钥解密 ==============");\n        System.out.println("密文：" + Base64.getUrlEncoder().encodeToString(ciphertext));\n        System.out.println("明文：" + new String(plaintext));\n\n        System.out.println("============== 公钥加密，私钥解密 ==============");\n        System.out.println("密文：" + Base64.getUrlEncoder().encodeToString(ciphertext2));\n        System.out.println("明文：" + new String(plaintext2));\n\n        System.out.println("============== 数字签名 ==============");\n        System.out.println("数字签名：" + Base64.getUrlEncoder().encodeToString(sign));\n        System.out.println("验证结果：" + result);\n    }\n\n}\n\n\n输出\n\n原文：Hello World!\n公钥：MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCzPtRLErTUcYtr8GmIpvbso7FN18thuEq02U21mh7TA4FH4TjvNgOZrZEORYu94dxrPdnrPjh0p62P5pDIjx_dtGlZr0aGWgtTvBbPwAKE4keXyPqv4VV6iXRzyQ2HdOvFOovim5eu0Tu_TxGeNpFfp0pYj2LXCzpsgSrdUPuPmwIDAQAB\n私钥：MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALM-1EsStNRxi2vwaYim9uyjsU3Xy2G4SrTZTbWaHtMDgUfhOO82A5mtkQ5Fi73h3Gs92es-OHSnrY_mkMiPH920aVmvRoZaC1O8Fs_AAoTiR5fI-q_hVXqJdHPJDYd068U6i-Kbl67RO79PEZ42kV-nSliPYtcLOmyBKt1Q-4-bAgMBAAECgYBJxOXiL8S0WjajKcKFNxIQuh3Sh6lwgkRcwcI1p0RgW-TtDEg-SuCYctJsKTsl3rq0eDQjmOvrNsc7ngygPidCiTdbD1H6m3tLrebBB-wZdXMSWPsHtQJsq4dE0e93mmfysciOP6QExOs0JqVjTyyBSK37LpUcLdalj2IJDtC0gQJBAPfMngZAuIPmXued7PUuWNBuwxnkmdMcs308eC_9vnLLXWhDB9xKMuXCMwqk16MJ6j1FQWtJu62T21yniWWQHIsCQQC5LWqKfRxVukgnBg0Pa95NVWWY01Yttnb125JsLxeKbR97KU4VgBaBcB9TyUdPr9lxAzGFg6Y3A1wfsfukaGsxAkEA1l719oLXHYSWZdmBvTozK14m-qeBS9lwjc9aSmpB8B1u2Vvj2Pd3wLyYW4Tv5-QT-J2JUr-e1TMseqOVgX-CsQJAETRoBq_zFv_0vjNwuTMTd2nsw5M3GY4vZU5eP1Dsxf63gxDmYVcCQEpzjqxPxNaYxEhArJ_7rHbSc1ts_ux4sQJBAIlbGQC4-92foXGzWT80rsqZlMQ8J8Nbjpoo7RUN9tgx60Vkr3xv26Vos77oqdufWlt5IiBZBS9acTA2suav6Qg=\n============== 私钥加密，公钥解密 ==============\n密文：qn6iGjSJV45EnH21RYRx2UZfMueqplbm1g3VIpBBQBuF63RdHdSgMJsVPAuB__V0rxpPlU3gR6qLyWu1mpaJ-ix_6KogAH64wqTWqPRh7E6aj767rybNpt9JyVlCmmpy9DiqHAUFWtBJDo34q-a7Fhq9c8bWrJ6jnn47IdmzHfU=\n明文：Hello World!\n============== 公钥加密，私钥解密 ==============\n密文：fsz2IFs69d7JDrH-yoe5pi5WKQU1Zml7SDSpPqTZUn6muSCjNp6x312deQCXKMGSeAdMpVeb01yZBfa0MT_6eYJYVseU7Rd6bDf6YIg3AZFC41yh5ITiTvQ-XzxugnppS12sLpXSWg0faa5qjcVZnoTX9p7nHr8n20y4CNMI6Rw=\n明文：Hello World!\n============== 数字签名 ==============\n数字签名：dTtUUlWX1wRQbW1PcA8O6WJcWcrHinEZRXwgLKEwBOm2DpvHnynvV_HYKS-qFE5_4vJQcPGJ2hZqWbfv1VKLHMUWuiXM7VJk70g3g7BF8i8RWbrCDOxgTR77jrEwidpr1PYJzWJVGq_HP36MxInGFLcVh2sN0fu8MppzsXUENZQ=\n验证结果：数字签名匹配\n\n\n\n# 术语\n\n * 明文(Plaintext)：指待加密信息。明文可以是文本文件、图片文件、二进制数据等。\n * 密文(Ciphertext)：指经过加密后的明文。密文通常以文本、二进制等形式存在。\n * 加密(Encryption)：指将明文转换为密文的过程。\n * 解密(Decryption)：指将密文转换为明文的过程。\n * 加密密钥(Encryption Key)：指通过加密算法进行加密操作用的密钥。\n * 解密密钥(Decryption Key)：指通过解密算法进行解密操作用的密钥。\n * 信道(Channel)：通信的通道，是信号传输的媒介。\n\n\n# 参考资料\n\n * 《Java 核心技术 卷 II 高级特性》\n * 《Java 加密与解密的艺术》',normalizedContent:'# java 编码和加密\n\n> 关键词：base64、消息摘要、数字签名、对称加密、非对称加密、md5、sha、hmac、aes、des、desede、rsa\n\n\n# base64 编码\n\n\n# base64 原理\n\nbase64 内容传送编码是一种以任意 8 位字节序列组合的描述形式，这种形式不易被人直接识别。\n\nbase64 是一种很常见的编码规范，其作用是将二进制序列转换为人类可读的 ascii 字符序列，常用在需用通过文本协议（比如 http 和 smtp）来传输二进制数据的情况下。base64 并不是加密解密算法，尽管我们有时也听到使用 base64 来加密解密的说法，但这里所说的加密与解密实际是指**编码（encode）和解码（decode）**的过程，其变换是非常简单的，仅仅能够避免信息被直接识别。\n\nbase64 算法主要是将给定的字符以字符编码(如 ascii 码，utf-8 码)对应的十进制数为基准，做编码操作：\n\n 1. 将给定的字符串以字符为单位，转换为对应的字符编码。\n 2. 将获得字符编码转换为二进制\n 3. 对二进制码做分组转换，每 3 个字节为一组，转换为每 4 个 6 位二进制位一组（不足 6 位时低位补 0）。这是一个分组变化的过程，3 个 8 位二进制码和 4 个 6 位二进制码的长度都是 24 位（38 = 46 = 24）。\n 4. 对获得的 4-6 二进制码补位，向 6 位二进制码添加 2 位高位 0，组成 4 个 8 位二进制码。\n 5. 对获得的 4-8 二进制码转换为十进制码。\n 6. 将获得的十进制码转换为 base64 字符表中对应的字符。\n\nbase64 编码表\n\n索引   对应字符   索引   对应字符   索引   对应字符   索引   对应字符\n0    a      17   r      34   i      51   z\n1    b      18   s      35   j      52   0\n2    c      19   t      36   k      53   1\n3    d      20   u      37   l      54   2\n4    e      21   v      38   m      55   3\n5    f      22   w      39   n      56   4\n6    g      23   x      40   o      57   5\n7    h      24   y      41   p      58   6\n8    i      25   z      42   q      59   7\n9    j      26   a      43   r      60   8\n10   k      27   b      44   s      61   9\n11   l      28   c      45   t      62   +\n12   m      29   d      46   u      63   /\n13   n      30   e      47   v           \n14   o      31   f      48   w           \n15   p      32   g      49   x           \n16   q      33   h      50   y           \n\n\n# base64 应用\n\nbase64 编码可用于在 http 环境下传递较长的标识信息。在其他应用程序中，也常常需要把二进制数据编码为适合放在 url(包括隐藏表单域)中的形式。此时，采用 base64 编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到，算是起到一个加密的作用。\n\n然而，标准的 base64 并不适合直接放在 url 里传输，因为 url 编码器会把标准 base64 中的 / 和 + 字符变为形如 %xx 的形式，而这些 % 号在存入数据库时还需要再进行转换，因为 ansi sql 中已将 % 号用作通配符。\n\n为解决此问题，可采用一种用于 url 的改进 base64 编码，它不仅在末尾填充 = 号，并将标准 base64 中的“+”和“/”分别改成了 - 和 _，这样就免去了在 url 编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。\n\n另有一种用于正则表达式的改进 base64 变种，它将 + 和 / 改成了 ! 和 -，因为 +, * 以及前面在 ircu 中用到的 [ 和 ] 在正则表达式中都可能具有特殊含义。\n\n【示例】java.util.base64 编码、解码示例\n\nbase64.getencoder() 和 base64.getdecoder() 提供了的是标准的 base64 编码、解码方式；\n\nbase64.geturlencoder() 和 base64.geturldecoder() 提供了 url 安全的 base64 编码、解码方式（将 + 和 / 替换为 - 和 _）。\n\nimport java.nio.charset.standardcharsets;\nimport java.util.base64;\n\npublic class base64demo {\n\n    public static void main(string[] args) {\n        string url = "https://www.baidu.com";\n        system.out.println("url:" + url);\n        // 标准的 base64 编码、解码\n        byte[] encoded = base64.getencoder().encode(url.getbytes(standardcharsets.utf_8));\n        byte[] decoded = base64.getdecoder().decode(encoded);\n        system.out.println("url safe base64 encoded:" + new string(encoded));\n        system.out.println("url safe base64 decoded:" + new string(decoded));\n        // url 安全的 base64 编码、解码\n        byte[] encoded2 = base64.geturlencoder().encode(url.getbytes(standardcharsets.utf_8));\n        byte[] decoded2 = base64.geturldecoder().decode(encoded2);\n        system.out.println("base64 encoded:" + new string(encoded2));\n        system.out.println("base64 decoded:" + new string(decoded2));\n    }\n\n}\n\n\n输出：\n\nurl:https://www.baidu.com\nurl safe base64 encoded:ahr0chm6ly93d3cuymfpzhuuy29t\nurl safe base64 decoded:https://www.baidu.com\nbase64 encoded:ahr0chm6ly93d3cuymfpzhuuy29t\nbase64 decoded:https://www.baidu.com\n\n\n\n# 消息摘要\n\n\n# 消息摘要概述\n\n消息摘要，其实就是将需要摘要的数据作为参数，经过哈希函数(hash)的计算，得到的散列值。\n\n消息摘要是一个唯一对应一个消息或文本的固定长度的值，它由一个单向 hash 加密函数对消息进行作用而产生。如果消息在途中改变了，则接收者通过对收到消息的新产生的摘要与原摘要比较，就可知道消息是否被改变了。因此消息摘要保证了消息的完整性。消息摘要采用单向 hash 函数将需加密的明文"摘要"成一串密文，这一串密文亦称为数字指纹(finger print)。它有固定的长度，且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。这样这串摘要便可成为验证明文是否是"真身"的"指纹"了。\n\n\n# 消息摘要特点\n\n * 唯一性：数据只要有一点改变，那么再通过消息摘要算法得到的摘要也会发生变化。虽然理论上有可能会发生碰撞，但是概率极其低。\n * 不可逆：消息摘要算法的密文无法被解密。\n * 不需要密钥，可使用于分布式网络。\n * 无论输入的明文有多长，计算出来的消息摘要的长度总是固定的。\n\n\n# 消息摘要常用算法\n\n消息摘要算法包括md(message digest，消息摘要算法)、sha(secure hash algorithm，安全散列算法)、**mac(message authenticationcode，消息认证码算法)**共 3 大系列，常用于验证数据的完整性，是数字签名算法的核心算法。\n\nmd5和sha1分别是md、sha算法系列中最有代表性的算法。\n\n如今，md5 已被发现有许多漏洞，从而不再安全。sha 算法比 md 算法的摘要长度更长，也更加安全。\n\n\n# 消息摘要应用\n\n# md5、sha 的范例\n\njdk 中使用 md5 和 sha 这两种消息摘要的方式基本一致，步骤如下：\n\n 1. 初始化 messagedigest 对象\n 2. 更新要计算的内容\n 3. 生成摘要\n\nimport java.security.messagedigest;\nimport java.util.base64;\n\npublic class messagedigestdemo {\n\n    public static byte[] encode(byte[] input, type type) throws exception {\n        // 根据类型，初始化消息摘要对象\n        messagedigest md5digest = messagedigest.getinstance(type.getname());\n\n        // 更新要计算的内容\n        md5digest.update(input);\n\n        // 完成哈希计算，返回摘要\n        return md5digest.digest();\n    }\n\n    public static byte[] encodewithbase64(byte[] input, type type) throws exception {\n        return base64.geturlencoder().encode(encode(input, type));\n    }\n\n    public static string encodewithbase64string(byte[] input, type type) throws exception {\n        return base64.geturlencoder().encodetostring(encode(input, type));\n    }\n\n    public enum type {\n        md2("md2"),\n        md5("md5"),\n        sha1("sha1"),\n        sha256("sha-256"),\n        sha384("sha-384"),\n        sha512("sha-512");\n\n        private string name;\n\n        type(string name) {\n            this.name = name;\n        }\n\n        public string getname() {\n            return this.name;\n        }\n    }\n\n    public static void main(string[] args) throws exception {\n        string msg = "hello world!";\n        system.out.println("md2: " + encodewithbase64string(msg.getbytes(), type.md2));\n        system.out.println("md5: " + encodewithbase64string(msg.getbytes(), type.md5));\n        system.out.println("sha1: " + encodewithbase64string(msg.getbytes(), type.sha1));\n        system.out.println("sha256: " + encodewithbase64string(msg.getbytes(), type.sha256));\n        system.out.println("sha384: " + encodewithbase64string(msg.getbytes(), type.sha384));\n        system.out.println("sha512: " + encodewithbase64string(msg.getbytes(), type.sha512));\n    }\n\n}\n\n\n【输出】\n\nmd2: mv98zyi_aft8q0uvea6hlg==\nmd5: 7qdih1muhjzehb6sv8unja==\nsha1: lve95gjovatpfv8el5x4nxwjkhe=\nsha256: f4oxzx_x_fo5lcgbskhwxfwtsx-j1ncost3sabjtkgk=\nsha384: v9dsdrvqbv7lg0efr8giewksvnbvgtlsjc0qescj4_1v0gh51c_ro4-we1jmrbpk\nsha512: hhhe1nbohxp-w02wfic8_vpujm9ivgtm3ajyvvjhkxqzcqferykcw88cnts0kms1ehubh_nln5n7xgtdb_tsya==\n\n\n# hmac 的范例\n\n\nimport java.nio.charset.standardcharsets;\nimport java.util.base64;\nimport javax.crypto.mac;\nimport javax.crypto.spec.secretkeyspec;\n\npublic class hmacmessagedigest {\n\n    public static void main(string[] args) throws exception {\n        string msg = "hello world!";\n        byte[] salt = "my salt".getbytes(standardcharsets.utf_8);\n        system.out.println("原文: " + msg);\n        system.out.println("hmacmd5: " + encodewithbase64string(msg.getbytes(), salt, hmactypeen.hmacmd5));\n        system.out.println("hmacsha1: " + encodewithbase64string(msg.getbytes(), salt, hmactypeen.hmacsha1));\n        system.out.println("hmacsha256: " + encodewithbase64string(msg.getbytes(), salt, hmactypeen.hmacsha256));\n        system.out.println("hmacsha384: " + encodewithbase64string(msg.getbytes(), salt, hmactypeen.hmacsha384));\n        system.out.println("hmacsha512: " + encodewithbase64string(msg.getbytes(), salt, hmactypeen.hmacsha512));\n    }\n\n    public static byte[] encode(byte[] plaintext, byte[] salt, hmactypeen type) throws exception {\n        secretkeyspec keyspec = new secretkeyspec(salt, type.name());\n        mac mac = mac.getinstance(keyspec.getalgorithm());\n        mac.init(keyspec);\n        return mac.dofinal(plaintext);\n    }\n\n    public static byte[] encodewithbase64(byte[] plaintext, byte[] salt, hmactypeen type) throws exception {\n        return base64.geturlencoder().encode(encode(plaintext, salt, type));\n    }\n\n    public static string encodewithbase64string(byte[] plaintext, byte[] salt, hmactypeen type) throws exception {\n        return base64.geturlencoder().encodetostring(encode(plaintext, salt, type));\n    }\n\n    /**\n     * jdk支持 hmacmd5, hmacsha1, hmacsha256, hmacsha384, hmacsha512\n     */\n    public enum hmactypeen {\n\n        hmacmd5, hmacsha1, hmacsha256, hmacsha384, hmacsha512;\n    }\n\n}\n\n\n输出\n\n原文: hello world!\nhmacmd5: re6blrsb1q26sfjtwxzusq==\nhmacsha1: cfu8a9h6cby9c5fo0omj2bnuilm=\nhmacsha256: z1czuqdwwfyyl7qedj2suh6iiehvi7o83dxml0jyer0=\nhmacsha384: 34mktrqboynwwznmqubjrdk_msldgqm2pmgcplzuplsknrg_cwfz4blpjcbbw88b\nhmacsha512: 6n77httz_atc04-ssmxhsk3wzh1samdudcl0cb_rzp4dpieng4lzkhxmbq8lck7xsnz6my_wipnstdp6pc_-5w==\n\n\n\n# 数字签名\n\n\n# 数字签名概述\n\n数字签名算法可以看做是一种带有密钥的消息摘要算法，并且这种密钥包含了公钥和私钥。也就是说，数字签名算法是非对称加密算法和消息摘要算法的结合体。\n\n数字签名算法要求能够验证数据完整性、认证数据来源，并起到抗否认的作用。\n\n数字签名算法包含签名和验证两项操作，遵循私钥签名，公钥验证的方式。\n\n签名时要使用私钥和待签名数据，验证时则需要公钥、签名值和待签名数据，其核心算法主要是消息摘要算法。\n\n\n\n数字签名常用算法：rsa、dsa、ecdsa\n\n\n# 数字签名算法应用\n\n# dsa 的范例\n\n数字签名有两个流程：签名和验证。\n\n它们的前提都是要有一个公钥、密钥对。\n\n数字签名用私钥为消息计算签名。\n\n【示例】用公钥验证摘要\n\npublic class dsacoder {\n\n    public static final string key_algorithm = "dsa";\n\n    public static final string sign_algorithm = "sha1withdsa";\n\n    /**\n     * dsa密钥长度默认1024位。 密钥长度必须是64的整数倍，范围在512~1024之间\n     */\n    private static final int key_size = 1024;\n\n    private keypair keypair;\n\n    public dsacoder() throws exception {\n        this.keypair = initkey();\n    }\n\n    private keypair initkey() throws exception {\n        // 初始化密钥对生成器\n        keypairgenerator keypairgen = keypairgenerator.getinstance(dsacoder.key_algorithm);\n        // 实例化密钥对生成器\n        keypairgen.initialize(key_size);\n        // 实例化密钥对\n        return keypairgen.genkeypair();\n    }\n\n    public byte[] signature(byte[] data, byte[] privatekey) throws exception {\n        pkcs8encodedkeyspec keyspec = new pkcs8encodedkeyspec(privatekey);\n        keyfactory keyfactory = keyfactory.getinstance(key_algorithm);\n        privatekey key = keyfactory.generateprivate(keyspec);\n\n        signature signature = signature.getinstance(sign_algorithm);\n        signature.initsign(key);\n        signature.update(data);\n        return signature.sign();\n    }\n\n    public byte[] getprivatekey() {\n        return keypair.getprivate().getencoded();\n    }\n\n    public boolean verify(byte[] data, byte[] publickey, byte[] sign) throws exception {\n        x509encodedkeyspec keyspec = new x509encodedkeyspec(publickey);\n        keyfactory keyfactory = keyfactory.getinstance(key_algorithm);\n        publickey key = keyfactory.generatepublic(keyspec);\n\n        signature signature = signature.getinstance(sign_algorithm);\n        signature.initverify(key);\n        signature.update(data);\n        return signature.verify(sign);\n    }\n\n    public byte[] getpublickey() {\n        return keypair.getpublic().getencoded();\n    }\n\n    public static void main(string[] args) throws exception {\n        string msg = "hello world";\n        dsacoder dsa = new dsacoder();\n        byte[] sign = dsa.signature(msg.getbytes(), dsa.getprivatekey());\n        boolean flag = dsa.verify(msg.getbytes(), dsa.getpublickey(), sign);\n        string result = flag ? "数字签名匹配" : "数字签名不匹配";\n        system.out.println("数字签名：" + base64.geturlencoder().encodetostring(sign));\n        system.out.println("验证结果：" + result);\n    }\n\n}\n\n\n【输出】\n\n数字签名：mcwcfdpuo_vronl5st0awary-mlxjuscahrmemnuvhpizfa2h2m37tne0putoa==\n验证结果：数字签名匹配\n\n\n\n# 对称加密\n\n\n# 对称加密概述\n\n对称加密算法主要有 des、3des（tripledes）、aes、idea、rc2、rc4、rc5 和 blowfish 等。\n\n对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发信方将明文（原始数据）和加密密钥（mi yao）一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。\n\n对称加密特点：\n\n * 优点：计算量小、加密速度快、加密效率高。\n * 缺点：算法是公开的，安全性得不到保证。\n\n通信双方每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得通信双方所拥有的密钥数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。\n\n而与公钥、密钥加密算法比起来，对称加密算法能够提供加密和认证却缺乏了签名功能，使得使用范围有所缩小。\n\n# 对称加密原理\n\n对称加密要求加密与解密使用同一个密钥，解密是加密的逆运算。由于加密、解密使用同一个密钥，这要求通信双方必须在通信前商定该密钥，并妥善保存该密钥。\n\n对称加密体制分为两种：\n\n一种是对明文的单个位（或字节）进行运算，称为流密码，也称为序列密码；\n\n一种是把明文信息划分为不同的组（或块）结构，分别对每个组（或块）进行加密、解密，称为分组密码。\n\n\n\n假设甲乙方作为通信双方。假定甲乙双方在消息传递前已商定加密算法，欲完成一次消息传递需要经过如下步骤。\n\n\n\n# 对称加密工作模式\n\n以 des 算法的工作模式为例，des 算法根据其加密算法所定义的明文分组的大小（56 位），将数据分割成若干 56 位的加密区块，再以加密区块为单位，分别进行加密处理。如果最后剩下不足一个区块的大小，称之为短块。短块的处理方法有填充法、流密码加密法、密文挪用技术。\n\n根据数据加密时每个加密区块见得关联方式来区分，可以分为以下种工作模式：\n\n(1) 电子密码本模式(electronic code book, ecb)\n\n用途：适合加密密钥，随机数等短数据。例如，安全地传递 des 密钥，ecb 是最合适的模式。\n\n(2) 密文链接模式(cipher booki chaining, cbc)\n\n用途：可加密任意长度的数据，适用于计算产生检测数据完整性的消息认证 mac。\n\n(3) 密文反馈模式(cipher feed back, cfb)\n\n用途：因错误传播无界，可以用于检查发现明文密文的篡改。\n\n(4) 输出反馈模式(output feed back, ofb)\n\n用途：使用于加密冗余性较大的数据，比如语音和图像数据。\n\naes 算法除了以上 4 中模式外，还有一种新的工作模式：\n\n(5) 计数器模式(counter, ctr)\n\n用途：适用于各种加密应用。\n\n本文对于各种工作模式的原理展开描述。个人认为，作为工程应用，了解其用途即可。\n\n# 对称加密填充方法\n\njava 中对称加密对于短块的处理，一般是采用填充方式。\n\n常采用的是：nopadding（不填充）、zeros 填充（0 填充）、pkcs5padding 填充。\n\nzerospadding\n\n方式：全部填充为 0 的字节\n\n结果如下：\n\nf1 f2 f3 f4 f5 f6 f7 f8 //第一块\n\nf9 00 00 00 00 00 00 00 //第二块\n\npkcs5padding\n\n方式：每个填充的字节都记录了填充的总字节数\n\n结果如下：\n\nf1 f2 f3 f4 f5 f6 f7 f8 //第一块\n\nf9 07 07 07 07 07 07 07 //第二块\n\n\n# 对称加密应用\n\n# 基于密钥加密的流程（des、desede、aes 和 idea）\n\ndes、desede、aes 和 idea 等算法都是基于密钥加密的对称加密算法，它们的实现流程也基本一致。步骤如下：\n\n（1）生成密钥\n\nkeygenerator kg = keygenerator.getinstance("des");\nsecurerandom random = new securerandom();\nkg.init(random);\nsecretkey secretkey = kg.generatekey();\n\n\n建议使用随机数来初始化密钥的生成。\n\n（2）初始化密码对象\n\ncipher cipher = cipher.getinstance("des/ecb/pkcs5padding");\ncipher.init(cipher.encrypt_mode, secretkey);\n\n\nencrypt_mode：加密模式\n\ndecrypt_mode：解密模式\n\n（3）执行\n\nstring plaintext = "hello world";\nbyte[] ciphertext = cipher.dofinal(plaintext.getbytes());\n\n\n一个完整的 des 加密解密范例\n\nimport java.nio.charset.standardcharsets;\nimport java.security.*;\nimport java.util.base64;\nimport javax.crypto.*;\nimport javax.crypto.spec.ivparameterspec;\n\n/**\n * des安全编码：是经典的对称加密算法。密钥仅56位，且迭代次数偏少。已被视为并不安全的加密算法。\n *\n * @author zhang peng\n * @since 2016年7月14日\n */\npublic class descoder {\n\n    public static final string key_algorithm_des = "des";\n\n    public static final string cipher_des_default = "des";\n\n    public static final string cipher_des_ecb_pkcs5padding = "des/ecb/pkcs5padding"; // 算法/模式/补码方式\n\n    public static final string cipher_des_cbc_pkcs5padding = "des/cbc/pkcs5padding";\n\n    public static final string cipher_des_cbc_nopadding = "des/cbc/nopadding";\n\n    private static final string seed = "%%%today is nice***"; // 用于生成随机数的种子\n\n    private key key;\n\n    private cipher cipher;\n\n    private string transformation;\n\n    public descoder() throws nosuchalgorithmexception, nosuchpaddingexception, nosuchproviderexception {\n        this.key = initkey();\n        this.cipher = cipher.getinstance(cipher_des_default);\n        this.transformation = cipher_des_default;\n    }\n\n    /**\n     * 根据随机数种子生成一个密钥\n     *\n     * @return key\n     * @throws nosuchalgorithmexception\n     * @throws nosuchproviderexception\n     * @author zhang peng\n     * @since 2016年7月14日\n     */\n    private key initkey() throws nosuchalgorithmexception, nosuchproviderexception {\n        // 根据种子生成一个安全的随机数\n        securerandom securerandom = null;\n        securerandom = new securerandom(seed.getbytes());\n\n        keygenerator keygen = keygenerator.getinstance(key_algorithm_des);\n        keygen.init(securerandom);\n        return keygen.generatekey();\n    }\n\n    public descoder(string transformation)\n        throws nosuchalgorithmexception, nosuchpaddingexception, nosuchproviderexception {\n        this.key = initkey();\n        this.cipher = cipher.getinstance(transformation);\n        this.transformation = transformation;\n    }\n\n    /**\n     * 加密\n     *\n     * @param input 明文\n     * @return byte[] 密文\n     * @throws invalidkeyexception\n     * @throws illegalblocksizeexception\n     * @throws badpaddingexception\n     * @throws invalidalgorithmparameterexception\n     * @author zhang peng\n     * @since 2016年7月20日\n     */\n    public byte[] encrypt(byte[] input) throws invalidkeyexception, illegalblocksizeexception, badpaddingexception,\n        invalidalgorithmparameterexception {\n        if (transformation.equals(cipher_des_cbc_pkcs5padding) || transformation.equals(cipher_des_cbc_nopadding)) {\n            cipher.init(cipher.encrypt_mode, key, new ivparameterspec(getiv()));\n        } else {\n            cipher.init(cipher.encrypt_mode, key);\n        }\n        return cipher.dofinal(input);\n    }\n\n    /**\n     * 解密\n     *\n     * @param input 密文\n     * @return byte[] 明文\n     * @throws invalidkeyexception\n     * @throws illegalblocksizeexception\n     * @throws badpaddingexception\n     * @throws invalidalgorithmparameterexception\n     * @author zhang peng\n     * @since 2016年7月20日\n     */\n    public byte[] decrypt(byte[] input) throws invalidkeyexception, illegalblocksizeexception, badpaddingexception,\n        invalidalgorithmparameterexception {\n        if (transformation.equals(cipher_des_cbc_pkcs5padding) || transformation.equals(cipher_des_cbc_nopadding)) {\n            cipher.init(cipher.decrypt_mode, key, new ivparameterspec(getiv()));\n        } else {\n            cipher.init(cipher.decrypt_mode, key);\n        }\n        return cipher.dofinal(input);\n    }\n\n    private byte[] getiv() {\n        string iv = "01234567"; // iv length: must be 8 bytes long\n        return iv.getbytes();\n    }\n\n    public static void main(string[] args) throws exception {\n        descoder aes = new descoder(cipher_des_cbc_pkcs5padding);\n\n        string msg = "hello world!";\n        system.out.println("原文: " + msg);\n        byte[] encoded = aes.encrypt(msg.getbytes(standardcharsets.utf_8));\n        string encodedbase64 = base64.geturlencoder().encodetostring(encoded);\n        system.out.println("密文: " + encodedbase64);\n\n        byte[] decodedbase64 = base64.geturldecoder().decode(encodedbase64);\n        byte[] decoded = aes.decrypt(decodedbase64);\n        system.out.println("明文: " + new string(decoded));\n    }\n\n}\n\n\n输出\n\n原文: hello world!\n密文: ttneu9eznqtxfkpmq_37qw==\n明文: hello world!\n\n\n# 基于口令加密的流程（pbe）\n\ndes、desede、aes、idea 这几种算法的应用模型几乎如出一辙。\n\n但是，并非所有对称加密算法都是如此。\n\n基于口令加密(password based encryption, pbe)是一种基于口令加密的算法。其特点是：口令由用户自己掌管，采用随机数（这里叫做盐）杂凑多重加密等方法保证数据的安全性。\n\npbe 没有密钥概念，密钥在其他对称加密算法中是经过计算得出的，pbe 则使用口令替代了密钥。\n\n流程：\n\n\n\n步骤如下：\n\n（1）产生盐\n\nsecurerandom securerandom = new securerandom();\nbyte[] salt = securerandom.generateseed(8); // 盐长度必须为8字节\n\n\n（2）根据密码产生 key\n\nstring password = "123456";\npbekeyspec keyspec = new pbekeyspec(password.tochararray());\nsecretkeyfactory keyfactory = secretkeyfactory.getinstance(key_algorithm);\nsecretkey secretkey = keyfactory.generatesecret(keyspec);\n\n\n（3）初始化加密或解密对象\n\npbeparameterspec paramspec = new pbeparameterspec(salt, iteration_count);\ncipher cipher = cipher.getinstance(key_algorithm);\ncipher.init(cipher.encrypt_mode, secretkey, paramspec);\n\n\n（4）执行\n\nbyte[] plaintext = "hello world".getbytes();\nbyte[] ciphertext = cipher.dofinal(plaintext);\n\n\n（5）完整 pbe 示例\n\nimport java.security.key;\nimport java.security.securerandom;\nimport java.util.base64;\nimport javax.crypto.cipher;\nimport javax.crypto.secretkey;\nimport javax.crypto.secretkeyfactory;\nimport javax.crypto.spec.pbekeyspec;\nimport javax.crypto.spec.pbeparameterspec;\n\n/**\n * 基于口令加密(password based encryption, pbe)，是一种对称加密算法。 其特点是：口令由用户自己掌管，采用随机数（这里叫做盐）杂凑多重加密等方法保证数据的安全性。\n * pbe没有密钥概念，密钥在其他对称加密算法中是经过计算得出的，pbe则使用口令替代了密钥。\n *\n * @author zhang peng\n * @since 2016年7月20日\n */\npublic class pbecoder {\n\n    public static final string key_algorithm = "pbewithmd5anddes";\n\n    public static final int iteration_count = 100;\n\n    private key key;\n\n    private byte[] salt;\n\n    public pbecoder(string password) throws exception {\n        this.salt = initsalt();\n        this.key = initkey(password);\n    }\n\n    private byte[] initsalt() {\n        securerandom securerandom = new securerandom();\n        return securerandom.generateseed(8); // 盐长度必须为8字节\n    }\n\n    private key initkey(string password) throws exception {\n        pbekeyspec keyspec = new pbekeyspec(password.tochararray());\n        secretkeyfactory keyfactory = secretkeyfactory.getinstance(key_algorithm);\n        return keyfactory.generatesecret(keyspec);\n    }\n\n    public byte[] encrypt(byte[] plaintext) throws exception {\n        pbeparameterspec paramspec = new pbeparameterspec(salt, iteration_count);\n        cipher cipher = cipher.getinstance(key_algorithm);\n        cipher.init(cipher.encrypt_mode, key, paramspec);\n        return cipher.dofinal(plaintext);\n    }\n\n    public byte[] decrypt(byte[] ciphertext) throws exception {\n        pbeparameterspec paramspec = new pbeparameterspec(salt, iteration_count);\n        cipher cipher = cipher.getinstance(key_algorithm);\n        cipher.init(cipher.decrypt_mode, key, paramspec);\n        return cipher.dofinal(ciphertext);\n    }\n\n    public static void test1() throws exception {\n\n        // 产生盐\n        securerandom securerandom = new securerandom();\n        byte[] salt = securerandom.generateseed(8); // 盐长度必须为8字节\n\n        // 产生key\n        string password = "123456";\n        pbekeyspec keyspec = new pbekeyspec(password.tochararray());\n        secretkeyfactory keyfactory = secretkeyfactory.getinstance(key_algorithm);\n        secretkey secretkey = keyfactory.generatesecret(keyspec);\n\n        pbeparameterspec paramspec = new pbeparameterspec(salt, iteration_count);\n        cipher cipher = cipher.getinstance(key_algorithm);\n        cipher.init(cipher.encrypt_mode, secretkey, paramspec);\n\n        byte[] plaintext = "hello world".getbytes();\n        byte[] ciphertext = cipher.dofinal(plaintext);\n        new string(ciphertext);\n    }\n\n    public static void main(string[] args) throws exception {\n        pbecoder encode = new pbecoder("123456");\n        string message = "hello world!";\n        byte[] ciphertext = encode.encrypt(message.getbytes());\n        byte[] plaintext = encode.decrypt(ciphertext);\n\n        system.out.println("原文：" + message);\n        system.out.println("密文：" + base64.geturlencoder().encodetostring(ciphertext));\n        system.out.println("明文：" + new string(plaintext));\n    }\n\n}\n\n\n\n# 非对称加密\n\n\n# 非对称加密概述\n\n非对称加密常用算法：dh(diffie-hellman，密钥交换算法)、rsa\n\n非对称加密算法和对称加密算法的主要差别在于非对称加密算法用于加密和解密的密钥是不同的。一个公开，称为公钥（public key）；一个保密，称为私钥（private key）。因此，非对称加密算法也称为双钥加密算法或公钥加密算法。\n\n非对称加密特点：\n\n * 优点：非对称加密算法解决了对称加密算法的密钥分配问题，并极大地提高了算法安全性。\n * 缺点：算法比对称算法更复杂，因此加密、解密速度都比对称算法慢很多。\n\n\n\n非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。\n\n另一方面，甲方可以使用乙方的公钥对机密信息进行签名后再发送给乙方；乙方再用自己的私匙对数据进行验证。\n\n甲方只能用其私钥解密，由其公钥加密后的任何信息。 非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要。\n\n\n# 非对称加密算法应用\n\nimport java.nio.charset.standardcharsets;\nimport java.security.*;\nimport java.security.spec.pkcs8encodedkeyspec;\nimport java.security.spec.x509encodedkeyspec;\nimport java.util.base64;\nimport javax.crypto.cipher;\n\n/**\n * rsa安全编码：非对称加密算法。它既可以用来加密、解密，也可以用来做数字签名\n *\n * @author zhang peng\n * @since 2016年7月20日\n */\npublic class rsacoder {\n\n    public final static string key_algorithm = "rsa";\n\n    public final static string sign_algorithm = "md5withrsa";\n\n    private keypair keypair;\n\n    public rsacoder() throws exception {\n        this.keypair = initkeypair();\n    }\n\n    private keypair initkeypair() throws exception {\n        // keypairgenerator类用于生成公钥和私钥对，基于rsa算法生成对象\n        keypairgenerator keypairgen = keypairgenerator.getinstance(key_algorithm);\n        // 初始化密钥对生成器，密钥大小为1024位\n        keypairgen.initialize(1024);\n        // 生成一个密钥对\n        return keypairgen.genkeypair();\n    }\n\n    public byte[] encryptbyprivatekey(byte[] plaintext, byte[] key) throws exception {\n        pkcs8encodedkeyspec keyspec = new pkcs8encodedkeyspec(key);\n        keyfactory keyfactory = keyfactory.getinstance(key_algorithm);\n        privatekey privatekey = keyfactory.generateprivate(keyspec);\n        cipher cipher = cipher.getinstance(keyfactory.getalgorithm());\n        cipher.init(cipher.encrypt_mode, privatekey);\n        return cipher.dofinal(plaintext);\n    }\n\n    public byte[] decryptbypublickey(byte[] ciphertext, byte[] key) throws exception {\n        x509encodedkeyspec keyspec = new x509encodedkeyspec(key);\n        keyfactory keyfactory = keyfactory.getinstance(key_algorithm);\n        publickey publickey = keyfactory.generatepublic(keyspec);\n        cipher cipher = cipher.getinstance(keyfactory.getalgorithm());\n        cipher.init(cipher.decrypt_mode, publickey);\n        return cipher.dofinal(ciphertext);\n    }\n\n    public byte[] encryptbypublickey(byte[] plaintext, byte[] key) throws exception {\n        x509encodedkeyspec keyspec = new x509encodedkeyspec(key);\n        keyfactory keyfactory = keyfactory.getinstance(key_algorithm);\n        publickey publickey = keyfactory.generatepublic(keyspec);\n        cipher cipher = cipher.getinstance(keyfactory.getalgorithm());\n        cipher.init(cipher.encrypt_mode, publickey);\n        return cipher.dofinal(plaintext);\n    }\n\n    public byte[] decryptbyprivatekey(byte[] ciphertext, byte[] key) throws exception {\n        pkcs8encodedkeyspec keyspec = new pkcs8encodedkeyspec(key);\n        keyfactory keyfactory = keyfactory.getinstance(key_algorithm);\n        privatekey privatekey = keyfactory.generateprivate(keyspec);\n        cipher cipher = cipher.getinstance(keyfactory.getalgorithm());\n        cipher.init(cipher.decrypt_mode, privatekey);\n        return cipher.dofinal(ciphertext);\n    }\n\n    public byte[] signature(byte[] data, byte[] privatekey, rsasigntypeen type) throws exception {\n        pkcs8encodedkeyspec keyspec = new pkcs8encodedkeyspec(privatekey);\n        keyfactory keyfactory = keyfactory.getinstance(key_algorithm);\n        privatekey key = keyfactory.generateprivate(keyspec);\n\n        signature signature = signature.getinstance(type.name());\n        signature.initsign(key);\n        signature.update(data);\n        return signature.sign();\n    }\n\n    public byte[] getprivatekey() {\n        return keypair.getprivate().getencoded();\n    }\n\n    public boolean verify(byte[] data, byte[] publickey, byte[] sign, rsasigntypeen type) throws exception {\n        x509encodedkeyspec keyspec = new x509encodedkeyspec(publickey);\n        keyfactory keyfactory = keyfactory.getinstance(key_algorithm);\n        publickey key = keyfactory.generatepublic(keyspec);\n\n        signature signature = signature.getinstance(type.name());\n        signature.initverify(key);\n        signature.update(data);\n        return signature.verify(sign);\n    }\n\n    public byte[] getpublickey() {\n        return keypair.getpublic().getencoded();\n    }\n\n    public enum rsasigntypeen {\n\n        md2withrsa,\n        md5withrsa,\n        sha1withrsa\n    }\n\n    public static void main(string[] args) throws exception {\n        string msg = "hello world!";\n        rsacoder coder = new rsacoder();\n        // 私钥加密，公钥解密\n        byte[] ciphertext = coder.encryptbyprivatekey(msg.getbytes(standardcharsets.utf_8), coder.keypair.getprivate().getencoded());\n        byte[] plaintext = coder.decryptbypublickey(ciphertext, coder.keypair.getpublic().getencoded());\n\n        // 公钥加密，私钥解密\n        byte[] ciphertext2 = coder.encryptbypublickey(msg.getbytes(), coder.keypair.getpublic().getencoded());\n        byte[] plaintext2 = coder.decryptbyprivatekey(ciphertext2, coder.keypair.getprivate().getencoded());\n\n        byte[] sign = coder.signature(msg.getbytes(), coder.getprivatekey(), rsasigntypeen.sha1withrsa);\n        boolean flag = coder.verify(msg.getbytes(), coder.getpublickey(), sign, rsasigntypeen.sha1withrsa);\n        string result = flag ? "数字签名匹配" : "数字签名不匹配";\n\n        system.out.println("原文：" + msg);\n        system.out.println("公钥：" + base64.geturlencoder().encodetostring(coder.keypair.getpublic().getencoded()));\n        system.out.println("私钥：" + base64.geturlencoder().encodetostring(coder.keypair.getprivate().getencoded()));\n\n        system.out.println("============== 私钥加密，公钥解密 ==============");\n        system.out.println("密文：" + base64.geturlencoder().encodetostring(ciphertext));\n        system.out.println("明文：" + new string(plaintext));\n\n        system.out.println("============== 公钥加密，私钥解密 ==============");\n        system.out.println("密文：" + base64.geturlencoder().encodetostring(ciphertext2));\n        system.out.println("明文：" + new string(plaintext2));\n\n        system.out.println("============== 数字签名 ==============");\n        system.out.println("数字签名：" + base64.geturlencoder().encodetostring(sign));\n        system.out.println("验证结果：" + result);\n    }\n\n}\n\n\n输出\n\n原文：hello world!\n公钥：migfma0gcsqgsib3dqebaquaa4gnadcbiqkbgqczptrlertucytr8gmipvbso7fn18thueq02u21mh7ta4fh4tjvngozrzeoryu94dxrpdnrpjh0p62p5pdijx_dtglzr0agwgttvbbpwake4kexypqv4vv6ixrzyq2hdovfoovim5eu0tu_txgenpffp0pyj2lxczpsgsrdupupmwidaqab\n私钥：miicdwibadanbgkqhkig9w0baqefaascamewggjdageaaogbalm-1esstnrxi2vwayim9uyjsu3xy2g4srtztbwahtmdgufhoo82a5mtkq5fi73h3gs92es-ohsnry_mkmiph920avmvrozac1o8fs_aaotir5fi-q_hvxqjdhpjdyd068u6i-kbl67ro79pez42kv-nslipytclomybkt1q-4-bagmbaaecgybjxoxil8s0wjajkckfnxiquh3sh6lwgkrcwci1p0rgw-ttdeg-sucyctjsktsl3rq0edqjmovrnsc7ngygpidcitdbd1h6m3tlrebbb-wzdxmswpshtqjsq4de0e93mmfysciop6qexos0jqvjtyybsk37lpucldalj2ijdtc0gqjbapfmngzauipmxued7puuwnbuwxnkmdmcs308ec_9vnllxwhdb9xkmuxcmwqk16mj6j1fqwtju62t21yniwwqhiscqqc5lwqkfrxvukgnbg0pa95nvwwy01yttnb125jslxekbr97ku4vgbabcb9tyudpr9lxazgfg6y3a1wfsfukagsxakea1l719olxhyswzdmbvtozk14m-qebs9lwjc9asmpb8b1u2vvj2pd3wlyyw4tv5-qt-j2jur-e1tmseqovgx-csqjaetrobq_zfv_0vjnwutmtd2nsw5m3gy4vzu5ep1dsxf63gxdmyvccqepzjqxpxnayxeharj_7rhbsc1ts_ux4sqjbailbgqc4-92foxgzwt80rsqzlmq8j8nbjpoo7run9tgx60vkr3xv26vos77oqdufwlt5iibzbs9acta2suav6qg=\n============== 私钥加密，公钥解密 ==============\n密文：qn6igjsjv45enh21ryrx2uzfmueqplbm1g3vipbbqbuf63rdhdsgmjsvpaub__v0rxpplu3gr6qlywu1mpaj-ix_6kogah64wqtwqprh7e6aj767rybnpt9jyvlcmmpy9diqhaufwtbjdo34q-a7fhq9c8bwrj6jnn47idmzhfu=\n明文：hello world!\n============== 公钥加密，私钥解密 ==============\n密文：fsz2ifs69d7jdrh-yoe5pi5wkqu1zml7sdsppqtzun6muscjnp6x312deqcxkmgseadmpveb01yzbfa0mt_6eyjyvseu7rd6bdf6yig3azfc41yh5ititvq-xzxugnpps12slpxswg0faa5qjcvznotx9p7nhr8n20y4cnmi6rw=\n明文：hello world!\n============== 数字签名 ==============\n数字签名：dttuulwx1wrqbw1pca8o6wjcwcrhinezrxwglkewbom2dpvhnynvv_hyks-qfe5_4vjqcpgj2hzqwbfv1vklhmuwuixm7vjk70g3g7bf8i8rwbrcdoxgtr77jrewidpr1pyjzwjvgq_hp36mxingflcvh2sn0fu8mppzsxuenzq=\n验证结果：数字签名匹配\n\n\n\n# 术语\n\n * 明文(plaintext)：指待加密信息。明文可以是文本文件、图片文件、二进制数据等。\n * 密文(ciphertext)：指经过加密后的明文。密文通常以文本、二进制等形式存在。\n * 加密(encryption)：指将明文转换为密文的过程。\n * 解密(decryption)：指将密文转换为明文的过程。\n * 加密密钥(encryption key)：指通过加密算法进行加密操作用的密钥。\n * 解密密钥(decryption key)：指通过解密算法进行解密操作用的密钥。\n * 信道(channel)：通信的通道，是信号传输的媒介。\n\n\n# 参考资料\n\n * 《java 核心技术 卷 ii 高级特性》\n * 《java 加密与解密的艺术》',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 本地化",frontmatter:{title:"Java 本地化",categories:["编程","Java","JavaSE","高级特性"],tags:["Java","JavaSE","本地化"],abbrlink:"5b562448",date:"2017-11-08T14:38:26.000Z",permalink:"/pages/f7bac4/"},regularPath:"/02.%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/03.Java%E6%9C%AC%E5%9C%B0%E5%8C%96.html",relativePath:"02.高级特性/03.Java本地化.md",key:"v-2b1eb9dc",path:"/pages/f7bac4/",headers:[{level:2,title:"背景知识",slug:"背景知识",normalizedTitle:"背景知识",charIndex:15},{level:3,title:"语言编码、国家/地区编码",slug:"语言编码、国家-地区编码",normalizedTitle:"语言编码、国家/地区编码",charIndex:150},{level:3,title:"字符编码",slug:"字符编码",normalizedTitle:"字符编码",charIndex:1596},{level:2,title:"Java 中实现本地化",slug:"java-中实现本地化",normalizedTitle:"java 中实现本地化",charIndex:2174},{level:3,title:"定义不同语种的模板",slug:"定义不同语种的模板",normalizedTitle:"定义不同语种的模板",charIndex:2274},{level:4,title:"定义 properties 文件",slug:"定义-properties-文件",normalizedTitle:"定义 properties 文件",charIndex:2476},{level:4,title:"Unicode 转换工具",slug:"unicode-转换工具",normalizedTitle:"unicode 转换工具",charIndex:2879},{level:3,title:"选择语种",slug:"选择语种",normalizedTitle:"选择语种",charIndex:2222},{level:4,title:"Locale",slug:"locale",normalizedTitle:"locale",charIndex:2847},{level:3,title:"加载指定语种的模板",slug:"加载指定语种的模板",normalizedTitle:"加载指定语种的模板",charIndex:2232},{level:4,title:"ResourceBoundle",slug:"resourceboundle",normalizedTitle:"resourceboundle",charIndex:4206},{level:2,title:"支持本地化的工具类",slug:"支持本地化的工具类",normalizedTitle:"支持本地化的工具类",charIndex:5648},{level:3,title:"NumberFormat",slug:"numberformat",normalizedTitle:"numberformat",charIndex:5687},{level:3,title:"DateFormat",slug:"dateformat",normalizedTitle:"dateformat",charIndex:5700},{level:3,title:"MessageFormat",slug:"messageformat",normalizedTitle:"messageformat",charIndex:5711}],headersStr:"背景知识 语言编码、国家/地区编码 字符编码 Java 中实现本地化 定义不同语种的模板 定义 properties 文件 Unicode 转换工具 选择语种 Locale 加载指定语种的模板 ResourceBoundle 支持本地化的工具类 NumberFormat DateFormat MessageFormat",content:'# Java 本地化\n\n\n# 背景知识\n\n通讯的发达，使得世界各地交流越来越紧密。许多的软件产品也要面向世界上不同国家的用户。其中，语言障碍显然是产品在不同语种用户中进行推广的一个重要问题。\n\n本文围绕本地化这一主题，先介绍国际标准的语言编码，然后讲解在 Java 应用中如何去实现本地化。\n\n\n# 语言编码、国家/地区编码\n\n做 web 开发的朋友可能多多少少接触过类似 zh-cn, en-us 这样的编码字样。\n\n这些编码是用来表示指定的国家地区的语言类型的。那么，这些含有特殊含义的编码是如何产生的呢？\n\nISO-639 标准使用编码定义了国际上常见的语言，每一种语言由两个小写字母表示。\n\nISO-3166 标准使用编码定义了国家/地区，每个国家/地区由两个大写字母表示。\n\n下表列举了一些常见国家、地区的语言编码：\n\n国家/地区        语言编码    国家/地区        语言编码\n简体中文(中国)     zh-cn   繁体中文(台湾地区)   zh-tw\n繁体中文(香港)     zh-hk   英语(香港)       en-hk\n英语(美国)       en-us   英语(英国)       en-gb\n英语(全球)       en-ww   英语(加拿大)      en-ca\n英语(澳大利亚)     en-au   英语(爱尔兰)      en-ie\n英语(芬兰)       en-fi   芬兰语(芬兰)      fi-fi\n英语(丹麦)       en-dk   丹麦语(丹麦)      da-dk\n英语(以色列)      en-il   希伯来语(以色列)    he-il\n英语(南非)       en-za   英语(印度)       en-in\n英语(挪威)       en-no   英语(新加坡)      en-sg\n英语(新西兰)      en-nz   英语(印度尼西亚)    en-id\n英语(菲律宾)      en-ph   英语(泰国)       en-th\n英语(马来西亚)     en-my   英语(阿拉伯)      en-xa\n韩文(韩国)       ko-kr   日语(日本)       ja-jp\n荷兰语(荷兰)      nl-nl   荷兰语(比利时)     nl-be\n葡萄牙语(葡萄牙)    pt-pt   葡萄牙语(巴西)     pt-br\n法语(法国)       fr-fr   法语(卢森堡)      fr-lu\n法语(瑞士)       fr-ch   法语(比利时)      fr-be\n法语(加拿大)      fr-ca   西班牙语(拉丁美洲)   es-la\n西班牙语(西班牙)    es-es   西班牙语(阿根廷)    es-ar\n西班牙语(美国)     es-us   西班牙语(墨西哥)    es-mx\n西班牙语(哥伦比亚)   es-co   西班牙语(波多黎各)   es-pr\n德语(德国)       de-de   德语(奥地利)      de-at\n德语(瑞士)       de-ch   俄语(俄罗斯)      ru-ru\n意大利语(意大利)    it-it   希腊语(希腊)      el-gr\n挪威语(挪威)      no-no   匈牙利语(匈牙利)    hu-hu\n土耳其语(土耳其)    tr-tr   捷克语(捷克共和国)   cs-cz\n斯洛文尼亚语       sl-sl   波兰语(波兰)      pl-pl\n瑞典语(瑞典)      sv-se                \n\n注：由表中可以看出语言、国家/地区编码一般都是英文单词的缩写。\n\n\n# 字符编码\n\n在此处，引申一下字符编码的概念。\n\n是不是有了语言、国家/地区编码，计算机就可以识别各种语言了？\n\n答案是否。作为程序员，相信每个人都会遇到过这样的情况：期望打印中文，结果输出的却是乱码。\n\n这种情况，往往是因为字符编码的问题。\n\n计算机在设计之初，并没有考虑多个国家，多种不同语言的应用场景。当时定义一种ASCII码，将字母、数字和其他符号编号用 7 比特的二进制数来表示。后来，计算机在世界开始普及，为了适应多种文字，出现了多种编码格式，例如中文汉字一般使用的编码格式为GB2312、GBK。\n\n由此，又产生了一个问题，不同字符编码之间互相无法识别。于是，为了一统江湖，出现了 unicode 编码。它为每种语言的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台的文本转换需求。\n\n有人不禁要问，既然 Unicode 可以支持所有语言的字符，那还要其他字符编码做什么？\n\nUnicode 有一个缺点：为了支持所有语言的字符，所以它需要用更多位数去表示，比如 ASCII 表示一个英文字符只需要一个字节，而 Unicode 则需要两个字节。很明显，如果字符数多，这样的效率会很低。\n\n为了解决这个问题，有出现了一些中间格式的字符编码：如 UTF-8、UTF-16、UTF-32 等（中国的程序员一般使用UTF-8编码）。\n\n\n# Java 中实现本地化\n\n本地化的实现原理很简单：\n\n 1. 先定义好不同语种的模板；\n 2. 选择语种；\n 3. 加载指定语种的模板。\n\n接下来，本文会按照步骤逐一讲解实现本地化的具体步骤\n\n\n# 定义不同语种的模板\n\nJava 中将多语言文本存储在格式为 properties 的资源文件中。\n\n它必须遵照以下的命名规范：\n\n<资源名>_<语言代码>_<国家/地区编码>.properties\n\n\n其中，语言编码和国家/地区编码都是可选的。\n\n注：<资源名>.properties 命名的本地化资源文件是默认的资源文件，即某个本地化类型在系统中找不到对应的资源文件，就采用这个默认的资源文件。\n\n# 定义 properties 文件\n\n在src/main/resources/locales 路径下定义名为 content 的不同语种资源文件：\n\ncontent_en_US.properties\n\nhelloWorld = HelloWorld!\ntime = The current time is %s.\n\n\ncontent_zh_CN.properties\n\nhelloWorld = \\u4e16\\u754c\\uff0c\\u4f60\\u597d\\uff01\ntime = \\u5f53\\u524d\\u65f6\\u95f4\\u662f\\u0025\\u0073\\u3002\n\n\n可以看到：几个资源文件中，定义的 Key 完全一致，只是 Value 是对应语言的字符串。\n\n虽然属性值各不相同，但属性名却是相同的，这样应用程序就可以通过 Locale 对象和属性名精确调用到某个具体的属性值了。\n\n# Unicode 转换工具\n\n上一节中，我们定义的中文资源文件中的属性值都是以\\u 开头的四位 16 进制数。其实，这表示的是一个 Unicode 编码。\n\nhelloWorld = \\u4e16\\u754c\\uff0c\\u4f60\\u597d\\uff01\ntime = \\u5f53\\u524d\\u65f6\\u95f4\\u662f\\u0025\\u0073\\u3002\n\n\n本文的字符编码中提到了，为了达到跨编码也正常显示的目的，有必要将非 ASCII 字符转为 Unicode 编码。上面的中文资源文件就是中文转为 Unicode 的结果。\n\n怎么将非 ASCII 字符转为 Unicode 编码呢？\n\nJDK 在 bin 目录下为我们提供了一个转换工具：native2ascii。\n\n它可以将中文字符的资源文件转换为 Unicode 代码格式的文件，命令格式如下：\n\nnative2ascii [-reverse] [-encoding 编码] [输入文件 [输出文件]]\n\n\n假设content_zh_CN.properties 在 d:\\ 目录。执行以下命令可以新建一个名为 content_zh_CN_new.properties 的文件，其中的内容就中文字符转为 UTF-8 编码格式的结果。\n\nnative2ascii -encoding utf-8 d:\\content_zh_CN.properties d:\\content_zh_CN_new.properties\n\n\n\n# 选择语种\n\n定义了多语言资源文件，第二步就是根据本地语种选择模板文件了。\n\n# Locale\n\n在 Java 中，一个 java.util.Locale 对象表示了特定的地理、政治和文化地区。需要 Locale 来执行其任务的操作称为语言环境敏感的操作，它使用 Locale 为用户量身定制本地信息。\n\n它有三个构造方法\n\nLocale(String language) ：根据语言编码初始化 Locale(String language, String country) ：根据语言编码、国家编码初始化 Locale(String language, String country, String variant) ：根据语言编码、国家编码、变体初始化\n\n此外，Locale 定义了一些常用的 Locale 常量：Locale.ENGLISH、Locale.CHINESE 等。\n\n// 初始化一个通用英语的locale.\nLocale locale1 = new Locale("en");\n// 初始化一个加拿大英语的locale.\nLocale locale2 = new Locale("en", "CA");\n// 初始化一个美式英语变种硅谷英语的locale\nLocale locale3 = new Locale("en", "US", "SiliconValley");\n// 根据Locale常量初始化一个简体中文\nLocale locale4 = Locale.SIMPLIFIED_CHINESE;\n\n\n\n# 加载指定语种的模板\n\n# ResourceBoundle\n\nJava 为我们提供了用于加载本地化资源文件的工具类：java.util.ResourceBoundle。\n\nResourceBoundle 提供了多个名为 getBundle 的静态重载方法，这些方法的作用是用来根据资源名、Locale 选择指定语种的资源文件。需要说明的是： getBundle 方法的第一个参数一般都是baseName ，这个参数表示资源文件名。\n\nResourceBoundle 还提供了名为 getString 的方法，用来获取资源文件中 key 对应的 value。\n\npublic static void main(String[] args) {\n    // 根据语言+地区编码初始化\n    ResourceBundle rbUS = ResourceBundle.getBundle("locales.content", new Locale("en", "US"));\n    // 根据Locale常量初始化\n    ResourceBundle rbZhCN = ResourceBundle.getBundle("locales.content", Locale.SIMPLIFIED_CHINESE);\n    // 获取本地系统默认的Locale初始化\n    ResourceBundle rbDefault = ResourceBundle.getBundle("locales.content");\n    // ResourceBundle rbDefault =ResourceBundle.getBundle("locales.content", Locale.getDefault()); // 与上行代码等价\n\n    System.out.println("us-US:" + rbUS.getString("helloWorld"));\n    System.out.println("us-US:" + String.format(rbUS.getString("time"), "08:00"));\n    System.out.println("zh-CN：" + rbZhCN.getString("helloWorld"));\n    System.out.println("zh-CN：" + String.format(rbZhCN.getString("time"), "08:00"));\n    System.out.println("default：" + rbDefault.getString("helloWorld"));\n    System.out.println("default：" + String.format(rbDefault.getString("time"), "08:00"));\n}\n\n\n输出\n\nus-US:HelloWorld!\nus-US:The current time is 08:00.\nzh-CN：世界，你好！\nzh-CN：当前时间是08:00。\ndefault：世界，你好！\ndefault：当前时间是08:00。\n\n\n注：在加载资源时，如果指定的本地化资源文件不存在，它会尝试按下面的顺序加载其他的资源：本地系统默认本地化对象对应的资源 -> 默认的资源。如果指定错误，Java 会提示找不到资源文件。\n\n\n# 支持本地化的工具类\n\nJava 中也提供了几个支持本地化的格式化工具类。例如：NumberFormat、DateFormat、MessageFormat\n\n\n# NumberFormat\n\nNumberFormat 是所有数字格式类的基类。它提供格式化和解析数字的接口。它也提供了决定数字所属语言类型的方法。\n\npublic static void main(String[] args) {\n\tdouble num = 123456.78;\n\tNumberFormat format = NumberFormat.getCurrencyInstance(Locale.SIMPLIFIED_CHINESE);\n\tSystem.out.format("%f 的本地化（%s）结果: %s", num, Locale.SIMPLIFIED_CHINESE, format.format(num));\n}\n\n\n\n# DateFormat\n\nDateFormat 是日期、时间格式化类的抽象类。它支持基于语言习惯的日期、时间格式。\n\npublic static void main(String[] args) {\n\tDate date = new Date();\n\tDateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.ENGLISH);\n\tDateFormat df2 = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.SIMPLIFIED_CHINESE);\n\tSystem.out.format("%s 的本地化（%s）结果: %s\\n", date, Locale.SIMPLIFIED_CHINESE, df.format(date));\n\tSystem.out.format("%s 的本地化（%s）结果: %s\\n", date, Locale.SIMPLIFIED_CHINESE, df2.format(date));\n}\n\n\n\n# MessageFormat\n\nMessageformat 提供一种与语言无关的拼接消息的方式。通过这种拼接方式，将最终呈现返回给使用者。\n\npublic static void main(String[] args) {\n\tString pattern1 = "{0}，你好！你于  {1} 消费  {2} 元。";\n\tString pattern2 = "At {1,time,short} On {1,date,long}，{0} paid {2,number, currency}.";\n\tObject[] params = {"Jack", new GregorianCalendar().getTime(), 8888};\n\tString msg1 = MessageFormat.format(pattern1, params);\n\tMessageFormat mf = new MessageFormat(pattern2, Locale.US);\n\tString msg2 = mf.format(params);\n\tSystem.out.println(msg1);\n\tSystem.out.println(msg2);\n}\n',normalizedContent:'# java 本地化\n\n\n# 背景知识\n\n通讯的发达，使得世界各地交流越来越紧密。许多的软件产品也要面向世界上不同国家的用户。其中，语言障碍显然是产品在不同语种用户中进行推广的一个重要问题。\n\n本文围绕本地化这一主题，先介绍国际标准的语言编码，然后讲解在 java 应用中如何去实现本地化。\n\n\n# 语言编码、国家/地区编码\n\n做 web 开发的朋友可能多多少少接触过类似 zh-cn, en-us 这样的编码字样。\n\n这些编码是用来表示指定的国家地区的语言类型的。那么，这些含有特殊含义的编码是如何产生的呢？\n\niso-639 标准使用编码定义了国际上常见的语言，每一种语言由两个小写字母表示。\n\niso-3166 标准使用编码定义了国家/地区，每个国家/地区由两个大写字母表示。\n\n下表列举了一些常见国家、地区的语言编码：\n\n国家/地区        语言编码    国家/地区        语言编码\n简体中文(中国)     zh-cn   繁体中文(台湾地区)   zh-tw\n繁体中文(香港)     zh-hk   英语(香港)       en-hk\n英语(美国)       en-us   英语(英国)       en-gb\n英语(全球)       en-ww   英语(加拿大)      en-ca\n英语(澳大利亚)     en-au   英语(爱尔兰)      en-ie\n英语(芬兰)       en-fi   芬兰语(芬兰)      fi-fi\n英语(丹麦)       en-dk   丹麦语(丹麦)      da-dk\n英语(以色列)      en-il   希伯来语(以色列)    he-il\n英语(南非)       en-za   英语(印度)       en-in\n英语(挪威)       en-no   英语(新加坡)      en-sg\n英语(新西兰)      en-nz   英语(印度尼西亚)    en-id\n英语(菲律宾)      en-ph   英语(泰国)       en-th\n英语(马来西亚)     en-my   英语(阿拉伯)      en-xa\n韩文(韩国)       ko-kr   日语(日本)       ja-jp\n荷兰语(荷兰)      nl-nl   荷兰语(比利时)     nl-be\n葡萄牙语(葡萄牙)    pt-pt   葡萄牙语(巴西)     pt-br\n法语(法国)       fr-fr   法语(卢森堡)      fr-lu\n法语(瑞士)       fr-ch   法语(比利时)      fr-be\n法语(加拿大)      fr-ca   西班牙语(拉丁美洲)   es-la\n西班牙语(西班牙)    es-es   西班牙语(阿根廷)    es-ar\n西班牙语(美国)     es-us   西班牙语(墨西哥)    es-mx\n西班牙语(哥伦比亚)   es-co   西班牙语(波多黎各)   es-pr\n德语(德国)       de-de   德语(奥地利)      de-at\n德语(瑞士)       de-ch   俄语(俄罗斯)      ru-ru\n意大利语(意大利)    it-it   希腊语(希腊)      el-gr\n挪威语(挪威)      no-no   匈牙利语(匈牙利)    hu-hu\n土耳其语(土耳其)    tr-tr   捷克语(捷克共和国)   cs-cz\n斯洛文尼亚语       sl-sl   波兰语(波兰)      pl-pl\n瑞典语(瑞典)      sv-se                \n\n注：由表中可以看出语言、国家/地区编码一般都是英文单词的缩写。\n\n\n# 字符编码\n\n在此处，引申一下字符编码的概念。\n\n是不是有了语言、国家/地区编码，计算机就可以识别各种语言了？\n\n答案是否。作为程序员，相信每个人都会遇到过这样的情况：期望打印中文，结果输出的却是乱码。\n\n这种情况，往往是因为字符编码的问题。\n\n计算机在设计之初，并没有考虑多个国家，多种不同语言的应用场景。当时定义一种ascii码，将字母、数字和其他符号编号用 7 比特的二进制数来表示。后来，计算机在世界开始普及，为了适应多种文字，出现了多种编码格式，例如中文汉字一般使用的编码格式为gb2312、gbk。\n\n由此，又产生了一个问题，不同字符编码之间互相无法识别。于是，为了一统江湖，出现了 unicode 编码。它为每种语言的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台的文本转换需求。\n\n有人不禁要问，既然 unicode 可以支持所有语言的字符，那还要其他字符编码做什么？\n\nunicode 有一个缺点：为了支持所有语言的字符，所以它需要用更多位数去表示，比如 ascii 表示一个英文字符只需要一个字节，而 unicode 则需要两个字节。很明显，如果字符数多，这样的效率会很低。\n\n为了解决这个问题，有出现了一些中间格式的字符编码：如 utf-8、utf-16、utf-32 等（中国的程序员一般使用utf-8编码）。\n\n\n# java 中实现本地化\n\n本地化的实现原理很简单：\n\n 1. 先定义好不同语种的模板；\n 2. 选择语种；\n 3. 加载指定语种的模板。\n\n接下来，本文会按照步骤逐一讲解实现本地化的具体步骤\n\n\n# 定义不同语种的模板\n\njava 中将多语言文本存储在格式为 properties 的资源文件中。\n\n它必须遵照以下的命名规范：\n\n<资源名>_<语言代码>_<国家/地区编码>.properties\n\n\n其中，语言编码和国家/地区编码都是可选的。\n\n注：<资源名>.properties 命名的本地化资源文件是默认的资源文件，即某个本地化类型在系统中找不到对应的资源文件，就采用这个默认的资源文件。\n\n# 定义 properties 文件\n\n在src/main/resources/locales 路径下定义名为 content 的不同语种资源文件：\n\ncontent_en_us.properties\n\nhelloworld = helloworld!\ntime = the current time is %s.\n\n\ncontent_zh_cn.properties\n\nhelloworld = \\u4e16\\u754c\\uff0c\\u4f60\\u597d\\uff01\ntime = \\u5f53\\u524d\\u65f6\\u95f4\\u662f\\u0025\\u0073\\u3002\n\n\n可以看到：几个资源文件中，定义的 key 完全一致，只是 value 是对应语言的字符串。\n\n虽然属性值各不相同，但属性名却是相同的，这样应用程序就可以通过 locale 对象和属性名精确调用到某个具体的属性值了。\n\n# unicode 转换工具\n\n上一节中，我们定义的中文资源文件中的属性值都是以\\u 开头的四位 16 进制数。其实，这表示的是一个 unicode 编码。\n\nhelloworld = \\u4e16\\u754c\\uff0c\\u4f60\\u597d\\uff01\ntime = \\u5f53\\u524d\\u65f6\\u95f4\\u662f\\u0025\\u0073\\u3002\n\n\n本文的字符编码中提到了，为了达到跨编码也正常显示的目的，有必要将非 ascii 字符转为 unicode 编码。上面的中文资源文件就是中文转为 unicode 的结果。\n\n怎么将非 ascii 字符转为 unicode 编码呢？\n\njdk 在 bin 目录下为我们提供了一个转换工具：native2ascii。\n\n它可以将中文字符的资源文件转换为 unicode 代码格式的文件，命令格式如下：\n\nnative2ascii [-reverse] [-encoding 编码] [输入文件 [输出文件]]\n\n\n假设content_zh_cn.properties 在 d:\\ 目录。执行以下命令可以新建一个名为 content_zh_cn_new.properties 的文件，其中的内容就中文字符转为 utf-8 编码格式的结果。\n\nnative2ascii -encoding utf-8 d:\\content_zh_cn.properties d:\\content_zh_cn_new.properties\n\n\n\n# 选择语种\n\n定义了多语言资源文件，第二步就是根据本地语种选择模板文件了。\n\n# locale\n\n在 java 中，一个 java.util.locale 对象表示了特定的地理、政治和文化地区。需要 locale 来执行其任务的操作称为语言环境敏感的操作，它使用 locale 为用户量身定制本地信息。\n\n它有三个构造方法\n\nlocale(string language) ：根据语言编码初始化 locale(string language, string country) ：根据语言编码、国家编码初始化 locale(string language, string country, string variant) ：根据语言编码、国家编码、变体初始化\n\n此外，locale 定义了一些常用的 locale 常量：locale.english、locale.chinese 等。\n\n// 初始化一个通用英语的locale.\nlocale locale1 = new locale("en");\n// 初始化一个加拿大英语的locale.\nlocale locale2 = new locale("en", "ca");\n// 初始化一个美式英语变种硅谷英语的locale\nlocale locale3 = new locale("en", "us", "siliconvalley");\n// 根据locale常量初始化一个简体中文\nlocale locale4 = locale.simplified_chinese;\n\n\n\n# 加载指定语种的模板\n\n# resourceboundle\n\njava 为我们提供了用于加载本地化资源文件的工具类：java.util.resourceboundle。\n\nresourceboundle 提供了多个名为 getbundle 的静态重载方法，这些方法的作用是用来根据资源名、locale 选择指定语种的资源文件。需要说明的是： getbundle 方法的第一个参数一般都是basename ，这个参数表示资源文件名。\n\nresourceboundle 还提供了名为 getstring 的方法，用来获取资源文件中 key 对应的 value。\n\npublic static void main(string[] args) {\n    // 根据语言+地区编码初始化\n    resourcebundle rbus = resourcebundle.getbundle("locales.content", new locale("en", "us"));\n    // 根据locale常量初始化\n    resourcebundle rbzhcn = resourcebundle.getbundle("locales.content", locale.simplified_chinese);\n    // 获取本地系统默认的locale初始化\n    resourcebundle rbdefault = resourcebundle.getbundle("locales.content");\n    // resourcebundle rbdefault =resourcebundle.getbundle("locales.content", locale.getdefault()); // 与上行代码等价\n\n    system.out.println("us-us:" + rbus.getstring("helloworld"));\n    system.out.println("us-us:" + string.format(rbus.getstring("time"), "08:00"));\n    system.out.println("zh-cn：" + rbzhcn.getstring("helloworld"));\n    system.out.println("zh-cn：" + string.format(rbzhcn.getstring("time"), "08:00"));\n    system.out.println("default：" + rbdefault.getstring("helloworld"));\n    system.out.println("default：" + string.format(rbdefault.getstring("time"), "08:00"));\n}\n\n\n输出\n\nus-us:helloworld!\nus-us:the current time is 08:00.\nzh-cn：世界，你好！\nzh-cn：当前时间是08:00。\ndefault：世界，你好！\ndefault：当前时间是08:00。\n\n\n注：在加载资源时，如果指定的本地化资源文件不存在，它会尝试按下面的顺序加载其他的资源：本地系统默认本地化对象对应的资源 -> 默认的资源。如果指定错误，java 会提示找不到资源文件。\n\n\n# 支持本地化的工具类\n\njava 中也提供了几个支持本地化的格式化工具类。例如：numberformat、dateformat、messageformat\n\n\n# numberformat\n\nnumberformat 是所有数字格式类的基类。它提供格式化和解析数字的接口。它也提供了决定数字所属语言类型的方法。\n\npublic static void main(string[] args) {\n\tdouble num = 123456.78;\n\tnumberformat format = numberformat.getcurrencyinstance(locale.simplified_chinese);\n\tsystem.out.format("%f 的本地化（%s）结果: %s", num, locale.simplified_chinese, format.format(num));\n}\n\n\n\n# dateformat\n\ndateformat 是日期、时间格式化类的抽象类。它支持基于语言习惯的日期、时间格式。\n\npublic static void main(string[] args) {\n\tdate date = new date();\n\tdateformat df = dateformat.getdateinstance(dateformat.medium, locale.english);\n\tdateformat df2 = dateformat.getdateinstance(dateformat.medium, locale.simplified_chinese);\n\tsystem.out.format("%s 的本地化（%s）结果: %s\\n", date, locale.simplified_chinese, df.format(date));\n\tsystem.out.format("%s 的本地化（%s）结果: %s\\n", date, locale.simplified_chinese, df2.format(date));\n}\n\n\n\n# messageformat\n\nmessageformat 提供一种与语言无关的拼接消息的方式。通过这种拼接方式，将最终呈现返回给使用者。\n\npublic static void main(string[] args) {\n\tstring pattern1 = "{0}，你好！你于  {1} 消费  {2} 元。";\n\tstring pattern2 = "at {1,time,short} on {1,date,long}，{0} paid {2,number, currency}.";\n\tobject[] params = {"jack", new gregoriancalendar().gettime(), 8888};\n\tstring msg1 = messageformat.format(pattern1, params);\n\tmessageformat mf = new messageformat(pattern2, locale.us);\n\tstring msg2 = mf.format(params);\n\tsystem.out.println(msg1);\n\tsystem.out.println(msg2);\n}\n',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"JDK8 入门指南",frontmatter:{title:"JDK8 入门指南",categories:["编程","Java","JavaSE","高级特性"],tags:["Java","JavaSE","JDK8"],abbrlink:"b6bbdf5c",date:"2019-05-06T15:02:02.000Z",permalink:"/pages/8c8dd6/"},regularPath:"/02.%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/04.JDK8.html",relativePath:"02.高级特性/04.JDK8.md",key:"v-4d01f884",path:"/pages/8c8dd6/",headers:[{level:2,title:"Default Methods for Interfaces(接口的默认方法)",slug:"default-methods-for-interfaces-接口的默认方法",normalizedTitle:"default methods for interfaces(接口的默认方法)",charIndex:150},{level:2,title:"Lambda expressions(Lambda 表达式)",slug:"lambda-expressions-lambda-表达式",normalizedTitle:"lambda expressions(lambda 表达式)",charIndex:766},{level:2,title:"Functional Interfaces(函数接口)",slug:"functional-interfaces-函数接口",normalizedTitle:"functional interfaces(函数接口)",charIndex:1537},{level:2,title:"Method and Constructor References(方法和构造器引用)",slug:"method-and-constructor-references-方法和构造器引用",normalizedTitle:"method and constructor references(方法和构造器引用)",charIndex:2120},{level:2,title:"Lambda Scopes(Lambda 作用域)",slug:"lambda-scopes-lambda-作用域",normalizedTitle:"lambda scopes(lambda 作用域)",charIndex:3321},{level:3,title:"Accessing local variables(访问本地变量)",slug:"accessing-local-variables-访问本地变量",normalizedTitle:"accessing local variables(访问本地变量)",charIndex:3414},{level:3,title:"Accessing fields and static variables(访问成员变量和静态变量)",slug:"accessing-fields-and-static-variables-访问成员变量和静态变量",normalizedTitle:"accessing fields and static variables(访问成员变量和静态变量)",charIndex:4001},{level:3,title:"Accessing Default Interface Methods（访问默认的接口方法）",slug:"accessing-default-interface-methods-访问默认的接口方法",normalizedTitle:"accessing default interface methods（访问默认的接口方法）",charIndex:4521},{level:2,title:"Built-in Functional Interfaces(内置函数接口)",slug:"built-in-functional-interfaces-内置函数接口",normalizedTitle:"built-in functional interfaces(内置函数接口)",charIndex:4745},{level:3,title:"Predicates",slug:"predicates",normalizedTitle:"predicates",charIndex:5020},{level:3,title:"Functions",slug:"functions",normalizedTitle:"functions",charIndex:5428},{level:3,title:"Suppliers",slug:"suppliers",normalizedTitle:"suppliers",charIndex:5678},{level:3,title:"Consumers",slug:"consumers",normalizedTitle:"consumers",charIndex:5828},{level:3,title:"Comparators",slug:"comparators",normalizedTitle:"comparators",charIndex:6e3},{level:2,title:"Optionals",slug:"optionals",normalizedTitle:"optionals",charIndex:6327},{level:2,title:"Streams",slug:"streams",normalizedTitle:"streams",charIndex:6777},{level:3,title:"Filter",slug:"filter",normalizedTitle:"filter",charIndex:7451},{level:3,title:"Sorted",slug:"sorted",normalizedTitle:"sorted",charIndex:7711},{level:3,title:"Map",slug:"map",normalizedTitle:"map",charIndex:8052},{level:3,title:"Match",slug:"match",normalizedTitle:"match",charIndex:8359},{level:4,title:"Count",slug:"count",normalizedTitle:"count",charIndex:8897},{level:3,title:"Reduce",slug:"reduce",normalizedTitle:"reduce",charIndex:9095},{level:2,title:"Parallel Streams",slug:"parallel-streams",normalizedTitle:"parallel streams",charIndex:9375},{level:3,title:"Sequential Sort",slug:"sequential-sort",normalizedTitle:"sequential sort",charIndex:9692},{level:3,title:"Parallel Sort",slug:"parallel-sort",normalizedTitle:"parallel sort",charIndex:10010},{level:2,title:"Maps",slug:"maps",normalizedTitle:"maps",charIndex:10400},{level:2,title:"Date API",slug:"date-api",normalizedTitle:"date api",charIndex:11636},{level:3,title:"Clock",slug:"clock",normalizedTitle:"clock",charIndex:11741},{level:3,title:"Timezones",slug:"timezones",normalizedTitle:"timezones",charIndex:12089},{level:3,title:"LocalTime",slug:"localtime",normalizedTitle:"localtime",charIndex:12503},{level:3,title:"LocalDate",slug:"localdate",normalizedTitle:"localdate",charIndex:13329},{level:3,title:"LocalDateTime",slug:"localdatetime",normalizedTitle:"localdatetime",charIndex:14042},{level:2,title:"Annotations",slug:"annotations",normalizedTitle:"annotations",charIndex:15211},{level:3,title:"Variant 1: 使用容器注解 (老套路)",slug:"variant-1-使用容器注解-老套路",normalizedTitle:"variant 1: 使用容器注解 (老套路)",charIndex:15441},{level:3,title:"Variant 2: 使用 repeatable 注解 (新套路)",slug:"variant-2-使用-repeatable-注解-新套路",normalizedTitle:"variant 2: 使用 repeatable 注解 (新套路)",charIndex:15528},{level:2,title:"JDK8 升级常见问题",slug:"jdk8-升级常见问题",normalizedTitle:"jdk8 升级常见问题",charIndex:15},{level:3,title:"Intellij 中的 JDK 环境设置",slug:"intellij-中的-jdk-环境设置",normalizedTitle:"intellij 中的 jdk 环境设置",charIndex:16524},{level:4,title:"Settings",slug:"settings",normalizedTitle:"settings",charIndex:16548},{level:4,title:"Projcet Settings",slug:"projcet-settings",normalizedTitle:"projcet settings",charIndex:16710},{level:4,title:"Application",slug:"application",normalizedTitle:"application",charIndex:16750},{level:3,title:"Linux 环境修改",slug:"linux-环境修改",normalizedTitle:"linux 环境修改",charIndex:16864},{level:4,title:"修改环境变量",slug:"修改环境变量",normalizedTitle:"修改环境变量",charIndex:16878},{level:4,title:"修改 maven",slug:"修改-maven",normalizedTitle:"修改 maven",charIndex:17017},{level:4,title:"修改 server",slug:"修改-server",normalizedTitle:"修改 server",charIndex:17143},{level:3,title:"sun.* 包缺失问题",slug:"sun-包缺失问题",normalizedTitle:"sun.* 包缺失问题",charIndex:17269},{level:3,title:"默认安全策略修改",slug:"默认安全策略修改",normalizedTitle:"默认安全策略修改",charIndex:17537},{level:3,title:"JVM 参数调整",slug:"jvm-参数调整",normalizedTitle:"jvm 参数调整",charIndex:17689},{level:3,title:"字节码问题",slug:"字节码问题",normalizedTitle:"字节码问题",charIndex:18954},{level:3,title:"Java 连接 redis 启动报错 Error redis clients jedis HostAndPort cant resolve localhost address",slug:"java-连接-redis-启动报错-error-redis-clients-jedis-hostandport-cant-resolve-localhost-address",normalizedTitle:"java 连接 redis 启动报错 error redis clients jedis hostandport cant resolve localhost address",charIndex:19531},{level:3,title:"Resin 容器指定 JDK 1.8",slug:"resin-容器指定-jdk-1-8",normalizedTitle:"resin 容器指定 jdk 1.8",charIndex:19841},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:20181}],headersStr:"Default Methods for Interfaces(接口的默认方法) Lambda expressions(Lambda 表达式) Functional Interfaces(函数接口) Method and Constructor References(方法和构造器引用) Lambda Scopes(Lambda 作用域) Accessing local variables(访问本地变量) Accessing fields and static variables(访问成员变量和静态变量) Accessing Default Interface Methods（访问默认的接口方法） Built-in Functional Interfaces(内置函数接口) Predicates Functions Suppliers Consumers Comparators Optionals Streams Filter Sorted Map Match Count Reduce Parallel Streams Sequential Sort Parallel Sort Maps Date API Clock Timezones LocalTime LocalDate LocalDateTime Annotations Variant 1: 使用容器注解 (老套路) Variant 2: 使用 repeatable 注解 (新套路) JDK8 升级常见问题 Intellij 中的 JDK 环境设置 Settings Projcet Settings Application Linux 环境修改 修改环境变量 修改 maven 修改 server sun.* 包缺失问题 默认安全策略修改 JVM 参数调整 字节码问题 Java 连接 redis 启动报错 Error redis clients jedis HostAndPort cant resolve localhost address Resin 容器指定 JDK 1.8 参考资料",content:'# JDK8 入门指南\n\n> JDK8 升级常见问题章节是我个人的经验整理。其他内容基本翻译自 java8-tutorial\n> \n> 📦 本文以及示例源码已归档在 javacore\n> \n> 关键词：Stream、lambda、Optional、@FunctionalInterface\n\n\n# Default Methods for Interfaces(接口的默认方法)\n\nJava 8 使我们能够通过使用 default 关键字将非抽象方法实现添加到接口。这个功能也被称为虚拟扩展方法。\n\n这是我们的第一个例子：\n\ninterface Formula {\n    double calculate(int a);\n\n    default double sqrt(int a) {\n        return Math.sqrt(a);\n    }\n}\n\n\n除了抽象方法 calculate ，接口 Formula 还定义了默认方法 sqrt。具体类只需要执行抽象方法计算。默认的方法 sqrt 可以用于开箱即用。\n\nFormula formula = new Formula() {\n    @Override\n    public double calculate(int a) {\n        return sqrt(a * 100);\n    }\n};\n\nformula.calculate(100);     // 100.0\nformula.sqrt(16);           // 4.0\n\n\nFormula 被实现为一个匿名对象。代码非常冗长：用于 sqrt(a * 100) 这样简单的计算的 6 行代码。正如我们将在下一节中看到的，在 Java 8 中实现单个方法对象有更好的方法。\n\n\n# Lambda expressions(Lambda 表达式)\n\n让我们从一个简单的例子来说明如何在以前版本的 Java 中对字符串列表进行排序：\n\nList<String> names = Arrays.asList("peter", "anna", "mike", "xenia");\n\nCollections.sort(names, new Comparator<String>() {\n    @Override\n    public int compare(String a, String b) {\n        return b.compareTo(a);\n    }\n});\n\n\n静态工具方法 Collections.sort 为了对指定的列表进行排序，接受一个列表和一个比较器。您会发现自己经常需要创建匿名比较器并将其传递给排序方法。\n\nJava 8 使用更简短的 lambda 表达式来避免常常创建匿名对象的问题：\n\nCollections.sort(names, (String a, String b) -> {\n    return b.compareTo(a);\n});\n\n\n如您所见，这段代码比上段代码简洁很多。但是，还可以更加简洁：\n\nCollections.sort(names, (String a, String b) -> b.compareTo(a));\n\n\n这行代码中，你省去了花括号 {} 和 return 关键字。但是，这还不算完，它还可以再进一步简洁：\n\nnames.sort((a, b) -> b.compareTo(a));\n\n\n列表现在有一个 sort 方法。此外，java 编译器知道参数类型，所以你可以不指定入参的数据类型。让我们深入探讨如何使用 lambda 表达式。\n\n\n# Functional Interfaces(函数接口)\n\nlambda 表达式如何适应 Java 的类型系统？每个 lambda 对应一个由接口指定的类型。一个所谓的函数接口必须包含一个抽象方法声明。该类型的每个 lambda 表达式都将与此抽象方法匹配。由于默认方法不是抽象的，所以你可以自由地添加默认方法到你的函数接口。\n\n只要保证接口仅包含一个抽象方法，就可以使用任意的接口作为 lambda 表达式。为确保您的接口符合要求，您应该添加 @FunctionalInterface 注解。编译器注意到这个注解后，一旦您尝试在接口中添加第二个抽象方法声明，编译器就会抛出编译器错误。\n\n示例：\n\n@FunctionalInterface\ninterface Converter<F, T> {\n    T convert(F from);\n}\n\n\nConverter<String, Integer> converter = (from) -> Integer.valueOf(from);\nInteger converted = converter.convert("123");\nSystem.out.println(converted);    // 123\n\n\n请记住，如果 @FunctionalInterface 注解被省略，代码也是有效的。\n\n\n# Method and Constructor References(方法和构造器引用)\n\n上面的示例代码可以通过使用静态方法引用进一步简化：\n\nConverter<String, Integer> converter = Integer::valueOf;\nInteger converted = converter.convert("123");\nSystem.out.println(converted);   // 123\n\n\nJava 8 允许您通过 :: 关键字传递方法或构造函数的引用。上面的例子展示了如何引用一个静态方法。但是我们也可以引用对象方法：\n\nclass Something {\n    String startsWith(String s) {\n        return String.valueOf(s.charAt(0));\n    }\n}\n\n\nSomething something = new Something();\nConverter<String, String> converter = something::startsWith;\nString converted = converter.convert("Java");\nSystem.out.println(converted);    // "J"\n\n\n我们来观察一下 :: 关键字是如何作用于构造器的。首先，我们定义一个有多个构造器的示例类。\n\nclass Person {\n    String firstName;\n    String lastName;\n\n    Person() {}\n\n    Person(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n}\n\n\n接着，我们指定一个用于创建 Person 对象的 PersonFactory 接口。\n\ninterface PersonFactory<P extends Person> {\n    P create(String firstName, String lastName);\n}\n\n\n我们不是手动实现工厂，而是通过构造引用将所有东西粘合在一起：\n\nPersonFactory<Person> personFactory = Person::new;\nPerson person = personFactory.create("Peter", "Parker");\n\n\n我们通过 Person::new 来创建一个 Person 构造器的引用。Java 编译器会根据PersonFactory.create 的签名自动匹配正确的构造器。\n\n\n# Lambda Scopes(Lambda 作用域)\n\n从 lambda 表达式访问外部作用域变量与匿名对象非常相似。您可以访问本地外部作用域的常量以及实例的成员变量和静态变量。\n\n\n# Accessing local variables(访问本地变量)\n\n我们可以访问 lambda 表达式作用域外部的常量：\n\nfinal int num = 1;\nConverter<Integer, String> stringConverter =\n        (from) -> String.valueOf(from + num);\n\nstringConverter.convert(2);     // 3\n\n\n不同于匿名对象的是：这个变量 num 不是一定要被 final 修饰。下面的代码一样合法：\n\nint num = 1;\nConverter<Integer, String> stringConverter =\n        (from) -> String.valueOf(from + num);\n\nstringConverter.convert(2);     // 3\n\n\n但是，num 必须是隐式常量的。下面的代码不能编译通过：\n\nint num = 1;\nConverter<Integer, String> stringConverter =\n        (from) -> String.valueOf(from + num);\nnum = 3;\n\n\n此外，在 lambda 表达式中对 num 做写操作也是被禁止的。\n\n\n# Accessing fields and static variables(访问成员变量和静态变量)\n\n与局部变量相比，我们既可以在 lambda 表达式中读写实例的成员变量，也可以读写实例的静态变量。这种行为在匿名对象中是众所周知的。\n\nclass Lambda4 {\n    static int outerStaticNum;\n    int outerNum;\n\n    void testScopes() {\n        Converter<Integer, String> stringConverter1 = (from) -> {\n            outerNum = 23;\n            return String.valueOf(from);\n        };\n\n        Converter<Integer, String> stringConverter2 = (from) -> {\n            outerStaticNum = 72;\n            return String.valueOf(from);\n        };\n    }\n}\n\n\n\n# Accessing Default Interface Methods（访问默认的接口方法）\n\n还记得第一节的 formula 例子吗？ Formula 接口定义了一个默认方法 sqrt，它可以被每个 formula 实例（包括匿名对象）访问。这个特性不适用于 lambda 表达式。\n\n默认方法不能被 lambda 表达式访问。下面的代码不能编译通过：\n\nFormula formula = (a) -> sqrt(a * 100);\n\n\n\n# Built-in Functional Interfaces(内置函数接口)\n\nJDK 1.8 API 包含许多内置的功能接口。它们中的一些在较早的 Java 版本（比如 Comparator 或 Runnable）中是众所周知的。这些现有的接口通过 @FunctionalInterfaceannotation 注解被扩展为支持 Lambda。\n\n但是，Java 8 API 也提供了不少新的函数接口。其中一些新接口在 Google Guava 库中是众所周知的。即使您熟悉这个库，也应该密切关注如何通过一些有用的方法扩展来扩展这些接口。\n\n\n# Predicates\n\nPredicate 是只有一个参数的布尔值函数。该接口包含各种默认方法，用于将谓词组合成复杂的逻辑术语（与、或、非）\n\nPredicate<String> predicate = (s) -> s.length() > 0;\n\npredicate.test("foo");              // true\npredicate.negate().test("foo");     // false\n\nPredicate<Boolean> nonNull = Objects::nonNull;\nPredicate<Boolean> isNull = Objects::isNull;\n\nPredicate<String> isEmpty = String::isEmpty;\nPredicate<String> isNotEmpty = isEmpty.negate();\n\n\n\n# Functions\n\nFunction 接受一个参数并产生一个结果。可以使用默认方法将多个函数链接在一起（compose、andThen）。\n\nFunction<String, Integer> toInteger = Integer::valueOf;\nFunction<String, String> backToString = toInteger.andThen(String::valueOf);\n\nbackToString.apply("123");     // "123"\n\n\n\n# Suppliers\n\nSupplier 产生一个泛型结果。与 Function 不同，Supplier 不接受参数。\n\nSupplier<Person> personSupplier = Person::new;\npersonSupplier.get();   // new Person\n\n\n\n# Consumers\n\nConsumer 表示要在一个输入参数上执行的操作。\n\nConsumer<Person> greeter = (p) -> System.out.println("Hello, " + p.firstName);\ngreeter.accept(new Person("Luke", "Skywalker"));\n\n\n\n# Comparators\n\n比较器在老版本的 Java 中是众所周知的。 Java 8 为接口添加了各种默认方法。\n\nComparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);\n\nPerson p1 = new Person("John", "Doe");\nPerson p2 = new Person("Alice", "Wonderland");\n\ncomparator.compare(p1, p2);             // > 0\ncomparator.reversed().compare(p1, p2);  // < 0\n\n\n\n# Optionals\n\nOptional 不是功能性接口，而是防止 NullPointerException 的好工具。这是下一节的一个重要概念，所以让我们快速看看 Optional 是如何工作的。\n\nOptional 是一个简单的容器，其值可以是 null 或非 null。想想一个可能返回一个非空结果的方法，但有时候什么都不返回。不是返回 null，而是返回 Java 8 中的 Optional。\n\nOptional<String> optional = Optional.of("bam");\n\noptional.isPresent();           // true\noptional.get();                 // "bam"\noptional.orElse("fallback");    // "bam"\n\noptional.ifPresent((s) -> System.out.println(s.charAt(0)));     // "b"\n\n\n\n# Streams\n\njava.util.Stream 表示可以在其上执行一个或多个操作的元素序列。流操作是中间或终端。当终端操作返回一个特定类型的结果时，中间操作返回流本身，所以你可以链接多个方法调用。流在源上创建，例如一个 java.util.Collection 像列表或集合（不支持映射）。流操作既可以按顺序执行，也可以并行执行。\n\n> 流是非常强大的，所以，我写了一个独立的 Java8 Streams 教程 。您还应该查看 Sequent，将其作为 Web 的类似库。\n\n我们先来看看顺序流如何工作。首先，我们以字符串列表的形式创建一个示例源代码：\n\nList<String> stringCollection = new ArrayList<>();\nstringCollection.add("ddd2");\nstringCollection.add("aaa2");\nstringCollection.add("bbb1");\nstringCollection.add("aaa1");\nstringCollection.add("bbb3");\nstringCollection.add("ccc");\nstringCollection.add("bbb2");\nstringCollection.add("ddd1");\n\n\nJava 8 中的集合已被扩展，因此您可以通过调用 Collection.stream() 或Collection.parallelStream() 来简单地创建流。以下各节介绍最常见的流操作。\n\n\n# Filter\n\n过滤器接受一个谓词来过滤流的所有元素。这个操作是中间的，使我们能够调用另一个流操作（forEach）的结果。 ForEach 接受一个消费者被执行的过滤流中的每个元素。 ForEach 是一个终端操作。它是无效的，所以我们不能调用另一个流操作。\n\nstringCollection\n    .stream()\n    .filter((s) -> s.startsWith("a"))\n    .forEach(System.out::println);\n\n// "aaa2", "aaa1"\n\n\n\n# Sorted\n\n排序是一个中间操作，返回流的排序视图。元素按自然顺序排序，除非您传递自定义比较器。\n\nstringCollection\n    .stream()\n    .sorted()\n    .filter((s) -> s.startsWith("a"))\n    .forEach(System.out::println);\n\n// "aaa1", "aaa2"\n\n\n请记住，排序只会创建流的排序视图，而不会操纵支持的集合的排序。 stringCollection 的排序是不变的：\n\nSystem.out.println(stringCollection);\n// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1\n\n\n\n# Map\n\n中间操作映射通过给定函数将每个元素转换为另一个对象。以下示例将每个字符串转换为大写字母字符串。但是您也可以使用 map 将每个对象转换为另一种类型。结果流的泛型类型取决于您传递给 map 的函数的泛型类型。\n\nstringCollection\n    .stream()\n    .map(String::toUpperCase)\n    .sorted((a, b) -> b.compareTo(a))\n    .forEach(System.out::println);\n\n// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"\n\n\n\n# Match\n\n可以使用各种匹配操作来检查某个谓词是否与流匹配。所有这些操作都是终端并返回布尔结果。\n\nboolean anyStartsWithA =\n    stringCollection\n        .stream()\n        .anyMatch((s) -> s.startsWith("a"));\n\nSystem.out.println(anyStartsWithA);      // true\n\nboolean allStartsWithA =\n    stringCollection\n        .stream()\n        .allMatch((s) -> s.startsWith("a"));\n\nSystem.out.println(allStartsWithA);      // false\n\nboolean noneStartsWithZ =\n    stringCollection\n        .stream()\n        .noneMatch((s) -> s.startsWith("z"));\n\nSystem.out.println(noneStartsWithZ);      // true\n\n\n# Count\n\nCount 是一个终端操作，返回流中元素的个数。\n\nlong startsWithB =\n    stringCollection\n        .stream()\n        .filter((s) -> s.startsWith("b"))\n        .count();\n\nSystem.out.println(startsWithB);    // 3\n\n\n\n# Reduce\n\n该终端操作使用给定的功能对流的元素进行缩减。结果是一个 Optional 持有缩小后的值。\n\nOptional<String> reduced =\n    stringCollection\n        .stream()\n        .sorted()\n        .reduce((s1, s2) -> s1 + "#" + s2);\n\nreduced.ifPresent(System.out::println);\n// "aaa1##aaa2##bbb1##bbb2##bbb3##ccc##ddd1##ddd2"\n\n\n\n# Parallel Streams\n\n如上所述，流可以是顺序的也可以是并行的。顺序流上的操作在单个线程上执行，而并行流上的操作在多个线程上同时执行。\n\n以下示例演示了通过使用并行流提高性能是多么容易。\n\n首先，我们创建一个较大的独特元素的列表：\n\nint max = 1000000;\nList<String> values = new ArrayList<>(max);\nfor (int i = 0; i < max; i++) {\n    UUID uuid = UUID.randomUUID();\n    values.add(uuid.toString());\n}\n\n\n现在我们测量对这个集合进行排序所花费的时间。\n\n\n# Sequential Sort\n\nlong t0 = System.nanoTime();\n\nlong count = values.stream().sorted().count();\nSystem.out.println(count);\n\nlong t1 = System.nanoTime();\n\nlong millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\nSystem.out.println(String.format("sequential sort took: %d ms", millis));\n\n// sequential sort took: 899 ms\n\n\n\n# Parallel Sort\n\nlong t0 = System.nanoTime();\n\nlong count = values.parallelStream().sorted().count();\nSystem.out.println(count);\n\nlong t1 = System.nanoTime();\n\nlong millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\nSystem.out.println(String.format("parallel sort took: %d ms", millis));\n\n// parallel sort took: 472 ms\n\n\n如你所见，两个代码段差不多，但是并行排序快了近 50%。你所需做的仅仅是将 stream() 改为 parallelStream() 。\n\n\n# Maps\n\n如前所述，map 不直接支持流。Map 接口本身没有可用的 stream() 方法，但是你可以通过 map.keySet().stream() 、 map.values().stream() 和 map.entrySet().stream() 创建指定的流。\n\n此外，map 支持各种新的、有用的方法来处理常见任务。\n\nMap<Integer, String> map = new HashMap<>();\n\nfor (int i = 0; i < 10; i++) {\n    map.putIfAbsent(i, "val" + i);\n}\n\nmap.forEach((id, val) -> System.out.println(val));\n\n\n上面的代码应该是自我解释的：putIfAbsent 阻止我们写入额外的空值检查；forEach 接受消费者为 map 的每个值实现操作。\n\n这个例子展示了如何利用函数来计算 map 上的代码：\n\nmap.computeIfPresent(3, (num, val) -> val + num);\nmap.get(3);             // val33\n\nmap.computeIfPresent(9, (num, val) -> null);\nmap.containsKey(9);     // false\n\nmap.computeIfAbsent(23, num -> "val" + num);\nmap.containsKey(23);    // true\n\nmap.computeIfAbsent(3, num -> "bam");\nmap.get(3);             // val33\n\n\n接下来，我们学习如何删除给定键的条目，只有当前键映射到给定值时：\n\nmap.remove(3, "val3");\nmap.get(3);             // val33\n\nmap.remove(3, "val33");\nmap.get(3);             // null\n\n\n另一个有用方法：\n\nmap.getOrDefault(42, "not found");  // not found\n\n\n合并一个 map 的 entry 很简单：\n\nmap.merge(9, "val9", (value, newValue) -> value.concat(newValue));\nmap.get(9);             // val9\n\nmap.merge(9, "concat", (value, newValue) -> value.concat(newValue));\nmap.get(9);             // val9concat\n\n\n如果不存在该键的条目，合并或者将键/值放入 map 中；否则将调用合并函数来更改现有值。\n\n\n# Date API\n\nJava 8 在 java.time 包下新增了一个全新的日期和时间 API。新的日期 API 与 Joda-Time 库相似，但不一样。以下示例涵盖了此新 API 的最重要部分。\n\n\n# Clock\n\nClock 提供对当前日期和时间的访问。Clock 知道一个时区，可以使用它来代替 System.currentTimeMillis() ，获取从 Unix EPOCH 开始的以毫秒为单位的当前时间。时间线上的某一时刻也由类 Instant 表示。 Instants 可以用来创建遗留的 java.util.Date 对象。\n\nClock clock = Clock.systemDefaultZone();\nlong millis = clock.millis();\n\nInstant instant = clock.instant();\nDate legacyDate = Date.from(instant);   // legacy java.util.Date\n\n\n\n# Timezones\n\n时区由 ZoneId 表示。他们可以很容易地通过静态工厂方法访问。时区定义了某一时刻和当地日期、时间之间转换的重要偏移量。\n\nSystem.out.println(ZoneId.getAvailableZoneIds());\n// prints all available timezone ids\n\nZoneId zone1 = ZoneId.of("Europe/Berlin");\nZoneId zone2 = ZoneId.of("Brazil/East");\nSystem.out.println(zone1.getRules());\nSystem.out.println(zone2.getRules());\n\n// ZoneRules[currentStandardOffset=+01:00]\n// ZoneRules[currentStandardOffset=-03:00]\n\n\n\n# LocalTime\n\nLocalTime 代表没有时区的时间，例如晚上 10 点或 17:30:15。以下示例为上面定义的时区创建两个本地时间。然后我们比较两次，并计算两次之间的小时和分钟的差异。\n\nLocalTime now1 = LocalTime.now(zone1);\nLocalTime now2 = LocalTime.now(zone2);\n\nSystem.out.println(now1.isBefore(now2));  // false\n\nlong hoursBetween = ChronoUnit.HOURS.between(now1, now2);\nlong minutesBetween = ChronoUnit.MINUTES.between(now1, now2);\n\nSystem.out.println(hoursBetween);       // -3\nSystem.out.println(minutesBetween);     // -239\n\n\nLocalTime 带有各种工厂方法，以简化新实例的创建，包括解析时间字符串。\n\nLocalTime late = LocalTime.of(23, 59, 59);\nSystem.out.println(late);       // 23:59:59\n\nDateTimeFormatter germanFormatter =\n    DateTimeFormatter\n        .ofLocalizedTime(FormatStyle.SHORT)\n        .withLocale(Locale.GERMAN);\n\nLocalTime leetTime = LocalTime.parse("13:37", germanFormatter);\nSystem.out.println(leetTime);   // 13:37\n\n\n\n# LocalDate\n\nLocalDate 表示不同的日期，例如：2014 年 3 月 11 日。它是不可变的，并且与 LocalTime 完全类似。该示例演示如何通过加减日、月或年来计算新日期。请记住，每个操作都会返回一个新的实例。\n\nLocalDate today = LocalDate.now();\nLocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);\nLocalDate yesterday = tomorrow.minusDays(2);\n\nLocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);\nDayOfWeek dayOfWeek = independenceDay.getDayOfWeek();\nSystem.out.println(dayOfWeek);    // FRIDAY\n\n\n从一个字符串中解析出 LocalDate 对象，和解析 LocalTime 一样的简单：\n\nDateTimeFormatter germanFormatter =\n    DateTimeFormatter\n        .ofLocalizedDate(FormatStyle.MEDIUM)\n        .withLocale(Locale.GERMAN);\n\nLocalDate xmas = LocalDate.parse("24.12.2014", germanFormatter);\nSystem.out.println(xmas);   // 2014-12-24\n\n\n\n# LocalDateTime\n\nLocalDateTime 表示日期时间。它将日期和时间组合成一个实例。 LocalDateTime 是不可变的，其作用类似于 LocalTime 和 LocalDate。我们可以利用方法去获取日期时间中某个单位的值。\n\nLocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);\n\nDayOfWeek dayOfWeek = sylvester.getDayOfWeek();\nSystem.out.println(dayOfWeek);      // WEDNESDAY\n\nMonth month = sylvester.getMonth();\nSystem.out.println(month);          // DECEMBER\n\nlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);\nSystem.out.println(minuteOfDay);    // 1439\n\n\n通过一个时区的附加信息可以转为一个实例。这个实例很容易转为java.util.Date 类型。\n\nInstant instant = sylvester\n        .atZone(ZoneId.systemDefault())\n        .toInstant();\n\nDate legacyDate = Date.from(instant);\nSystem.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014\n\n\n日期时间的格式化类似于 Date 或 Time。我们可以使用自定义模式创建格式化程序，而不是使用预定义的格式。\n\nDateTimeFormatter formatter =\n    DateTimeFormatter\n        .ofPattern("MMM dd, yyyy - HH:mm");\n\nLocalDateTime parsed = LocalDateTime.parse("Nov 03, 2014 - 07:13", formatter);\nString string = formatter.format(parsed);\nSystem.out.println(string);     // Nov 03, 2014 - 07:13\n\n\n不同于 java.text.NumberFormat ， DateTimeFormatter 是不可变且线程安全的 。\n\n更多关于日期格式化的内容可以参考这里.\n\n\n# Annotations\n\nJava 8 中的注释是可重复的。让我们直接看一个例子来解决这个问题。\n\n首先，我们定义一个包含实际注释数组的外层注释：\n\n@interface Hints {\n    Hint[] value();\n}\n\n@Repeatable(Hints.class)\n@interface Hint {\n    String value();\n}\n\n\nJava8 允许我们通过使用 @Repeatable 注解来引入多个同类型的注解。\n\n\n# Variant 1: 使用容器注解 (老套路)\n\n@Hints({@Hint("hint1"), @Hint("hint2")})\nclass Person {}\n\n\n\n# Variant 2: 使用 repeatable 注解 (新套路)\n\n@Hint("hint1")\n@Hint("hint2")\nclass Person {}\n\n\n使用场景 2，Java 编译器隐式地设置了 @Hints 注解。\n\n这对于通过反射来读取注解信息很重要。\n\nHint hint = Person.class.getAnnotation(Hint.class);\nSystem.out.println(hint);                   // null\n\nHints hints1 = Person.class.getAnnotation(Hints.class);\nSystem.out.println(hints1.value().length);  // 2\n\nHint[] hints2 = Person.class.getAnnotationsByType(Hint.class);\nSystem.out.println(hints2.length);          // 2\n\n\n尽管，我们从没有在 Person 类上声明 @Hints 注解，但是仍可以通过getAnnotation(Hints.class) 读取它。然而，更便利的方式是 getAnnotationsByType ，它可以直接访问所有 @Hint 注解。\n\n此外，Java 8 中的注释使用扩展了两个新的目标：\n\n@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})\n@interface MyAnnotation {}\n\n\n水平线以上为 java8-tutorial 翻译内容。\n\n----------------------------------------\n\n\n# JDK8 升级常见问题\n\n> JDK8 发布很久了，它提供了许多吸引人的新特性，能够提高编程效率。\n> \n> 如果是新的项目，使用 JDK8 当然是最好的选择。但是，对于一些老的项目，升级到 JDK8 则存在一些兼容性问题，是否升级需要酌情考虑。\n> \n> 近期，我在工作中遇到一个任务，将部门所有项目的 JDK 版本升级到 1.8 （老版本大多是 1.6）。在这个过程中，遇到一些问题点，并结合在网上看到的坑，在这里总结一下。\n\n\n# Intellij 中的 JDK 环境设置\n\n# Settings\n\n点击 File > Settings > Java Compiler\n\nProject bytecode version 选择 1.8\n\n点击 File > Settings > Build Tools > Maven > Importing\n\n选择 JDK for importer 为 1.8\n\n# Projcet Settings\n\nProject SDK 选择 1.8\n\n# Application\n\n如果 web 应用的启动方式为 Application ，需要修改 JRE\n\n点击 Run/Debug Configurations > Configuration\n\n选择 JRE 为 1.8\n\n\n# Linux 环境修改\n\n# 修改环境变量\n\n修改 /etc/profile 中的 JAVA_HOME，设置 为 jdk8 所在路径。\n\n修改后，执行 source /etc/profile 生效。\n\n编译、发布脚本中如果有 export JAVA_HOME ，需要注意，需要使用 jdk8 的路径。\n\n# 修改 maven\n\nsettings.xml 中 profile 的激活条件如果是 jdk，需要修改一下 jdk 版本\n\n<activation>\n  <jdk>1.8</jdk> \x3c!-- 修改为 1.8 --\x3e\n</activation>\n\n\n# 修改 server\n\n修改 server 中的 javac 版本，以 resin 为例：\n\n修改 resin 配置文件中的 javac 参数。\n\n<javac compiler="internal" args="-source 1.8"/>\n\n\n\n# sun.* 包缺失问题\n\nJDK8 不再提供 sun.* 包供开发者使用，因为这些接口不是公共接口，不能保证在所有 Java 兼容的平台上工作。\n\n使用了这些 API 的程序如果要升级到 JDK 1.8 需要寻求替代方案。\n\n虽然，也可以自己导入包含 sun.* 接口 jar 包到 classpath 目录，但这不是一个好的做法。\n\n需要详细了解为什么不要使用 sun.* ，可以参考官方文档：Why Developers Should Not Write Programs That Call \'sun\' Packages\n\n\n# 默认安全策略修改\n\n升级后估计有些小伙伴在使用不安全算法时可能会发生错误，so，支持不安全算法还是有必要的\n\n找到$JAVA_HOME 下 jre/lib/security/java.security ，将禁用的算法设置为空：jdk.certpath.disabledAlgorithms= 。\n\n\n# JVM 参数调整\n\n在 jdk8 中，PermSize 相关的参数已经不被使用：\n\n-XX:MaxPermSize=size\n\nSets the maximum permanent generation space size (in bytes). This option was deprecated in JDK 8, and superseded by the -XX:MaxMetaspaceSize option.\n\n-XX:PermSize=size\n\nSets the space (in bytes) allocated to the permanent generation that triggers a garbage collection if it is exceeded. This option was deprecated un JDK 8, and superseded by the -XX:MetaspaceSize option.\n\n\nJDK8 中再也没有 PermGen 了。其中的某些部分，如被 intern 的字符串，在 JDK7 中已经移到了普通堆里。其余结构在 JDK8 中会被移到称作“Metaspace”的本机内存区中，该区域在默认情况下会自动生长，也会被垃圾回收。它有两个标记：MetaspaceSize 和 MaxMetaspaceSize。\n\n-XX:MetaspaceSize=size\n\n> Sets the size of the allocated class metadata space that will trigger a garbage collection the first time it is exceeded. This threshold for a garbage collection is increased or decreased depending on the amount of metadata used. The default size depends on the platform.\n\n-XX:MaxMetaspaceSize=size\n\n> Sets the maximum amount of native memory that can be allocated for class metadata. By default, the size is not limited. The amount of metadata for an application depends on the application itself, other running applications, and the amount of memory available on the system.\n\n以下示例显示如何将类类元数据的上限设置为 256 MB：\n\nXX:MaxMetaspaceSize=256m\n\n\n# 字节码问题\n\nASM 5.0 beta 开始支持 JDK8\n\n字节码错误\n\nCaused by: java.io.IOException: invalid constant type: 15\n\tat javassist.bytecode.ConstPool.readOne(ConstPool.java:1113)\n\n\n * 查找组件用到了 mvel，mvel 为了提高效率进行了字节码优化，正好碰上 JDK8 死穴，所以需要升级。\n\n<dependency>\n  <groupId>org.mvel</groupId>\n  <artifactId>mvel2</artifactId>\n  <version>2.2.7.Final</version>\n</dependency>\n\n\n * javassist\n\n<dependency>\n  <groupId>org.javassist</groupId>\n  <artifactId>javassist</artifactId>\n  <version>3.18.1-GA</version>\n</dependency>\n\n\n> 注意\n> \n> 有些部署工具不会删除旧版本 jar 包，所以可以尝试手动删除老版本 jar 包。\n\nhttp://asm.ow2.org/history.html\n\n\n# Java 连接 redis 启动报错 Error redis clients jedis HostAndPort cant resolve localhost address\n\n错误环境: 本地 window 开发环境没有问题。上到 Linux 环境,启动出现问题。 错误信息: Error redis clients jedis HostAndPort cant resolve localhost address\n\n解决办法:\n\n（1）查看 Linux 系统的主机名\n\n# hostname\ntemplate\n\n\n（2）查看/etc/hosts 文件中是否有 127.0.0.1 对应主机名，如果没有则添加\n\n\n# Resin 容器指定 JDK 1.8\n\n如果 resin 容器原来版本低于 JDK1.8，运行 JDK 1.8 编译的 web app 时，可能会提示错误：\n\njava.lang.UnsupportedClassVersionError: PR/Sort : Unsupported major.minor version 52.0\n\n\n解决方法就是，使用 JDK 1.8 要重新编译一下。然后，我在部署时出现过编译后仍报错的情况，重启一下服务器后，问题解决，不知是什么原因。\n\n./configure --prefix=/usr/local/resin  --with-java=/usr/local/jdk1.8.0_121\nmake & make install\n\n\n\n# 参考资料\n\n * java8-tutorial\n * Compatibility Guide for JDK 8\n * Compatibility Guide for JDK 8 中文翻译\n * Why Developers Should Not Write Programs That Call \'sun\' Packages',normalizedContent:'# jdk8 入门指南\n\n> jdk8 升级常见问题章节是我个人的经验整理。其他内容基本翻译自 java8-tutorial\n> \n> 📦 本文以及示例源码已归档在 javacore\n> \n> 关键词：stream、lambda、optional、@functionalinterface\n\n\n# default methods for interfaces(接口的默认方法)\n\njava 8 使我们能够通过使用 default 关键字将非抽象方法实现添加到接口。这个功能也被称为虚拟扩展方法。\n\n这是我们的第一个例子：\n\ninterface formula {\n    double calculate(int a);\n\n    default double sqrt(int a) {\n        return math.sqrt(a);\n    }\n}\n\n\n除了抽象方法 calculate ，接口 formula 还定义了默认方法 sqrt。具体类只需要执行抽象方法计算。默认的方法 sqrt 可以用于开箱即用。\n\nformula formula = new formula() {\n    @override\n    public double calculate(int a) {\n        return sqrt(a * 100);\n    }\n};\n\nformula.calculate(100);     // 100.0\nformula.sqrt(16);           // 4.0\n\n\nformula 被实现为一个匿名对象。代码非常冗长：用于 sqrt(a * 100) 这样简单的计算的 6 行代码。正如我们将在下一节中看到的，在 java 8 中实现单个方法对象有更好的方法。\n\n\n# lambda expressions(lambda 表达式)\n\n让我们从一个简单的例子来说明如何在以前版本的 java 中对字符串列表进行排序：\n\nlist<string> names = arrays.aslist("peter", "anna", "mike", "xenia");\n\ncollections.sort(names, new comparator<string>() {\n    @override\n    public int compare(string a, string b) {\n        return b.compareto(a);\n    }\n});\n\n\n静态工具方法 collections.sort 为了对指定的列表进行排序，接受一个列表和一个比较器。您会发现自己经常需要创建匿名比较器并将其传递给排序方法。\n\njava 8 使用更简短的 lambda 表达式来避免常常创建匿名对象的问题：\n\ncollections.sort(names, (string a, string b) -> {\n    return b.compareto(a);\n});\n\n\n如您所见，这段代码比上段代码简洁很多。但是，还可以更加简洁：\n\ncollections.sort(names, (string a, string b) -> b.compareto(a));\n\n\n这行代码中，你省去了花括号 {} 和 return 关键字。但是，这还不算完，它还可以再进一步简洁：\n\nnames.sort((a, b) -> b.compareto(a));\n\n\n列表现在有一个 sort 方法。此外，java 编译器知道参数类型，所以你可以不指定入参的数据类型。让我们深入探讨如何使用 lambda 表达式。\n\n\n# functional interfaces(函数接口)\n\nlambda 表达式如何适应 java 的类型系统？每个 lambda 对应一个由接口指定的类型。一个所谓的函数接口必须包含一个抽象方法声明。该类型的每个 lambda 表达式都将与此抽象方法匹配。由于默认方法不是抽象的，所以你可以自由地添加默认方法到你的函数接口。\n\n只要保证接口仅包含一个抽象方法，就可以使用任意的接口作为 lambda 表达式。为确保您的接口符合要求，您应该添加 @functionalinterface 注解。编译器注意到这个注解后，一旦您尝试在接口中添加第二个抽象方法声明，编译器就会抛出编译器错误。\n\n示例：\n\n@functionalinterface\ninterface converter<f, t> {\n    t convert(f from);\n}\n\n\nconverter<string, integer> converter = (from) -> integer.valueof(from);\ninteger converted = converter.convert("123");\nsystem.out.println(converted);    // 123\n\n\n请记住，如果 @functionalinterface 注解被省略，代码也是有效的。\n\n\n# method and constructor references(方法和构造器引用)\n\n上面的示例代码可以通过使用静态方法引用进一步简化：\n\nconverter<string, integer> converter = integer::valueof;\ninteger converted = converter.convert("123");\nsystem.out.println(converted);   // 123\n\n\njava 8 允许您通过 :: 关键字传递方法或构造函数的引用。上面的例子展示了如何引用一个静态方法。但是我们也可以引用对象方法：\n\nclass something {\n    string startswith(string s) {\n        return string.valueof(s.charat(0));\n    }\n}\n\n\nsomething something = new something();\nconverter<string, string> converter = something::startswith;\nstring converted = converter.convert("java");\nsystem.out.println(converted);    // "j"\n\n\n我们来观察一下 :: 关键字是如何作用于构造器的。首先，我们定义一个有多个构造器的示例类。\n\nclass person {\n    string firstname;\n    string lastname;\n\n    person() {}\n\n    person(string firstname, string lastname) {\n        this.firstname = firstname;\n        this.lastname = lastname;\n    }\n}\n\n\n接着，我们指定一个用于创建 person 对象的 personfactory 接口。\n\ninterface personfactory<p extends person> {\n    p create(string firstname, string lastname);\n}\n\n\n我们不是手动实现工厂，而是通过构造引用将所有东西粘合在一起：\n\npersonfactory<person> personfactory = person::new;\nperson person = personfactory.create("peter", "parker");\n\n\n我们通过 person::new 来创建一个 person 构造器的引用。java 编译器会根据personfactory.create 的签名自动匹配正确的构造器。\n\n\n# lambda scopes(lambda 作用域)\n\n从 lambda 表达式访问外部作用域变量与匿名对象非常相似。您可以访问本地外部作用域的常量以及实例的成员变量和静态变量。\n\n\n# accessing local variables(访问本地变量)\n\n我们可以访问 lambda 表达式作用域外部的常量：\n\nfinal int num = 1;\nconverter<integer, string> stringconverter =\n        (from) -> string.valueof(from + num);\n\nstringconverter.convert(2);     // 3\n\n\n不同于匿名对象的是：这个变量 num 不是一定要被 final 修饰。下面的代码一样合法：\n\nint num = 1;\nconverter<integer, string> stringconverter =\n        (from) -> string.valueof(from + num);\n\nstringconverter.convert(2);     // 3\n\n\n但是，num 必须是隐式常量的。下面的代码不能编译通过：\n\nint num = 1;\nconverter<integer, string> stringconverter =\n        (from) -> string.valueof(from + num);\nnum = 3;\n\n\n此外，在 lambda 表达式中对 num 做写操作也是被禁止的。\n\n\n# accessing fields and static variables(访问成员变量和静态变量)\n\n与局部变量相比，我们既可以在 lambda 表达式中读写实例的成员变量，也可以读写实例的静态变量。这种行为在匿名对象中是众所周知的。\n\nclass lambda4 {\n    static int outerstaticnum;\n    int outernum;\n\n    void testscopes() {\n        converter<integer, string> stringconverter1 = (from) -> {\n            outernum = 23;\n            return string.valueof(from);\n        };\n\n        converter<integer, string> stringconverter2 = (from) -> {\n            outerstaticnum = 72;\n            return string.valueof(from);\n        };\n    }\n}\n\n\n\n# accessing default interface methods（访问默认的接口方法）\n\n还记得第一节的 formula 例子吗？ formula 接口定义了一个默认方法 sqrt，它可以被每个 formula 实例（包括匿名对象）访问。这个特性不适用于 lambda 表达式。\n\n默认方法不能被 lambda 表达式访问。下面的代码不能编译通过：\n\nformula formula = (a) -> sqrt(a * 100);\n\n\n\n# built-in functional interfaces(内置函数接口)\n\njdk 1.8 api 包含许多内置的功能接口。它们中的一些在较早的 java 版本（比如 comparator 或 runnable）中是众所周知的。这些现有的接口通过 @functionalinterfaceannotation 注解被扩展为支持 lambda。\n\n但是，java 8 api 也提供了不少新的函数接口。其中一些新接口在 google guava 库中是众所周知的。即使您熟悉这个库，也应该密切关注如何通过一些有用的方法扩展来扩展这些接口。\n\n\n# predicates\n\npredicate 是只有一个参数的布尔值函数。该接口包含各种默认方法，用于将谓词组合成复杂的逻辑术语（与、或、非）\n\npredicate<string> predicate = (s) -> s.length() > 0;\n\npredicate.test("foo");              // true\npredicate.negate().test("foo");     // false\n\npredicate<boolean> nonnull = objects::nonnull;\npredicate<boolean> isnull = objects::isnull;\n\npredicate<string> isempty = string::isempty;\npredicate<string> isnotempty = isempty.negate();\n\n\n\n# functions\n\nfunction 接受一个参数并产生一个结果。可以使用默认方法将多个函数链接在一起（compose、andthen）。\n\nfunction<string, integer> tointeger = integer::valueof;\nfunction<string, string> backtostring = tointeger.andthen(string::valueof);\n\nbacktostring.apply("123");     // "123"\n\n\n\n# suppliers\n\nsupplier 产生一个泛型结果。与 function 不同，supplier 不接受参数。\n\nsupplier<person> personsupplier = person::new;\npersonsupplier.get();   // new person\n\n\n\n# consumers\n\nconsumer 表示要在一个输入参数上执行的操作。\n\nconsumer<person> greeter = (p) -> system.out.println("hello, " + p.firstname);\ngreeter.accept(new person("luke", "skywalker"));\n\n\n\n# comparators\n\n比较器在老版本的 java 中是众所周知的。 java 8 为接口添加了各种默认方法。\n\ncomparator<person> comparator = (p1, p2) -> p1.firstname.compareto(p2.firstname);\n\nperson p1 = new person("john", "doe");\nperson p2 = new person("alice", "wonderland");\n\ncomparator.compare(p1, p2);             // > 0\ncomparator.reversed().compare(p1, p2);  // < 0\n\n\n\n# optionals\n\noptional 不是功能性接口，而是防止 nullpointerexception 的好工具。这是下一节的一个重要概念，所以让我们快速看看 optional 是如何工作的。\n\noptional 是一个简单的容器，其值可以是 null 或非 null。想想一个可能返回一个非空结果的方法，但有时候什么都不返回。不是返回 null，而是返回 java 8 中的 optional。\n\noptional<string> optional = optional.of("bam");\n\noptional.ispresent();           // true\noptional.get();                 // "bam"\noptional.orelse("fallback");    // "bam"\n\noptional.ifpresent((s) -> system.out.println(s.charat(0)));     // "b"\n\n\n\n# streams\n\njava.util.stream 表示可以在其上执行一个或多个操作的元素序列。流操作是中间或终端。当终端操作返回一个特定类型的结果时，中间操作返回流本身，所以你可以链接多个方法调用。流在源上创建，例如一个 java.util.collection 像列表或集合（不支持映射）。流操作既可以按顺序执行，也可以并行执行。\n\n> 流是非常强大的，所以，我写了一个独立的 java8 streams 教程 。您还应该查看 sequent，将其作为 web 的类似库。\n\n我们先来看看顺序流如何工作。首先，我们以字符串列表的形式创建一个示例源代码：\n\nlist<string> stringcollection = new arraylist<>();\nstringcollection.add("ddd2");\nstringcollection.add("aaa2");\nstringcollection.add("bbb1");\nstringcollection.add("aaa1");\nstringcollection.add("bbb3");\nstringcollection.add("ccc");\nstringcollection.add("bbb2");\nstringcollection.add("ddd1");\n\n\njava 8 中的集合已被扩展，因此您可以通过调用 collection.stream() 或collection.parallelstream() 来简单地创建流。以下各节介绍最常见的流操作。\n\n\n# filter\n\n过滤器接受一个谓词来过滤流的所有元素。这个操作是中间的，使我们能够调用另一个流操作（foreach）的结果。 foreach 接受一个消费者被执行的过滤流中的每个元素。 foreach 是一个终端操作。它是无效的，所以我们不能调用另一个流操作。\n\nstringcollection\n    .stream()\n    .filter((s) -> s.startswith("a"))\n    .foreach(system.out::println);\n\n// "aaa2", "aaa1"\n\n\n\n# sorted\n\n排序是一个中间操作，返回流的排序视图。元素按自然顺序排序，除非您传递自定义比较器。\n\nstringcollection\n    .stream()\n    .sorted()\n    .filter((s) -> s.startswith("a"))\n    .foreach(system.out::println);\n\n// "aaa1", "aaa2"\n\n\n请记住，排序只会创建流的排序视图，而不会操纵支持的集合的排序。 stringcollection 的排序是不变的：\n\nsystem.out.println(stringcollection);\n// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1\n\n\n\n# map\n\n中间操作映射通过给定函数将每个元素转换为另一个对象。以下示例将每个字符串转换为大写字母字符串。但是您也可以使用 map 将每个对象转换为另一种类型。结果流的泛型类型取决于您传递给 map 的函数的泛型类型。\n\nstringcollection\n    .stream()\n    .map(string::touppercase)\n    .sorted((a, b) -> b.compareto(a))\n    .foreach(system.out::println);\n\n// "ddd2", "ddd1", "ccc", "bbb3", "bbb2", "aaa2", "aaa1"\n\n\n\n# match\n\n可以使用各种匹配操作来检查某个谓词是否与流匹配。所有这些操作都是终端并返回布尔结果。\n\nboolean anystartswitha =\n    stringcollection\n        .stream()\n        .anymatch((s) -> s.startswith("a"));\n\nsystem.out.println(anystartswitha);      // true\n\nboolean allstartswitha =\n    stringcollection\n        .stream()\n        .allmatch((s) -> s.startswith("a"));\n\nsystem.out.println(allstartswitha);      // false\n\nboolean nonestartswithz =\n    stringcollection\n        .stream()\n        .nonematch((s) -> s.startswith("z"));\n\nsystem.out.println(nonestartswithz);      // true\n\n\n# count\n\ncount 是一个终端操作，返回流中元素的个数。\n\nlong startswithb =\n    stringcollection\n        .stream()\n        .filter((s) -> s.startswith("b"))\n        .count();\n\nsystem.out.println(startswithb);    // 3\n\n\n\n# reduce\n\n该终端操作使用给定的功能对流的元素进行缩减。结果是一个 optional 持有缩小后的值。\n\noptional<string> reduced =\n    stringcollection\n        .stream()\n        .sorted()\n        .reduce((s1, s2) -> s1 + "#" + s2);\n\nreduced.ifpresent(system.out::println);\n// "aaa1##aaa2##bbb1##bbb2##bbb3##ccc##ddd1##ddd2"\n\n\n\n# parallel streams\n\n如上所述，流可以是顺序的也可以是并行的。顺序流上的操作在单个线程上执行，而并行流上的操作在多个线程上同时执行。\n\n以下示例演示了通过使用并行流提高性能是多么容易。\n\n首先，我们创建一个较大的独特元素的列表：\n\nint max = 1000000;\nlist<string> values = new arraylist<>(max);\nfor (int i = 0; i < max; i++) {\n    uuid uuid = uuid.randomuuid();\n    values.add(uuid.tostring());\n}\n\n\n现在我们测量对这个集合进行排序所花费的时间。\n\n\n# sequential sort\n\nlong t0 = system.nanotime();\n\nlong count = values.stream().sorted().count();\nsystem.out.println(count);\n\nlong t1 = system.nanotime();\n\nlong millis = timeunit.nanoseconds.tomillis(t1 - t0);\nsystem.out.println(string.format("sequential sort took: %d ms", millis));\n\n// sequential sort took: 899 ms\n\n\n\n# parallel sort\n\nlong t0 = system.nanotime();\n\nlong count = values.parallelstream().sorted().count();\nsystem.out.println(count);\n\nlong t1 = system.nanotime();\n\nlong millis = timeunit.nanoseconds.tomillis(t1 - t0);\nsystem.out.println(string.format("parallel sort took: %d ms", millis));\n\n// parallel sort took: 472 ms\n\n\n如你所见，两个代码段差不多，但是并行排序快了近 50%。你所需做的仅仅是将 stream() 改为 parallelstream() 。\n\n\n# maps\n\n如前所述，map 不直接支持流。map 接口本身没有可用的 stream() 方法，但是你可以通过 map.keyset().stream() 、 map.values().stream() 和 map.entryset().stream() 创建指定的流。\n\n此外，map 支持各种新的、有用的方法来处理常见任务。\n\nmap<integer, string> map = new hashmap<>();\n\nfor (int i = 0; i < 10; i++) {\n    map.putifabsent(i, "val" + i);\n}\n\nmap.foreach((id, val) -> system.out.println(val));\n\n\n上面的代码应该是自我解释的：putifabsent 阻止我们写入额外的空值检查；foreach 接受消费者为 map 的每个值实现操作。\n\n这个例子展示了如何利用函数来计算 map 上的代码：\n\nmap.computeifpresent(3, (num, val) -> val + num);\nmap.get(3);             // val33\n\nmap.computeifpresent(9, (num, val) -> null);\nmap.containskey(9);     // false\n\nmap.computeifabsent(23, num -> "val" + num);\nmap.containskey(23);    // true\n\nmap.computeifabsent(3, num -> "bam");\nmap.get(3);             // val33\n\n\n接下来，我们学习如何删除给定键的条目，只有当前键映射到给定值时：\n\nmap.remove(3, "val3");\nmap.get(3);             // val33\n\nmap.remove(3, "val33");\nmap.get(3);             // null\n\n\n另一个有用方法：\n\nmap.getordefault(42, "not found");  // not found\n\n\n合并一个 map 的 entry 很简单：\n\nmap.merge(9, "val9", (value, newvalue) -> value.concat(newvalue));\nmap.get(9);             // val9\n\nmap.merge(9, "concat", (value, newvalue) -> value.concat(newvalue));\nmap.get(9);             // val9concat\n\n\n如果不存在该键的条目，合并或者将键/值放入 map 中；否则将调用合并函数来更改现有值。\n\n\n# date api\n\njava 8 在 java.time 包下新增了一个全新的日期和时间 api。新的日期 api 与 joda-time 库相似，但不一样。以下示例涵盖了此新 api 的最重要部分。\n\n\n# clock\n\nclock 提供对当前日期和时间的访问。clock 知道一个时区，可以使用它来代替 system.currenttimemillis() ，获取从 unix epoch 开始的以毫秒为单位的当前时间。时间线上的某一时刻也由类 instant 表示。 instants 可以用来创建遗留的 java.util.date 对象。\n\nclock clock = clock.systemdefaultzone();\nlong millis = clock.millis();\n\ninstant instant = clock.instant();\ndate legacydate = date.from(instant);   // legacy java.util.date\n\n\n\n# timezones\n\n时区由 zoneid 表示。他们可以很容易地通过静态工厂方法访问。时区定义了某一时刻和当地日期、时间之间转换的重要偏移量。\n\nsystem.out.println(zoneid.getavailablezoneids());\n// prints all available timezone ids\n\nzoneid zone1 = zoneid.of("europe/berlin");\nzoneid zone2 = zoneid.of("brazil/east");\nsystem.out.println(zone1.getrules());\nsystem.out.println(zone2.getrules());\n\n// zonerules[currentstandardoffset=+01:00]\n// zonerules[currentstandardoffset=-03:00]\n\n\n\n# localtime\n\nlocaltime 代表没有时区的时间，例如晚上 10 点或 17:30:15。以下示例为上面定义的时区创建两个本地时间。然后我们比较两次，并计算两次之间的小时和分钟的差异。\n\nlocaltime now1 = localtime.now(zone1);\nlocaltime now2 = localtime.now(zone2);\n\nsystem.out.println(now1.isbefore(now2));  // false\n\nlong hoursbetween = chronounit.hours.between(now1, now2);\nlong minutesbetween = chronounit.minutes.between(now1, now2);\n\nsystem.out.println(hoursbetween);       // -3\nsystem.out.println(minutesbetween);     // -239\n\n\nlocaltime 带有各种工厂方法，以简化新实例的创建，包括解析时间字符串。\n\nlocaltime late = localtime.of(23, 59, 59);\nsystem.out.println(late);       // 23:59:59\n\ndatetimeformatter germanformatter =\n    datetimeformatter\n        .oflocalizedtime(formatstyle.short)\n        .withlocale(locale.german);\n\nlocaltime leettime = localtime.parse("13:37", germanformatter);\nsystem.out.println(leettime);   // 13:37\n\n\n\n# localdate\n\nlocaldate 表示不同的日期，例如：2014 年 3 月 11 日。它是不可变的，并且与 localtime 完全类似。该示例演示如何通过加减日、月或年来计算新日期。请记住，每个操作都会返回一个新的实例。\n\nlocaldate today = localdate.now();\nlocaldate tomorrow = today.plus(1, chronounit.days);\nlocaldate yesterday = tomorrow.minusdays(2);\n\nlocaldate independenceday = localdate.of(2014, month.july, 4);\ndayofweek dayofweek = independenceday.getdayofweek();\nsystem.out.println(dayofweek);    // friday\n\n\n从一个字符串中解析出 localdate 对象，和解析 localtime 一样的简单：\n\ndatetimeformatter germanformatter =\n    datetimeformatter\n        .oflocalizeddate(formatstyle.medium)\n        .withlocale(locale.german);\n\nlocaldate xmas = localdate.parse("24.12.2014", germanformatter);\nsystem.out.println(xmas);   // 2014-12-24\n\n\n\n# localdatetime\n\nlocaldatetime 表示日期时间。它将日期和时间组合成一个实例。 localdatetime 是不可变的，其作用类似于 localtime 和 localdate。我们可以利用方法去获取日期时间中某个单位的值。\n\nlocaldatetime sylvester = localdatetime.of(2014, month.december, 31, 23, 59, 59);\n\ndayofweek dayofweek = sylvester.getdayofweek();\nsystem.out.println(dayofweek);      // wednesday\n\nmonth month = sylvester.getmonth();\nsystem.out.println(month);          // december\n\nlong minuteofday = sylvester.getlong(chronofield.minute_of_day);\nsystem.out.println(minuteofday);    // 1439\n\n\n通过一个时区的附加信息可以转为一个实例。这个实例很容易转为java.util.date 类型。\n\ninstant instant = sylvester\n        .atzone(zoneid.systemdefault())\n        .toinstant();\n\ndate legacydate = date.from(instant);\nsystem.out.println(legacydate);     // wed dec 31 23:59:59 cet 2014\n\n\n日期时间的格式化类似于 date 或 time。我们可以使用自定义模式创建格式化程序，而不是使用预定义的格式。\n\ndatetimeformatter formatter =\n    datetimeformatter\n        .ofpattern("mmm dd, yyyy - hh:mm");\n\nlocaldatetime parsed = localdatetime.parse("nov 03, 2014 - 07:13", formatter);\nstring string = formatter.format(parsed);\nsystem.out.println(string);     // nov 03, 2014 - 07:13\n\n\n不同于 java.text.numberformat ， datetimeformatter 是不可变且线程安全的 。\n\n更多关于日期格式化的内容可以参考这里.\n\n\n# annotations\n\njava 8 中的注释是可重复的。让我们直接看一个例子来解决这个问题。\n\n首先，我们定义一个包含实际注释数组的外层注释：\n\n@interface hints {\n    hint[] value();\n}\n\n@repeatable(hints.class)\n@interface hint {\n    string value();\n}\n\n\njava8 允许我们通过使用 @repeatable 注解来引入多个同类型的注解。\n\n\n# variant 1: 使用容器注解 (老套路)\n\n@hints({@hint("hint1"), @hint("hint2")})\nclass person {}\n\n\n\n# variant 2: 使用 repeatable 注解 (新套路)\n\n@hint("hint1")\n@hint("hint2")\nclass person {}\n\n\n使用场景 2，java 编译器隐式地设置了 @hints 注解。\n\n这对于通过反射来读取注解信息很重要。\n\nhint hint = person.class.getannotation(hint.class);\nsystem.out.println(hint);                   // null\n\nhints hints1 = person.class.getannotation(hints.class);\nsystem.out.println(hints1.value().length);  // 2\n\nhint[] hints2 = person.class.getannotationsbytype(hint.class);\nsystem.out.println(hints2.length);          // 2\n\n\n尽管，我们从没有在 person 类上声明 @hints 注解，但是仍可以通过getannotation(hints.class) 读取它。然而，更便利的方式是 getannotationsbytype ，它可以直接访问所有 @hint 注解。\n\n此外，java 8 中的注释使用扩展了两个新的目标：\n\n@target({elementtype.type_parameter, elementtype.type_use})\n@interface myannotation {}\n\n\n水平线以上为 java8-tutorial 翻译内容。\n\n----------------------------------------\n\n\n# jdk8 升级常见问题\n\n> jdk8 发布很久了，它提供了许多吸引人的新特性，能够提高编程效率。\n> \n> 如果是新的项目，使用 jdk8 当然是最好的选择。但是，对于一些老的项目，升级到 jdk8 则存在一些兼容性问题，是否升级需要酌情考虑。\n> \n> 近期，我在工作中遇到一个任务，将部门所有项目的 jdk 版本升级到 1.8 （老版本大多是 1.6）。在这个过程中，遇到一些问题点，并结合在网上看到的坑，在这里总结一下。\n\n\n# intellij 中的 jdk 环境设置\n\n# settings\n\n点击 file > settings > java compiler\n\nproject bytecode version 选择 1.8\n\n点击 file > settings > build tools > maven > importing\n\n选择 jdk for importer 为 1.8\n\n# projcet settings\n\nproject sdk 选择 1.8\n\n# application\n\n如果 web 应用的启动方式为 application ，需要修改 jre\n\n点击 run/debug configurations > configuration\n\n选择 jre 为 1.8\n\n\n# linux 环境修改\n\n# 修改环境变量\n\n修改 /etc/profile 中的 java_home，设置 为 jdk8 所在路径。\n\n修改后，执行 source /etc/profile 生效。\n\n编译、发布脚本中如果有 export java_home ，需要注意，需要使用 jdk8 的路径。\n\n# 修改 maven\n\nsettings.xml 中 profile 的激活条件如果是 jdk，需要修改一下 jdk 版本\n\n<activation>\n  <jdk>1.8</jdk> \x3c!-- 修改为 1.8 --\x3e\n</activation>\n\n\n# 修改 server\n\n修改 server 中的 javac 版本，以 resin 为例：\n\n修改 resin 配置文件中的 javac 参数。\n\n<javac compiler="internal" args="-source 1.8"/>\n\n\n\n# sun.* 包缺失问题\n\njdk8 不再提供 sun.* 包供开发者使用，因为这些接口不是公共接口，不能保证在所有 java 兼容的平台上工作。\n\n使用了这些 api 的程序如果要升级到 jdk 1.8 需要寻求替代方案。\n\n虽然，也可以自己导入包含 sun.* 接口 jar 包到 classpath 目录，但这不是一个好的做法。\n\n需要详细了解为什么不要使用 sun.* ，可以参考官方文档：why developers should not write programs that call \'sun\' packages\n\n\n# 默认安全策略修改\n\n升级后估计有些小伙伴在使用不安全算法时可能会发生错误，so，支持不安全算法还是有必要的\n\n找到$java_home 下 jre/lib/security/java.security ，将禁用的算法设置为空：jdk.certpath.disabledalgorithms= 。\n\n\n# jvm 参数调整\n\n在 jdk8 中，permsize 相关的参数已经不被使用：\n\n-xx:maxpermsize=size\n\nsets the maximum permanent generation space size (in bytes). this option was deprecated in jdk 8, and superseded by the -xx:maxmetaspacesize option.\n\n-xx:permsize=size\n\nsets the space (in bytes) allocated to the permanent generation that triggers a garbage collection if it is exceeded. this option was deprecated un jdk 8, and superseded by the -xx:metaspacesize option.\n\n\njdk8 中再也没有 permgen 了。其中的某些部分，如被 intern 的字符串，在 jdk7 中已经移到了普通堆里。其余结构在 jdk8 中会被移到称作“metaspace”的本机内存区中，该区域在默认情况下会自动生长，也会被垃圾回收。它有两个标记：metaspacesize 和 maxmetaspacesize。\n\n-xx:metaspacesize=size\n\n> sets the size of the allocated class metadata space that will trigger a garbage collection the first time it is exceeded. this threshold for a garbage collection is increased or decreased depending on the amount of metadata used. the default size depends on the platform.\n\n-xx:maxmetaspacesize=size\n\n> sets the maximum amount of native memory that can be allocated for class metadata. by default, the size is not limited. the amount of metadata for an application depends on the application itself, other running applications, and the amount of memory available on the system.\n\n以下示例显示如何将类类元数据的上限设置为 256 mb：\n\nxx:maxmetaspacesize=256m\n\n\n# 字节码问题\n\nasm 5.0 beta 开始支持 jdk8\n\n字节码错误\n\ncaused by: java.io.ioexception: invalid constant type: 15\n\tat javassist.bytecode.constpool.readone(constpool.java:1113)\n\n\n * 查找组件用到了 mvel，mvel 为了提高效率进行了字节码优化，正好碰上 jdk8 死穴，所以需要升级。\n\n<dependency>\n  <groupid>org.mvel</groupid>\n  <artifactid>mvel2</artifactid>\n  <version>2.2.7.final</version>\n</dependency>\n\n\n * javassist\n\n<dependency>\n  <groupid>org.javassist</groupid>\n  <artifactid>javassist</artifactid>\n  <version>3.18.1-ga</version>\n</dependency>\n\n\n> 注意\n> \n> 有些部署工具不会删除旧版本 jar 包，所以可以尝试手动删除老版本 jar 包。\n\nhttp://asm.ow2.org/history.html\n\n\n# java 连接 redis 启动报错 error redis clients jedis hostandport cant resolve localhost address\n\n错误环境: 本地 window 开发环境没有问题。上到 linux 环境,启动出现问题。 错误信息: error redis clients jedis hostandport cant resolve localhost address\n\n解决办法:\n\n（1）查看 linux 系统的主机名\n\n# hostname\ntemplate\n\n\n（2）查看/etc/hosts 文件中是否有 127.0.0.1 对应主机名，如果没有则添加\n\n\n# resin 容器指定 jdk 1.8\n\n如果 resin 容器原来版本低于 jdk1.8，运行 jdk 1.8 编译的 web app 时，可能会提示错误：\n\njava.lang.unsupportedclassversionerror: pr/sort : unsupported major.minor version 52.0\n\n\n解决方法就是，使用 jdk 1.8 要重新编译一下。然后，我在部署时出现过编译后仍报错的情况，重启一下服务器后，问题解决，不知是什么原因。\n\n./configure --prefix=/usr/local/resin  --with-java=/usr/local/jdk1.8.0_121\nmake & make install\n\n\n\n# 参考资料\n\n * java8-tutorial\n * compatibility guide for jdk 8\n * compatibility guide for jdk 8 中文翻译\n * why developers should not write programs that call \'sun\' packages',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 编程规范",frontmatter:{title:"Java 编程规范",categories:["编程","Java","JavaSE"],tags:["Java","JavaSE"],abbrlink:"a13c53ac",date:"2019-05-06T15:02:02.000Z",permalink:"/pages/c63b72/"},regularPath:"/02.%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/99.Java%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83.html",relativePath:"02.高级特性/99.Java编程规范.md",key:"v-6680f397",path:"/pages/c63b72/",headers:[{level:2,title:"Effective Java",slug:"effective-java",normalizedTitle:"effective java",charIndex:51},{level:2,title:"资源",slug:"资源",normalizedTitle:"资源",charIndex:2235}],headersStr:"Effective Java 资源",content:"# Java 编程规范\n\n> 编程规范就是 Java 开发的最佳实践。帮助开发人员少走弯路。\n\n\n# Effective Java\n\n * 第 2 章 创建、销毁对象\n   * 第 1 条：考虑用静态工厂方法代替构造器\n   * 第 2 条：遇到多个构造器参数时要考虑用构建器\n   * 第 3 条：用私有构造器或者枚举类型强化 Singleton 属性\n   * 第 4 条：通过私有构造器强化不可实例化的能力\n   * 第 5 条：避免创建不必要的对象\n   * 第 6 条：消除过期的对象引用\n   * 第 7 条：避免使用终结方法\n * 第 3 章 对于所有对象都通用的方法\n   * 第 8 条：覆盖 equals 时请遵守通用约定\n   * 第 9 条：覆盖 equals 时总要覆盖 hashCode\n   * 第 10 条：始终要覆盖 toString\n   * 第 11 条：谨慎地覆盖 clone\n   * 第 12 条：考虑实现 Comparable 接口\n * 第 4 章 类和接口\n   * 第 13 条：使类和成员的可访问性最小化\n   * 第 14 条：在公有类中使用访问方法而非公有域\n   * 第 15 条：使可变性最小化\n   * 第 16 条：复合优先于继承\n   * 第 17 条：要么为继承而设计，并提供文档说明，要么就禁止继承\n   * 第 18 条：接口优于抽象类\n   * 第 19 条：接口只用于定义类型\n   * 第 20 条：类层次优于标签类\n   * 第 21 条：用函数对象表示策略\n   * 第 22 条：优先考虑静态成员类\n * 第 5 章 泛型\n   * 第 23 条：请不要在新代码中使用原生态类型\n   * 第 24 条：消除非受检警告\n   * 第 25 条：列表优先于数组\n   * 第 26 条：优先考虑泛型\n   * 第 27 条：优先考虑泛型方法\n   * 第 28 条：利用有限制通配符来提升 API 的灵活性\n   * 第 29 条：优先考虑类型安全的异构容器\n * 第 6 章 枚举和注解\n   * 第 30 条：用 enum 代替 int 常量\n   * 第 31 条：用实例域代替序数\n   * 第 32 条：用 EnumSet 代替位域\n   * 第 33 条：用 EnumMap 代替序数索引\n   * 第 34 条：用接口模拟可伸缩的枚举\n   * 第 35 条：注解优先于命名模式\n   * 第 36 条：坚持使用 Override 注解\n   * 第 37 条：用标记接口定义类型\n * 第 7 章 方法\n   * 第 38 条：检查参数的有效性\n   * 第 39 条：必要时进行保护性拷贝\n   * 第 40 条：谨慎设计方法签名\n   * 第 41 条：慎用重载\n   * 第 42 条：慎用可变参数\n   * 第 43 条：返回零长度的数组或者集合，而不是：null\n   * 第 44 条：为所有导出的 API 元素编写文档注释\n * 第 8 章 通用程序设计\n   * 第 45 条：将局部变量的作用域最小化\n   * 第 46 条：for-each 循环优先于传统的 for 循环\n   * 第 47 条：了解和使用类库\n   * 第 48 条：如果需要精确的答案，请避免使用 float 和 double\n   * 第 49 条：基本类型优先于装箱基本类型\n   * 第 50 条：如果其他类型更适合，则尽量避免使用字符串\n   * 第 51 条：当心字符串连接的性能\n   * 第 52 条：通过接口引用对象\n   * 第 53 条：接口优先于反射机制\n   * 第 54 条：谨慎地使用本地方法\n   * 第 55 条：谨慎地进行优化\n   * 第 56 条：遵守普遍接受的命名惯例\n * 第 9 章 异常\n   * 第 57 条：只针对异常的情况才使用异常\n   * 第 58 条：对可恢复的情况使用受检异常，对编程错误使用运行时异常\n   * 第 59 条：避免不必要地使用受检的异常\n   * 第 60 条：优先使用标准的异常\n   * 第 61 条：抛出与抽象相对应的异常\n   * 第 62 条：每个方法抛出的异常都要有文档\n   * 第 63 条：在细节消息中包含能捕获失败的信息\n   * 第 64 条：努力使失败保持原子性\n   * 第 65 条：不要忽略异常\n * 第 10 章 并发\n   * 第 66 条：同步访问共享的可变数据\n   * 第 67 条：避免过度同步\n   * 第 68 条：executor 和 task 优先干线程\n   * 第 69 条：并发工具优先于 wait 和 notify\n   * 第 70 条：线程安全性的文档化\n   * 第 71 条：慎用延迟初始化\n   * 第 72 条：不要依赖于线程调度器\n   * 第 73 条：避免使用线程组\n * 第 11 章 序列化\n   * 第 74 条：谨慎地实现 Serializable 接口\n   * 第 75 条：考虑使用自定义的序列化形式\n   * 第 76 条：保护性地编写 readObject 方法\n   * 第 77 条：对于实例控制，枚举类型优先于 readResolve\n   * 第 78 条：考虑用序列化代理代替序列化实例\n\n\n# 资源\n\n * Effective Java\n * 阿里巴巴 Java 开发手册\n * Google Java 编程指南",normalizedContent:"# java 编程规范\n\n> 编程规范就是 java 开发的最佳实践。帮助开发人员少走弯路。\n\n\n# effective java\n\n * 第 2 章 创建、销毁对象\n   * 第 1 条：考虑用静态工厂方法代替构造器\n   * 第 2 条：遇到多个构造器参数时要考虑用构建器\n   * 第 3 条：用私有构造器或者枚举类型强化 singleton 属性\n   * 第 4 条：通过私有构造器强化不可实例化的能力\n   * 第 5 条：避免创建不必要的对象\n   * 第 6 条：消除过期的对象引用\n   * 第 7 条：避免使用终结方法\n * 第 3 章 对于所有对象都通用的方法\n   * 第 8 条：覆盖 equals 时请遵守通用约定\n   * 第 9 条：覆盖 equals 时总要覆盖 hashcode\n   * 第 10 条：始终要覆盖 tostring\n   * 第 11 条：谨慎地覆盖 clone\n   * 第 12 条：考虑实现 comparable 接口\n * 第 4 章 类和接口\n   * 第 13 条：使类和成员的可访问性最小化\n   * 第 14 条：在公有类中使用访问方法而非公有域\n   * 第 15 条：使可变性最小化\n   * 第 16 条：复合优先于继承\n   * 第 17 条：要么为继承而设计，并提供文档说明，要么就禁止继承\n   * 第 18 条：接口优于抽象类\n   * 第 19 条：接口只用于定义类型\n   * 第 20 条：类层次优于标签类\n   * 第 21 条：用函数对象表示策略\n   * 第 22 条：优先考虑静态成员类\n * 第 5 章 泛型\n   * 第 23 条：请不要在新代码中使用原生态类型\n   * 第 24 条：消除非受检警告\n   * 第 25 条：列表优先于数组\n   * 第 26 条：优先考虑泛型\n   * 第 27 条：优先考虑泛型方法\n   * 第 28 条：利用有限制通配符来提升 api 的灵活性\n   * 第 29 条：优先考虑类型安全的异构容器\n * 第 6 章 枚举和注解\n   * 第 30 条：用 enum 代替 int 常量\n   * 第 31 条：用实例域代替序数\n   * 第 32 条：用 enumset 代替位域\n   * 第 33 条：用 enummap 代替序数索引\n   * 第 34 条：用接口模拟可伸缩的枚举\n   * 第 35 条：注解优先于命名模式\n   * 第 36 条：坚持使用 override 注解\n   * 第 37 条：用标记接口定义类型\n * 第 7 章 方法\n   * 第 38 条：检查参数的有效性\n   * 第 39 条：必要时进行保护性拷贝\n   * 第 40 条：谨慎设计方法签名\n   * 第 41 条：慎用重载\n   * 第 42 条：慎用可变参数\n   * 第 43 条：返回零长度的数组或者集合，而不是：null\n   * 第 44 条：为所有导出的 api 元素编写文档注释\n * 第 8 章 通用程序设计\n   * 第 45 条：将局部变量的作用域最小化\n   * 第 46 条：for-each 循环优先于传统的 for 循环\n   * 第 47 条：了解和使用类库\n   * 第 48 条：如果需要精确的答案，请避免使用 float 和 double\n   * 第 49 条：基本类型优先于装箱基本类型\n   * 第 50 条：如果其他类型更适合，则尽量避免使用字符串\n   * 第 51 条：当心字符串连接的性能\n   * 第 52 条：通过接口引用对象\n   * 第 53 条：接口优先于反射机制\n   * 第 54 条：谨慎地使用本地方法\n   * 第 55 条：谨慎地进行优化\n   * 第 56 条：遵守普遍接受的命名惯例\n * 第 9 章 异常\n   * 第 57 条：只针对异常的情况才使用异常\n   * 第 58 条：对可恢复的情况使用受检异常，对编程错误使用运行时异常\n   * 第 59 条：避免不必要地使用受检的异常\n   * 第 60 条：优先使用标准的异常\n   * 第 61 条：抛出与抽象相对应的异常\n   * 第 62 条：每个方法抛出的异常都要有文档\n   * 第 63 条：在细节消息中包含能捕获失败的信息\n   * 第 64 条：努力使失败保持原子性\n   * 第 65 条：不要忽略异常\n * 第 10 章 并发\n   * 第 66 条：同步访问共享的可变数据\n   * 第 67 条：避免过度同步\n   * 第 68 条：executor 和 task 优先干线程\n   * 第 69 条：并发工具优先于 wait 和 notify\n   * 第 70 条：线程安全性的文档化\n   * 第 71 条：慎用延迟初始化\n   * 第 72 条：不要依赖于线程调度器\n   * 第 73 条：避免使用线程组\n * 第 11 章 序列化\n   * 第 74 条：谨慎地实现 serializable 接口\n   * 第 75 条：考虑使用自定义的序列化形式\n   * 第 76 条：保护性地编写 readobject 方法\n   * 第 77 条：对于实例控制，枚举类型优先于 readresolve\n   * 第 78 条：考虑用序列化代理代替序列化实例\n\n\n# 资源\n\n * effective java\n * 阿里巴巴 java 开发手册\n * google java 编程指南",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 高级特性",frontmatter:{title:"Java 高级特性",categories:["编程","Java","JavaSE"],tags:["Java","JavaSE"],abbrlink:"f04481ec",date:"2020-06-04T13:51:01.000Z",hidden:!0,permalink:"/pages/dfadaa/"},regularPath:"/02.%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/",relativePath:"02.高级特性/README.md",key:"v-db310efe",path:"/pages/dfadaa/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:43},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:283},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:916}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Java 高级特性\n\n> Java 高级总结 Java 的一些高级特性。\n\n\n# 📖 内容\n\n * Java 正则从入门到精通 - 关键词：Pattern、Matcher、捕获与非捕获、反向引用、零宽断言、贪婪与懒惰、元字符、DFA、NFA\n * Java 编码和加密 - 关键词：Base64、消息摘要、数字签名、对称加密、非对称加密、MD5、SHA、HMAC、AES、DES、DESede、RSA\n * Java 本地化\n * Java JDK8 - 关键词：Stream、lambda、Optional、@FunctionalInterface\n\n\n# 📚 资料\n\n * 书籍\n   * Java 四大名著\n     * 《Java 编程思想（Thinking in java）》\n     * 《Java 核心技术 卷 I 基础知识》\n     * 《Java 核心技术 卷 II 高级特性》\n     * 《Effective Java》\n   * Java 并发\n     * 《Java 并发编程实战》\n     * 《Java 并发编程的艺术》\n   * Java 虚拟机\n     * 《深入理解 Java 虚拟机》\n   * Java 入门\n     * 《O'Reilly：Head First Java》\n     * 《疯狂 Java 讲义》\n   * 其他\n     * 《Head First 设计模式》\n     * 《Java 网络编程》\n     * 《Java 加密与解密的艺术》\n     * 《阿里巴巴 Java 开发手册》\n * 教程、社区\n   * Runoob Java 教程\n   * java-design-patterns\n   * Java\n   * 《Java 核心技术面试精讲》\n   * 《Java 性能调优实战》\n   * 《Java 业务开发常见错误 100 例》\n   * 深入拆解 Java 虚拟机\n   * 《Java 并发编程实战》\n * 面试\n   * CS-Notes\n   * JavaGuide\n   * advanced-java\n\n\n# 🚪 传送\n\n◾ 🏠 JAVACORE 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"# java 高级特性\n\n> java 高级总结 java 的一些高级特性。\n\n\n# 📖 内容\n\n * java 正则从入门到精通 - 关键词：pattern、matcher、捕获与非捕获、反向引用、零宽断言、贪婪与懒惰、元字符、dfa、nfa\n * java 编码和加密 - 关键词：base64、消息摘要、数字签名、对称加密、非对称加密、md5、sha、hmac、aes、des、desede、rsa\n * java 本地化\n * java jdk8 - 关键词：stream、lambda、optional、@functionalinterface\n\n\n# 📚 资料\n\n * 书籍\n   * java 四大名著\n     * 《java 编程思想（thinking in java）》\n     * 《java 核心技术 卷 i 基础知识》\n     * 《java 核心技术 卷 ii 高级特性》\n     * 《effective java》\n   * java 并发\n     * 《java 并发编程实战》\n     * 《java 并发编程的艺术》\n   * java 虚拟机\n     * 《深入理解 java 虚拟机》\n   * java 入门\n     * 《o'reilly：head first java》\n     * 《疯狂 java 讲义》\n   * 其他\n     * 《head first 设计模式》\n     * 《java 网络编程》\n     * 《java 加密与解密的艺术》\n     * 《阿里巴巴 java 开发手册》\n * 教程、社区\n   * runoob java 教程\n   * java-design-patterns\n   * java\n   * 《java 核心技术面试精讲》\n   * 《java 性能调优实战》\n   * 《java 业务开发常见错误 100 例》\n   * 深入拆解 java 虚拟机\n   * 《java 并发编程实战》\n * 面试\n   * cs-notes\n   * javaguide\n   * advanced-java\n\n\n# 🚪 传送\n\n◾ 🏠 javacore 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 容器简介",frontmatter:{title:"Java 容器简介",categories:["编程","Java","JavaSE","容器"],tags:["Java","JavaSE","容器"],abbrlink:"78ed2691",date:"2019-12-29T21:49:58.000Z",permalink:"/pages/3b9a57/"},regularPath:"/03.%E5%AE%B9%E5%99%A8/01.Java%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B.html",relativePath:"03.容器/01.Java容器简介.md",key:"v-10aec85a",path:"/pages/3b9a57/",headers:[{level:2,title:"容器简介",slug:"容器简介",normalizedTitle:"容器简介",charIndex:7},{level:3,title:"数组与容器",slug:"数组与容器",normalizedTitle:"数组与容器",charIndex:27},{level:3,title:"容器框架",slug:"容器框架",normalizedTitle:"容器框架",charIndex:246},{level:2,title:"容器的基本机制",slug:"容器的基本机制",normalizedTitle:"容器的基本机制",charIndex:501},{level:3,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:584},{level:3,title:"Iterable 和 Iterator",slug:"iterable-和-iterator",normalizedTitle:"iterable 和 iterator",charIndex:1024},{level:3,title:"Comparable 和 Comparator",slug:"comparable-和-comparator",normalizedTitle:"comparable 和 comparator",charIndex:2289},{level:3,title:"Cloneable",slug:"cloneable",normalizedTitle:"cloneable",charIndex:3353},{level:3,title:"fail-fast",slug:"fail-fast",normalizedTitle:"fail-fast",charIndex:3642},{level:4,title:"fail-fast 的要点",slug:"fail-fast-的要点",normalizedTitle:"fail-fast 的要点",charIndex:3655},{level:4,title:"解决 fail-fast",slug:"解决-fail-fast",normalizedTitle:"解决 fail-fast",charIndex:5576},{level:2,title:"容器和线程安全",slug:"容器和线程安全",normalizedTitle:"容器和线程安全",charIndex:5768},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5844}],headersStr:"容器简介 数组与容器 容器框架 容器的基本机制 泛型 Iterable 和 Iterator Comparable 和 Comparator Cloneable fail-fast fail-fast 的要点 解决 fail-fast 容器和线程安全 参考资料",content:'# Java 容器简介\n\n\n\n\n# 容器简介\n\n\n# 数组与容器\n\nJava 中常用的存储容器就是数组和容器，二者有以下区别：\n\n * 存储大小是否固定\n   * 数组的长度固定；\n   * 容器的长度可变。\n * 数据类型\n   * 数组可以存储基本数据类型，也可以存储引用数据类型；\n   * 容器只能存储引用数据类型，基本数据类型的变量要转换成对应的包装类才能放入容器类中。\n\n> 💡 不了解什么是基本数据类型、引用数据类型、包装类这些概念，可以参考：Java 基本数据类型\n\n\n# 容器框架\n\n\n\nJava 容器框架主要分为 Collection 和 Map 两种。其中，Collection 又分为 List、Set 以及 Queue。\n\n * Collection - 一个独立元素的序列，这些元素都服从一条或者多条规则。\n   * List - 必须按照插入的顺序保存元素。\n   * Set - 不能有重复的元素。\n   * Queue - 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。\n * Map - 一组成对的“键值对”对象，允许你使用键来查找值。\n\n\n# 容器的基本机制\n\n> Java 的容器具有一定的共性，它们或全部或部分依赖以下技术。所以，学习以下技术点，对于理解 Java 容器的特性和原理有很大的帮助。\n\n\n# 泛型\n\nJava 1.5 引入了泛型技术。\n\nJava 容器通过泛型技术来保证其数据的类型安全。什么是类型安全呢？\n\n举例来说：如果有一个 List<Object> 容器，Java 编译器在编译时不会对原始类型进行类型安全检查，却会对带参数的类型进行检查，通过使用 Object 作为类型，可以告知编译器该方法可以接受任何类型的对象，比如 String 或 Integer。\n\nList<Object> list = new ArrayList<Object>();\nlist.add("123");\nlist.add(123);\n\n\n如果没有泛型技术，如示例中的代码那样，容器中就可能存储任意数据类型，这是很危险的行为。\n\nList<String> list = new ArrayList<String>();\nlist.add("123");\nlist.add(123);\n\n\n> 💡 想深入了解 Java 泛型技术的用法和原理可以参考：深入理解 Java 泛型\n\n\n# Iterable 和 Iterator\n\n> Iterable 和 Iterator 目的在于遍历访问容器中的元素。\n\nIterator 接口定义：\n\npublic interface Iterator<E> {\n\n    boolean hasNext();\n\n    E next();\n\n    default void remove() {\n        throw new UnsupportedOperationException("remove");\n    }\n\n    default void forEachRemaining(Consumer<? super E> action) {\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n    }\n}\n\n\nIterable 接口定义：\n\npublic interface Iterable<T> {\n\n    Iterator<T> iterator();\n\n    default void forEach(Consumer<? super T> action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }\n\n    default Spliterator<T> spliterator() {\n        return Spliterators.spliteratorUnknownSize(iterator(), 0);\n    }\n}\n\n\nCollection 接口扩展了 Iterable 接口。\n\n迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的接口。它是一个经典的设计模式——迭代器模式（Iterator）。\n\n迭代器模式 - 提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。\n\n\n\n示例：迭代器遍历\n\npublic class IteratorDemo {\n\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        Iterator it = list.iterator();\n        while (it.hasNext()) {\n            System.out.println(it.next());\n        }\n    }\n\n}\n\n\n\n# Comparable 和 Comparator\n\nComparable 是排序接口。若一个类实现了 Comparable 接口，表示该类的实例可以比较，也就意味着支持排序。实现了 Comparable 接口的类的对象的列表或数组可以通过 Collections.sort 或 Arrays.sort 进行自动排序。\n\nComparable 接口定义：\n\npublic interface Comparable<T> {\n    public int compareTo(T o);\n}\n\n\nComparator 是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现 Comparable 接口)，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现 Comparator 接口即可。也就是说，我们可以通过实现 Comparator 来新建一个比较器，然后通过这个比较器对类进行排序。\n\nComparator 接口定义：\n\n@FunctionalInterface\npublic interface Comparator<T> {\n\n    int compare(T o1, T o2);\n\n    boolean equals(Object obj);\n\n    // 反转\n    default Comparator<T> reversed() {\n        return Collections.reverseOrder(this);\n    }\n\n    default Comparator<T> thenComparing(Comparator<? super T> other) {\n        Objects.requireNonNull(other);\n        return (Comparator<T> & Serializable) (c1, c2) -> {\n            int res = compare(c1, c2);\n            return (res != 0) ? res : other.compare(c1, c2);\n        };\n    }\n\n    // thenComparingXXX 方法略\n\n    // 静态方法略\n}\n\n\n在 Java 容器中，一些可以排序的容器，如 TreeMap、TreeSet，都可以通过传入 Comparator，来定义内部元素的排序规则。\n\n\n# Cloneable\n\nJava 中 一个类要实现 clone 功能 必须实现 Cloneable 接口，否则在调用 clone() 时会报 CloneNotSupportedException 异常。\n\nJava 中所有类都默认继承 java.lang.Object 类，在 java.lang.Object 类中有一个方法 clone()，这个方法将返回 Object 对象的一个拷贝。Object 类里的 clone() 方法仅仅用于浅拷贝（拷贝基本成员属性，对于引用类型仅返回指向改地址的引用）。\n\n如果 Java 类需要深拷贝，需要覆写 clone() 方法。\n\n\n# fail-fast\n\n# fail-fast 的要点\n\nJava 容器（如：ArrayList、HashMap、TreeSet 等待）的 javadoc 中常常提到类似的描述：\n\n> 注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败（fail-fast）迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。\n\n那么，我们不禁要问，什么是 fail-fast，为什么要有 fail-fast 机制？\n\nfail-fast 是 Java 容器的一种错误检测机制。当多个线程对容器进行结构上的改变的操作时，就可能触发 fail-fast 机制。记住是有可能，而不是一定。\n\n例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历容器 A 中的元素，在某个时候线程 2 修改了容器 A 的结构（是结构上面的修改，而不是简单的修改容器元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。\n\n容器在迭代操作中改变元素个数（添加、删除元素）都可能会导致 fail-fast。\n\n示例：fail-fast 示例\n\npublic class FailFastDemo {\n\n    private static int MAX = 100;\n\n    private static List<Integer> list = new ArrayList<>();\n\n    public static void main(String[] args) {\n        for (int i = 0; i < MAX; i++) {\n            list.add(i);\n        }\n        new Thread(new MyThreadA()).start();\n        new Thread(new MyThreadB()).start();\n    }\n\n    /** 迭代遍历容器所有元素 */\n    static class MyThreadA implements Runnable {\n\n        @Override\n        public void run() {\n            Iterator<Integer> iterator = list.iterator();\n            while (iterator.hasNext()) {\n                int i = iterator.next();\n                System.out.println("MyThreadA 访问元素:" + i);\n                try {\n                    TimeUnit.MILLISECONDS.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n    }\n\n    /** 遍历删除指定范围内的所有偶数 */\n    static class MyThreadB implements Runnable {\n\n        @Override\n        public void run() {\n            int i = 0;\n            while (i < MAX) {\n                if (i % 2 == 0) {\n                    System.out.println("MyThreadB 删除元素" + i);\n                    list.remove(i);\n                }\n                i++;\n            }\n        }\n\n    }\n\n}\n\n\n执行后，会抛出 java.util.ConcurrentModificationException 异常。\n\n# 解决 fail-fast\n\nfail-fast 有两种解决方案：\n\n * 在遍历过程中所有涉及到改变容器个数的地方全部加上 synchronized 或者直接使用 Collections.synchronizedXXX 容器，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作，影响吞吐。\n * 使用并发容器，如：CopyOnWriterArrayList。\n\n\n# 容器和线程安全\n\n为了在并发环境下安全地使用容器，Java 提供了同步容器和并发容器。\n\n> 同步容器和并发容器详情请参考：同步容器和并发容器\n\n\n# 参考资料\n\n * Java 编程思想（第 4 版）\n * 由浅入深理解 java 集合(一)——集合框架 Collection、Map\n * 由浅入深理解 java 集合(二)——集合 Set\n * Java 提高篇（三十）-----Iterator\n * Java 提高篇（三四）-----fail-fast 机制',normalizedContent:'# java 容器简介\n\n\n\n\n# 容器简介\n\n\n# 数组与容器\n\njava 中常用的存储容器就是数组和容器，二者有以下区别：\n\n * 存储大小是否固定\n   * 数组的长度固定；\n   * 容器的长度可变。\n * 数据类型\n   * 数组可以存储基本数据类型，也可以存储引用数据类型；\n   * 容器只能存储引用数据类型，基本数据类型的变量要转换成对应的包装类才能放入容器类中。\n\n> 💡 不了解什么是基本数据类型、引用数据类型、包装类这些概念，可以参考：java 基本数据类型\n\n\n# 容器框架\n\n\n\njava 容器框架主要分为 collection 和 map 两种。其中，collection 又分为 list、set 以及 queue。\n\n * collection - 一个独立元素的序列，这些元素都服从一条或者多条规则。\n   * list - 必须按照插入的顺序保存元素。\n   * set - 不能有重复的元素。\n   * queue - 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。\n * map - 一组成对的“键值对”对象，允许你使用键来查找值。\n\n\n# 容器的基本机制\n\n> java 的容器具有一定的共性，它们或全部或部分依赖以下技术。所以，学习以下技术点，对于理解 java 容器的特性和原理有很大的帮助。\n\n\n# 泛型\n\njava 1.5 引入了泛型技术。\n\njava 容器通过泛型技术来保证其数据的类型安全。什么是类型安全呢？\n\n举例来说：如果有一个 list<object> 容器，java 编译器在编译时不会对原始类型进行类型安全检查，却会对带参数的类型进行检查，通过使用 object 作为类型，可以告知编译器该方法可以接受任何类型的对象，比如 string 或 integer。\n\nlist<object> list = new arraylist<object>();\nlist.add("123");\nlist.add(123);\n\n\n如果没有泛型技术，如示例中的代码那样，容器中就可能存储任意数据类型，这是很危险的行为。\n\nlist<string> list = new arraylist<string>();\nlist.add("123");\nlist.add(123);\n\n\n> 💡 想深入了解 java 泛型技术的用法和原理可以参考：深入理解 java 泛型\n\n\n# iterable 和 iterator\n\n> iterable 和 iterator 目的在于遍历访问容器中的元素。\n\niterator 接口定义：\n\npublic interface iterator<e> {\n\n    boolean hasnext();\n\n    e next();\n\n    default void remove() {\n        throw new unsupportedoperationexception("remove");\n    }\n\n    default void foreachremaining(consumer<? super e> action) {\n        objects.requirenonnull(action);\n        while (hasnext())\n            action.accept(next());\n    }\n}\n\n\niterable 接口定义：\n\npublic interface iterable<t> {\n\n    iterator<t> iterator();\n\n    default void foreach(consumer<? super t> action) {\n        objects.requirenonnull(action);\n        for (t t : this) {\n            action.accept(t);\n        }\n    }\n\n    default spliterator<t> spliterator() {\n        return spliterators.spliteratorunknownsize(iterator(), 0);\n    }\n}\n\n\ncollection 接口扩展了 iterable 接口。\n\n迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的接口。它是一个经典的设计模式——迭代器模式（iterator）。\n\n迭代器模式 - 提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。\n\n\n\n示例：迭代器遍历\n\npublic class iteratordemo {\n\n    public static void main(string[] args) {\n        list<integer> list = new arraylist<>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        iterator it = list.iterator();\n        while (it.hasnext()) {\n            system.out.println(it.next());\n        }\n    }\n\n}\n\n\n\n# comparable 和 comparator\n\ncomparable 是排序接口。若一个类实现了 comparable 接口，表示该类的实例可以比较，也就意味着支持排序。实现了 comparable 接口的类的对象的列表或数组可以通过 collections.sort 或 arrays.sort 进行自动排序。\n\ncomparable 接口定义：\n\npublic interface comparable<t> {\n    public int compareto(t o);\n}\n\n\ncomparator 是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现 comparable 接口)，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现 comparator 接口即可。也就是说，我们可以通过实现 comparator 来新建一个比较器，然后通过这个比较器对类进行排序。\n\ncomparator 接口定义：\n\n@functionalinterface\npublic interface comparator<t> {\n\n    int compare(t o1, t o2);\n\n    boolean equals(object obj);\n\n    // 反转\n    default comparator<t> reversed() {\n        return collections.reverseorder(this);\n    }\n\n    default comparator<t> thencomparing(comparator<? super t> other) {\n        objects.requirenonnull(other);\n        return (comparator<t> & serializable) (c1, c2) -> {\n            int res = compare(c1, c2);\n            return (res != 0) ? res : other.compare(c1, c2);\n        };\n    }\n\n    // thencomparingxxx 方法略\n\n    // 静态方法略\n}\n\n\n在 java 容器中，一些可以排序的容器，如 treemap、treeset，都可以通过传入 comparator，来定义内部元素的排序规则。\n\n\n# cloneable\n\njava 中 一个类要实现 clone 功能 必须实现 cloneable 接口，否则在调用 clone() 时会报 clonenotsupportedexception 异常。\n\njava 中所有类都默认继承 java.lang.object 类，在 java.lang.object 类中有一个方法 clone()，这个方法将返回 object 对象的一个拷贝。object 类里的 clone() 方法仅仅用于浅拷贝（拷贝基本成员属性，对于引用类型仅返回指向改地址的引用）。\n\n如果 java 类需要深拷贝，需要覆写 clone() 方法。\n\n\n# fail-fast\n\n# fail-fast 的要点\n\njava 容器（如：arraylist、hashmap、treeset 等待）的 javadoc 中常常提到类似的描述：\n\n> 注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败（fail-fast）迭代器会尽最大努力抛出 concurrentmodificationexception。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。\n\n那么，我们不禁要问，什么是 fail-fast，为什么要有 fail-fast 机制？\n\nfail-fast 是 java 容器的一种错误检测机制。当多个线程对容器进行结构上的改变的操作时，就可能触发 fail-fast 机制。记住是有可能，而不是一定。\n\n例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 iterator 在遍历容器 a 中的元素，在某个时候线程 2 修改了容器 a 的结构（是结构上面的修改，而不是简单的修改容器元素的内容），那么这个时候程序就会抛出 concurrentmodificationexception 异常，从而产生 fail-fast 机制。\n\n容器在迭代操作中改变元素个数（添加、删除元素）都可能会导致 fail-fast。\n\n示例：fail-fast 示例\n\npublic class failfastdemo {\n\n    private static int max = 100;\n\n    private static list<integer> list = new arraylist<>();\n\n    public static void main(string[] args) {\n        for (int i = 0; i < max; i++) {\n            list.add(i);\n        }\n        new thread(new mythreada()).start();\n        new thread(new mythreadb()).start();\n    }\n\n    /** 迭代遍历容器所有元素 */\n    static class mythreada implements runnable {\n\n        @override\n        public void run() {\n            iterator<integer> iterator = list.iterator();\n            while (iterator.hasnext()) {\n                int i = iterator.next();\n                system.out.println("mythreada 访问元素:" + i);\n                try {\n                    timeunit.milliseconds.sleep(100);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n\n    }\n\n    /** 遍历删除指定范围内的所有偶数 */\n    static class mythreadb implements runnable {\n\n        @override\n        public void run() {\n            int i = 0;\n            while (i < max) {\n                if (i % 2 == 0) {\n                    system.out.println("mythreadb 删除元素" + i);\n                    list.remove(i);\n                }\n                i++;\n            }\n        }\n\n    }\n\n}\n\n\n执行后，会抛出 java.util.concurrentmodificationexception 异常。\n\n# 解决 fail-fast\n\nfail-fast 有两种解决方案：\n\n * 在遍历过程中所有涉及到改变容器个数的地方全部加上 synchronized 或者直接使用 collections.synchronizedxxx 容器，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作，影响吞吐。\n * 使用并发容器，如：copyonwriterarraylist。\n\n\n# 容器和线程安全\n\n为了在并发环境下安全地使用容器，java 提供了同步容器和并发容器。\n\n> 同步容器和并发容器详情请参考：同步容器和并发容器\n\n\n# 参考资料\n\n * java 编程思想（第 4 版）\n * 由浅入深理解 java 集合(一)——集合框架 collection、map\n * 由浅入深理解 java 集合(二)——集合 set\n * java 提高篇（三十）-----iterator\n * java 提高篇（三四）-----fail-fast 机制',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 容器之 List",frontmatter:{title:"Java 容器之 List",categories:["编程","Java","JavaSE","容器"],tags:["Java","JavaSE","容器"],abbrlink:"4387fa0f",date:"2018-06-27T23:12:18.000Z",permalink:"/pages/decaa9/"},regularPath:"/03.%E5%AE%B9%E5%99%A8/02.Java%E5%AE%B9%E5%99%A8%E4%B9%8BList.html",relativePath:"03.容器/02.Java容器之List.md",key:"v-4a35b4c6",path:"/pages/decaa9/",headers:[{level:2,title:"List 简介",slug:"list-简介",normalizedTitle:"list 简介",charIndex:61},{level:3,title:"ArrayList 和 LinkedList",slug:"arraylist-和-linkedlist",normalizedTitle:"arraylist 和 linkedlist",charIndex:324},{level:3,title:"Vector 和 Stack",slug:"vector-和-stack",normalizedTitle:"vector 和 stack",charIndex:568},{level:2,title:"ArrayList",slug:"arraylist",normalizedTitle:"arraylist",charIndex:324},{level:3,title:"ArrayList 要点",slug:"arraylist-要点",normalizedTitle:"arraylist 要点",charIndex:869},{level:3,title:"ArrayList 原理",slug:"arraylist-原理",normalizedTitle:"arraylist 原理",charIndex:1516},{level:4,title:"ArrayList 的数据结构",slug:"arraylist-的数据结构",normalizedTitle:"arraylist 的数据结构",charIndex:1532},{level:4,title:"ArrayList 的序列化",slug:"arraylist-的序列化",normalizedTitle:"arraylist 的序列化",charIndex:1798},{level:4,title:"ArrayList 构造方法",slug:"arraylist-构造方法",normalizedTitle:"arraylist 构造方法",charIndex:2070},{level:4,title:"ArrayList 访问元素",slug:"arraylist-访问元素",normalizedTitle:"arraylist 访问元素",charIndex:2776},{level:4,title:"ArrayList 添加元素",slug:"arraylist-添加元素",normalizedTitle:"arraylist 添加元素",charIndex:3035},{level:4,title:"ArrayList 删除元素",slug:"arraylist-删除元素",normalizedTitle:"arraylist 删除元素",charIndex:4855},{level:4,title:"ArrayList 的 Fail-Fast",slug:"arraylist-的-fail-fast",normalizedTitle:"arraylist 的 fail-fast",charIndex:5369},{level:2,title:"LinkedList",slug:"linkedlist",normalizedTitle:"linkedlist",charIndex:336},{level:3,title:"LinkedList 要点",slug:"linkedlist-要点",normalizedTitle:"linkedlist 要点",charIndex:6172},{level:3,title:"LinkedList 原理",slug:"linkedlist-原理",normalizedTitle:"linkedlist 原理",charIndex:6682},{level:4,title:"LinkedList 的数据结构",slug:"linkedlist-的数据结构",normalizedTitle:"linkedlist 的数据结构",charIndex:6699},{level:4,title:"LinkedList 的序列化",slug:"linkedlist-的序列化",normalizedTitle:"linkedlist 的序列化",charIndex:7157},{level:4,title:"LinkedList 访问元素",slug:"linkedlist-访问元素",normalizedTitle:"linkedlist 访问元素",charIndex:7367},{level:4,title:"LinkedList 添加元素",slug:"linkedlist-添加元素",normalizedTitle:"linkedlist 添加元素",charIndex:8118},{level:4,title:"LinkedList 删除元素",slug:"linkedlist-删除元素",normalizedTitle:"linkedlist 删除元素",charIndex:9435},{level:2,title:"List 常见问题",slug:"list-常见问题",normalizedTitle:"list 常见问题",charIndex:10591},{level:3,title:"Arrays.asList 问题点",slug:"arrays-aslist-问题点",normalizedTitle:"arrays.aslist 问题点",charIndex:10605},{level:3,title:"List.subList 问题点",slug:"list-sublist-问题点",normalizedTitle:"list.sublist 问题点",charIndex:13312},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:14836}],headersStr:"List 简介 ArrayList 和 LinkedList Vector 和 Stack ArrayList ArrayList 要点 ArrayList 原理 ArrayList 的数据结构 ArrayList 的序列化 ArrayList 构造方法 ArrayList 访问元素 ArrayList 添加元素 ArrayList 删除元素 ArrayList 的 Fail-Fast LinkedList LinkedList 要点 LinkedList 原理 LinkedList 的数据结构 LinkedList 的序列化 LinkedList 访问元素 LinkedList 添加元素 LinkedList 删除元素 List 常见问题 Arrays.asList 问题点 List.subList 问题点 参考资料",content:'# Java 容器之 List\n\n> List 是 Collection 的子接口，其中可以保存各个重复的内容。\n\n\n# List 简介\n\nList 是一个接口，它继承于 Collection 的接口。它代表着有序的队列。\n\nAbstractList 是一个抽象类，它继承于 AbstractCollection。AbstractList 实现了 List 接口中除 size()、get(int location) 之外的函数。\n\nAbstractSequentialList 是一个抽象类，它继承于 AbstractList。AbstractSequentialList 实现了“链表中，根据 index 索引值操作链表的全部函数”。\n\n\n# ArrayList 和 LinkedList\n\nArrayList、LinkedList 是 List 最常用的实现。\n\n * ArrayList 基于动态数组实现，存在容量限制，当元素数超过最大容量时，会自动扩容；LinkedList 基于双向链表实现，不存在容量限制。\n * ArrayList 随机访问速度较快，随机插入、删除速度较慢；LinkedList 随机插入、删除速度较快，随机访问速度较慢。\n * ArrayList 和 LinkedList 都不是线程安全的。\n\n\n# Vector 和 Stack\n\nVector 和 Stack 的设计目标是作为线程安全的 List 实现，替代 ArrayList。\n\n * Vector - Vector 和 ArrayList 类似，也实现了 List 接口。但是， Vector 中的主要方法都是 synchronized 方法，即通过互斥同步方式保证操作的线程安全。\n * Stack - Stack 也是一个同步容器，它的方法也用 synchronized 进行了同步，它实际上是继承于 Vector 类。\n\n\n# ArrayList\n\n> ArrayList 从数据结构角度来看，可以视为支持动态扩容的线性表。\n\n\n\n\n# ArrayList 要点\n\nArrayList 是一个数组队列，相当于动态数组。ArrayList 默认初始容量大小为 10 ，添加元素时，如果发现容量已满，会自动扩容为原始大小的 1.5 倍。因此，应该尽量在初始化 ArrayList 时，为其指定合适的初始化容量大小，减少扩容操作产生的性能开销。\n\nArrayList 定义：\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n\n\n从 ArrayList 的定义，不难看出 ArrayList 的一些基本特性：\n\n * ArrayList 实现了 List 接口，并继承了 AbstractList，它支持所有 List 的操作。\n * ArrayList 实现了 RandomAccess 接口，支持随机访问。RandomAccess 是一个标志接口，它意味着“只要实现该接口的 List 类，都支持快速随机访问”。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。\n * ArrayList 实现了 Cloneable 接口，默认为浅拷贝。\n * ArrayList 实现了 Serializable 接口，支持序列化，能通过序列化方式传输。\n * ArrayList 是非线程安全的。\n\n\n# ArrayList 原理\n\n# ArrayList 的数据结构\n\nArrayList 包含了两个重要的元素：elementData 和 size。\n\n// 默认初始化容量\nprivate static final int DEFAULT_CAPACITY = 10;\n// 对象数组\ntransient Object[] elementData;\n// 数组长度\nprivate int size;\n\n\n * size - 是动态数组的实际大小。\n * elementData - 是一个 Object 数组，用于保存添加到 ArrayList 中的元素。\n\n# ArrayList 的序列化\n\nArrayList 具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。为此，ArrayList 定制了其序列化方式。具体做法是：\n\n * 存储元素的 Object 数组（即 elementData）使用 transient 修饰，使得它可以被 Java 序列化所忽略。\n * ArrayList 重写了 writeObject() 和 readObject() 来控制序列化数组中有元素填充那部分内容。\n\n> 💡 不了解 Java 序列化方式，可以参考：Java 序列化\n\n# ArrayList 构造方法\n\nArrayList 类实现了三个构造函数：\n\n * 第一个是默认构造方法，ArrayList 会创建一个空数组；\n * 第二个是创建 ArrayList 对象时，传入一个初始化值；\n * 第三个是传入一个集合类型进行初始化。\n\n当 ArrayList 新增元素时，如果所存储的元素已经超过其当前容量，它会计算容量后再进行动态扩容。数组的动态扩容会导致整个数组进行一次内存复制。因此，初始化 ArrayList 时，指定数组初始大小，有助于减少数组的扩容次数，从而提高系统性能。\n\npublic ArrayList() {\n    // 创建一个空数组\n\tthis.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n\npublic ArrayList(int initialCapacity) {\n\tif (initialCapacity > 0) {\n        // 根据初始化值创建数组大小\n\t\tthis.elementData = new Object[initialCapacity];\n\t} else if (initialCapacity == 0) {\n        // 初始化值为 0 时，创建一个空数组\n\t\tthis.elementData = EMPTY_ELEMENTDATA;\n\t} else {\n\t\tthrow new IllegalArgumentException("Illegal Capacity: "+\n\t\t\t\t\t\t\t\t\t\t   initialCapacity);\n\t}\n}\n\n\n# ArrayList 访问元素\n\nArrayList 访问元素的实现主要基于以下关键性源码：\n\n// 获取第 index 个元素\npublic E get(int index) {\n    rangeCheck(index);\n    return elementData(index);\n}\n\nE elementData(int index) {\n    return (E) elementData[index];\n}\n\n\n实现非常简单，其实就是通过数组下标访问数组元素，其时间复杂度为 O(1)，所以很快。\n\n# ArrayList 添加元素\n\nArrayList 添加元素有两种方法：一种是添加元素到数组末尾，另外一种是添加元素到任意位置。\n\n// 添加元素到数组末尾\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n\n// 添加元素到任意位置\npublic void add(int index, E element) {\n\trangeCheckForAdd(index);\n\n\tensureCapacityInternal(size + 1);  // Increments modCount!!\n\tSystem.arraycopy(elementData, index, elementData, index + 1,\n\t\t\t\t\t size - index);\n\telementData[index] = element;\n\tsize++;\n}\n\n\n两种添加元素方法的不同点是：\n\n * 添加元素到任意位置，会导致在该位置后的所有元素都需要重新排列；\n * 而添加元素到数组末尾，在没有发生扩容的前提下，是不会有元素复制排序过程的。\n\n两种添加元素方法的共同点是：添加元素时，会先检查容量大小，如果发现容量不足，会自动扩容为原始大小的 1.5 倍。\n\nArrayList 添加元素的实现主要基于以下关键性源码：\n\nprivate void ensureCapacityInternal(int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n\n    ensureExplicitCapacity(minCapacity);\n}\n\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\n\nArrayList 执行添加元素动作（add 方法）时，调用 ensureCapacityInternal 方法来保证容量足够。\n\n * 如果容量足够时，将数据作为数组中 size+1 位置上的元素写入，并将 size 自增 1。\n * 如果容量不够时，需要使用 grow 方法进行扩容数组，新容量的大小为 oldCapacity + (oldCapacity >> 1)，也就是旧容量的 1.5 倍。扩容操作实际上是调用 Arrays.copyOf() 把原数组拷贝为一个新数组，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。\n\n# ArrayList 删除元素\n\nArrayList 的删除方法和添加元素到任意位置方法有些相似。\n\nArrayList 在每一次有效的删除操作后，都要进行数组的重组，并且删除的元素位置越靠前，数组重组的开销就越大。具体来说，ArrayList 会**调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上。\n\npublic E remove(int index) {\n    rangeCheck(index);\n\n    modCount++;\n    E oldValue = elementData(index);\n\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index, numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n\n    return oldValue;\n}\n\n\n# ArrayList 的 Fail-Fast\n\nArrayList 使用 modCount 来记录结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。\n\n在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果发生改变，ArrayList 会抛出 ConcurrentModificationException。\n\nprivate void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException{\n    // Write out element count, and any hidden stuff\n    int expectedModCount = modCount;\n    s.defaultWriteObject();\n\n    // Write out size as capacity for behavioural compatibility with clone()\n    s.writeInt(size);\n\n    // Write out all elements in the proper order.\n    for (int i=0; i<size; i++) {\n        s.writeObject(elementData[i]);\n    }\n\n    if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n    }\n}\n\n\n\n# LinkedList\n\n> LinkedList 从数据结构角度来看，可以视为双链表。\n\n\n\n\n# LinkedList 要点\n\nLinkedList 基于双链表结构实现。由于是双链表，所以顺序访问会非常高效，而随机访问效率比较低。\n\nLinkedList 定义：\n\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n\n\n从 LinkedList 的定义，可以得出 LinkedList 的一些基本特性：\n\n * LinkedList 实现了 List 接口，并继承了 AbstractSequentialList ，它支持所有 List 的操作。\n * LinkedList 实现了 Deque 接口，也可以被当作队列（Queue）或双端队列（Deque）进行操作，此外，也可以用来实现栈。\n * LinkedList 实现了 Cloneable 接口，默认为浅拷贝。\n * LinkedList 实现了 Serializable 接口，支持序列化。\n * LinkedList 是非线程安全的。\n\n\n# LinkedList 原理\n\n# LinkedList 的数据结构\n\nLinkedList 内部维护了一个双链表。\n\nLinkedList 通过 Node 类型的头尾指针（first 和 last）来访问数据。\n\n// 链表长度\ntransient int size = 0;\n// 链表头节点\ntransient Node<E> first;\n// 链表尾节点\ntransient Node<E> last;\n\n\n * size - 表示双链表中节点的个数，初始为 0。\n * first 和 last - 分别是双链表的头节点和尾节点。\n\nNode 是 LinkedList 的内部类，它表示链表中的元素实例。Node 中包含三个元素：\n\n * prev 是该节点的上一个节点；\n * next 是该节点的下一个节点；\n * item 是该节点所包含的值。\n\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n    ...\n}\n\n\n# LinkedList 的序列化\n\nLinkedList 与 ArrayList 一样也定制了自身的序列化方式。具体做法是：\n\n * 将 size （双链表容量大小）、first 和last （双链表的头尾节点）修饰为 transient，使得它们可以被 Java 序列化所忽略。\n * 重写了 writeObject() 和 readObject() 来控制序列化时，只处理双链表中能被头节点链式引用的节点元素。\n\n# LinkedList 访问元素\n\nLinkedList 访问元素的实现主要基于以下关键性源码：\n\npublic E get(int index) {\n\tcheckElementIndex(index);\n\treturn node(index).item;\n}\n\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n\n\n获取 LinkedList 第 index 个元素的算法是：\n\n * 判断 index 在链表前半部分，还是后半部分。\n * 如果是前半部分，从头节点开始查找；如果是后半部分，从尾结点开始查找。\n\nLinkedList 这种访问元素的性能是 O(N) 级别的（极端情况下，扫描 N/2 个元素）；相比于 ArrayList 的 O(1)，显然要慢不少。\n\n推荐使用迭代器遍历 LinkedList ，不要使用传统的 for 循环。注：foreach 语法会被编译器转换成迭代器遍历，但是它的遍历过程中不允许修改 List 长度，即不能进行增删操作。\n\n# LinkedList 添加元素\n\nLinkedList 有多种添加元素方法：\n\n * add(E e)：默认添加元素方法（插入尾部）\n * add(int index, E element)：添加元素到任意位置\n * addFirst(E e)：在头部添加元素\n * addLast(E e)：在尾部添加元素\n\npublic boolean add(E e) {\n\tlinkLast(e);\n\treturn true;\n}\n\npublic void add(int index, E element) {\n\tcheckPositionIndex(index);\n\n\tif (index == size)\n\t\tlinkLast(element);\n\telse\n\t\tlinkBefore(element, node(index));\n}\n\npublic void addFirst(E e) {\n\tlinkFirst(e);\n}\n\npublic void addLast(E e) {\n\tlinkLast(e);\n}\n\n\nLinkedList 添加元素的实现主要基于以下关键性源码：\n\nprivate void linkFirst(E e) {\n\tfinal Node<E> f = first;\n\tfinal Node<E> newNode = new Node<>(null, e, f);\n\tfirst = newNode;\n\tif (f == null)\n\t\tlast = newNode;\n\telse\n\t\tf.prev = newNode;\n\tsize++;\n\tmodCount++;\n}\n\nvoid linkLast(E e) {\n\tfinal Node<E> l = last;\n\tfinal Node<E> newNode = new Node<>(l, e, null);\n\tlast = newNode;\n\tif (l == null)\n\t\tfirst = newNode;\n\telse\n\t\tl.next = newNode;\n\tsize++;\n\tmodCount++;\n}\n\nvoid linkBefore(E e, Node<E> succ) {\n\t// assert succ != null;\n\tfinal Node<E> pred = succ.prev;\n\tfinal Node<E> newNode = new Node<>(pred, e, succ);\n\tsucc.prev = newNode;\n\tif (pred == null)\n\t\tfirst = newNode;\n\telse\n\t\tpred.next = newNode;\n\tsize++;\n\tmodCount++;\n}\n\n\n算法如下：\n\n * 将新添加的数据包装为 Node；\n * 如果往头部添加元素，将头指针 first 指向新的 Node，之前的 first 对象的 prev 指向新的 Node。\n * 如果是向尾部添加元素，则将尾指针 last 指向新的 Node，之前的 last 对象的 next 指向新的 Node。\n\n# LinkedList 删除元素\n\nLinkedList 删除元素的实现主要基于以下关键性源码：\n\npublic boolean remove(Object o) {\n    if (o == null) {\n        // 遍历找到要删除的元素节点\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (x.item == null) {\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        // 遍历找到要删除的元素节点\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nE unlink(Node<E> x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n\n    if (prev == null) {\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n\n    if (next == null) {\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n\n\n算法说明：\n\n * 遍历找到要删除的元素节点，然后调用 unlink 方法删除节点；\n * unlink 删除节点的方法：\n   * 如果当前节点有前驱节点，则让前驱节点指向当前节点的下一个节点；否则，让双链表头指针指向下一个节点。\n   * 如果当前节点有后继节点，则让后继节点指向当前节点的前一个节点；否则，让双链表尾指针指向上一个节点。\n\n\n# List 常见问题\n\n\n# Arrays.asList 问题点\n\n在业务开发中，我们常常会把原始的数组转换为 List 类数据结构，来继续展开各种 Stream 操作。通常，我们会使用 Arrays.asList 方法可以把数组一键转换为 List。\n\n【示例】Arrays.asList 转换基本类型数组\n\nint[] arr = { 1, 2, 3 };\nList list = Arrays.asList(arr);\nlog.info("list:{} size:{} class:{}", list, list.size(), list.get(0).getClass());\n\n\n【输出】\n\n11:26:33.214 [main] INFO io.github.dunwu.javacore.container.list.AsList示例 - list:[[I@ae45eb6] size:1 class:class [I\n\n\n数组元素个数为 3，但转换后的列表个数为 1。\n\n由此可知， Arrays.asList 第一个问题点：不能直接使用 Arrays.asList 来转换基本类型数组。\n\n其原因是：Arrays.asList 方法传入的是一个泛型 T 类型可变参数，最终 int 数组整体作为了一个对象成为了泛型类型 T：\n\npublic static <T> List<T> asList(T... a) {\n    return new ArrayList<>(a);\n}\n\n\n直接遍历这样的 List 必然会出现 Bug，修复方式有两种，如果使用 Java8 以上版本可以使用 Arrays.stream 方法来转换，否则可以把 int 数组声明为包装类型 Integer 数组：\n\n【示例】转换整型数组为 List 的正确方式\n\nint[] arr1 = { 1, 2, 3 };\nList list1 = Arrays.stream(arr1).boxed().collect(Collectors.toList());\nlog.info("list:{} size:{} class:{}", list1, list1.size(), list1.get(0).getClass());\n\nInteger[] arr2 = { 1, 2, 3 };\nList list2 = Arrays.asList(arr2);\nlog.info("list:{} size:{} class:{}", list2, list2.size(), list2.get(0).getClass());\n\n\n【示例】Arrays.asList 转换引用类型数组\n\nString[] arr = { "1", "2", "3" };\nList list = Arrays.asList(arr);\narr[1] = "4";\ntry {\n    list.add("5");\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\nlog.info("arr:{} list:{}", Arrays.toString(arr), list);\n\n\n抛出 java.lang.UnsupportedOperationException。\n\n抛出异常的原因在于 Arrays.asList 第二个问题点：Arrays.asList 返回的 List 不支持增删操作。Arrays.asList 返回的 List 并不是我们期望的 java.util.ArrayList，而是 Arrays 的内部类 ArrayList。\n\n查看源码，我们可以发现 Arrays.asList 返回的 ArrayList 继承了 AbstractList，但是并没有覆写 add 和 remove 方法。\n\nprivate static class ArrayList<E> extends AbstractList<E>\n    implements RandomAccess, java.io.Serializable\n{\n    private static final long serialVersionUID = -2764017481108945198L;\n    private final E[] a;\n\n    ArrayList(E[] array) {\n        a = Objects.requireNonNull(array);\n    }\n\n    // ...\n\n    @Override\n    public E set(int index, E element) {\n        E oldValue = a[index];\n        a[index] = element;\n        return oldValue;\n    }\n\n}\n\npublic abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n    public void add(int index, E element) {\n        throw new UnsupportedOperationException();\n    }\n\n    public E remove(int index) {\n        throw new UnsupportedOperationException();\n    }\n}\n\n\nArrays.asList 第三个问题点：对原始数组的修改会影响到我们获得的那个 List。ArrayList 其实是直接使用了原始的数组。\n\n解决方法很简单，重新 new 一个 ArrayList 初始化 Arrays.asList 返回的 List 即可：\n\nString[] arr = { "1", "2", "3" };\nList list = new ArrayList(Arrays.asList(arr));\narr[1] = "4";\ntry {\n    list.add("5");\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\nlog.info("arr:{} list:{}", Arrays.toString(arr), list);\n\n\n\n# List.subList 问题点\n\nList.subList 直接引用了原始的 List，也可以认为是共享“存储”，而且对原始 List 直接进行结构性修改会导致 SubList 出现异常。\n\nprivate static List<List<Integer>> data = new ArrayList<>();\n\nprivate static void oom() {\n    for (int i = 0; i < 1000; i++) {\n        List<Integer> rawList = IntStream.rangeClosed(1, 100000).boxed().collect(Collectors.toList());\n        data.add(rawList.subList(0, 1));\n    }\n}\n\n\n出现 OOM 的原因是，循环中的 1000 个具有 10 万个元素的 List 始终得不到回收，因为它始终被 subList 方法返回的 List 强引用。\n\n解决方法是：\n\nprivate static void oomfix() {\n    for (int i = 0; i < 1000; i++) {\n        List<Integer> rawList = IntStream.rangeClosed(1, 100000).boxed().collect(Collectors.toList());\n        data.add(new ArrayList<>(rawList.subList(0, 1)));\n    }\n}\n\n\n【示例】子 List 强引用原始的 List\n\nprivate static void wrong() {\n    List<Integer> list = IntStream.rangeClosed(1, 10).boxed().collect(Collectors.toList());\n    List<Integer> subList = list.subList(1, 4);\n    System.out.println(subList);\n    subList.remove(1);\n    System.out.println(list);\n    list.add(0);\n    try {\n        subList.forEach(System.out::println);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n\n\n抛出 java.util.ConcurrentModificationException。\n\n解决方法：\n\n一种是，不直接使用 subList 方法返回的 SubList，而是重新使用 new ArrayList，在构造方法传入 SubList，来构建一个独立的 ArrayList；\n\n另一种是，对于 Java 8 使用 Stream 的 skip 和 limit API 来跳过流中的元素，以及限制流中元素的个数，同样可以达到 SubList 切片的目的。\n\n//方式一：\nList<Integer> subList = new ArrayList<>(list.subList(1, 4));\n//方式二：\nList<Integer> subList = list.stream().skip(1).limit(3).collect(Collectors.toList());\n\n\n\n# 参考资料\n\n * Java 编程思想（第 4 版）\n * https://www.cnblogs.com/skywang12345/p/3308556.html\n * http://www.cnblogs.com/skywang12345/p/3308807.html',normalizedContent:'# java 容器之 list\n\n> list 是 collection 的子接口，其中可以保存各个重复的内容。\n\n\n# list 简介\n\nlist 是一个接口，它继承于 collection 的接口。它代表着有序的队列。\n\nabstractlist 是一个抽象类，它继承于 abstractcollection。abstractlist 实现了 list 接口中除 size()、get(int location) 之外的函数。\n\nabstractsequentiallist 是一个抽象类，它继承于 abstractlist。abstractsequentiallist 实现了“链表中，根据 index 索引值操作链表的全部函数”。\n\n\n# arraylist 和 linkedlist\n\narraylist、linkedlist 是 list 最常用的实现。\n\n * arraylist 基于动态数组实现，存在容量限制，当元素数超过最大容量时，会自动扩容；linkedlist 基于双向链表实现，不存在容量限制。\n * arraylist 随机访问速度较快，随机插入、删除速度较慢；linkedlist 随机插入、删除速度较快，随机访问速度较慢。\n * arraylist 和 linkedlist 都不是线程安全的。\n\n\n# vector 和 stack\n\nvector 和 stack 的设计目标是作为线程安全的 list 实现，替代 arraylist。\n\n * vector - vector 和 arraylist 类似，也实现了 list 接口。但是， vector 中的主要方法都是 synchronized 方法，即通过互斥同步方式保证操作的线程安全。\n * stack - stack 也是一个同步容器，它的方法也用 synchronized 进行了同步，它实际上是继承于 vector 类。\n\n\n# arraylist\n\n> arraylist 从数据结构角度来看，可以视为支持动态扩容的线性表。\n\n\n\n\n# arraylist 要点\n\narraylist 是一个数组队列，相当于动态数组。arraylist 默认初始容量大小为 10 ，添加元素时，如果发现容量已满，会自动扩容为原始大小的 1.5 倍。因此，应该尽量在初始化 arraylist 时，为其指定合适的初始化容量大小，减少扩容操作产生的性能开销。\n\narraylist 定义：\n\npublic class arraylist<e> extends abstractlist<e>\n        implements list<e>, randomaccess, cloneable, java.io.serializable\n\n\n从 arraylist 的定义，不难看出 arraylist 的一些基本特性：\n\n * arraylist 实现了 list 接口，并继承了 abstractlist，它支持所有 list 的操作。\n * arraylist 实现了 randomaccess 接口，支持随机访问。randomaccess 是一个标志接口，它意味着“只要实现该接口的 list 类，都支持快速随机访问”。在 arraylist 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。\n * arraylist 实现了 cloneable 接口，默认为浅拷贝。\n * arraylist 实现了 serializable 接口，支持序列化，能通过序列化方式传输。\n * arraylist 是非线程安全的。\n\n\n# arraylist 原理\n\n# arraylist 的数据结构\n\narraylist 包含了两个重要的元素：elementdata 和 size。\n\n// 默认初始化容量\nprivate static final int default_capacity = 10;\n// 对象数组\ntransient object[] elementdata;\n// 数组长度\nprivate int size;\n\n\n * size - 是动态数组的实际大小。\n * elementdata - 是一个 object 数组，用于保存添加到 arraylist 中的元素。\n\n# arraylist 的序列化\n\narraylist 具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。为此，arraylist 定制了其序列化方式。具体做法是：\n\n * 存储元素的 object 数组（即 elementdata）使用 transient 修饰，使得它可以被 java 序列化所忽略。\n * arraylist 重写了 writeobject() 和 readobject() 来控制序列化数组中有元素填充那部分内容。\n\n> 💡 不了解 java 序列化方式，可以参考：java 序列化\n\n# arraylist 构造方法\n\narraylist 类实现了三个构造函数：\n\n * 第一个是默认构造方法，arraylist 会创建一个空数组；\n * 第二个是创建 arraylist 对象时，传入一个初始化值；\n * 第三个是传入一个集合类型进行初始化。\n\n当 arraylist 新增元素时，如果所存储的元素已经超过其当前容量，它会计算容量后再进行动态扩容。数组的动态扩容会导致整个数组进行一次内存复制。因此，初始化 arraylist 时，指定数组初始大小，有助于减少数组的扩容次数，从而提高系统性能。\n\npublic arraylist() {\n    // 创建一个空数组\n\tthis.elementdata = defaultcapacity_empty_elementdata;\n}\n\npublic arraylist(int initialcapacity) {\n\tif (initialcapacity > 0) {\n        // 根据初始化值创建数组大小\n\t\tthis.elementdata = new object[initialcapacity];\n\t} else if (initialcapacity == 0) {\n        // 初始化值为 0 时，创建一个空数组\n\t\tthis.elementdata = empty_elementdata;\n\t} else {\n\t\tthrow new illegalargumentexception("illegal capacity: "+\n\t\t\t\t\t\t\t\t\t\t   initialcapacity);\n\t}\n}\n\n\n# arraylist 访问元素\n\narraylist 访问元素的实现主要基于以下关键性源码：\n\n// 获取第 index 个元素\npublic e get(int index) {\n    rangecheck(index);\n    return elementdata(index);\n}\n\ne elementdata(int index) {\n    return (e) elementdata[index];\n}\n\n\n实现非常简单，其实就是通过数组下标访问数组元素，其时间复杂度为 o(1)，所以很快。\n\n# arraylist 添加元素\n\narraylist 添加元素有两种方法：一种是添加元素到数组末尾，另外一种是添加元素到任意位置。\n\n// 添加元素到数组末尾\npublic boolean add(e e) {\n    ensurecapacityinternal(size + 1);  // increments modcount!!\n    elementdata[size++] = e;\n    return true;\n}\n\n// 添加元素到任意位置\npublic void add(int index, e element) {\n\trangecheckforadd(index);\n\n\tensurecapacityinternal(size + 1);  // increments modcount!!\n\tsystem.arraycopy(elementdata, index, elementdata, index + 1,\n\t\t\t\t\t size - index);\n\telementdata[index] = element;\n\tsize++;\n}\n\n\n两种添加元素方法的不同点是：\n\n * 添加元素到任意位置，会导致在该位置后的所有元素都需要重新排列；\n * 而添加元素到数组末尾，在没有发生扩容的前提下，是不会有元素复制排序过程的。\n\n两种添加元素方法的共同点是：添加元素时，会先检查容量大小，如果发现容量不足，会自动扩容为原始大小的 1.5 倍。\n\narraylist 添加元素的实现主要基于以下关键性源码：\n\nprivate void ensurecapacityinternal(int mincapacity) {\n    if (elementdata == defaultcapacity_empty_elementdata) {\n        mincapacity = math.max(default_capacity, mincapacity);\n    }\n\n    ensureexplicitcapacity(mincapacity);\n}\n\nprivate void ensureexplicitcapacity(int mincapacity) {\n    modcount++;\n\n    // overflow-conscious code\n    if (mincapacity - elementdata.length > 0)\n        grow(mincapacity);\n}\n\nprivate void grow(int mincapacity) {\n    // overflow-conscious code\n    int oldcapacity = elementdata.length;\n    int newcapacity = oldcapacity + (oldcapacity >> 1);\n    if (newcapacity - mincapacity < 0)\n        newcapacity = mincapacity;\n    if (newcapacity - max_array_size > 0)\n        newcapacity = hugecapacity(mincapacity);\n    // mincapacity is usually close to size, so this is a win:\n    elementdata = arrays.copyof(elementdata, newcapacity);\n}\n\n\narraylist 执行添加元素动作（add 方法）时，调用 ensurecapacityinternal 方法来保证容量足够。\n\n * 如果容量足够时，将数据作为数组中 size+1 位置上的元素写入，并将 size 自增 1。\n * 如果容量不够时，需要使用 grow 方法进行扩容数组，新容量的大小为 oldcapacity + (oldcapacity >> 1)，也就是旧容量的 1.5 倍。扩容操作实际上是调用 arrays.copyof() 把原数组拷贝为一个新数组，因此最好在创建 arraylist 对象时就指定大概的容量大小，减少扩容操作的次数。\n\n# arraylist 删除元素\n\narraylist 的删除方法和添加元素到任意位置方法有些相似。\n\narraylist 在每一次有效的删除操作后，都要进行数组的重组，并且删除的元素位置越靠前，数组重组的开销就越大。具体来说，arraylist 会**调用 system.arraycopy() 将 index+1 后面的元素都复制到 index 位置上。\n\npublic e remove(int index) {\n    rangecheck(index);\n\n    modcount++;\n    e oldvalue = elementdata(index);\n\n    int nummoved = size - index - 1;\n    if (nummoved > 0)\n        system.arraycopy(elementdata, index+1, elementdata, index, nummoved);\n    elementdata[--size] = null; // clear to let gc do its work\n\n    return oldvalue;\n}\n\n\n# arraylist 的 fail-fast\n\narraylist 使用 modcount 来记录结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。\n\n在进行序列化或者迭代等操作时，需要比较操作前后 modcount 是否改变，如果发生改变，arraylist 会抛出 concurrentmodificationexception。\n\nprivate void writeobject(java.io.objectoutputstream s)\n    throws java.io.ioexception{\n    // write out element count, and any hidden stuff\n    int expectedmodcount = modcount;\n    s.defaultwriteobject();\n\n    // write out size as capacity for behavioural compatibility with clone()\n    s.writeint(size);\n\n    // write out all elements in the proper order.\n    for (int i=0; i<size; i++) {\n        s.writeobject(elementdata[i]);\n    }\n\n    if (modcount != expectedmodcount) {\n        throw new concurrentmodificationexception();\n    }\n}\n\n\n\n# linkedlist\n\n> linkedlist 从数据结构角度来看，可以视为双链表。\n\n\n\n\n# linkedlist 要点\n\nlinkedlist 基于双链表结构实现。由于是双链表，所以顺序访问会非常高效，而随机访问效率比较低。\n\nlinkedlist 定义：\n\npublic class linkedlist<e>\n    extends abstractsequentiallist<e>\n    implements list<e>, deque<e>, cloneable, java.io.serializable\n\n\n从 linkedlist 的定义，可以得出 linkedlist 的一些基本特性：\n\n * linkedlist 实现了 list 接口，并继承了 abstractsequentiallist ，它支持所有 list 的操作。\n * linkedlist 实现了 deque 接口，也可以被当作队列（queue）或双端队列（deque）进行操作，此外，也可以用来实现栈。\n * linkedlist 实现了 cloneable 接口，默认为浅拷贝。\n * linkedlist 实现了 serializable 接口，支持序列化。\n * linkedlist 是非线程安全的。\n\n\n# linkedlist 原理\n\n# linkedlist 的数据结构\n\nlinkedlist 内部维护了一个双链表。\n\nlinkedlist 通过 node 类型的头尾指针（first 和 last）来访问数据。\n\n// 链表长度\ntransient int size = 0;\n// 链表头节点\ntransient node<e> first;\n// 链表尾节点\ntransient node<e> last;\n\n\n * size - 表示双链表中节点的个数，初始为 0。\n * first 和 last - 分别是双链表的头节点和尾节点。\n\nnode 是 linkedlist 的内部类，它表示链表中的元素实例。node 中包含三个元素：\n\n * prev 是该节点的上一个节点；\n * next 是该节点的下一个节点；\n * item 是该节点所包含的值。\n\nprivate static class node<e> {\n    e item;\n    node<e> next;\n    node<e> prev;\n    ...\n}\n\n\n# linkedlist 的序列化\n\nlinkedlist 与 arraylist 一样也定制了自身的序列化方式。具体做法是：\n\n * 将 size （双链表容量大小）、first 和last （双链表的头尾节点）修饰为 transient，使得它们可以被 java 序列化所忽略。\n * 重写了 writeobject() 和 readobject() 来控制序列化时，只处理双链表中能被头节点链式引用的节点元素。\n\n# linkedlist 访问元素\n\nlinkedlist 访问元素的实现主要基于以下关键性源码：\n\npublic e get(int index) {\n\tcheckelementindex(index);\n\treturn node(index).item;\n}\n\nnode<e> node(int index) {\n    // assert iselementindex(index);\n\n    if (index < (size >> 1)) {\n        node<e> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        node<e> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n\n\n获取 linkedlist 第 index 个元素的算法是：\n\n * 判断 index 在链表前半部分，还是后半部分。\n * 如果是前半部分，从头节点开始查找；如果是后半部分，从尾结点开始查找。\n\nlinkedlist 这种访问元素的性能是 o(n) 级别的（极端情况下，扫描 n/2 个元素）；相比于 arraylist 的 o(1)，显然要慢不少。\n\n推荐使用迭代器遍历 linkedlist ，不要使用传统的 for 循环。注：foreach 语法会被编译器转换成迭代器遍历，但是它的遍历过程中不允许修改 list 长度，即不能进行增删操作。\n\n# linkedlist 添加元素\n\nlinkedlist 有多种添加元素方法：\n\n * add(e e)：默认添加元素方法（插入尾部）\n * add(int index, e element)：添加元素到任意位置\n * addfirst(e e)：在头部添加元素\n * addlast(e e)：在尾部添加元素\n\npublic boolean add(e e) {\n\tlinklast(e);\n\treturn true;\n}\n\npublic void add(int index, e element) {\n\tcheckpositionindex(index);\n\n\tif (index == size)\n\t\tlinklast(element);\n\telse\n\t\tlinkbefore(element, node(index));\n}\n\npublic void addfirst(e e) {\n\tlinkfirst(e);\n}\n\npublic void addlast(e e) {\n\tlinklast(e);\n}\n\n\nlinkedlist 添加元素的实现主要基于以下关键性源码：\n\nprivate void linkfirst(e e) {\n\tfinal node<e> f = first;\n\tfinal node<e> newnode = new node<>(null, e, f);\n\tfirst = newnode;\n\tif (f == null)\n\t\tlast = newnode;\n\telse\n\t\tf.prev = newnode;\n\tsize++;\n\tmodcount++;\n}\n\nvoid linklast(e e) {\n\tfinal node<e> l = last;\n\tfinal node<e> newnode = new node<>(l, e, null);\n\tlast = newnode;\n\tif (l == null)\n\t\tfirst = newnode;\n\telse\n\t\tl.next = newnode;\n\tsize++;\n\tmodcount++;\n}\n\nvoid linkbefore(e e, node<e> succ) {\n\t// assert succ != null;\n\tfinal node<e> pred = succ.prev;\n\tfinal node<e> newnode = new node<>(pred, e, succ);\n\tsucc.prev = newnode;\n\tif (pred == null)\n\t\tfirst = newnode;\n\telse\n\t\tpred.next = newnode;\n\tsize++;\n\tmodcount++;\n}\n\n\n算法如下：\n\n * 将新添加的数据包装为 node；\n * 如果往头部添加元素，将头指针 first 指向新的 node，之前的 first 对象的 prev 指向新的 node。\n * 如果是向尾部添加元素，则将尾指针 last 指向新的 node，之前的 last 对象的 next 指向新的 node。\n\n# linkedlist 删除元素\n\nlinkedlist 删除元素的实现主要基于以下关键性源码：\n\npublic boolean remove(object o) {\n    if (o == null) {\n        // 遍历找到要删除的元素节点\n        for (node<e> x = first; x != null; x = x.next) {\n            if (x.item == null) {\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        // 遍历找到要删除的元素节点\n        for (node<e> x = first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\ne unlink(node<e> x) {\n    // assert x != null;\n    final e element = x.item;\n    final node<e> next = x.next;\n    final node<e> prev = x.prev;\n\n    if (prev == null) {\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n\n    if (next == null) {\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n\n    x.item = null;\n    size--;\n    modcount++;\n    return element;\n}\n\n\n算法说明：\n\n * 遍历找到要删除的元素节点，然后调用 unlink 方法删除节点；\n * unlink 删除节点的方法：\n   * 如果当前节点有前驱节点，则让前驱节点指向当前节点的下一个节点；否则，让双链表头指针指向下一个节点。\n   * 如果当前节点有后继节点，则让后继节点指向当前节点的前一个节点；否则，让双链表尾指针指向上一个节点。\n\n\n# list 常见问题\n\n\n# arrays.aslist 问题点\n\n在业务开发中，我们常常会把原始的数组转换为 list 类数据结构，来继续展开各种 stream 操作。通常，我们会使用 arrays.aslist 方法可以把数组一键转换为 list。\n\n【示例】arrays.aslist 转换基本类型数组\n\nint[] arr = { 1, 2, 3 };\nlist list = arrays.aslist(arr);\nlog.info("list:{} size:{} class:{}", list, list.size(), list.get(0).getclass());\n\n\n【输出】\n\n11:26:33.214 [main] info io.github.dunwu.javacore.container.list.aslist示例 - list:[[i@ae45eb6] size:1 class:class [i\n\n\n数组元素个数为 3，但转换后的列表个数为 1。\n\n由此可知， arrays.aslist 第一个问题点：不能直接使用 arrays.aslist 来转换基本类型数组。\n\n其原因是：arrays.aslist 方法传入的是一个泛型 t 类型可变参数，最终 int 数组整体作为了一个对象成为了泛型类型 t：\n\npublic static <t> list<t> aslist(t... a) {\n    return new arraylist<>(a);\n}\n\n\n直接遍历这样的 list 必然会出现 bug，修复方式有两种，如果使用 java8 以上版本可以使用 arrays.stream 方法来转换，否则可以把 int 数组声明为包装类型 integer 数组：\n\n【示例】转换整型数组为 list 的正确方式\n\nint[] arr1 = { 1, 2, 3 };\nlist list1 = arrays.stream(arr1).boxed().collect(collectors.tolist());\nlog.info("list:{} size:{} class:{}", list1, list1.size(), list1.get(0).getclass());\n\ninteger[] arr2 = { 1, 2, 3 };\nlist list2 = arrays.aslist(arr2);\nlog.info("list:{} size:{} class:{}", list2, list2.size(), list2.get(0).getclass());\n\n\n【示例】arrays.aslist 转换引用类型数组\n\nstring[] arr = { "1", "2", "3" };\nlist list = arrays.aslist(arr);\narr[1] = "4";\ntry {\n    list.add("5");\n} catch (exception ex) {\n    ex.printstacktrace();\n}\nlog.info("arr:{} list:{}", arrays.tostring(arr), list);\n\n\n抛出 java.lang.unsupportedoperationexception。\n\n抛出异常的原因在于 arrays.aslist 第二个问题点：arrays.aslist 返回的 list 不支持增删操作。arrays.aslist 返回的 list 并不是我们期望的 java.util.arraylist，而是 arrays 的内部类 arraylist。\n\n查看源码，我们可以发现 arrays.aslist 返回的 arraylist 继承了 abstractlist，但是并没有覆写 add 和 remove 方法。\n\nprivate static class arraylist<e> extends abstractlist<e>\n    implements randomaccess, java.io.serializable\n{\n    private static final long serialversionuid = -2764017481108945198l;\n    private final e[] a;\n\n    arraylist(e[] array) {\n        a = objects.requirenonnull(array);\n    }\n\n    // ...\n\n    @override\n    public e set(int index, e element) {\n        e oldvalue = a[index];\n        a[index] = element;\n        return oldvalue;\n    }\n\n}\n\npublic abstract class abstractlist<e> extends abstractcollection<e> implements list<e> {\n    public void add(int index, e element) {\n        throw new unsupportedoperationexception();\n    }\n\n    public e remove(int index) {\n        throw new unsupportedoperationexception();\n    }\n}\n\n\narrays.aslist 第三个问题点：对原始数组的修改会影响到我们获得的那个 list。arraylist 其实是直接使用了原始的数组。\n\n解决方法很简单，重新 new 一个 arraylist 初始化 arrays.aslist 返回的 list 即可：\n\nstring[] arr = { "1", "2", "3" };\nlist list = new arraylist(arrays.aslist(arr));\narr[1] = "4";\ntry {\n    list.add("5");\n} catch (exception ex) {\n    ex.printstacktrace();\n}\nlog.info("arr:{} list:{}", arrays.tostring(arr), list);\n\n\n\n# list.sublist 问题点\n\nlist.sublist 直接引用了原始的 list，也可以认为是共享“存储”，而且对原始 list 直接进行结构性修改会导致 sublist 出现异常。\n\nprivate static list<list<integer>> data = new arraylist<>();\n\nprivate static void oom() {\n    for (int i = 0; i < 1000; i++) {\n        list<integer> rawlist = intstream.rangeclosed(1, 100000).boxed().collect(collectors.tolist());\n        data.add(rawlist.sublist(0, 1));\n    }\n}\n\n\n出现 oom 的原因是，循环中的 1000 个具有 10 万个元素的 list 始终得不到回收，因为它始终被 sublist 方法返回的 list 强引用。\n\n解决方法是：\n\nprivate static void oomfix() {\n    for (int i = 0; i < 1000; i++) {\n        list<integer> rawlist = intstream.rangeclosed(1, 100000).boxed().collect(collectors.tolist());\n        data.add(new arraylist<>(rawlist.sublist(0, 1)));\n    }\n}\n\n\n【示例】子 list 强引用原始的 list\n\nprivate static void wrong() {\n    list<integer> list = intstream.rangeclosed(1, 10).boxed().collect(collectors.tolist());\n    list<integer> sublist = list.sublist(1, 4);\n    system.out.println(sublist);\n    sublist.remove(1);\n    system.out.println(list);\n    list.add(0);\n    try {\n        sublist.foreach(system.out::println);\n    } catch (exception ex) {\n        ex.printstacktrace();\n    }\n}\n\n\n抛出 java.util.concurrentmodificationexception。\n\n解决方法：\n\n一种是，不直接使用 sublist 方法返回的 sublist，而是重新使用 new arraylist，在构造方法传入 sublist，来构建一个独立的 arraylist；\n\n另一种是，对于 java 8 使用 stream 的 skip 和 limit api 来跳过流中的元素，以及限制流中元素的个数，同样可以达到 sublist 切片的目的。\n\n//方式一：\nlist<integer> sublist = new arraylist<>(list.sublist(1, 4));\n//方式二：\nlist<integer> sublist = list.stream().skip(1).limit(3).collect(collectors.tolist());\n\n\n\n# 参考资料\n\n * java 编程思想（第 4 版）\n * https://www.cnblogs.com/skywang12345/p/3308556.html\n * http://www.cnblogs.com/skywang12345/p/3308807.html',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 容器之 Map",frontmatter:{title:"Java 容器之 Map",categories:["编程","Java","JavaSE","容器"],tags:["Java","JavaSE","容器"],abbrlink:"b16ba4bf",date:"2019-12-29T21:49:58.000Z",permalink:"/pages/6ce173/"},regularPath:"/03.%E5%AE%B9%E5%99%A8/03.Java%E5%AE%B9%E5%99%A8%E4%B9%8BMap.html",relativePath:"03.容器/03.Java容器之Map.md",key:"v-25ace197",path:"/pages/6ce173/",headers:[{level:2,title:"Map 简介",slug:"map-简介",normalizedTitle:"map 简介",charIndex:19},{level:3,title:"Map 架构",slug:"map-架构",normalizedTitle:"map 架构",charIndex:30},{level:3,title:"Map 接口",slug:"map-接口",normalizedTitle:"map 接口",charIndex:450},{level:3,title:"Map.Entry 接口",slug:"map-entry-接口",normalizedTitle:"map.entry 接口",charIndex:1475},{level:3,title:"AbstractMap 抽象类",slug:"abstractmap-抽象类",normalizedTitle:"abstractmap 抽象类",charIndex:1630},{level:3,title:"SortedMap 接口",slug:"sortedmap-接口",normalizedTitle:"sortedmap 接口",charIndex:2066},{level:3,title:"NavigableMap 接口",slug:"navigablemap-接口",normalizedTitle:"navigablemap 接口",charIndex:441},{level:3,title:"Dictionary 抽象类",slug:"dictionary-抽象类",normalizedTitle:"dictionary 抽象类",charIndex:3194},{level:2,title:"HashMap 类",slug:"hashmap-类",normalizedTitle:"hashmap 类",charIndex:1260},{level:3,title:"HashMap 要点",slug:"hashmap-要点",normalizedTitle:"hashmap 要点",charIndex:3361},{level:3,title:"HashMap 原理",slug:"hashmap-原理",normalizedTitle:"hashmap 原理",charIndex:4018},{level:4,title:"HashMap 数据结构",slug:"hashmap-数据结构",normalizedTitle:"hashmap 数据结构",charIndex:4032},{level:4,title:"HashMap 构造方法",slug:"hashmap-构造方法",normalizedTitle:"hashmap 构造方法",charIndex:4721},{level:4,title:"put 方法的实现",slug:"put-方法的实现",normalizedTitle:"put 方法的实现",charIndex:5011},{level:4,title:"get 方法的实现",slug:"get-方法的实现",normalizedTitle:"get 方法的实现",charIndex:7645},{level:4,title:"hash 方法的实现",slug:"hash-方法的实现",normalizedTitle:"hash 方法的实现",charIndex:8871},{level:4,title:"resize 的实现",slug:"resize-的实现",normalizedTitle:"resize 的实现",charIndex:10269},{level:2,title:"LinkedHashMap 类",slug:"linkedhashmap-类",normalizedTitle:"linkedhashmap 类",charIndex:13933},{level:3,title:"LinkedHashMap 要点",slug:"linkedhashmap-要点",normalizedTitle:"linkedhashmap 要点",charIndex:13953},{level:3,title:"LinkedHashMap 要点",slug:"linkedhashmap-要点-2",normalizedTitle:"linkedhashmap 要点",charIndex:13953},{level:4,title:"LinkedHashMap 数据结构",slug:"linkedhashmap-数据结构",normalizedTitle:"linkedhashmap 数据结构",charIndex:14196},{level:2,title:"TreeMap 类",slug:"treemap-类",normalizedTitle:"treemap 类",charIndex:14652},{level:3,title:"TreeMap 要点",slug:"treemap-要点",normalizedTitle:"treemap 要点",charIndex:14666},{level:3,title:"TreeMap 原理",slug:"treemap-原理",normalizedTitle:"treemap 原理",charIndex:14789},{level:4,title:"put 方法",slug:"put-方法",normalizedTitle:"put 方法",charIndex:1968},{level:4,title:"get 方法",slug:"get-方法",normalizedTitle:"get 方法",charIndex:7645},{level:3,title:"remove 方法",slug:"remove-方法",normalizedTitle:"remove 方法",charIndex:17066},{level:3,title:"TreeMap 示例",slug:"treemap-示例",normalizedTitle:"treemap 示例",charIndex:18802},{level:2,title:"WeakHashMap",slug:"weakhashmap",normalizedTitle:"weakhashmap",charIndex:886},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:20781},{level:3,title:"Map 简介",slug:"map-简介-2",normalizedTitle:"map 简介",charIndex:19},{level:3,title:"HashMap",slug:"hashmap",normalizedTitle:"hashmap",charIndex:412},{level:3,title:"其他 Map",slug:"其他-map",normalizedTitle:"其他 map",charIndex:20815},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:20828}],headersStr:"Map 简介 Map 架构 Map 接口 Map.Entry 接口 AbstractMap 抽象类 SortedMap 接口 NavigableMap 接口 Dictionary 抽象类 HashMap 类 HashMap 要点 HashMap 原理 HashMap 数据结构 HashMap 构造方法 put 方法的实现 get 方法的实现 hash 方法的实现 resize 的实现 LinkedHashMap 类 LinkedHashMap 要点 LinkedHashMap 要点 LinkedHashMap 数据结构 TreeMap 类 TreeMap 要点 TreeMap 原理 put 方法 get 方法 remove 方法 TreeMap 示例 WeakHashMap 总结 Map 简介 HashMap 其他 Map 参考资料",content:'# Java 容器之 Map\n\n\n# Map 简介\n\n\n# Map 架构\n\n\n\nMap 家族主要成员功能如下：\n\n * Map 是 Map 容器家族的祖先，Map 是一个用于保存键值对(key-value)的接口。Map 中不能包含重复的键；每个键最多只能映射到一个值。\n * AbstractMap 继承了 Map 的抽象类，它实现了 Map 中的核心 API。其它 Map 的实现类可以通过继承 AbstractMap 来减少重复编码。\n * SortedMap 继承了 Map 的接口。SortedMap 中的内容是排序的键值对，排序的方法是通过实现比较器(Comparator)完成的。\n * NavigableMap 继承了 SortedMap 的接口。相比于 SortedMap，NavigableMap 有一系列的“导航”方法；如"获取大于/等于某对象的键值对"、“获取小于/等于某对象的键值对”等等。\n * HashMap 继承了 AbstractMap，但没实现 NavigableMap 接口。HashMap 的主要作用是储存无序的键值对，而 Hash 也体现了它的查找效率很高。HashMap 是使用最广泛的 Map。\n * Hashtable 虽然没有继承 AbstractMap，但它继承了 Dictionary（Dictionary 也是键值对的接口），而且也实现 Map 接口。因此，Hashtable 的主要作用是储存无序的键值对。和 HashMap 相比，Hashtable 在它的主要方法中使用 synchronized 关键字修饰，来保证线程安全。但是，由于它的锁粒度太大，非常影响读写速度，所以，现代 Java 程序几乎不会使用 Hashtable ，如果需要保证线程安全，一般会用 ConcurrentHashMap 来替代。\n * TreeMap 继承了 AbstractMap，且实现了 NavigableMap 接口。TreeMap 的主要作用是储存有序的键值对，排序依据根据元素类型的 Comparator 而定。\n * WeakHashMap 继承了 AbstractMap。WeakHashMap 的键是弱引用 （即 WeakReference），它的主要作用是当 GC 内存不足时，会自动将 WeakHashMap 中的 key 回收，这避免了 WeakHashMap 的内存空间无限膨胀。很明显，WeakHashMap 适用于作为缓存。\n\n\n# Map 接口\n\nMap 的定义如下：\n\npublic interface Map<K,V> { }\n\n\nMap 是一个用于保存键值对(key-value)的接口。Map 中不能包含重复的键；每个键最多只能映射到一个值。\n\nMap 接口提供三种 Collection 视图，允许以键集、值集或键-值映射关系集的形式访问数据。\n\nMap 有些实现类，可以有序的保存元素，如 TreeMap；另一些实现类则不保证顺序，如 HashMap 类。\n\nMap 的实现类应该提供 2 个“标准的”构造方法：\n\n * void（无参数）构造方法，用于创建空 Map；\n * 带有单个 Map 类型参数的构造方法，用于创建一个与其参数具有相同键-值映射关系的新 Map。\n\n实际上，后一个构造方法允许用户复制任意 Map，生成所需类的一个等价 Map。尽管无法强制执行此建议（因为接口不能包含构造方法），但是 JDK 中所有通用的 Map 实现都遵从它。\n\n\n# Map.Entry 接口\n\nMap.Entry 一般用于通过迭代器（Iterator）访问问 Map。\n\nMap.Entry 是 Map 中内部的一个接口，Map.Entry 代表了 键值对 实体，Map 通过 entrySet() 获取 Map.Entry 集合，从而通过该集合实现对键值对的操作。\n\n\n# AbstractMap 抽象类\n\nAbstractMap 的定义如下：\n\npublic abstract class AbstractMap<K,V> implements Map<K,V> {}\n\n\nAbstractMap 抽象类提供了 Map 接口的核心实现，以最大限度地减少实现 Map 接口所需的工作。\n\n要实现不可修改的 Map，编程人员只需扩展此类并提供 entrySet() 方法的实现即可，该方法将返回 Map 的映射关系 Set 视图。通常，返回的 set 将依次在 AbstractSet 上实现。此 Set 不支持 add() 或 remove() 方法，其迭代器也不支持 remove() 方法。\n\n要实现可修改的 Map，编程人员必须另外重写此类的 put 方法（否则将抛出 UnsupportedOperationException），entrySet().iterator() 返回的迭代器也必须另外实现其 remove() 方法。\n\n\n# SortedMap 接口\n\nSortedMap 的定义如下：\n\npublic interface SortedMap<K,V> extends Map<K,V> { }\n\n\nSortedMap 继承了 Map ，它是一个有序的 Map。\n\nSortedMap 的排序方式有两种：自然排序或者用户指定比较器。插入有序 SortedMap 的所有元素都必须实现 Comparable 接口（或者被指定的比较器所接受）。\n\n另外，所有 SortedMap 实现类都应该提供 4 个“标准”构造方法：\n\n 1. void（无参数）构造方法，它创建一个空的有序 Map，按照键的自然顺序进行排序。\n 2. 带有一个 Comparator 类型参数的构造方法，它创建一个空的有序 Map，根据指定的比较器进行排序。\n 3. 带有一个 Map 类型参数的构造方法，它创建一个新的有序 Map，其键-值映射关系与参数相同，按照键的自然顺序进行排序。\n 4. 带有一个 SortedMap 类型参数的构造方法，它创建一个新的有序 Map，其键-值映射关系和排序方法与输入的有序 Map 相同。无法保证强制实施此建议，因为接口不能包含构造方法。\n\n\n# NavigableMap 接口\n\nNavigableMap 的定义如下：\n\npublic interface NavigableMap<K,V> extends SortedMap<K,V> { }\n\n\nNavigableMap 继承了 SortedMap ，它提供了丰富的查找方法。\n\nNavigableMap 分别提供了获取“键”、“键-值对”、“键集”、“键-值对集”的相关方法。\n\nNavigableMap 提供的功能可以分为 4 类：\n\n * 获取键-值对\n   * lowerEntry、floorEntry、ceilingEntry 和 higherEntry 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键关联的 Map.Entry 对象。\n   * firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 方法，它们返回和/或移除最小和最大的映射关系（如果存在），否则返回 null。\n * 获取键。这个和第 1 类比较类似。\n   * lowerKey、floorKey、ceilingKey 和 higherKey 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键。\n * 获取键的集合\n   * navigableKeySet、descendingKeySet 分别获取正序/反序的键集。\n * 获取键-值对的子集\n\n\n# Dictionary 抽象类\n\nDictionary 的定义如下：\n\npublic abstract class Dictionary<K,V> {}\n\n\nDictionary 是 JDK 1.0 定义的操作键值对的抽象类，它包括了操作键值对的基本方法。\n\n\n# HashMap 类\n\nHashMap 类是最常用的 Map。\n\n\n# HashMap 要点\n\n从 HashMap 的命名，也可以看出：HashMap 以散列方式存储键值对。\n\nHashMap 允许使用空值和空键。（HashMap 类大致等同于 Hashtable，除了它是不同步的并且允许为空值。）这个类不保序；特别是，它的元素顺序可能会随着时间的推移变化。\n\nHashMap 有两个影响其性能的参数：初始容量和负载因子。\n\n * 容量是哈希表中桶的数量，初始容量就是哈希表创建时的容量。\n * 加载因子是散列表在其容量自动扩容之前被允许的最大饱和量。当哈希表中的 entry 数量超过负载因子和当前容量的乘积时，散列表就会被重新映射（即重建内部数据结构），一般散列表大约是存储桶数量的两倍。\n\n通常，默认加载因子（0.75）在时间和空间成本之间提供了良好的平衡。较高的值会减少空间开销，但会增加查找成本（反映在大部分 HashMap 类的操作中，包括 get 和 put）。在设置初始容量时，应考虑映射中的条目数量及其负载因子，以尽量减少重新运行操作的次数。如果初始容量大于最大入口数除以负载因子，则不会发生重新刷新操作。\n\n如果许多映射要存储在 HashMap 实例中，使用足够大的容量创建映射将允许映射存储的效率高于根据需要执行自动重新散列以增长表。请注意，使用多个具有相同 hashCode() 的密钥是降低任何散列表性能的一个可靠方法。为了改善影响，当键是 Comparable 时，该类可以使用键之间的比较顺序来帮助断开关系。\n\nHashMap 不是线程安全的。\n\n\n# HashMap 原理\n\n# HashMap 数据结构\n\nHashMap 的核心字段：\n\n * table - HashMap 使用一个 Node<K,V>[] 类型的数组 table 来储存元素。\n * size - 初始容量。 初始为 16，每次容量不够自动扩容\n * loadFactor - 负载因子。自动扩容之前被允许的最大饱和量，默认 0.75。\n\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable {\n\n    // 该表在初次使用时初始化，并根据需要调整大小。分配时，长度总是2的幂。\n    transient Node<K,V>[] table;\n    // 保存缓存的 entrySet()。请注意，AbstractMap 字段用于 keySet() 和 values()。\n    transient Set<Map.Entry<K,V>> entrySet;\n    // map 中的键值对数\n    transient int size;\n    // 这个HashMap被结构修改的次数结构修改是那些改变HashMap中的映射数量或者修改其内部结构（例如，重新散列）的修改。\n    transient int modCount;\n    // 下一个调整大小的值（容量*加载因子）。\n    int threshold;\n    // 散列表的加载因子\n    final float loadFactor;\n}\n\n\n# HashMap 构造方法\n\npublic HashMap(); // 默认加载因子0.75\npublic HashMap(int initialCapacity); // 默认加载因子0.75；以 initialCapacity 初始化容量\npublic HashMap(int initialCapacity, float loadFactor); // 以 initialCapacity 初始化容量；以 loadFactor 初始化加载因子\npublic HashMap(Map<? extends K, ? extends V> m) // 默认加载因子0.75\n\n\n# put 方法的实现\n\nput 方法大致的思路为：\n\n * 对 key 的 hashCode() 做 hash 计算，然后根据 hash 值再计算 Node 的存储位置;\n * 如果没有哈希碰撞，直接放到桶里；如果有哈希碰撞，以链表的形式存在桶后。\n * 如果哈希碰撞导致链表过长(大于等于 TREEIFY_THRESHOLD，数值为 8)，就把链表转换成红黑树；\n * 如果节点已经存在就替换旧值\n * 桶数量超过容量*负载因子（即 load factor * current capacity），HashMap 调用 resize 自动扩容一倍\n\n具体代码的实现如下：\n\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\n// hashcode 无符号位移 16 位\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // tab 为空则创建\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 计算 index，并对 null 做处理\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; K k;\n        // 节点存在\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 该链为树\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 该链为链表\n        else {\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        // 写入\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n\n\n为什么计算 hash 使用 hashcode 无符号位移 16 位。\n\n假设要添加两个对象 a 和 b，如果数组长度是 16，这时对象 a 和 b 通过公式 (n - 1) & hash 运算，也就是 (16-1)＆a.hashCode 和 (16-1)＆b.hashCode，15 的二进制为 0000000000000000000000000001111，假设对象 A 的 hashCode 为 1000010001110001000001111000000，对象 B 的 hashCode 为 0111011100111000101000010100000，你会发现上述与运算结果都是 0。这样的哈希结果就太让人失望了，很明显不是一个好的哈希算法。\n\n但如果我们将 hashCode 值右移 16 位（h >>> 16 代表无符号右移 16 位），也就是取 int 类型的一半，刚好可以将该二进制数对半切开，并且使用位异或运算（如果两个数对应的位置相反，则结果为 1，反之为 0），这样的话，就能避免上面的情况发生。这就是 hash() 方法的具体实现方式。简而言之，就是尽量打乱 hashCode 真正参与运算的低 16 位。\n\n# get 方法的实现\n\n在理解了 put 之后，get 就很简单了。大致思路如下：\n\n * 对 key 的 hashCode() 做 hash 计算，然后根据 hash 值再计算桶的 index\n\n * 如果桶中的第一个节点命中，直接返回；\n\n * 如果有冲突，则通过 key.equals(k) 去查找对应的 entry\n   \n   * 若为树，则在红黑树中通过 key.equals(k) 查找，O(logn)；\n   \n   * 若为链表，则在链表中通过 key.equals(k) 查找，O(n)。\n\n具体代码的实现如下：\n\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 直接命中\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        // 未命中\n        if ((e = first.next) != null) {\n            // 在树中 get\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            // 在链表中 get\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n\n\n# hash 方法的实现\n\nHashMap 计算桶下标（index）公式：key.hashCode() ^ (h >>> 16)。\n\n下面针对这个公式来详细讲解。\n\n在 get 和 put 的过程中，计算下标时，先对 hashCode 进行 hash 操作，然后再通过 hash 值进一步计算下标，如下图所示：\n\n\n\n在对 hashCode() 计算 hash 时具体实现是这样的：\n\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\n\n可以看到这个方法大概的作用就是：高 16bit 不变，低 16bit 和高 16bit 做了一个异或。\n\n在设计 hash 方法时，因为目前的 table 长度 n 为 2 的幂，而计算下标的时候，是这样实现的(使用 & 位操作，而非 % 求余)：\n\n(n - 1) & hash\n\n\n设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在 n - 1 为 15(0x1111) 时，其实散列真正生效的只是低 4bit 的有效位，当然容易碰撞了。\n\n因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高 16bit 和低 16bit 异或了一下。设计者还解释到因为现在大多数的 hashCode 的分布已经很不错了，就算是发生了碰撞也用 O(logn)的 tree 去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table 长度比较小时)，从而引起的碰撞。\n\n如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)，在 JEP-180 中，描述了这个问题：\n\n> Improve the performance of java.util.HashMap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class.\n\n之前已经提过，在获取 HashMap 的元素时，基本分两步：\n\n 1. 首先根据 hashCode()做 hash，然后确定 bucket 的 index；\n\n 2. 如果 bucket 的节点的 key 不是我们需要的，则通过 keys.equals()在链中找。\n\n在 JDK8 之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行 get 时，两步的时间复杂度是 O(1)+O(n)。因此，当碰撞很厉害的时候 n 很大，O(n)的速度显然是影响速度的。\n\n因此在 JDK8 中，利用红黑树替换链表，这样复杂度就变成了 O(1)+O(logn)了，这样在 n 很大的时候，能够比较理想的解决这个问题，在 JDK8：HashMap 的性能提升一文中有性能测试的结果。\n\n# resize 的实现\n\n当 put 时，如果发现目前的 bucket 占用程度已经超过了 Load Factor 所希望的比例，那么就会发生 resize。在 resize 的过程，简单的说就是把 bucket 扩充为 2 倍，之后重新计算 index，把节点再放到新的 bucket 中。\n\n当超过限制的时候会 resize，然而又因为我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。\n\n怎么理解呢？例如我们从 16 扩展为 32 时，具体的变化如下所示：\n\n\n\n因此元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化：\n\n\n\n因此，我们在扩充 HashMap 的时候，不需要重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”。可以看看下图为 16 扩充为 32 的 resize 示意图：\n\n\n\n这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。\n\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        // 超过最大值就不再扩充了，就只好随你碰撞去吧\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 没超过最大值，就扩充为原来的 2 倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                    oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n\n    // 计算新的 resize 上限\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                    (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({"rawtypes","unchecked"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    if (oldTab != null) {\n        // 把每个 bucket 都移动到新的 buckets 中\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        // 原索引\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        // 原索引+oldCap\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 原索引放到bucket里\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    // 原索引+oldCap放到bucket里\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n\n\n\n# LinkedHashMap 类\n\n\n# LinkedHashMap 要点\n\nLinkedHashMap 通过维护一个保存所有条目（Entry）的双向链表，保证了元素迭代的顺序（即插入顺序）。\n\n关注点             结论\n是否允许键值对为 null   Key 和 Value 都允许 null\n是否允许重复数据        Key 重复会覆盖、Value 允许重复\n是否有序            按照元素插入顺序存储\n是否线程安全          非线程安全\n\n\n# LinkedHashMap 要点\n\n# LinkedHashMap 数据结构\n\nLinkedHashMap 通过维护一对 LinkedHashMap.Entry<K,V> 类型的头尾指针，以双链表形式，保存所有数据。\n\n学习过数据结构的双链表，就能理解其元素存储以及访问必然是有序的。\n\npublic class LinkedHashMap<K,V>\n    extends HashMap<K,V>\n    implements Map<K,V> {\n\n    // 双链表的头指针\n    transient LinkedHashMap.Entry<K,V> head;\n    // 双链表的尾指针\n    transient LinkedHashMap.Entry<K,V> tail;\n    // 迭代排序方法：true 表示访问顺序；false 表示插入顺序\n    final boolean accessOrder;\n}\n\n\nLinkedHashMap 继承了 HashMap 的 put 方法，本身没有实现 put 方法。\n\n\n# TreeMap 类\n\n\n# TreeMap 要点\n\nTreeMap 基于红黑树实现。\n\nTreeMap 是有序的。它的排序规则是：根据 map 中的 key 的自然语义顺序或提供的比较器（Comparator）的自定义比较顺序。\n\nTreeMap 不是线程安全的。\n\n\n# TreeMap 原理\n\n# put 方法\n\npublic V put(K key, V value) {\n    Entry<K,V> t = root;\n    // 如果根节点为 null，插入第一个节点\n    if (t == null) {\n        compare(key, key); // type (and possibly null) check\n\n        root = new Entry<>(key, value, null);\n        size = 1;\n        modCount++;\n        return null;\n    }\n    int cmp;\n    Entry<K,V> parent;\n    // split comparator and comparable paths\n    Comparator<? super K> cpr = comparator;\n    // 每个节点的左孩子节点的值小于它；右孩子节点的值大于它\n    // 如果有比较器，使用比较器进行比较\n    if (cpr != null) {\n        do {\n            parent = t;\n            cmp = cpr.compare(key, t.key);\n            if (cmp < 0)\n                t = t.left;\n            else if (cmp > 0)\n                t = t.right;\n            else\n                return t.setValue(value);\n        } while (t != null);\n    }\n    // 没有比较器，使用 key 的自然顺序进行比较\n    else {\n        if (key == null)\n            throw new NullPointerException();\n        @SuppressWarnings("unchecked")\n            Comparable<? super K> k = (Comparable<? super K>) key;\n        do {\n            parent = t;\n            cmp = k.compareTo(t.key);\n            if (cmp < 0)\n                t = t.left;\n            else if (cmp > 0)\n                t = t.right;\n            else\n                return t.setValue(value);\n        } while (t != null);\n    }\n    // 通过上面的遍历未找到 key 值，则新插入节点\n    Entry<K,V> e = new Entry<>(key, value, parent);\n    if (cmp < 0)\n        parent.left = e;\n    else\n        parent.right = e;\n    // 插入后，为了维持红黑树的平衡需要调整\n    fixAfterInsertion(e);\n    size++;\n    modCount++;\n    return null;\n}\n\n\n# get 方法\n\npublic V get(Object key) {\n    Entry<K,V> p = getEntry(key);\n    return (p==null ? null : p.value);\n}\n\nfinal Entry<K,V> getEntry(Object key) {\n    // Offload comparator-based version for sake of performance\n    if (comparator != null)\n        return getEntryUsingComparator(key);\n    if (key == null)\n        throw new NullPointerException();\n    @SuppressWarnings("unchecked")\n        Comparable<? super K> k = (Comparable<? super K>) key;\n    Entry<K,V> p = root;\n    // 按照二叉树搜索的方式进行搜索，搜到返回\n    while (p != null) {\n        int cmp = k.compareTo(p.key);\n        if (cmp < 0)\n            p = p.left;\n        else if (cmp > 0)\n            p = p.right;\n        else\n            return p;\n    }\n    return null;\n}\n\n\n\n# remove 方法\n\npublic V remove(Object key) {\n    Entry<K,V> p = getEntry(key);\n    if (p == null)\n        return null;\n\n    V oldValue = p.value;\n    deleteEntry(p);\n    return oldValue;\n}\nprivate void deleteEntry(Entry<K,V> p) {\n    modCount++;\n    size--;\n\n    // 如果当前节点有左右孩子节点，使用后继节点替换要删除的节点\n    // If strictly internal, copy successor\'s element to p and then make p\n    // point to successor.\n    if (p.left != null && p.right != null) {\n        Entry<K,V> s = successor(p);\n        p.key = s.key;\n        p.value = s.value;\n        p = s;\n    } // p has 2 children\n\n    // Start fixup at replacement node, if it exists.\n    Entry<K,V> replacement = (p.left != null ? p.left : p.right);\n\n    if (replacement != null) { // 要删除的节点有一个孩子节点\n        // Link replacement to parent\n        replacement.parent = p.parent;\n        if (p.parent == null)\n            root = replacement;\n        else if (p == p.parent.left)\n            p.parent.left  = replacement;\n        else\n D:\\codes\\zp\\java\\database\\docs\\redis\\分布式锁.md           p.parent.right = replacement;\n\n        // Null out links so they are OK to use by fixAfterDeletion.\n        p.left = p.right = p.parent = null;\n\n        // Fix replacement\n        if (p.color == BLACK)\n            fixAfterDeletion(replacement);\n    } else if (p.parent == null) { // return if we are the only node.\n        root = null;\n    } else { //  No children. Use self as phantom replacement and unlink.\n        if (p.color == BLACK)\n            fixAfterDeletion(p);\n\n        if (p.parent != null) {\n            if (p == p.parent.left)\n                p.parent.left = null;\n            else if (p == p.parent.right)\n                p.parent.right = null;\n            p.parent = null;\n        }\n    }\n}\n\n\n\n# TreeMap 示例\n\npublic class TreeMapDemo {\n\n    private static final String[] chars = "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z".split(" ");\n\n    public static void main(String[] args) {\n        TreeMap<Integer, String> treeMap = new TreeMap<>();\n        for (int i = 0; i < chars.length; i++) {\n            treeMap.put(i, chars[i]);\n        }\n        System.out.println(treeMap);\n        Integer low = treeMap.firstKey();\n        Integer high = treeMap.lastKey();\n        System.out.println(low);\n        System.out.println(high);\n        Iterator<Integer> it = treeMap.keySet().iterator();\n        for (int i = 0; i <= 6; i++) {\n            if (i == 3) { low = it.next(); }\n            if (i == 6) { high = it.next(); } else { it.next(); }\n        }\n        System.out.println(low);\n        System.out.println(high);\n        System.out.println(treeMap.subMap(low, high));\n        System.out.println(treeMap.headMap(high));\n        System.out.println(treeMap.tailMap(low));\n    }\n}\n\n\n\n# WeakHashMap\n\nWeakHashMap 的定义如下：\n\npublic class WeakHashMap<K,V>\n    extends AbstractMap<K,V>\n    implements Map<K,V> {}\n\n\nWeakHashMap 继承了 AbstractMap，实现了 Map 接口。\n\n和 HashMap 一样，WeakHashMap 也是一个散列表，它存储的内容也是键值对(key-value)映射，而且键和值都可以是 null。\n\n不过 WeakHashMap 的键是弱键。在 WeakHashMap 中，当某个键不再被其它对象引用，会被从 WeakHashMap 中被自动移除。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。某个键被终止时，它对应的键值对也就从映射中有效地移除了。\n\n这个弱键的原理呢？大致上就是，通过 WeakReference 和 ReferenceQueue 实现的。\n\nWeakHashMap 的 key 是弱键，即是 WeakReference 类型的；ReferenceQueue 是一个队列，它会保存被 GC 回收的弱键。实现步骤是：\n\n 1. 新建 WeakHashMap，将键值对添加到 WeakHashMap 中。实际上，WeakHashMap 是通过数组 table 保存 Entry(键值对)；每一个 Entry 实际上是一个单向链表，即 Entry 是键值对链表。\n 2. 当某弱键不再被其它对象引用，并被 GC 回收时。在 GC 回收该弱键时，这个弱键也同时会被添加到 ReferenceQueue(queue)队列中。\n 3. 当下一次我们需要操作 WeakHashMap 时，会先同步 table 和 queue。table 中保存了全部的键值对，而 queue 中保存被 GC 回收的键值对；同步它们，就是删除 table 中被 GC 回收的键值对。\n\n这就是弱键如何被自动从 WeakHashMap 中删除的步骤了。\n\n和 HashMap 一样，WeakHashMap 是不同步的。可以使用 Collections.synchronizedMap 方法来构造同步的 WeakHashMap。\n\n\n# 总结\n\n\n# Map 简介\n\n\n\n\n# HashMap\n\n\n\n\n# 其他 Map\n\n\n\n\n# 参考资料\n\n * Java-HashMap 工作原理及实现\n * Map 综述（二）：彻头彻尾理解 LinkedHashMap\n * Java 集合系列 09 之 Map 架构\n * Java 集合系列 13 之 WeakHashMap 详细介绍(源码解析)和使用示例',normalizedContent:'# java 容器之 map\n\n\n# map 简介\n\n\n# map 架构\n\n\n\nmap 家族主要成员功能如下：\n\n * map 是 map 容器家族的祖先，map 是一个用于保存键值对(key-value)的接口。map 中不能包含重复的键；每个键最多只能映射到一个值。\n * abstractmap 继承了 map 的抽象类，它实现了 map 中的核心 api。其它 map 的实现类可以通过继承 abstractmap 来减少重复编码。\n * sortedmap 继承了 map 的接口。sortedmap 中的内容是排序的键值对，排序的方法是通过实现比较器(comparator)完成的。\n * navigablemap 继承了 sortedmap 的接口。相比于 sortedmap，navigablemap 有一系列的“导航”方法；如"获取大于/等于某对象的键值对"、“获取小于/等于某对象的键值对”等等。\n * hashmap 继承了 abstractmap，但没实现 navigablemap 接口。hashmap 的主要作用是储存无序的键值对，而 hash 也体现了它的查找效率很高。hashmap 是使用最广泛的 map。\n * hashtable 虽然没有继承 abstractmap，但它继承了 dictionary（dictionary 也是键值对的接口），而且也实现 map 接口。因此，hashtable 的主要作用是储存无序的键值对。和 hashmap 相比，hashtable 在它的主要方法中使用 synchronized 关键字修饰，来保证线程安全。但是，由于它的锁粒度太大，非常影响读写速度，所以，现代 java 程序几乎不会使用 hashtable ，如果需要保证线程安全，一般会用 concurrenthashmap 来替代。\n * treemap 继承了 abstractmap，且实现了 navigablemap 接口。treemap 的主要作用是储存有序的键值对，排序依据根据元素类型的 comparator 而定。\n * weakhashmap 继承了 abstractmap。weakhashmap 的键是弱引用 （即 weakreference），它的主要作用是当 gc 内存不足时，会自动将 weakhashmap 中的 key 回收，这避免了 weakhashmap 的内存空间无限膨胀。很明显，weakhashmap 适用于作为缓存。\n\n\n# map 接口\n\nmap 的定义如下：\n\npublic interface map<k,v> { }\n\n\nmap 是一个用于保存键值对(key-value)的接口。map 中不能包含重复的键；每个键最多只能映射到一个值。\n\nmap 接口提供三种 collection 视图，允许以键集、值集或键-值映射关系集的形式访问数据。\n\nmap 有些实现类，可以有序的保存元素，如 treemap；另一些实现类则不保证顺序，如 hashmap 类。\n\nmap 的实现类应该提供 2 个“标准的”构造方法：\n\n * void（无参数）构造方法，用于创建空 map；\n * 带有单个 map 类型参数的构造方法，用于创建一个与其参数具有相同键-值映射关系的新 map。\n\n实际上，后一个构造方法允许用户复制任意 map，生成所需类的一个等价 map。尽管无法强制执行此建议（因为接口不能包含构造方法），但是 jdk 中所有通用的 map 实现都遵从它。\n\n\n# map.entry 接口\n\nmap.entry 一般用于通过迭代器（iterator）访问问 map。\n\nmap.entry 是 map 中内部的一个接口，map.entry 代表了 键值对 实体，map 通过 entryset() 获取 map.entry 集合，从而通过该集合实现对键值对的操作。\n\n\n# abstractmap 抽象类\n\nabstractmap 的定义如下：\n\npublic abstract class abstractmap<k,v> implements map<k,v> {}\n\n\nabstractmap 抽象类提供了 map 接口的核心实现，以最大限度地减少实现 map 接口所需的工作。\n\n要实现不可修改的 map，编程人员只需扩展此类并提供 entryset() 方法的实现即可，该方法将返回 map 的映射关系 set 视图。通常，返回的 set 将依次在 abstractset 上实现。此 set 不支持 add() 或 remove() 方法，其迭代器也不支持 remove() 方法。\n\n要实现可修改的 map，编程人员必须另外重写此类的 put 方法（否则将抛出 unsupportedoperationexception），entryset().iterator() 返回的迭代器也必须另外实现其 remove() 方法。\n\n\n# sortedmap 接口\n\nsortedmap 的定义如下：\n\npublic interface sortedmap<k,v> extends map<k,v> { }\n\n\nsortedmap 继承了 map ，它是一个有序的 map。\n\nsortedmap 的排序方式有两种：自然排序或者用户指定比较器。插入有序 sortedmap 的所有元素都必须实现 comparable 接口（或者被指定的比较器所接受）。\n\n另外，所有 sortedmap 实现类都应该提供 4 个“标准”构造方法：\n\n 1. void（无参数）构造方法，它创建一个空的有序 map，按照键的自然顺序进行排序。\n 2. 带有一个 comparator 类型参数的构造方法，它创建一个空的有序 map，根据指定的比较器进行排序。\n 3. 带有一个 map 类型参数的构造方法，它创建一个新的有序 map，其键-值映射关系与参数相同，按照键的自然顺序进行排序。\n 4. 带有一个 sortedmap 类型参数的构造方法，它创建一个新的有序 map，其键-值映射关系和排序方法与输入的有序 map 相同。无法保证强制实施此建议，因为接口不能包含构造方法。\n\n\n# navigablemap 接口\n\nnavigablemap 的定义如下：\n\npublic interface navigablemap<k,v> extends sortedmap<k,v> { }\n\n\nnavigablemap 继承了 sortedmap ，它提供了丰富的查找方法。\n\nnavigablemap 分别提供了获取“键”、“键-值对”、“键集”、“键-值对集”的相关方法。\n\nnavigablemap 提供的功能可以分为 4 类：\n\n * 获取键-值对\n   * lowerentry、floorentry、ceilingentry 和 higherentry 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键关联的 map.entry 对象。\n   * firstentry、pollfirstentry、lastentry 和 polllastentry 方法，它们返回和/或移除最小和最大的映射关系（如果存在），否则返回 null。\n * 获取键。这个和第 1 类比较类似。\n   * lowerkey、floorkey、ceilingkey 和 higherkey 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键。\n * 获取键的集合\n   * navigablekeyset、descendingkeyset 分别获取正序/反序的键集。\n * 获取键-值对的子集\n\n\n# dictionary 抽象类\n\ndictionary 的定义如下：\n\npublic abstract class dictionary<k,v> {}\n\n\ndictionary 是 jdk 1.0 定义的操作键值对的抽象类，它包括了操作键值对的基本方法。\n\n\n# hashmap 类\n\nhashmap 类是最常用的 map。\n\n\n# hashmap 要点\n\n从 hashmap 的命名，也可以看出：hashmap 以散列方式存储键值对。\n\nhashmap 允许使用空值和空键。（hashmap 类大致等同于 hashtable，除了它是不同步的并且允许为空值。）这个类不保序；特别是，它的元素顺序可能会随着时间的推移变化。\n\nhashmap 有两个影响其性能的参数：初始容量和负载因子。\n\n * 容量是哈希表中桶的数量，初始容量就是哈希表创建时的容量。\n * 加载因子是散列表在其容量自动扩容之前被允许的最大饱和量。当哈希表中的 entry 数量超过负载因子和当前容量的乘积时，散列表就会被重新映射（即重建内部数据结构），一般散列表大约是存储桶数量的两倍。\n\n通常，默认加载因子（0.75）在时间和空间成本之间提供了良好的平衡。较高的值会减少空间开销，但会增加查找成本（反映在大部分 hashmap 类的操作中，包括 get 和 put）。在设置初始容量时，应考虑映射中的条目数量及其负载因子，以尽量减少重新运行操作的次数。如果初始容量大于最大入口数除以负载因子，则不会发生重新刷新操作。\n\n如果许多映射要存储在 hashmap 实例中，使用足够大的容量创建映射将允许映射存储的效率高于根据需要执行自动重新散列以增长表。请注意，使用多个具有相同 hashcode() 的密钥是降低任何散列表性能的一个可靠方法。为了改善影响，当键是 comparable 时，该类可以使用键之间的比较顺序来帮助断开关系。\n\nhashmap 不是线程安全的。\n\n\n# hashmap 原理\n\n# hashmap 数据结构\n\nhashmap 的核心字段：\n\n * table - hashmap 使用一个 node<k,v>[] 类型的数组 table 来储存元素。\n * size - 初始容量。 初始为 16，每次容量不够自动扩容\n * loadfactor - 负载因子。自动扩容之前被允许的最大饱和量，默认 0.75。\n\npublic class hashmap<k,v> extends abstractmap<k,v>\n    implements map<k,v>, cloneable, serializable {\n\n    // 该表在初次使用时初始化，并根据需要调整大小。分配时，长度总是2的幂。\n    transient node<k,v>[] table;\n    // 保存缓存的 entryset()。请注意，abstractmap 字段用于 keyset() 和 values()。\n    transient set<map.entry<k,v>> entryset;\n    // map 中的键值对数\n    transient int size;\n    // 这个hashmap被结构修改的次数结构修改是那些改变hashmap中的映射数量或者修改其内部结构（例如，重新散列）的修改。\n    transient int modcount;\n    // 下一个调整大小的值（容量*加载因子）。\n    int threshold;\n    // 散列表的加载因子\n    final float loadfactor;\n}\n\n\n# hashmap 构造方法\n\npublic hashmap(); // 默认加载因子0.75\npublic hashmap(int initialcapacity); // 默认加载因子0.75；以 initialcapacity 初始化容量\npublic hashmap(int initialcapacity, float loadfactor); // 以 initialcapacity 初始化容量；以 loadfactor 初始化加载因子\npublic hashmap(map<? extends k, ? extends v> m) // 默认加载因子0.75\n\n\n# put 方法的实现\n\nput 方法大致的思路为：\n\n * 对 key 的 hashcode() 做 hash 计算，然后根据 hash 值再计算 node 的存储位置;\n * 如果没有哈希碰撞，直接放到桶里；如果有哈希碰撞，以链表的形式存在桶后。\n * 如果哈希碰撞导致链表过长(大于等于 treeify_threshold，数值为 8)，就把链表转换成红黑树；\n * 如果节点已经存在就替换旧值\n * 桶数量超过容量*负载因子（即 load factor * current capacity），hashmap 调用 resize 自动扩容一倍\n\n具体代码的实现如下：\n\npublic v put(k key, v value) {\n    return putval(hash(key), key, value, false, true);\n}\n\n// hashcode 无符号位移 16 位\nstatic final int hash(object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashcode()) ^ (h >>> 16);\n}\n\nfinal v putval(int hash, k key, v value, boolean onlyifabsent,\n                   boolean evict) {\n    node<k,v>[] tab; node<k,v> p; int n, i;\n    // tab 为空则创建\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 计算 index，并对 null 做处理\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newnode(hash, key, value, null);\n    else {\n        node<k,v> e; k k;\n        // 节点存在\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 该链为树\n        else if (p instanceof treenode)\n            e = ((treenode<k,v>)p).puttreeval(this, tab, hash, key, value);\n        // 该链为链表\n        else {\n            for (int bincount = 0; ; ++bincount) {\n                if ((e = p.next) == null) {\n                    p.next = newnode(hash, key, value, null);\n                    if (bincount >= treeify_threshold - 1) // -1 for 1st\n                        treeifybin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        // 写入\n        if (e != null) { // existing mapping for key\n            v oldvalue = e.value;\n            if (!onlyifabsent || oldvalue == null)\n                e.value = value;\n            afternodeaccess(e);\n            return oldvalue;\n        }\n    }\n    ++modcount;\n    if (++size > threshold)\n        resize();\n    afternodeinsertion(evict);\n    return null;\n}\n\n\n为什么计算 hash 使用 hashcode 无符号位移 16 位。\n\n假设要添加两个对象 a 和 b，如果数组长度是 16，这时对象 a 和 b 通过公式 (n - 1) & hash 运算，也就是 (16-1)＆a.hashcode 和 (16-1)＆b.hashcode，15 的二进制为 0000000000000000000000000001111，假设对象 a 的 hashcode 为 1000010001110001000001111000000，对象 b 的 hashcode 为 0111011100111000101000010100000，你会发现上述与运算结果都是 0。这样的哈希结果就太让人失望了，很明显不是一个好的哈希算法。\n\n但如果我们将 hashcode 值右移 16 位（h >>> 16 代表无符号右移 16 位），也就是取 int 类型的一半，刚好可以将该二进制数对半切开，并且使用位异或运算（如果两个数对应的位置相反，则结果为 1，反之为 0），这样的话，就能避免上面的情况发生。这就是 hash() 方法的具体实现方式。简而言之，就是尽量打乱 hashcode 真正参与运算的低 16 位。\n\n# get 方法的实现\n\n在理解了 put 之后，get 就很简单了。大致思路如下：\n\n * 对 key 的 hashcode() 做 hash 计算，然后根据 hash 值再计算桶的 index\n\n * 如果桶中的第一个节点命中，直接返回；\n\n * 如果有冲突，则通过 key.equals(k) 去查找对应的 entry\n   \n   * 若为树，则在红黑树中通过 key.equals(k) 查找，o(logn)；\n   \n   * 若为链表，则在链表中通过 key.equals(k) 查找，o(n)。\n\n具体代码的实现如下：\n\npublic v get(object key) {\n    node<k,v> e;\n    return (e = getnode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal node<k,v> getnode(int hash, object key) {\n        node<k,v>[] tab; node<k,v> first, e; int n; k k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 直接命中\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        // 未命中\n        if ((e = first.next) != null) {\n            // 在树中 get\n            if (first instanceof treenode)\n                return ((treenode<k,v>)first).gettreenode(hash, key);\n            // 在链表中 get\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n\n\n# hash 方法的实现\n\nhashmap 计算桶下标（index）公式：key.hashcode() ^ (h >>> 16)。\n\n下面针对这个公式来详细讲解。\n\n在 get 和 put 的过程中，计算下标时，先对 hashcode 进行 hash 操作，然后再通过 hash 值进一步计算下标，如下图所示：\n\n\n\n在对 hashcode() 计算 hash 时具体实现是这样的：\n\nstatic final int hash(object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashcode()) ^ (h >>> 16);\n}\n\n\n可以看到这个方法大概的作用就是：高 16bit 不变，低 16bit 和高 16bit 做了一个异或。\n\n在设计 hash 方法时，因为目前的 table 长度 n 为 2 的幂，而计算下标的时候，是这样实现的(使用 & 位操作，而非 % 求余)：\n\n(n - 1) & hash\n\n\n设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在 n - 1 为 15(0x1111) 时，其实散列真正生效的只是低 4bit 的有效位，当然容易碰撞了。\n\n因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高 16bit 和低 16bit 异或了一下。设计者还解释到因为现在大多数的 hashcode 的分布已经很不错了，就算是发生了碰撞也用 o(logn)的 tree 去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table 长度比较小时)，从而引起的碰撞。\n\n如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)，在 jep-180 中，描述了这个问题：\n\n> improve the performance of java.util.hashmap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. implement the same improvement in the linkedhashmap class.\n\n之前已经提过，在获取 hashmap 的元素时，基本分两步：\n\n 1. 首先根据 hashcode()做 hash，然后确定 bucket 的 index；\n\n 2. 如果 bucket 的节点的 key 不是我们需要的，则通过 keys.equals()在链中找。\n\n在 jdk8 之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行 get 时，两步的时间复杂度是 o(1)+o(n)。因此，当碰撞很厉害的时候 n 很大，o(n)的速度显然是影响速度的。\n\n因此在 jdk8 中，利用红黑树替换链表，这样复杂度就变成了 o(1)+o(logn)了，这样在 n 很大的时候，能够比较理想的解决这个问题，在 jdk8：hashmap 的性能提升一文中有性能测试的结果。\n\n# resize 的实现\n\n当 put 时，如果发现目前的 bucket 占用程度已经超过了 load factor 所希望的比例，那么就会发生 resize。在 resize 的过程，简单的说就是把 bucket 扩充为 2 倍，之后重新计算 index，把节点再放到新的 bucket 中。\n\n当超过限制的时候会 resize，然而又因为我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。\n\n怎么理解呢？例如我们从 16 扩展为 32 时，具体的变化如下所示：\n\n\n\n因此元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化：\n\n\n\n因此，我们在扩充 hashmap 的时候，不需要重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldcap”。可以看看下图为 16 扩充为 32 的 resize 示意图：\n\n\n\n这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。\n\nfinal node<k,v>[] resize() {\n    node<k,v>[] oldtab = table;\n    int oldcap = (oldtab == null) ? 0 : oldtab.length;\n    int oldthr = threshold;\n    int newcap, newthr = 0;\n    if (oldcap > 0) {\n        // 超过最大值就不再扩充了，就只好随你碰撞去吧\n        if (oldcap >= maximum_capacity) {\n            threshold = integer.max_value;\n            return oldtab;\n        }\n        // 没超过最大值，就扩充为原来的 2 倍\n        else if ((newcap = oldcap << 1) < maximum_capacity &&\n                    oldcap >= default_initial_capacity)\n            newthr = oldthr << 1; // double threshold\n    }\n    else if (oldthr > 0) // initial capacity was placed in threshold\n        newcap = oldthr;\n    else {               // zero initial threshold signifies using defaults\n        newcap = default_initial_capacity;\n        newthr = (int)(default_load_factor * default_initial_capacity);\n    }\n\n    // 计算新的 resize 上限\n    if (newthr == 0) {\n        float ft = (float)newcap * loadfactor;\n        newthr = (newcap < maximum_capacity && ft < (float)maximum_capacity ?\n                    (int)ft : integer.max_value);\n    }\n    threshold = newthr;\n    @suppresswarnings({"rawtypes","unchecked"})\n        node<k,v>[] newtab = (node<k,v>[])new node[newcap];\n    table = newtab;\n    if (oldtab != null) {\n        // 把每个 bucket 都移动到新的 buckets 中\n        for (int j = 0; j < oldcap; ++j) {\n            node<k,v> e;\n            if ((e = oldtab[j]) != null) {\n                oldtab[j] = null;\n                if (e.next == null)\n                    newtab[e.hash & (newcap - 1)] = e;\n                else if (e instanceof treenode)\n                    ((treenode<k,v>)e).split(this, newtab, j, oldcap);\n                else { // preserve order\n                    node<k,v> lohead = null, lotail = null;\n                    node<k,v> hihead = null, hitail = null;\n                    node<k,v> next;\n                    do {\n                        next = e.next;\n                        // 原索引\n                        if ((e.hash & oldcap) == 0) {\n                            if (lotail == null)\n                                lohead = e;\n                            else\n                                lotail.next = e;\n                            lotail = e;\n                        }\n                        // 原索引+oldcap\n                        else {\n                            if (hitail == null)\n                                hihead = e;\n                            else\n                                hitail.next = e;\n                            hitail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 原索引放到bucket里\n                    if (lotail != null) {\n                        lotail.next = null;\n                        newtab[j] = lohead;\n                    }\n                    // 原索引+oldcap放到bucket里\n                    if (hitail != null) {\n                        hitail.next = null;\n                        newtab[j + oldcap] = hihead;\n                    }\n                }\n            }\n        }\n    }\n    return newtab;\n}\n\n\n\n# linkedhashmap 类\n\n\n# linkedhashmap 要点\n\nlinkedhashmap 通过维护一个保存所有条目（entry）的双向链表，保证了元素迭代的顺序（即插入顺序）。\n\n关注点             结论\n是否允许键值对为 null   key 和 value 都允许 null\n是否允许重复数据        key 重复会覆盖、value 允许重复\n是否有序            按照元素插入顺序存储\n是否线程安全          非线程安全\n\n\n# linkedhashmap 要点\n\n# linkedhashmap 数据结构\n\nlinkedhashmap 通过维护一对 linkedhashmap.entry<k,v> 类型的头尾指针，以双链表形式，保存所有数据。\n\n学习过数据结构的双链表，就能理解其元素存储以及访问必然是有序的。\n\npublic class linkedhashmap<k,v>\n    extends hashmap<k,v>\n    implements map<k,v> {\n\n    // 双链表的头指针\n    transient linkedhashmap.entry<k,v> head;\n    // 双链表的尾指针\n    transient linkedhashmap.entry<k,v> tail;\n    // 迭代排序方法：true 表示访问顺序；false 表示插入顺序\n    final boolean accessorder;\n}\n\n\nlinkedhashmap 继承了 hashmap 的 put 方法，本身没有实现 put 方法。\n\n\n# treemap 类\n\n\n# treemap 要点\n\ntreemap 基于红黑树实现。\n\ntreemap 是有序的。它的排序规则是：根据 map 中的 key 的自然语义顺序或提供的比较器（comparator）的自定义比较顺序。\n\ntreemap 不是线程安全的。\n\n\n# treemap 原理\n\n# put 方法\n\npublic v put(k key, v value) {\n    entry<k,v> t = root;\n    // 如果根节点为 null，插入第一个节点\n    if (t == null) {\n        compare(key, key); // type (and possibly null) check\n\n        root = new entry<>(key, value, null);\n        size = 1;\n        modcount++;\n        return null;\n    }\n    int cmp;\n    entry<k,v> parent;\n    // split comparator and comparable paths\n    comparator<? super k> cpr = comparator;\n    // 每个节点的左孩子节点的值小于它；右孩子节点的值大于它\n    // 如果有比较器，使用比较器进行比较\n    if (cpr != null) {\n        do {\n            parent = t;\n            cmp = cpr.compare(key, t.key);\n            if (cmp < 0)\n                t = t.left;\n            else if (cmp > 0)\n                t = t.right;\n            else\n                return t.setvalue(value);\n        } while (t != null);\n    }\n    // 没有比较器，使用 key 的自然顺序进行比较\n    else {\n        if (key == null)\n            throw new nullpointerexception();\n        @suppresswarnings("unchecked")\n            comparable<? super k> k = (comparable<? super k>) key;\n        do {\n            parent = t;\n            cmp = k.compareto(t.key);\n            if (cmp < 0)\n                t = t.left;\n            else if (cmp > 0)\n                t = t.right;\n            else\n                return t.setvalue(value);\n        } while (t != null);\n    }\n    // 通过上面的遍历未找到 key 值，则新插入节点\n    entry<k,v> e = new entry<>(key, value, parent);\n    if (cmp < 0)\n        parent.left = e;\n    else\n        parent.right = e;\n    // 插入后，为了维持红黑树的平衡需要调整\n    fixafterinsertion(e);\n    size++;\n    modcount++;\n    return null;\n}\n\n\n# get 方法\n\npublic v get(object key) {\n    entry<k,v> p = getentry(key);\n    return (p==null ? null : p.value);\n}\n\nfinal entry<k,v> getentry(object key) {\n    // offload comparator-based version for sake of performance\n    if (comparator != null)\n        return getentryusingcomparator(key);\n    if (key == null)\n        throw new nullpointerexception();\n    @suppresswarnings("unchecked")\n        comparable<? super k> k = (comparable<? super k>) key;\n    entry<k,v> p = root;\n    // 按照二叉树搜索的方式进行搜索，搜到返回\n    while (p != null) {\n        int cmp = k.compareto(p.key);\n        if (cmp < 0)\n            p = p.left;\n        else if (cmp > 0)\n            p = p.right;\n        else\n            return p;\n    }\n    return null;\n}\n\n\n\n# remove 方法\n\npublic v remove(object key) {\n    entry<k,v> p = getentry(key);\n    if (p == null)\n        return null;\n\n    v oldvalue = p.value;\n    deleteentry(p);\n    return oldvalue;\n}\nprivate void deleteentry(entry<k,v> p) {\n    modcount++;\n    size--;\n\n    // 如果当前节点有左右孩子节点，使用后继节点替换要删除的节点\n    // if strictly internal, copy successor\'s element to p and then make p\n    // point to successor.\n    if (p.left != null && p.right != null) {\n        entry<k,v> s = successor(p);\n        p.key = s.key;\n        p.value = s.value;\n        p = s;\n    } // p has 2 children\n\n    // start fixup at replacement node, if it exists.\n    entry<k,v> replacement = (p.left != null ? p.left : p.right);\n\n    if (replacement != null) { // 要删除的节点有一个孩子节点\n        // link replacement to parent\n        replacement.parent = p.parent;\n        if (p.parent == null)\n            root = replacement;\n        else if (p == p.parent.left)\n            p.parent.left  = replacement;\n        else\n d:\\codes\\zp\\java\\database\\docs\\redis\\分布式锁.md           p.parent.right = replacement;\n\n        // null out links so they are ok to use by fixafterdeletion.\n        p.left = p.right = p.parent = null;\n\n        // fix replacement\n        if (p.color == black)\n            fixafterdeletion(replacement);\n    } else if (p.parent == null) { // return if we are the only node.\n        root = null;\n    } else { //  no children. use self as phantom replacement and unlink.\n        if (p.color == black)\n            fixafterdeletion(p);\n\n        if (p.parent != null) {\n            if (p == p.parent.left)\n                p.parent.left = null;\n            else if (p == p.parent.right)\n                p.parent.right = null;\n            p.parent = null;\n        }\n    }\n}\n\n\n\n# treemap 示例\n\npublic class treemapdemo {\n\n    private static final string[] chars = "a b c d e f g h i j k l m n o p q r s t u v w x y z".split(" ");\n\n    public static void main(string[] args) {\n        treemap<integer, string> treemap = new treemap<>();\n        for (int i = 0; i < chars.length; i++) {\n            treemap.put(i, chars[i]);\n        }\n        system.out.println(treemap);\n        integer low = treemap.firstkey();\n        integer high = treemap.lastkey();\n        system.out.println(low);\n        system.out.println(high);\n        iterator<integer> it = treemap.keyset().iterator();\n        for (int i = 0; i <= 6; i++) {\n            if (i == 3) { low = it.next(); }\n            if (i == 6) { high = it.next(); } else { it.next(); }\n        }\n        system.out.println(low);\n        system.out.println(high);\n        system.out.println(treemap.submap(low, high));\n        system.out.println(treemap.headmap(high));\n        system.out.println(treemap.tailmap(low));\n    }\n}\n\n\n\n# weakhashmap\n\nweakhashmap 的定义如下：\n\npublic class weakhashmap<k,v>\n    extends abstractmap<k,v>\n    implements map<k,v> {}\n\n\nweakhashmap 继承了 abstractmap，实现了 map 接口。\n\n和 hashmap 一样，weakhashmap 也是一个散列表，它存储的内容也是键值对(key-value)映射，而且键和值都可以是 null。\n\n不过 weakhashmap 的键是弱键。在 weakhashmap 中，当某个键不再被其它对象引用，会被从 weakhashmap 中被自动移除。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。某个键被终止时，它对应的键值对也就从映射中有效地移除了。\n\n这个弱键的原理呢？大致上就是，通过 weakreference 和 referencequeue 实现的。\n\nweakhashmap 的 key 是弱键，即是 weakreference 类型的；referencequeue 是一个队列，它会保存被 gc 回收的弱键。实现步骤是：\n\n 1. 新建 weakhashmap，将键值对添加到 weakhashmap 中。实际上，weakhashmap 是通过数组 table 保存 entry(键值对)；每一个 entry 实际上是一个单向链表，即 entry 是键值对链表。\n 2. 当某弱键不再被其它对象引用，并被 gc 回收时。在 gc 回收该弱键时，这个弱键也同时会被添加到 referencequeue(queue)队列中。\n 3. 当下一次我们需要操作 weakhashmap 时，会先同步 table 和 queue。table 中保存了全部的键值对，而 queue 中保存被 gc 回收的键值对；同步它们，就是删除 table 中被 gc 回收的键值对。\n\n这就是弱键如何被自动从 weakhashmap 中删除的步骤了。\n\n和 hashmap 一样，weakhashmap 是不同步的。可以使用 collections.synchronizedmap 方法来构造同步的 weakhashmap。\n\n\n# 总结\n\n\n# map 简介\n\n\n\n\n# hashmap\n\n\n\n\n# 其他 map\n\n\n\n\n# 参考资料\n\n * java-hashmap 工作原理及实现\n * map 综述（二）：彻头彻尾理解 linkedhashmap\n * java 集合系列 09 之 map 架构\n * java 集合系列 13 之 weakhashmap 详细介绍(源码解析)和使用示例',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 容器之 Set",frontmatter:{title:"Java 容器之 Set",categories:["编程","Java","JavaSE","容器"],tags:["Java","JavaSE","容器"],abbrlink:"c4d22bd8",date:"2019-12-29T21:49:58.000Z",permalink:"/pages/b12803/"},regularPath:"/03.%E5%AE%B9%E5%99%A8/04.Java%E5%AE%B9%E5%99%A8%E4%B9%8BSet.html",relativePath:"03.容器/04.Java容器之Set.md",key:"v-547c7992",path:"/pages/b12803/",headers:[{level:2,title:"Set 简介",slug:"set-简介",normalizedTitle:"set 简介",charIndex:19},{level:3,title:"Set 接口",slug:"set-接口",normalizedTitle:"set 接口",charIndex:589},{level:3,title:"SortedSet 接口",slug:"sortedset-接口",normalizedTitle:"sortedset 接口",charIndex:723},{level:3,title:"NavigableSet 接口",slug:"navigableset-接口",normalizedTitle:"navigableset 接口",charIndex:1046},{level:3,title:"AbstractSet 抽象类",slug:"abstractset-抽象类",normalizedTitle:"abstractset 抽象类",charIndex:1544},{level:2,title:"HashSet 类",slug:"hashset-类",normalizedTitle:"hashset 类",charIndex:371},{level:3,title:"HashSet 要点",slug:"hashset-要点",normalizedTitle:"hashset 要点",charIndex:1972},{level:3,title:"HashSet 原理",slug:"hashset-原理",normalizedTitle:"hashset 原理",charIndex:2172},{level:2,title:"TreeSet 类",slug:"treeset-类",normalizedTitle:"treeset 类",charIndex:437},{level:3,title:"TreeSet 要点",slug:"treeset-要点",normalizedTitle:"treeset 要点",charIndex:2823},{level:3,title:"TreeSet 源码",slug:"treeset-源码",normalizedTitle:"treeset 源码",charIndex:3041},{level:2,title:"LinkedHashSet 类",slug:"linkedhashset-类",normalizedTitle:"linkedhashset 类",charIndex:3479},{level:3,title:"LinkedHashSet 要点",slug:"linkedhashset-要点",normalizedTitle:"linkedhashset 要点",charIndex:3664},{level:3,title:"LinkedHashSet 原理",slug:"linkedhashset-原理",normalizedTitle:"linkedhashset 原理",charIndex:3877},{level:2,title:"EnumSet 类",slug:"enumset-类",normalizedTitle:"enumset 类",charIndex:4561},{level:3,title:"EnumSet 要点",slug:"enumset-要点",normalizedTitle:"enumset 要点",charIndex:4715},{level:2,title:"要点总结",slug:"要点总结",normalizedTitle:"要点总结",charIndex:5015},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5026}],headersStr:"Set 简介 Set 接口 SortedSet 接口 NavigableSet 接口 AbstractSet 抽象类 HashSet 类 HashSet 要点 HashSet 原理 TreeSet 类 TreeSet 要点 TreeSet 源码 LinkedHashSet 类 LinkedHashSet 要点 LinkedHashSet 原理 EnumSet 类 EnumSet 要点 要点总结 参考资料",content:'# Java 容器之 Set\n\n\n# Set 简介\n\n\n\nSet 家族成员简介：\n\n * Set 继承了 Collection 的接口。实际上 Set 就是 Collection，只是行为略有不同：Set 集合不允许有重复元素。\n * SortedSet 继承了 Set 的接口。SortedSet 中的内容是排序的唯一值，排序的方法是通过比较器(Comparator)。\n * NavigableSet 继承了 SortedSet 的接口。它提供了丰富的查找方法：如"获取大于/等于某值的元素"、“获取小于/等于某值的元素”等等。\n * AbstractSet 是一个抽象类，它继承于 AbstractCollection，AbstractCollection 实现了 Set 中的绝大部分方法，为实现 Set 的实例类提供了便利。\n * HashSet 类依赖于 HashMap，它实际上是通过 HashMap 实现的。HashSet 中的元素是无序的、散列的。\n * TreeSet 类依赖于 TreeMap，它实际上是通过 TreeMap 实现的。TreeSet 中的元素是有序的，它是按自然排序或者用户指定比较器排序的 Set。\n * LinkedHashSet 是按插入顺序排序的 Set。\n * EnumSet 是只能存放 Emum 枚举类型的 Set。\n\n\n# Set 接口\n\nSet 继承了 Collection 的接口。实际上，Set 就是 Collection，二者提供的方法完全相同。\n\nSet 接口定义如下：\n\npublic interface Set<E> extends Collection<E> {}\n\n\n\n# SortedSet 接口\n\n继承了 Set 的接口。SortedSet 中的内容是排序的唯一值，排序的方法是通过比较器(Comparator)。\n\nSortedSet 接口定义如下：\n\npublic interface SortedSet<E> extends Set<E> {}\n\n\nSortedSet 接口新扩展的方法：\n\n * comparator - 返回 Comparator\n * subSet - 返回指定区间的子集\n * headSet - 返回小于指定元素的子集\n * tailSet - 返回大于指定元素的子集\n * first - 返回第一个元素\n * last - 返回最后一个元素\n * spliterator\n\n\n# NavigableSet 接口\n\nNavigableSet 继承了 SortedSet。它提供了丰富的查找方法。\n\nNavigableSet 接口定义如下：\n\npublic interface NavigableSet<E> extends SortedSet<E> {}\n\n\nNavigableSet 接口新扩展的方法：\n\n * lower - 返回小于指定值的元素中最接近的元素\n * higher - 返回大于指定值的元素中最接近的元素\n * floor - 返回小于或等于指定值的元素中最接近的元素\n * ceiling - 返回大于或等于指定值的元素中最接近的元素\n * pollFirst - 检索并移除第一个（最小的）元素\n * pollLast - 检索并移除最后一个（最大的）元素\n * descendingSet - 返回反序排列的 Set\n * descendingIterator - 返回反序排列的 Set 的迭代器\n * subSet - 返回指定区间的子集\n * headSet - 返回小于指定元素的子集\n * tailSet - 返回大于指定元素的子集\n\n\n# AbstractSet 抽象类\n\nAbstractSet 类提供 Set 接口的核心实现，以最大限度地减少实现 Set 接口所需的工作。\n\nAbstractSet 抽象类定义如下：\n\npublic abstract class AbstractSet<E> extends AbstractCollection<E> implements Set<E> {}\n\n\n事实上，主要的实现已经在 AbstractCollection 中完成。\n\n\n# HashSet 类\n\nHashSet 类依赖于 HashMap，它实际上是通过 HashMap 实现的。HashSet 中的元素是无序的、散列的。\n\nHashSet 类定义如下：\n\npublic class HashSet<E>\n    extends AbstractSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable {}\n\n\n\n# HashSet 要点\n\n * HashSet 通过继承 AbstractSet 实现了 Set 接口中的骨干方法。\n * HashSet 实现了 Cloneable，所以支持克隆。\n * HashSet 实现了 Serializable，所以支持序列化。\n * HashSet 中存储的元素是无序的。\n * HashSet 允许 null 值的元素。\n * HashSet 不是线程安全的。\n\n\n# HashSet 原理\n\nHashSet 是基于 HashMap 实现的。\n\n// HashSet 的核心，通过维护一个 HashMap 实体来实现 HashSet 方法\nprivate transient HashMap<E,Object> map;\n\n// PRESENT 是用于关联 map 中当前操作元素的一个虚拟值\nprivate static final Object PRESENT = new Object();\n}\n\n\n * HashSet 中维护了一个 HashMap 对象 map，HashSet 的重要方法，如 add、remove、iterator、clear、size 等都是围绕 map 实现的。\n   * HashSet 类中通过定义 writeObject() 和 readObject() 方法确定了其序列化和反序列化的机制。\n * PRESENT 是用于关联 map 中当前操作元素的一个虚拟值。\n\n\n# TreeSet 类\n\nTreeSet 类依赖于 TreeMap，它实际上是通过 TreeMap 实现的。TreeSet 中的元素是有序的，它是按自然排序或者用户指定比较器排序的 Set。\n\nTreeSet 类定义如下：\n\npublic class TreeSet<E> extends AbstractSet<E>\n    implements NavigableSet<E>, Cloneable, java.io.Serializable {}\n\n\n\n# TreeSet 要点\n\n * TreeSet 通过继承 AbstractSet 实现了 NavigableSet 接口中的骨干方法。\n * TreeSet 实现了 Cloneable，所以支持克隆。\n * TreeSet 实现了 Serializable，所以支持序列化。\n * TreeSet 中存储的元素是有序的。排序规则是自然顺序或比较器（Comparator）中提供的顺序规则。\n * TreeSet 不是线程安全的。\n\n\n# TreeSet 源码\n\nTreeSet 是基于 TreeMap 实现的。\n\n// TreeSet 的核心，通过维护一个 NavigableMap 实体来实现 TreeSet 方法\nprivate transient NavigableMap<E,Object> m;\n\n// PRESENT 是用于关联 map 中当前操作元素的一个虚拟值\nprivate static final Object PRESENT = new Object();\n\n\n * TreeSet 中维护了一个 NavigableMap 对象 map（实际上是一个 TreeMap 实例），TreeSet 的重要方法，如 add、remove、iterator、clear、size 等都是围绕 map 实现的。\n * PRESENT 是用于关联 map 中当前操作元素的一个虚拟值。TreeSet 中的元素都被当成 TreeMap 的 key 存储，而 value 都填的是 PRESENT。\n\n\n# LinkedHashSet 类\n\nLinkedHashSet 是按插入顺序排序的 Set。\n\nLinkedHashSet 类定义如下：\n\npublic class LinkedHashSet<E>\n    extends HashSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable {}\n\n\n\n# LinkedHashSet 要点\n\n * LinkedHashSet 通过继承 HashSet 实现了 Set 接口中的骨干方法。\n * LinkedHashSet 实现了 Cloneable，所以支持克隆。\n * LinkedHashSet 实现了 Serializable，所以支持序列化。\n * LinkedHashSet 中存储的元素是按照插入顺序保存的。\n * LinkedHashSet 不是线程安全的。\n\n\n# LinkedHashSet 原理\n\nLinkedHashSet 有三个构造方法，无一例外，都是调用父类 HashSet 的构造方法。\n\npublic LinkedHashSet(int initialCapacity, float loadFactor) {\n    super(initialCapacity, loadFactor, true);\n}\npublic LinkedHashSet(int initialCapacity) {\n    super(initialCapacity, .75f, true);\n}\npublic LinkedHashSet() {\n    super(16, .75f, true);\n}\n\n\n需要强调的是：LinkedHashSet 构造方法实际上调用的是父类 HashSet 的非 public 构造方法。\n\nHashSet(int initialCapacity, float loadFactor, boolean dummy) {\n    map = new LinkedHashMap<>(initialCapacity, loadFactor);\n}\n\n\n不同于 HashSet public 构造方法中初始化的 HashMap 实例，这个构造方法中，初始化了 LinkedHashMap 实例。\n\n也就是说，实际上，LinkedHashSet 维护了一个双链表。由双链表的特性可以知道，它是按照元素的插入顺序保存的。所以，这就是 LinkedHashSet 中存储的元素是按照插入顺序保存的原理。\n\n\n# EnumSet 类\n\nEnumSet 类定义如下：\n\npublic abstract class EnumSet<E extends Enum<E>> extends AbstractSet<E>\n    implements Cloneable, java.io.Serializable {}\n\n\n\n# EnumSet 要点\n\n * EnumSet 继承了 AbstractSet，所以有 Set 接口中的骨干方法。\n * EnumSet 实现了 Cloneable，所以支持克隆。\n * EnumSet 实现了 Serializable，所以支持序列化。\n * EnumSet 通过 <E extends Enum<E>> 限定了存储元素必须是枚举值。\n * EnumSet 没有构造方法，只能通过类中的 static 方法来创建 EnumSet 对象。\n * EnumSet 是有序的。以枚举值在 EnumSet 类中的定义顺序来决定集合元素的顺序。\n * EnumSet 不是线程安全的。\n\n\n# 要点总结\n\n\n\n\n# 参考资料\n\n * Java 编程思想（Thinking in java）',normalizedContent:'# java 容器之 set\n\n\n# set 简介\n\n\n\nset 家族成员简介：\n\n * set 继承了 collection 的接口。实际上 set 就是 collection，只是行为略有不同：set 集合不允许有重复元素。\n * sortedset 继承了 set 的接口。sortedset 中的内容是排序的唯一值，排序的方法是通过比较器(comparator)。\n * navigableset 继承了 sortedset 的接口。它提供了丰富的查找方法：如"获取大于/等于某值的元素"、“获取小于/等于某值的元素”等等。\n * abstractset 是一个抽象类，它继承于 abstractcollection，abstractcollection 实现了 set 中的绝大部分方法，为实现 set 的实例类提供了便利。\n * hashset 类依赖于 hashmap，它实际上是通过 hashmap 实现的。hashset 中的元素是无序的、散列的。\n * treeset 类依赖于 treemap，它实际上是通过 treemap 实现的。treeset 中的元素是有序的，它是按自然排序或者用户指定比较器排序的 set。\n * linkedhashset 是按插入顺序排序的 set。\n * enumset 是只能存放 emum 枚举类型的 set。\n\n\n# set 接口\n\nset 继承了 collection 的接口。实际上，set 就是 collection，二者提供的方法完全相同。\n\nset 接口定义如下：\n\npublic interface set<e> extends collection<e> {}\n\n\n\n# sortedset 接口\n\n继承了 set 的接口。sortedset 中的内容是排序的唯一值，排序的方法是通过比较器(comparator)。\n\nsortedset 接口定义如下：\n\npublic interface sortedset<e> extends set<e> {}\n\n\nsortedset 接口新扩展的方法：\n\n * comparator - 返回 comparator\n * subset - 返回指定区间的子集\n * headset - 返回小于指定元素的子集\n * tailset - 返回大于指定元素的子集\n * first - 返回第一个元素\n * last - 返回最后一个元素\n * spliterator\n\n\n# navigableset 接口\n\nnavigableset 继承了 sortedset。它提供了丰富的查找方法。\n\nnavigableset 接口定义如下：\n\npublic interface navigableset<e> extends sortedset<e> {}\n\n\nnavigableset 接口新扩展的方法：\n\n * lower - 返回小于指定值的元素中最接近的元素\n * higher - 返回大于指定值的元素中最接近的元素\n * floor - 返回小于或等于指定值的元素中最接近的元素\n * ceiling - 返回大于或等于指定值的元素中最接近的元素\n * pollfirst - 检索并移除第一个（最小的）元素\n * polllast - 检索并移除最后一个（最大的）元素\n * descendingset - 返回反序排列的 set\n * descendingiterator - 返回反序排列的 set 的迭代器\n * subset - 返回指定区间的子集\n * headset - 返回小于指定元素的子集\n * tailset - 返回大于指定元素的子集\n\n\n# abstractset 抽象类\n\nabstractset 类提供 set 接口的核心实现，以最大限度地减少实现 set 接口所需的工作。\n\nabstractset 抽象类定义如下：\n\npublic abstract class abstractset<e> extends abstractcollection<e> implements set<e> {}\n\n\n事实上，主要的实现已经在 abstractcollection 中完成。\n\n\n# hashset 类\n\nhashset 类依赖于 hashmap，它实际上是通过 hashmap 实现的。hashset 中的元素是无序的、散列的。\n\nhashset 类定义如下：\n\npublic class hashset<e>\n    extends abstractset<e>\n    implements set<e>, cloneable, java.io.serializable {}\n\n\n\n# hashset 要点\n\n * hashset 通过继承 abstractset 实现了 set 接口中的骨干方法。\n * hashset 实现了 cloneable，所以支持克隆。\n * hashset 实现了 serializable，所以支持序列化。\n * hashset 中存储的元素是无序的。\n * hashset 允许 null 值的元素。\n * hashset 不是线程安全的。\n\n\n# hashset 原理\n\nhashset 是基于 hashmap 实现的。\n\n// hashset 的核心，通过维护一个 hashmap 实体来实现 hashset 方法\nprivate transient hashmap<e,object> map;\n\n// present 是用于关联 map 中当前操作元素的一个虚拟值\nprivate static final object present = new object();\n}\n\n\n * hashset 中维护了一个 hashmap 对象 map，hashset 的重要方法，如 add、remove、iterator、clear、size 等都是围绕 map 实现的。\n   * hashset 类中通过定义 writeobject() 和 readobject() 方法确定了其序列化和反序列化的机制。\n * present 是用于关联 map 中当前操作元素的一个虚拟值。\n\n\n# treeset 类\n\ntreeset 类依赖于 treemap，它实际上是通过 treemap 实现的。treeset 中的元素是有序的，它是按自然排序或者用户指定比较器排序的 set。\n\ntreeset 类定义如下：\n\npublic class treeset<e> extends abstractset<e>\n    implements navigableset<e>, cloneable, java.io.serializable {}\n\n\n\n# treeset 要点\n\n * treeset 通过继承 abstractset 实现了 navigableset 接口中的骨干方法。\n * treeset 实现了 cloneable，所以支持克隆。\n * treeset 实现了 serializable，所以支持序列化。\n * treeset 中存储的元素是有序的。排序规则是自然顺序或比较器（comparator）中提供的顺序规则。\n * treeset 不是线程安全的。\n\n\n# treeset 源码\n\ntreeset 是基于 treemap 实现的。\n\n// treeset 的核心，通过维护一个 navigablemap 实体来实现 treeset 方法\nprivate transient navigablemap<e,object> m;\n\n// present 是用于关联 map 中当前操作元素的一个虚拟值\nprivate static final object present = new object();\n\n\n * treeset 中维护了一个 navigablemap 对象 map（实际上是一个 treemap 实例），treeset 的重要方法，如 add、remove、iterator、clear、size 等都是围绕 map 实现的。\n * present 是用于关联 map 中当前操作元素的一个虚拟值。treeset 中的元素都被当成 treemap 的 key 存储，而 value 都填的是 present。\n\n\n# linkedhashset 类\n\nlinkedhashset 是按插入顺序排序的 set。\n\nlinkedhashset 类定义如下：\n\npublic class linkedhashset<e>\n    extends hashset<e>\n    implements set<e>, cloneable, java.io.serializable {}\n\n\n\n# linkedhashset 要点\n\n * linkedhashset 通过继承 hashset 实现了 set 接口中的骨干方法。\n * linkedhashset 实现了 cloneable，所以支持克隆。\n * linkedhashset 实现了 serializable，所以支持序列化。\n * linkedhashset 中存储的元素是按照插入顺序保存的。\n * linkedhashset 不是线程安全的。\n\n\n# linkedhashset 原理\n\nlinkedhashset 有三个构造方法，无一例外，都是调用父类 hashset 的构造方法。\n\npublic linkedhashset(int initialcapacity, float loadfactor) {\n    super(initialcapacity, loadfactor, true);\n}\npublic linkedhashset(int initialcapacity) {\n    super(initialcapacity, .75f, true);\n}\npublic linkedhashset() {\n    super(16, .75f, true);\n}\n\n\n需要强调的是：linkedhashset 构造方法实际上调用的是父类 hashset 的非 public 构造方法。\n\nhashset(int initialcapacity, float loadfactor, boolean dummy) {\n    map = new linkedhashmap<>(initialcapacity, loadfactor);\n}\n\n\n不同于 hashset public 构造方法中初始化的 hashmap 实例，这个构造方法中，初始化了 linkedhashmap 实例。\n\n也就是说，实际上，linkedhashset 维护了一个双链表。由双链表的特性可以知道，它是按照元素的插入顺序保存的。所以，这就是 linkedhashset 中存储的元素是按照插入顺序保存的原理。\n\n\n# enumset 类\n\nenumset 类定义如下：\n\npublic abstract class enumset<e extends enum<e>> extends abstractset<e>\n    implements cloneable, java.io.serializable {}\n\n\n\n# enumset 要点\n\n * enumset 继承了 abstractset，所以有 set 接口中的骨干方法。\n * enumset 实现了 cloneable，所以支持克隆。\n * enumset 实现了 serializable，所以支持序列化。\n * enumset 通过 <e extends enum<e>> 限定了存储元素必须是枚举值。\n * enumset 没有构造方法，只能通过类中的 static 方法来创建 enumset 对象。\n * enumset 是有序的。以枚举值在 enumset 类中的定义顺序来决定集合元素的顺序。\n * enumset 不是线程安全的。\n\n\n# 要点总结\n\n\n\n\n# 参考资料\n\n * java 编程思想（thinking in java）',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 容器之 Queue",frontmatter:{title:"Java 容器之 Queue",categories:["编程","Java","JavaSE","容器"],tags:["Java","JavaSE","容器"],abbrlink:"fc29b5a6",date:"2020-02-21T16:26:21.000Z",permalink:"/pages/3c422d/"},regularPath:"/03.%E5%AE%B9%E5%99%A8/05.Java%E5%AE%B9%E5%99%A8%E4%B9%8BQueue.html",relativePath:"03.容器/05.Java容器之Queue.md",key:"v-3c0b8b37",path:"/pages/3c422d/",headers:[{level:2,title:"Queue 简介",slug:"queue-简介",normalizedTitle:"queue 简介",charIndex:21},{level:3,title:"Queue 接口",slug:"queue-接口",normalizedTitle:"queue 接口",charIndex:36},{level:3,title:"AbstractQueue 抽象类",slug:"abstractqueue-抽象类",normalizedTitle:"abstractqueue 抽象类",charIndex:117},{level:3,title:"Deque 接口",slug:"deque-接口",normalizedTitle:"deque 接口",charIndex:324},{level:2,title:"ArrayDeque",slug:"arraydeque",normalizedTitle:"arraydeque",charIndex:558},{level:2,title:"LinkedList",slug:"linkedlist",normalizedTitle:"linkedlist",charIndex:636},{level:2,title:"PriorityQueue",slug:"priorityqueue",normalizedTitle:"priorityqueue",charIndex:1570},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1901}],headersStr:"Queue 简介 Queue 接口 AbstractQueue 抽象类 Deque 接口 ArrayDeque LinkedList PriorityQueue 参考资料",content:'# Java 容器之 Queue\n\n\n# Queue 简介\n\n\n\n\n# Queue 接口\n\nQueue 接口定义如下：\n\npublic interface Queue<E> extends Collection<E> {}\n\n\n\n# AbstractQueue 抽象类\n\nAbstractQueue 类提供 Queue 接口的核心实现，以最大限度地减少实现 Queue 接口所需的工作。\n\nAbstractQueue 抽象类定义如下：\n\npublic abstract class AbstractQueue<E>\n    extends AbstractCollection<E>\n    implements Queue<E> {}\n\n\n\n# Deque 接口\n\nDeque 接口是 double ended queue 的缩写，即双端队列。Deque 继承 Queue 接口，并扩展支持在队列的两端插入和删除元素。\n\n所以提供了特定的方法，如:\n\n * 尾部插入时需要的 addLast(e)、offerLast(e)。\n * 尾部删除所需要的 removeLast()、pollLast()。\n\n大多数的实现对元素的数量没有限制，但这个接口既支持有容量限制的 deque，也支持没有固定大小限制的。\n\n\n# ArrayDeque\n\nArrayDeque 是 Deque 的顺序表实现。\n\nArrayDeque 用一个动态数组实现了栈和队列所需的所有操作。\n\n\n# LinkedList\n\nLinkedList 是 Deque 的链表实现。\n\n示例：\n\npublic class LinkedListQueueDemo {\n\n    public static void main(String[] args) {\n        //add()和remove()方法在失败的时候会抛出异常(不推荐)\n        Queue<String> queue = new LinkedList<>();\n\n        queue.offer("a"); // 入队\n        queue.offer("b"); // 入队\n        queue.offer("c"); // 入队\n        for (String q : queue) {\n            System.out.println(q);\n        }\n        System.out.println("===");\n        System.out.println("poll=" + queue.poll()); // 出队\n        for (String q : queue) {\n            System.out.println(q);\n        }\n        System.out.println("===");\n        System.out.println("element=" + queue.element()); //返回第一个元素\n        for (String q : queue) {\n            System.out.println(q);\n        }\n        System.out.println("===");\n        System.out.println("peek=" + queue.peek()); //返回第一个元素\n        for (String q : queue) {\n            System.out.println(q);\n        }\n    }\n\n}\n\n\n\n# PriorityQueue\n\nPriorityQueue 类定义如下：\n\npublic class PriorityQueue<E> extends AbstractQueue<E>\n    implements java.io.Serializable {}\n\n\nPriorityQueue 要点：\n\n * PriorityQueue 实现了 Serializable，支持序列化。\n * PriorityQueue 类是无界优先级队列。\n * PriorityQueue 中的元素根据自然顺序或 Comparator 提供的顺序排序。\n * PriorityQueue 不接受 null 值元素。\n * PriorityQueue 不是线程安全的。\n\n\n# 参考资料\n\n * 解读 Java 并发队列 BlockingQueue',normalizedContent:'# java 容器之 queue\n\n\n# queue 简介\n\n\n\n\n# queue 接口\n\nqueue 接口定义如下：\n\npublic interface queue<e> extends collection<e> {}\n\n\n\n# abstractqueue 抽象类\n\nabstractqueue 类提供 queue 接口的核心实现，以最大限度地减少实现 queue 接口所需的工作。\n\nabstractqueue 抽象类定义如下：\n\npublic abstract class abstractqueue<e>\n    extends abstractcollection<e>\n    implements queue<e> {}\n\n\n\n# deque 接口\n\ndeque 接口是 double ended queue 的缩写，即双端队列。deque 继承 queue 接口，并扩展支持在队列的两端插入和删除元素。\n\n所以提供了特定的方法，如:\n\n * 尾部插入时需要的 addlast(e)、offerlast(e)。\n * 尾部删除所需要的 removelast()、polllast()。\n\n大多数的实现对元素的数量没有限制，但这个接口既支持有容量限制的 deque，也支持没有固定大小限制的。\n\n\n# arraydeque\n\narraydeque 是 deque 的顺序表实现。\n\narraydeque 用一个动态数组实现了栈和队列所需的所有操作。\n\n\n# linkedlist\n\nlinkedlist 是 deque 的链表实现。\n\n示例：\n\npublic class linkedlistqueuedemo {\n\n    public static void main(string[] args) {\n        //add()和remove()方法在失败的时候会抛出异常(不推荐)\n        queue<string> queue = new linkedlist<>();\n\n        queue.offer("a"); // 入队\n        queue.offer("b"); // 入队\n        queue.offer("c"); // 入队\n        for (string q : queue) {\n            system.out.println(q);\n        }\n        system.out.println("===");\n        system.out.println("poll=" + queue.poll()); // 出队\n        for (string q : queue) {\n            system.out.println(q);\n        }\n        system.out.println("===");\n        system.out.println("element=" + queue.element()); //返回第一个元素\n        for (string q : queue) {\n            system.out.println(q);\n        }\n        system.out.println("===");\n        system.out.println("peek=" + queue.peek()); //返回第一个元素\n        for (string q : queue) {\n            system.out.println(q);\n        }\n    }\n\n}\n\n\n\n# priorityqueue\n\npriorityqueue 类定义如下：\n\npublic class priorityqueue<e> extends abstractqueue<e>\n    implements java.io.serializable {}\n\n\npriorityqueue 要点：\n\n * priorityqueue 实现了 serializable，支持序列化。\n * priorityqueue 类是无界优先级队列。\n * priorityqueue 中的元素根据自然顺序或 comparator 提供的顺序排序。\n * priorityqueue 不接受 null 值元素。\n * priorityqueue 不是线程安全的。\n\n\n# 参考资料\n\n * 解读 java 并发队列 blockingqueue',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 容器之 Stream",frontmatter:{title:"Java 容器之 Stream",categories:["编程","Java","JavaSE","容器"],tags:["Java","JavaSE","容器"],abbrlink:"1b645ce9",date:"2020-12-05T18:30:22.000Z",permalink:"/pages/7d4bd9/"},regularPath:"/03.%E5%AE%B9%E5%99%A8/06.Java%E5%AE%B9%E5%99%A8%E4%B9%8BStream.html",relativePath:"03.容器/06.Java容器之Stream.md",key:"v-ece8b2de",path:"/pages/7d4bd9/",headers:[{level:2,title:"Stream 简介",slug:"stream-简介",normalizedTitle:"stream 简介",charIndex:22},{level:2,title:"Stream 操作分类",slug:"stream-操作分类",normalizedTitle:"stream 操作分类",charIndex:215},{level:2,title:"Stream 源码实现",slug:"stream-源码实现",normalizedTitle:"stream 源码实现",charIndex:500},{level:2,title:"Stream 并行处理",slug:"stream-并行处理",normalizedTitle:"stream 并行处理",charIndex:1186},{level:2,title:"4. 参考资料",slug:"_4-参考资料",normalizedTitle:"4. 参考资料",charIndex:1232}],headersStr:"Stream 简介 Stream 操作分类 Stream 源码实现 Stream 并行处理 4. 参考资料",content:"# Java 容器之 Stream\n\n\n# Stream 简介\n\n在 Java8 中，Collection 新增了两个流方法，分别是 stream() 和 parallelStream()。\n\nStream 相当于高级版的 Iterator，他可以通过 Lambda 表达式对集合进行各种非常便利、高效的聚合操作（Aggregate Operation），或者大批量数据操作 (Bulk Data Operation)。\n\n\n# Stream 操作分类\n\n官方将 Stream 中的操作分为两大类：中间操作（Intermediate operations）和终结操作（Terminal operations）。\n\n中间操作又可以分为无状态（Stateless）与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响，后者是指该操作只有拿到所有元素之后才能继续下去。\n\n终结操作又可以分为短路（Short-circuiting）与非短路（Unshort-circuiting）操作，前者是指遇到某些符合条件的元素就可以得到最终结果，后者是指必须处理完所有元素才能得到最终结果。\n\n\n# Stream 源码实现\n\n\n\nBaseStream 和 Stream 是最顶层的接口类。BaseStream 主要定义了流的基本接口方法，例如，spliterator、isParallel 等；Stream 则定义了一些流的常用操作方法，例如，map、filter 等。\n\nSink 接口是定义每个 Stream 操作之间关系的协议，他包含 begin()、end()、cancellationRequested()、accpt() 四个方法。ReferencePipeline 最终会将整个 Stream 流操作组装成一个调用链，而这条调用链上的各个 Stream 操作的上下关系就是通过 Sink 接口协议来定义实现的。\n\nReferencePipeline 是一个结构类，他通过定义内部类组装了各种操作流。他定义了 Head、StatelessOp、StatefulOp 三个内部类，实现了 BaseStream 与 Stream 的接口方法。Head 类主要用来定义数据源操作，在初次调用 names.stream() 方法时，会加载 Head 对象，此时为加载数据源操作；接着加载的是中间操作，分别为无状态中间操作 StatelessOp 对象和有状态操作 StatefulOp 对象，此时的 Stage 并没有执行，而是通过 AbstractPipeline 生成了一个中间操作 Stage 链表；当我们调用终结操作时，会生成一个最终的 Stage，通过这个 Stage 触发之前的中间操作，从最后一个 Stage 开始，递归产生一个 Sink 链。\n\n\n# Stream 并行处理\n\nStream 处理数据的方式有两种，串行处理和并行处理。\n\n\n# 4. 参考资料\n\n * Java 编程思想（第 4 版）",normalizedContent:"# java 容器之 stream\n\n\n# stream 简介\n\n在 java8 中，collection 新增了两个流方法，分别是 stream() 和 parallelstream()。\n\nstream 相当于高级版的 iterator，他可以通过 lambda 表达式对集合进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。\n\n\n# stream 操作分类\n\n官方将 stream 中的操作分为两大类：中间操作（intermediate operations）和终结操作（terminal operations）。\n\n中间操作又可以分为无状态（stateless）与有状态（stateful）操作，前者是指元素的处理不受之前元素的影响，后者是指该操作只有拿到所有元素之后才能继续下去。\n\n终结操作又可以分为短路（short-circuiting）与非短路（unshort-circuiting）操作，前者是指遇到某些符合条件的元素就可以得到最终结果，后者是指必须处理完所有元素才能得到最终结果。\n\n\n# stream 源码实现\n\n\n\nbasestream 和 stream 是最顶层的接口类。basestream 主要定义了流的基本接口方法，例如，spliterator、isparallel 等；stream 则定义了一些流的常用操作方法，例如，map、filter 等。\n\nsink 接口是定义每个 stream 操作之间关系的协议，他包含 begin()、end()、cancellationrequested()、accpt() 四个方法。referencepipeline 最终会将整个 stream 流操作组装成一个调用链，而这条调用链上的各个 stream 操作的上下关系就是通过 sink 接口协议来定义实现的。\n\nreferencepipeline 是一个结构类，他通过定义内部类组装了各种操作流。他定义了 head、statelessop、statefulop 三个内部类，实现了 basestream 与 stream 的接口方法。head 类主要用来定义数据源操作，在初次调用 names.stream() 方法时，会加载 head 对象，此时为加载数据源操作；接着加载的是中间操作，分别为无状态中间操作 statelessop 对象和有状态操作 statefulop 对象，此时的 stage 并没有执行，而是通过 abstractpipeline 生成了一个中间操作 stage 链表；当我们调用终结操作时，会生成一个最终的 stage，通过这个 stage 触发之前的中间操作，从最后一个 stage 开始，递归产生一个 sink 链。\n\n\n# stream 并行处理\n\nstream 处理数据的方式有两种，串行处理和并行处理。\n\n\n# 4. 参考资料\n\n * java 编程思想（第 4 版）",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 容器",frontmatter:{title:"Java 容器",categories:["编程","Java","JavaSE","容器"],tags:["Java","JavaSE","容器"],abbrlink:"f431e3b",date:"2020-06-04T13:51:01.000Z",hidden:!0,permalink:"/pages/e1abdb/"},regularPath:"/03.%E5%AE%B9%E5%99%A8/",relativePath:"03.容器/README.md",key:"v-66468b6a",path:"/pages/e1abdb/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:48},{level:2,title:"📖 资料",slug:"📖-资料",normalizedTitle:"📖 资料",charIndex:424},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:886}],headersStr:"📖 内容 📖 资料 🚪 传送",content:"# Java 容器\n\n> Java 容器涉及许多数据结构知识点，所以设立专题进行总结。\n\n\n# 📖 内容\n\n * Java 容器简介 - 关键词：Collection、泛型、Iterable、Iterator、Comparable、Comparator、Cloneable、fail-fast\n * Java 容器之 List - 关键词：List、ArrayList、LinkedList\n * Java 容器之 Map - 关键词：Map、HashMap、TreeMap、LinkedHashMap、WeakHashMap\n * Java 容器之 Set - 关键词：Set、HashSet、TreeSet、LinkedHashSet、EmumSet\n * Java 容器之 Queue - 关键词：Queue、Deque、ArrayDeque、LinkedList、PriorityQueue\n * Java 容器之 Stream\n\n\n# 📖 资料\n\n * 书籍\n   * Java 四大名著\n     * 《Java 编程思想（Thinking in java）》\n     * 《Java 核心技术 卷 I 基础知识》\n     * 《Java 核心技术 卷 II 高级特性》\n     * 《Effective Java》\n   * Java 入门\n     * 《O'Reilly：Head First Java》\n     * 《Java 从入门到精通》\n     * 《疯狂 Java 讲义》\n * 教程、社区\n   * Runoob Java 教程\n   * java-design-patterns\n   * Java\n   * 《Java 核心技术面试精讲》\n   * 《Java 性能调优实战》\n   * 《Java 业务开发常见错误 100 例》\n   * 深入拆解 Java 虚拟机\n   * 《Java 并发编程实战》\n * 面试\n   * CS-Notes\n   * JavaGuide\n   * advanced-java\n\n\n# 🚪 传送\n\n◾ 🏠 JAVACORE 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"# java 容器\n\n> java 容器涉及许多数据结构知识点，所以设立专题进行总结。\n\n\n# 📖 内容\n\n * java 容器简介 - 关键词：collection、泛型、iterable、iterator、comparable、comparator、cloneable、fail-fast\n * java 容器之 list - 关键词：list、arraylist、linkedlist\n * java 容器之 map - 关键词：map、hashmap、treemap、linkedhashmap、weakhashmap\n * java 容器之 set - 关键词：set、hashset、treeset、linkedhashset、emumset\n * java 容器之 queue - 关键词：queue、deque、arraydeque、linkedlist、priorityqueue\n * java 容器之 stream\n\n\n# 📖 资料\n\n * 书籍\n   * java 四大名著\n     * 《java 编程思想（thinking in java）》\n     * 《java 核心技术 卷 i 基础知识》\n     * 《java 核心技术 卷 ii 高级特性》\n     * 《effective java》\n   * java 入门\n     * 《o'reilly：head first java》\n     * 《java 从入门到精通》\n     * 《疯狂 java 讲义》\n * 教程、社区\n   * runoob java 教程\n   * java-design-patterns\n   * java\n   * 《java 核心技术面试精讲》\n   * 《java 性能调优实战》\n   * 《java 业务开发常见错误 100 例》\n   * 深入拆解 java 虚拟机\n   * 《java 并发编程实战》\n * 面试\n   * cs-notes\n   * javaguide\n   * advanced-java\n\n\n# 🚪 传送\n\n◾ 🏠 javacore 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java IO 模型",frontmatter:{title:"Java IO 模型",categories:["编程","Java","JavaSE","IO"],tags:["Java","JavaSE","IO"],abbrlink:"860dd814",date:"2020-11-21T16:36:40.000Z",permalink:"/pages/99f4f4/"},regularPath:"/04.IO/01.JavaIO%E6%A8%A1%E5%9E%8B.html",relativePath:"04.IO/01.JavaIO模型.md",key:"v-894864aa",path:"/pages/99f4f4/",headers:[{level:2,title:"UNIX I/O 模型",slug:"unix-i-o-模型",normalizedTitle:"unix i/o 模型",charIndex:152},{level:3,title:"同步阻塞 I/O",slug:"同步阻塞-i-o",normalizedTitle:"同步阻塞 i/o",charIndex:192},{level:3,title:"同步非阻塞 I/O",slug:"同步非阻塞-i-o",normalizedTitle:"同步非阻塞 i/o",charIndex:204},{level:3,title:"I/O 多路复用",slug:"i-o-多路复用",normalizedTitle:"i/o 多路复用",charIndex:217},{level:3,title:"信号驱动 I/O",slug:"信号驱动-i-o",normalizedTitle:"信号驱动 i/o",charIndex:229},{level:3,title:"异步 I/O",slug:"异步-i-o",normalizedTitle:"异步 i/o",charIndex:241},{level:2,title:"Java I/O 模型",slug:"java-i-o-模型",normalizedTitle:"java i/o 模型",charIndex:1486},{level:3,title:"BIO",slug:"bio",normalizedTitle:"bio",charIndex:1502},{level:4,title:"BIO 简介",slug:"bio-简介",normalizedTitle:"bio 简介",charIndex:1565},{level:4,title:"BIO 的性能缺陷",slug:"bio-的性能缺陷",normalizedTitle:"bio 的性能缺陷",charIndex:1853},{level:3,title:"NIO",slug:"nio",normalizedTitle:"nio",charIndex:2323},{level:4,title:"使用缓冲区优化读写流",slug:"使用缓冲区优化读写流",normalizedTitle:"使用缓冲区优化读写流",charIndex:2569},{level:4,title:"使用 DirectBuffer 减少内存复制",slug:"使用-directbuffer-减少内存复制",normalizedTitle:"使用 directbuffer 减少内存复制",charIndex:2791},{level:4,title:"优化 I/O，避免阻塞",slug:"优化-i-o-避免阻塞",normalizedTitle:"优化 i/o，避免阻塞",charIndex:3123},{level:3,title:"AIO",slug:"aio",normalizedTitle:"aio",charIndex:3307},{level:2,title:"传统 IO 流",slug:"传统-io-流",normalizedTitle:"传统 io 流",charIndex:3552},{level:3,title:"字节流",slug:"字节流",normalizedTitle:"字节流",charIndex:3638},{level:4,title:"文件字节流",slug:"文件字节流",normalizedTitle:"文件字节流",charIndex:3860},{level:4,title:"内存字节流",slug:"内存字节流",normalizedTitle:"内存字节流",charIndex:5262},{level:4,title:"管道流",slug:"管道流",normalizedTitle:"管道流",charIndex:6226},{level:4,title:"对象字节流",slug:"对象字节流",normalizedTitle:"对象字节流",charIndex:8170},{level:4,title:"数据操作流",slug:"数据操作流",normalizedTitle:"数据操作流",charIndex:8272},{level:4,title:"合并流",slug:"合并流",normalizedTitle:"合并流",charIndex:10574},{level:3,title:"字符流",slug:"字符流",normalizedTitle:"字符流",charIndex:3642},{level:4,title:"文件字符流",slug:"文件字符流",normalizedTitle:"文件字符流",charIndex:11356},{level:4,title:"字节流转换字符流",slug:"字节流转换字符流",normalizedTitle:"字节流转换字符流",charIndex:12824},{level:3,title:"字节流 vs. 字符流",slug:"字节流-vs-字符流",normalizedTitle:"字节流 vs. 字符流",charIndex:13697},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:14087}],headersStr:"UNIX I/O 模型 同步阻塞 I/O 同步非阻塞 I/O I/O 多路复用 信号驱动 I/O 异步 I/O Java I/O 模型 BIO BIO 简介 BIO 的性能缺陷 NIO 使用缓冲区优化读写流 使用 DirectBuffer 减少内存复制 优化 I/O，避免阻塞 AIO 传统 IO 流 字节流 文件字节流 内存字节流 管道流 对象字节流 数据操作流 合并流 字符流 文件字符流 字节流转换字符流 字节流 vs. 字符流 参考资料",content:'# Java IO 模型\n\n> 所谓的I/O，就是计算机内存与外部设备之间拷贝数据的过程。由于 CPU 访问内存的速度远远高于外部设备，因此 CPU 是先把外部设备的数据读到内存里，然后再进行处理。\n> \n> 关键词：InputStream、OutputStream、Reader、Writer\n\n\n# UNIX I/O 模型\n\nUNIX 系统下的 I/O 模型有 5 种：\n\n * 同步阻塞 I/O\n * 同步非阻塞 I/O\n * I/O 多路复用\n * 信号驱动 I/O\n * 异步 I/O\n\n如何去理解 UNIX I/O 模型，大致有以下两个维度：\n\n * 区分同步或异步（synchronous/asynchronous）。简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。\n * 区分阻塞与非阻塞（blocking/non-blocking）。在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。\n\n不能一概而论认为同步或阻塞就是低效，具体还要看应用和系统特征。\n\n对于一个网络 I/O 通信过程，比如网络数据读取，会涉及两个对象，一个是调用这个 I/O 操作的用户线程，另外一个就是操作系统内核。一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间。\n\n当用户线程发起 I/O 操作后，网络数据读取操作会经历两个步骤：\n\n * 用户线程等待内核将数据从网卡拷贝到内核空间。\n * 内核将数据从内核空间拷贝到用户空间。\n\n各种 I/O 模型的区别就是：它们实现这两个步骤的方式是不一样的。\n\n\n# 同步阻塞 I/O\n\n用户线程发起 read 调用后就阻塞了，让出 CPU。内核等待网卡数据到来，把数据从网卡拷贝到内核空间，接着把数据拷贝到用户空间，再把用户线程叫醒。\n\n\n\n\n# 同步非阻塞 I/O\n\n用户线程不断的发起 read 调用，数据没到内核空间时，每次都返回失败，直到数据到了内核空间，这一次 read 调用后，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程叫醒。\n\n\n\n\n# I/O 多路复用\n\n用户线程的读取操作分成两步了，线程先发起 select 调用，目的是问内核数据准备好了吗？等内核把数据准备好了，用户线程再发起 read 调用。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。那为什么叫 I/O 多路复用呢？因为一次 select 调用可以向内核查多个数据通道（Channel）的状态，所以叫多路复用。\n\n\n\n\n# 信号驱动 I/O\n\n首先开启 Socket 的信号驱动 I/O 功能，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。信号驱动式 I/O 模型的优点是我们在数据报到达期间进程不会被阻塞，我们只要等待信号处理函数的通知即可\n\n\n# 异步 I/O\n\n用户线程发起 read 调用的同时注册一个回调函数，read 立即返回，等内核将数据准备好后，再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞。\n\n\n\n\n# Java I/O 模型\n\n\n# BIO\n\n> BIO（blocking IO） 即阻塞 IO。指的主要是传统的 java.io 包，它基于流模型实现。\n\n# BIO 简介\n\njava.io 包提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。\n\n很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。\n\nBIO 的优点是代码比较简单、直观；缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。\n\n# BIO 的性能缺陷\n\nBIO 会阻塞进程，不适合高并发场景。\n\n采用 BIO 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端连接。服务端一般在while(true) 循环中调用 accept() 方法等待客户端的连接请求，一旦接收到一个连接请求，就可以建立 Socket，并基于这个 Socket 进行读写操作。此时，不能再接收其他客户端连接请求，只能等待当前连接的操作执行完成。\n\n如果要让 BIO 通信模型 能够同时处理多个客户端请求，就必须使用多线程（主要原因是socket.accept()、socket.read()、socket.write() 涉及的三个主要函数都是同步阻塞的），但会造成不必要的线程开销。不过可以通过 线程池机制 改善，线程池还可以让线程的创建和回收成本相对较低。\n\n即使可以用线程池略微优化，但是会消耗宝贵的线程资源，并且在百万级并发场景下也撑不住。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。\n\n\n# NIO\n\n> NIO（non-blocking IO） 即非阻塞 IO。指的是 Java 1.4 中引入的 java.nio 包。\n\n为了解决 BIO 的性能问题， Java 1.4 中引入的 java.nio 包。NIO 优化了内存复制以及阻塞导致的严重性能问题。\n\njava.nio 包提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。\n\nNIO 有哪些性能优化点呢？\n\n# 使用缓冲区优化读写流\n\nNIO 与传统 I/O 不同，它是基于块（Block）的，它以块为基本单位处理数据。在 NIO 中，最为重要的两个组件是缓冲区（Buffer）和通道（Channel）。\n\nBuffer 是一块连续的内存块，是 NIO 读写数据的缓冲。Buffer 可以将文件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。Channel 表示缓冲数据的源头或者目的地，它用于读取缓冲或者写入数据，是访问缓冲的接口。\n\n# 使用 DirectBuffer 减少内存复制\n\nNIO 还提供了一个可以直接访问物理内存的类 DirectBuffer。普通的 Buffer 分配的是 JVM 堆内存，而 DirectBuffer 是直接分配物理内存。\n\n数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而 DirectBuffer 则是直接将步骤简化为从内核空间复制到外部设备，减少了数据拷贝。\n\n这里拓展一点，由于 DirectBuffer 申请的是非 JVM 的物理内存，所以创建和销毁的代价很高。DirectBuffer 申请的内存并不是直接由 JVM 负责垃圾回收，但在 DirectBuffer 包装类被回收时，会通过 Java 引用机制来释放该内存块。\n\n# 优化 I/O，避免阻塞\n\n传统 I/O 的数据读写是在用户空间和内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。\n\nNIO 的 Channel 有自己的处理器，可以完成内核空间和磁盘之间的 I/O 操作。在 NIO 中，我们读取和写入数据都要通过 Channel，由于 Channel 是双向的，所以读、写可以同时进行。\n\n\n# AIO\n\n> AIO（Asynchronous IO） 即异步非阻塞 IO，指的是 Java 7 中，对 NIO 有了进一步的改进，也称为 NIO2，引入了异步非阻塞 IO 方式。\n\n在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。\n\n\n# 传统 IO 流\n\n流从概念上来说是一个连续的数据流。当程序需要读数据的时候就需要使用输入流读取数据，当需要往外写数据的时候就需要输出流。\n\nBIO 中操作的流主要有两大类，字节流和字符流，两类根据流的方向都可以分为输入流和输出流。\n\n * 字节流\n   * 输入字节流：InputStream\n   * 输出字节流：OutputStream\n * 字符流\n   * 输入字符流：Reader\n   * 输出字符流：Writer\n\n\n\n\n# 字节流\n\n字节流主要操作字节数据或二进制对象。\n\n字节流有两个核心抽象类：InputStream 和 OutputStream。所有的字节流类都继承自这两个抽象类。\n\n\n\n# 文件字节流\n\nFileOutputStream 和 FileInputStream 提供了读写字节到文件的能力。\n\n文件流操作一般步骤：\n\n 1. 使用 File 类绑定一个文件。\n 2. 把 File 对象绑定到流对象上。\n 3. 进行读或写操作。\n 4. 关闭流\n\nFileOutputStream 和 FileInputStream 示例：\n\npublic class FileStreamDemo {\n\n    private static final String FILEPATH = "temp.log";\n\n    public static void main(String[] args) throws Exception {\n        write(FILEPATH);\n        read(FILEPATH);\n    }\n\n    public static void write(String filepath) throws IOException {\n        // 第1步、使用File类找到一个文件\n        File f = new File(filepath);\n\n        // 第2步、通过子类实例化父类对象\n        OutputStream out = new FileOutputStream(f);\n        // 实例化时，默认为覆盖原文件内容方式；如果添加true参数，则变为对原文件追加内容的方式。\n        // OutputStream out = new FileOutputStream(f, true);\n\n        // 第3步、进行写操作\n        String str = "Hello World\\n";\n        byte[] bytes = str.getBytes();\n        out.write(bytes);\n\n        // 第4步、关闭输出流\n        out.close();\n    }\n\n    public static void read(String filepath) throws IOException {\n        // 第1步、使用File类找到一个文件\n        File f = new File(filepath);\n\n        // 第2步、通过子类实例化父类对象\n        InputStream input = new FileInputStream(f);\n\n        // 第3步、进行读操作\n        // 有三种读取方式，体会其差异\n        byte[] bytes = new byte[(int) f.length()];\n        int len = input.read(bytes); // 读取内容\n        System.out.println("读入数据的长度：" + len);\n\n        // 第4步、关闭输入流\n        input.close();\n        System.out.println("内容为：\\n" + new String(bytes));\n    }\n\n}\n\n\n# 内存字节流\n\nByteArrayInputStream 和 ByteArrayOutputStream 是用来完成内存的输入和输出功能。\n\n内存操作流一般在生成一些临时信息时才使用。 如果临时信息保存在文件中，还需要在有效期过后删除文件，这样比较麻烦。\n\nByteArrayInputStream 和 ByteArrayOutputStream 示例：\n\npublic class ByteArrayStreamDemo {\n\n    public static void main(String[] args) {\n        String str = "HELLOWORLD"; // 定义一个字符串，全部由大写字母组成\n        ByteArrayInputStream bis = new ByteArrayInputStream(str.getBytes());\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        // 准备从内存ByteArrayInputStream中读取内容\n        int temp = 0;\n        while ((temp = bis.read()) != -1) {\n            char c = (char) temp; // 读取的数字变为字符\n            bos.write(Character.toLowerCase(c)); // 将字符变为小写\n        }\n        // 所有的数据就全部都在ByteArrayOutputStream中\n        String newStr = bos.toString(); // 取出内容\n        try {\n            bis.close();\n            bos.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.out.println(newStr);\n    }\n\n}\n\n\n# 管道流\n\n管道流的主要作用是可以进行两个线程间的通信。\n\n如果要进行管道通信，则必须把 PipedOutputStream 连接在 PipedInputStream 上。为此，PipedOutputStream 中提供了 connect() 方法。\n\npublic class PipedStreamDemo {\n\n    public static void main(String[] args) {\n        Send s = new Send();\n        Receive r = new Receive();\n        try {\n            s.getPos().connect(r.getPis()); // 连接管道\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        new Thread(s).start(); // 启动线程\n        new Thread(r).start(); // 启动线程\n    }\n\n    static class Send implements Runnable {\n\n        private PipedOutputStream pos = null;\n\n        Send() {\n            pos = new PipedOutputStream(); // 实例化输出流\n        }\n\n        @Override\n        public void run() {\n            String str = "Hello World!!!";\n            try {\n                pos.write(str.getBytes());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            try {\n                pos.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        /**\n         * 得到此线程的管道输出流\n         */\n        PipedOutputStream getPos() {\n            return pos;\n        }\n\n    }\n\n    static class Receive implements Runnable {\n\n        private PipedInputStream pis = null;\n\n        Receive() {\n            pis = new PipedInputStream();\n        }\n\n        @Override\n        public void run() {\n            byte[] b = new byte[1024];\n            int len = 0;\n            try {\n                len = pis.read(b);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            try {\n                pis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            System.out.println("接收的内容为：" + new String(b, 0, len));\n        }\n\n        /**\n         * 得到此线程的管道输入流\n         */\n        PipedInputStream getPis() {\n            return pis;\n        }\n\n    }\n\n}\n\n\n# 对象字节流\n\nObjectInputStream 和 ObjectOutputStream 是对象输入输出流，一般用于对象序列化。\n\n这里不展开叙述，想了解详细内容和示例可以参考：Java 序列化\n\n# 数据操作流\n\n数据操作流提供了格式化读入和输出数据的方法，分别为 DataInputStream 和 DataOutputStream。\n\nDataInputStream 和 DataOutputStream 格式化读写数据示例：\n\npublic class DataStreamDemo {\n\n    public static final String FILEPATH = "temp.log";\n\n    public static void main(String[] args) throws IOException {\n        write(FILEPATH);\n        read(FILEPATH);\n    }\n\n    private static void write(String filepath) throws IOException {\n        // 1.使用 File 类绑定一个文件\n        File f = new File(filepath);\n\n        // 2.把 File 对象绑定到流对象上\n        DataOutputStream dos = new DataOutputStream(new FileOutputStream(f));\n\n        // 3.进行读或写操作\n        String[] names = { "衬衣", "手套", "围巾" };\n        float[] prices = { 98.3f, 30.3f, 50.5f };\n        int[] nums = { 3, 2, 1 };\n        for (int i = 0; i < names.length; i++) {\n            dos.writeChars(names[i]);\n            dos.writeChar(\'\\t\');\n            dos.writeFloat(prices[i]);\n            dos.writeChar(\'\\t\');\n            dos.writeInt(nums[i]);\n            dos.writeChar(\'\\n\');\n        }\n\n        // 4.关闭流\n        dos.close();\n    }\n\n    private static void read(String filepath) throws IOException {\n        // 1.使用 File 类绑定一个文件\n        File f = new File(filepath);\n\n        // 2.把 File 对象绑定到流对象上\n        DataInputStream dis = new DataInputStream(new FileInputStream(f));\n\n        // 3.进行读或写操作\n        String name = null; // 接收名称\n        float price = 0.0f; // 接收价格\n        int num = 0; // 接收数量\n        char[] temp = null; // 接收商品名称\n        int len = 0; // 保存读取数据的个数\n        char c = 0; // \'\\u0000\'\n        try {\n            while (true) {\n                temp = new char[200]; // 开辟空间\n                len = 0;\n                while ((c = dis.readChar()) != \'\\t\') { // 接收内容\n                    temp[len] = c;\n                    len++; // 读取长度加1\n                }\n                name = new String(temp, 0, len); // 将字符数组变为String\n                price = dis.readFloat(); // 读取价格\n                dis.readChar(); // 读取\\t\n                num = dis.readInt(); // 读取int\n                dis.readChar(); // 读取\\n\n                System.out.printf("名称：%s；价格：%5.2f；数量：%d\\n", name, price, num);\n            }\n        } catch (EOFException e) {\n            System.out.println("结束");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 4.关闭流\n        dis.close();\n    }\n\n}\n\n\n# 合并流\n\n合并流的主要功能是将多个 InputStream 合并为一个 InputStream 流。合并流的功能由 SequenceInputStream 完成。\n\npublic class SequenceInputStreamDemo {\n\n    public static void main(String[] args) throws Exception {\n\n        InputStream is1 = new FileInputStream("temp1.log");\n        InputStream is2 = new FileInputStream("temp2.log");\n        SequenceInputStream sis = new SequenceInputStream(is1, is2);\n\n        int temp = 0; // 接收内容\n        OutputStream os = new FileOutputStream("temp3.logt");\n        while ((temp = sis.read()) != -1) { // 循环输出\n            os.write(temp); // 保存内容\n        }\n\n        sis.close(); // 关闭合并流\n        is1.close(); // 关闭输入流1\n        is2.close(); // 关闭输入流2\n        os.close(); // 关闭输出流\n    }\n\n}\n\n\n\n# 字符流\n\n字符流主要操作字符，一个字符等于两个字节。\n\n字符流有两个核心类：Reader 类和 Writer 。所有的字符流类都继承自这两个抽象类。\n\n\n\n# 文件字符流\n\n文件字符流 FileReader 和 FileWriter 可以向文件读写文本数据。\n\nFileReader 和 FileWriter 读写文件示例：\n\npublic class FileReadWriteDemo {\n\n    private static final String FILEPATH = "temp.log";\n\n    public static void main(String[] args) throws IOException {\n        write(FILEPATH);\n        System.out.println("内容为：" + new String(read(FILEPATH)));\n    }\n\n    public static void write(String filepath) throws IOException {\n        // 1.使用 File 类绑定一个文件\n        File f = new File(filepath);\n\n        // 2.把 File 对象绑定到流对象上\n        Writer out = new FileWriter(f);\n        // Writer out = new FileWriter(f, true); // 追加内容方式\n\n        // 3.进行读或写操作\n        String str = "Hello World!!!\\r\\n";\n        out.write(str);\n\n        // 4.关闭流\n        // 字符流操作时使用了缓冲区，并在关闭字符流时会强制将缓冲区内容输出\n        // 如果不关闭流，则缓冲区的内容是无法输出的\n        // 如果想在不关闭流时，将缓冲区内容输出，可以使用 flush 强制清空缓冲区\n        out.flush();\n        out.close();\n    }\n\n    public static char[] read(String filepath) throws IOException {\n        // 1.使用 File 类绑定一个文件\n        File f = new File(filepath);\n\n        // 2.把 File 对象绑定到流对象上\n        Reader input = new FileReader(f);\n\n        // 3.进行读或写操作\n        int temp = 0; // 接收每一个内容\n        int len = 0; // 读取内容\n        char[] c = new char[1024];\n        while ((temp = input.read()) != -1) {\n            // 如果不是-1就表示还有内容，可以继续读取\n            c[len] = (char) temp;\n            len++;\n        }\n        System.out.println("文件字符数为：" + len);\n\n        // 4.关闭流\n        input.close();\n\n        return c;\n    }\n\n}\n\n\n# 字节流转换字符流\n\n我们可以在程序中通过 InputStream 和 Reader 从数据源中读取数据，然后也可以在程序中将数据通过 OutputStream 和 Writer 输出到目标媒介中\n\n使用 InputStreamReader 可以将输入字节流转化为输入字符流；使用OutputStreamWriter可以将输出字节流转化为输出字符流。\n\nOutputStreamWriter 示例：\n\npublic class OutputStreamWriterDemo {\n\n    public static void main(String[] args) throws IOException {\n        File f = new File("temp.log");\n        Writer out = new OutputStreamWriter(new FileOutputStream(f));\n        out.write("hello world!!");\n        out.close();\n    }\n\n}\n\n\nInputStreamReader 示例：\n\npublic class InputStreamReaderDemo {\n\n    public static void main(String[] args) throws IOException {\n        File f = new File("temp.log");\n        Reader reader = new InputStreamReader(new FileInputStream(f));\n        char[] c = new char[1024];\n        int len = reader.read(c);\n        reader.close();\n        System.out.println(new String(c, 0, len));\n    }\n\n}\n\n\n\n# 字节流 vs. 字符流\n\n相同点：\n\n字节流和字符流都有 read()、write()、flush()、close() 这样的方法，这决定了它们的操作方式近似。\n\n不同点：\n\n * 数据类型\n   * 字节流的数据是字节（二进制对象）。主要核心类是 InputStream 类和 OutputStream 类。\n   * 字符流的数据是字符，一个字符等于两个字节。主要核心类是 Reader 类和 Writer 类。\n * 缓冲区\n   * 字节流在操作时本身不会用到缓冲区（内存），是文件直接操作的。\n   * 字符流在操作时是使用了缓冲区，通过缓冲区再操作文件。\n\n选择：\n\n所有的文件在硬盘或传输时都是以字节方式保存的，例如图片，影音文件等都是按字节方式存储的。字符流无法读写这些文件。\n\n所以，除了纯文本数据文件使用字符流以外，其他文件类型都应该使用字节流方式。\n\n\n# 参考资料\n\n * 《Java 编程思想（Thinking in java）》\n * 《Java 核心技术 卷 I 基础知识》\n * 《Java 从入门到精通》\n * 《Java 核心技术面试精讲》\n * BIO,NIO,AIO 总结\n * 深入拆解 Tomcat & Jetty',normalizedContent:'# java io 模型\n\n> 所谓的i/o，就是计算机内存与外部设备之间拷贝数据的过程。由于 cpu 访问内存的速度远远高于外部设备，因此 cpu 是先把外部设备的数据读到内存里，然后再进行处理。\n> \n> 关键词：inputstream、outputstream、reader、writer\n\n\n# unix i/o 模型\n\nunix 系统下的 i/o 模型有 5 种：\n\n * 同步阻塞 i/o\n * 同步非阻塞 i/o\n * i/o 多路复用\n * 信号驱动 i/o\n * 异步 i/o\n\n如何去理解 unix i/o 模型，大致有以下两个维度：\n\n * 区分同步或异步（synchronous/asynchronous）。简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。\n * 区分阻塞与非阻塞（blocking/non-blocking）。在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 serversocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 io 操作是否结束，直接返回，相应操作在后台继续处理。\n\n不能一概而论认为同步或阻塞就是低效，具体还要看应用和系统特征。\n\n对于一个网络 i/o 通信过程，比如网络数据读取，会涉及两个对象，一个是调用这个 i/o 操作的用户线程，另外一个就是操作系统内核。一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间。\n\n当用户线程发起 i/o 操作后，网络数据读取操作会经历两个步骤：\n\n * 用户线程等待内核将数据从网卡拷贝到内核空间。\n * 内核将数据从内核空间拷贝到用户空间。\n\n各种 i/o 模型的区别就是：它们实现这两个步骤的方式是不一样的。\n\n\n# 同步阻塞 i/o\n\n用户线程发起 read 调用后就阻塞了，让出 cpu。内核等待网卡数据到来，把数据从网卡拷贝到内核空间，接着把数据拷贝到用户空间，再把用户线程叫醒。\n\n\n\n\n# 同步非阻塞 i/o\n\n用户线程不断的发起 read 调用，数据没到内核空间时，每次都返回失败，直到数据到了内核空间，这一次 read 调用后，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程叫醒。\n\n\n\n\n# i/o 多路复用\n\n用户线程的读取操作分成两步了，线程先发起 select 调用，目的是问内核数据准备好了吗？等内核把数据准备好了，用户线程再发起 read 调用。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。那为什么叫 i/o 多路复用呢？因为一次 select 调用可以向内核查多个数据通道（channel）的状态，所以叫多路复用。\n\n\n\n\n# 信号驱动 i/o\n\n首先开启 socket 的信号驱动 i/o 功能，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个 sigio 信号，可以在信号处理函数中调用 i/o 操作函数处理数据。信号驱动式 i/o 模型的优点是我们在数据报到达期间进程不会被阻塞，我们只要等待信号处理函数的通知即可\n\n\n# 异步 i/o\n\n用户线程发起 read 调用的同时注册一个回调函数，read 立即返回，等内核将数据准备好后，再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞。\n\n\n\n\n# java i/o 模型\n\n\n# bio\n\n> bio（blocking io） 即阻塞 io。指的主要是传统的 java.io 包，它基于流模型实现。\n\n# bio 简介\n\njava.io 包提供了我们最熟知的一些 io 功能，比如 file 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。\n\n很多时候，人们也把 java.net 下面提供的部分网络 api，比如 socket、serversocket、httpurlconnection 也归类到同步阻塞 io 类库，因为网络通信同样是 io 行为。\n\nbio 的优点是代码比较简单、直观；缺点则是 io 效率和扩展性存在局限性，容易成为应用性能的瓶颈。\n\n# bio 的性能缺陷\n\nbio 会阻塞进程，不适合高并发场景。\n\n采用 bio 的服务端，通常由一个独立的 acceptor 线程负责监听客户端连接。服务端一般在while(true) 循环中调用 accept() 方法等待客户端的连接请求，一旦接收到一个连接请求，就可以建立 socket，并基于这个 socket 进行读写操作。此时，不能再接收其他客户端连接请求，只能等待当前连接的操作执行完成。\n\n如果要让 bio 通信模型 能够同时处理多个客户端请求，就必须使用多线程（主要原因是socket.accept()、socket.read()、socket.write() 涉及的三个主要函数都是同步阻塞的），但会造成不必要的线程开销。不过可以通过 线程池机制 改善，线程池还可以让线程的创建和回收成本相对较低。\n\n即使可以用线程池略微优化，但是会消耗宝贵的线程资源，并且在百万级并发场景下也撑不住。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。\n\n\n# nio\n\n> nio（non-blocking io） 即非阻塞 io。指的是 java 1.4 中引入的 java.nio 包。\n\n为了解决 bio 的性能问题， java 1.4 中引入的 java.nio 包。nio 优化了内存复制以及阻塞导致的严重性能问题。\n\njava.nio 包提供了 channel、selector、buffer 等新的抽象，可以构建多路复用的、同步非阻塞 io 程序，同时提供了更接近操作系统底层的高性能数据操作方式。\n\nnio 有哪些性能优化点呢？\n\n# 使用缓冲区优化读写流\n\nnio 与传统 i/o 不同，它是基于块（block）的，它以块为基本单位处理数据。在 nio 中，最为重要的两个组件是缓冲区（buffer）和通道（channel）。\n\nbuffer 是一块连续的内存块，是 nio 读写数据的缓冲。buffer 可以将文件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。channel 表示缓冲数据的源头或者目的地，它用于读取缓冲或者写入数据，是访问缓冲的接口。\n\n# 使用 directbuffer 减少内存复制\n\nnio 还提供了一个可以直接访问物理内存的类 directbuffer。普通的 buffer 分配的是 jvm 堆内存，而 directbuffer 是直接分配物理内存。\n\n数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而 directbuffer 则是直接将步骤简化为从内核空间复制到外部设备，减少了数据拷贝。\n\n这里拓展一点，由于 directbuffer 申请的是非 jvm 的物理内存，所以创建和销毁的代价很高。directbuffer 申请的内存并不是直接由 jvm 负责垃圾回收，但在 directbuffer 包装类被回收时，会通过 java 引用机制来释放该内存块。\n\n# 优化 i/o，避免阻塞\n\n传统 i/o 的数据读写是在用户空间和内核空间来回复制，而内核空间的数据是通过操作系统层面的 i/o 接口从磁盘读取或写入。\n\nnio 的 channel 有自己的处理器，可以完成内核空间和磁盘之间的 i/o 操作。在 nio 中，我们读取和写入数据都要通过 channel，由于 channel 是双向的，所以读、写可以同时进行。\n\n\n# aio\n\n> aio（asynchronous io） 即异步非阻塞 io，指的是 java 7 中，对 nio 有了进一步的改进，也称为 nio2，引入了异步非阻塞 io 方式。\n\n在 java 7 中，nio 有了进一步的改进，也就是 nio 2，引入了异步非阻塞 io 方式，也有很多人叫它 aio（asynchronous io）。异步 io 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。\n\n\n# 传统 io 流\n\n流从概念上来说是一个连续的数据流。当程序需要读数据的时候就需要使用输入流读取数据，当需要往外写数据的时候就需要输出流。\n\nbio 中操作的流主要有两大类，字节流和字符流，两类根据流的方向都可以分为输入流和输出流。\n\n * 字节流\n   * 输入字节流：inputstream\n   * 输出字节流：outputstream\n * 字符流\n   * 输入字符流：reader\n   * 输出字符流：writer\n\n\n\n\n# 字节流\n\n字节流主要操作字节数据或二进制对象。\n\n字节流有两个核心抽象类：inputstream 和 outputstream。所有的字节流类都继承自这两个抽象类。\n\n\n\n# 文件字节流\n\nfileoutputstream 和 fileinputstream 提供了读写字节到文件的能力。\n\n文件流操作一般步骤：\n\n 1. 使用 file 类绑定一个文件。\n 2. 把 file 对象绑定到流对象上。\n 3. 进行读或写操作。\n 4. 关闭流\n\nfileoutputstream 和 fileinputstream 示例：\n\npublic class filestreamdemo {\n\n    private static final string filepath = "temp.log";\n\n    public static void main(string[] args) throws exception {\n        write(filepath);\n        read(filepath);\n    }\n\n    public static void write(string filepath) throws ioexception {\n        // 第1步、使用file类找到一个文件\n        file f = new file(filepath);\n\n        // 第2步、通过子类实例化父类对象\n        outputstream out = new fileoutputstream(f);\n        // 实例化时，默认为覆盖原文件内容方式；如果添加true参数，则变为对原文件追加内容的方式。\n        // outputstream out = new fileoutputstream(f, true);\n\n        // 第3步、进行写操作\n        string str = "hello world\\n";\n        byte[] bytes = str.getbytes();\n        out.write(bytes);\n\n        // 第4步、关闭输出流\n        out.close();\n    }\n\n    public static void read(string filepath) throws ioexception {\n        // 第1步、使用file类找到一个文件\n        file f = new file(filepath);\n\n        // 第2步、通过子类实例化父类对象\n        inputstream input = new fileinputstream(f);\n\n        // 第3步、进行读操作\n        // 有三种读取方式，体会其差异\n        byte[] bytes = new byte[(int) f.length()];\n        int len = input.read(bytes); // 读取内容\n        system.out.println("读入数据的长度：" + len);\n\n        // 第4步、关闭输入流\n        input.close();\n        system.out.println("内容为：\\n" + new string(bytes));\n    }\n\n}\n\n\n# 内存字节流\n\nbytearrayinputstream 和 bytearrayoutputstream 是用来完成内存的输入和输出功能。\n\n内存操作流一般在生成一些临时信息时才使用。 如果临时信息保存在文件中，还需要在有效期过后删除文件，这样比较麻烦。\n\nbytearrayinputstream 和 bytearrayoutputstream 示例：\n\npublic class bytearraystreamdemo {\n\n    public static void main(string[] args) {\n        string str = "helloworld"; // 定义一个字符串，全部由大写字母组成\n        bytearrayinputstream bis = new bytearrayinputstream(str.getbytes());\n        bytearrayoutputstream bos = new bytearrayoutputstream();\n        // 准备从内存bytearrayinputstream中读取内容\n        int temp = 0;\n        while ((temp = bis.read()) != -1) {\n            char c = (char) temp; // 读取的数字变为字符\n            bos.write(character.tolowercase(c)); // 将字符变为小写\n        }\n        // 所有的数据就全部都在bytearrayoutputstream中\n        string newstr = bos.tostring(); // 取出内容\n        try {\n            bis.close();\n            bos.close();\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n        system.out.println(newstr);\n    }\n\n}\n\n\n# 管道流\n\n管道流的主要作用是可以进行两个线程间的通信。\n\n如果要进行管道通信，则必须把 pipedoutputstream 连接在 pipedinputstream 上。为此，pipedoutputstream 中提供了 connect() 方法。\n\npublic class pipedstreamdemo {\n\n    public static void main(string[] args) {\n        send s = new send();\n        receive r = new receive();\n        try {\n            s.getpos().connect(r.getpis()); // 连接管道\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n        new thread(s).start(); // 启动线程\n        new thread(r).start(); // 启动线程\n    }\n\n    static class send implements runnable {\n\n        private pipedoutputstream pos = null;\n\n        send() {\n            pos = new pipedoutputstream(); // 实例化输出流\n        }\n\n        @override\n        public void run() {\n            string str = "hello world!!!";\n            try {\n                pos.write(str.getbytes());\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n            try {\n                pos.close();\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n        }\n\n        /**\n         * 得到此线程的管道输出流\n         */\n        pipedoutputstream getpos() {\n            return pos;\n        }\n\n    }\n\n    static class receive implements runnable {\n\n        private pipedinputstream pis = null;\n\n        receive() {\n            pis = new pipedinputstream();\n        }\n\n        @override\n        public void run() {\n            byte[] b = new byte[1024];\n            int len = 0;\n            try {\n                len = pis.read(b);\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n            try {\n                pis.close();\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n            system.out.println("接收的内容为：" + new string(b, 0, len));\n        }\n\n        /**\n         * 得到此线程的管道输入流\n         */\n        pipedinputstream getpis() {\n            return pis;\n        }\n\n    }\n\n}\n\n\n# 对象字节流\n\nobjectinputstream 和 objectoutputstream 是对象输入输出流，一般用于对象序列化。\n\n这里不展开叙述，想了解详细内容和示例可以参考：java 序列化\n\n# 数据操作流\n\n数据操作流提供了格式化读入和输出数据的方法，分别为 datainputstream 和 dataoutputstream。\n\ndatainputstream 和 dataoutputstream 格式化读写数据示例：\n\npublic class datastreamdemo {\n\n    public static final string filepath = "temp.log";\n\n    public static void main(string[] args) throws ioexception {\n        write(filepath);\n        read(filepath);\n    }\n\n    private static void write(string filepath) throws ioexception {\n        // 1.使用 file 类绑定一个文件\n        file f = new file(filepath);\n\n        // 2.把 file 对象绑定到流对象上\n        dataoutputstream dos = new dataoutputstream(new fileoutputstream(f));\n\n        // 3.进行读或写操作\n        string[] names = { "衬衣", "手套", "围巾" };\n        float[] prices = { 98.3f, 30.3f, 50.5f };\n        int[] nums = { 3, 2, 1 };\n        for (int i = 0; i < names.length; i++) {\n            dos.writechars(names[i]);\n            dos.writechar(\'\\t\');\n            dos.writefloat(prices[i]);\n            dos.writechar(\'\\t\');\n            dos.writeint(nums[i]);\n            dos.writechar(\'\\n\');\n        }\n\n        // 4.关闭流\n        dos.close();\n    }\n\n    private static void read(string filepath) throws ioexception {\n        // 1.使用 file 类绑定一个文件\n        file f = new file(filepath);\n\n        // 2.把 file 对象绑定到流对象上\n        datainputstream dis = new datainputstream(new fileinputstream(f));\n\n        // 3.进行读或写操作\n        string name = null; // 接收名称\n        float price = 0.0f; // 接收价格\n        int num = 0; // 接收数量\n        char[] temp = null; // 接收商品名称\n        int len = 0; // 保存读取数据的个数\n        char c = 0; // \'\\u0000\'\n        try {\n            while (true) {\n                temp = new char[200]; // 开辟空间\n                len = 0;\n                while ((c = dis.readchar()) != \'\\t\') { // 接收内容\n                    temp[len] = c;\n                    len++; // 读取长度加1\n                }\n                name = new string(temp, 0, len); // 将字符数组变为string\n                price = dis.readfloat(); // 读取价格\n                dis.readchar(); // 读取\\t\n                num = dis.readint(); // 读取int\n                dis.readchar(); // 读取\\n\n                system.out.printf("名称：%s；价格：%5.2f；数量：%d\\n", name, price, num);\n            }\n        } catch (eofexception e) {\n            system.out.println("结束");\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n\n        // 4.关闭流\n        dis.close();\n    }\n\n}\n\n\n# 合并流\n\n合并流的主要功能是将多个 inputstream 合并为一个 inputstream 流。合并流的功能由 sequenceinputstream 完成。\n\npublic class sequenceinputstreamdemo {\n\n    public static void main(string[] args) throws exception {\n\n        inputstream is1 = new fileinputstream("temp1.log");\n        inputstream is2 = new fileinputstream("temp2.log");\n        sequenceinputstream sis = new sequenceinputstream(is1, is2);\n\n        int temp = 0; // 接收内容\n        outputstream os = new fileoutputstream("temp3.logt");\n        while ((temp = sis.read()) != -1) { // 循环输出\n            os.write(temp); // 保存内容\n        }\n\n        sis.close(); // 关闭合并流\n        is1.close(); // 关闭输入流1\n        is2.close(); // 关闭输入流2\n        os.close(); // 关闭输出流\n    }\n\n}\n\n\n\n# 字符流\n\n字符流主要操作字符，一个字符等于两个字节。\n\n字符流有两个核心类：reader 类和 writer 。所有的字符流类都继承自这两个抽象类。\n\n\n\n# 文件字符流\n\n文件字符流 filereader 和 filewriter 可以向文件读写文本数据。\n\nfilereader 和 filewriter 读写文件示例：\n\npublic class filereadwritedemo {\n\n    private static final string filepath = "temp.log";\n\n    public static void main(string[] args) throws ioexception {\n        write(filepath);\n        system.out.println("内容为：" + new string(read(filepath)));\n    }\n\n    public static void write(string filepath) throws ioexception {\n        // 1.使用 file 类绑定一个文件\n        file f = new file(filepath);\n\n        // 2.把 file 对象绑定到流对象上\n        writer out = new filewriter(f);\n        // writer out = new filewriter(f, true); // 追加内容方式\n\n        // 3.进行读或写操作\n        string str = "hello world!!!\\r\\n";\n        out.write(str);\n\n        // 4.关闭流\n        // 字符流操作时使用了缓冲区，并在关闭字符流时会强制将缓冲区内容输出\n        // 如果不关闭流，则缓冲区的内容是无法输出的\n        // 如果想在不关闭流时，将缓冲区内容输出，可以使用 flush 强制清空缓冲区\n        out.flush();\n        out.close();\n    }\n\n    public static char[] read(string filepath) throws ioexception {\n        // 1.使用 file 类绑定一个文件\n        file f = new file(filepath);\n\n        // 2.把 file 对象绑定到流对象上\n        reader input = new filereader(f);\n\n        // 3.进行读或写操作\n        int temp = 0; // 接收每一个内容\n        int len = 0; // 读取内容\n        char[] c = new char[1024];\n        while ((temp = input.read()) != -1) {\n            // 如果不是-1就表示还有内容，可以继续读取\n            c[len] = (char) temp;\n            len++;\n        }\n        system.out.println("文件字符数为：" + len);\n\n        // 4.关闭流\n        input.close();\n\n        return c;\n    }\n\n}\n\n\n# 字节流转换字符流\n\n我们可以在程序中通过 inputstream 和 reader 从数据源中读取数据，然后也可以在程序中将数据通过 outputstream 和 writer 输出到目标媒介中\n\n使用 inputstreamreader 可以将输入字节流转化为输入字符流；使用outputstreamwriter可以将输出字节流转化为输出字符流。\n\noutputstreamwriter 示例：\n\npublic class outputstreamwriterdemo {\n\n    public static void main(string[] args) throws ioexception {\n        file f = new file("temp.log");\n        writer out = new outputstreamwriter(new fileoutputstream(f));\n        out.write("hello world!!");\n        out.close();\n    }\n\n}\n\n\ninputstreamreader 示例：\n\npublic class inputstreamreaderdemo {\n\n    public static void main(string[] args) throws ioexception {\n        file f = new file("temp.log");\n        reader reader = new inputstreamreader(new fileinputstream(f));\n        char[] c = new char[1024];\n        int len = reader.read(c);\n        reader.close();\n        system.out.println(new string(c, 0, len));\n    }\n\n}\n\n\n\n# 字节流 vs. 字符流\n\n相同点：\n\n字节流和字符流都有 read()、write()、flush()、close() 这样的方法，这决定了它们的操作方式近似。\n\n不同点：\n\n * 数据类型\n   * 字节流的数据是字节（二进制对象）。主要核心类是 inputstream 类和 outputstream 类。\n   * 字符流的数据是字符，一个字符等于两个字节。主要核心类是 reader 类和 writer 类。\n * 缓冲区\n   * 字节流在操作时本身不会用到缓冲区（内存），是文件直接操作的。\n   * 字符流在操作时是使用了缓冲区，通过缓冲区再操作文件。\n\n选择：\n\n所有的文件在硬盘或传输时都是以字节方式保存的，例如图片，影音文件等都是按字节方式存储的。字符流无法读写这些文件。\n\n所以，除了纯文本数据文件使用字符流以外，其他文件类型都应该使用字节流方式。\n\n\n# 参考资料\n\n * 《java 编程思想（thinking in java）》\n * 《java 核心技术 卷 i 基础知识》\n * 《java 从入门到精通》\n * 《java 核心技术面试精讲》\n * bio,nio,aio 总结\n * 深入拆解 tomcat & jetty',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java NIO",frontmatter:{title:"Java NIO",categories:["编程","Java","JavaSE","IO"],tags:["Java","JavaSE","IO","NIO"],abbrlink:94795185,date:"2020-02-19T18:54:21.000Z",permalink:"/pages/ff6965/"},regularPath:"/04.IO/02.JavaNIO.html",relativePath:"04.IO/02.JavaNIO.md",key:"v-52187be7",path:"/pages/ff6965/",headers:[{level:2,title:"NIO 简介",slug:"nio-简介",normalizedTitle:"nio 简介",charIndex:55},{level:3,title:"NIO 和 BIO 的区别",slug:"nio-和-bio-的区别",normalizedTitle:"nio 和 bio 的区别",charIndex:461},{level:4,title:"Non-blocking IO(非阻塞)",slug:"non-blocking-io-非阻塞",normalizedTitle:"non-blocking io(非阻塞)",charIndex:478},{level:4,title:"Buffer(缓冲区)",slug:"buffer-缓冲区",normalizedTitle:"buffer(缓冲区)",charIndex:765},{level:4,title:"Channel (通道)",slug:"channel-通道",normalizedTitle:"channel (通道)",charIndex:1238},{level:4,title:"Selector (选择器)",slug:"selector-选择器",normalizedTitle:"selector (选择器)",charIndex:1346},{level:3,title:"NIO 的基本流程",slug:"nio-的基本流程",normalizedTitle:"nio 的基本流程",charIndex:1463},{level:3,title:"NIO 核心组件",slug:"nio-核心组件",normalizedTitle:"nio 核心组件",charIndex:1589},{level:2,title:"Channel(通道)",slug:"channel-通道-2",normalizedTitle:"channel(通道)",charIndex:1620},{level:2,title:"Buffer(缓冲区)",slug:"buffer-缓冲区-2",normalizedTitle:"buffer(缓冲区)",charIndex:765},{level:3,title:"缓冲区状态变量",slug:"缓冲区状态变量",normalizedTitle:"缓冲区状态变量",charIndex:2682},{level:3,title:"文件 NIO 示例",slug:"文件-nio-示例",normalizedTitle:"文件 nio 示例",charIndex:3158},{level:3,title:"DirectBuffer",slug:"directbuffer",normalizedTitle:"directbuffer",charIndex:3969},{level:2,title:"Selector(选择器)",slug:"selector-选择器-2",normalizedTitle:"selector(选择器)",charIndex:1650},{level:3,title:"创建选择器",slug:"创建选择器",normalizedTitle:"创建选择器",charIndex:4924},{level:3,title:"将通道注册到选择器上",slug:"将通道注册到选择器上",normalizedTitle:"将通道注册到选择器上",charIndex:4973},{level:3,title:"监听事件",slug:"监听事件",normalizedTitle:"监听事件",charIndex:4537},{level:3,title:"获取到达的事件",slug:"获取到达的事件",normalizedTitle:"获取到达的事件",charIndex:5760},{level:3,title:"事件循环",slug:"事件循环",normalizedTitle:"事件循环",charIndex:6082},{level:3,title:"套接字 NIO 示例",slug:"套接字-nio-示例",normalizedTitle:"套接字 nio 示例",charIndex:6567},{level:3,title:"内存映射文件",slug:"内存映射文件",normalizedTitle:"内存映射文件",charIndex:9083},{level:2,title:"NIO vs. BIO",slug:"nio-vs-bio",normalizedTitle:"nio vs. bio",charIndex:9421},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:9715}],headersStr:"NIO 简介 NIO 和 BIO 的区别 Non-blocking IO(非阻塞) Buffer(缓冲区) Channel (通道) Selector (选择器) NIO 的基本流程 NIO 核心组件 Channel(通道) Buffer(缓冲区) 缓冲区状态变量 文件 NIO 示例 DirectBuffer Selector(选择器) 创建选择器 将通道注册到选择器上 监听事件 获取到达的事件 事件循环 套接字 NIO 示例 内存映射文件 NIO vs. BIO 参考资料",content:'# Java NIO\n\n> 关键词：Channel、Buffer、Selector、非阻塞、多路复用\n\n\n# NIO 简介\n\nNIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel 、Selector、Buffer 等抽象。\n\nNIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。\n\n\n# NIO 和 BIO 的区别\n\n# Non-blocking IO(非阻塞)\n\nBIO 是阻塞的，NIO 是非阻塞的。\n\nBIO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。在此期间，该线程不能再干其他任何事。\n\nNIO 使我们可以进行非阻塞 IO 操作。比如说，单线程中从通道读取数据到 buffer，同时可以继续做别的事情，当数据读取到 buffer 中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。\n\n# Buffer(缓冲区)\n\nBIO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。\n\nBuffer 是一个对象，它包含一些要写入或者要读出的数据。在 NIO 类库中加入 Buffer 对象，体现了 NIO 与 BIO 的一个重要区别。在面向流的 BIO 中可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。\n\n在 NIO 厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读缓冲区中的数据; 在写入数据时，写入到缓冲区中。任何时候访问 NIO 中的数据，都是通过缓冲区进行操作。\n\n最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了 ByteBuffer,还有其他的一些缓冲区，事实上，每一种 Java 基本类型（除了 Boolean 类型）都对应有一种缓冲区。\n\n# Channel (通道)\n\nNIO 通过 Channel（通道） 进行读写。\n\n通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和 Buffer 交互。因为 Buffer，通道可以异步地读写。\n\n# Selector (选择器)\n\nNIO 有选择器，而 IO 没有。\n\n选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。\n\n\n# NIO 的基本流程\n\n通常来说 NIO 中的所有 IO 都是从 Channel（通道） 开始的。\n\n * 从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。\n * 从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。\n\n\n# NIO 核心组件\n\nNIO 包含下面几个核心的组件：\n\n * Channel(通道)\n * Buffer(缓冲区)\n * Selector(选择器)\n\n\n# Channel(通道)\n\n通道（Channel）是对 BIO 中的流的模拟，可以通过它读写数据。\n\nChannel，类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。\n\nFile 或者 Socket，通常被认为是比较高层次的抽象，而 Channel 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过 Socket 获取 Channel，反之亦然。\n\n通道与流的不同之处在于：\n\n * 流是单向的 - 一个流只能单纯的负责读或写。\n * 通道是双向的 - 一个通道可以同时用于读写。\n\n通道包括以下类型：\n\n * FileChannel：从文件中读写数据；\n * DatagramChannel：通过 UDP 读写网络中数据；\n * SocketChannel：通过 TCP 读写网络中数据；\n * ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。\n\n\n# Buffer(缓冲区)\n\nNIO 与传统 I/O 不同，它是基于块（Block）的，它以块为基本单位处理数据。Buffer 是一块连续的内存块，是 NIO 读写数据的缓冲。Buffer 可以将文件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。\n\n向 Channel 读写的数据都必须先置于缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。\n\nBIO 和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。\n\n缓冲区包括以下类型：\n\n * ByteBuffer\n * CharBuffer\n * ShortBuffer\n * IntBuffer\n * LongBuffer\n * FloatBuffer\n * DoubleBuffer\n\n\n# 缓冲区状态变量\n\n * capacity：最大容量；\n * position：当前已经读写的字节数；\n * limit：还可以读写的字节数。\n * mark：记录上一次 postion 的位置，默认是 0，算是一个便利性的考虑，往往不是必须 的。\n\n缓冲区状态变量的改变过程举例：\n\n 1. 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。\n 2. 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。\n 3. 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。\n 4. 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。\n 5. 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。\n\n\n# 文件 NIO 示例\n\n以下展示了使用 NIO 快速复制文件的实例：\n\npublic static void fastCopy(String src, String dist) throws IOException {\n\n    /* 获得源文件的输入字节流 */\n    FileInputStream fin = new FileInputStream(src);\n\n    /* 获取输入字节流的文件通道 */\n    FileChannel fcin = fin.getChannel();\n\n    /* 获取目标文件的输出字节流 */\n    FileOutputStream fout = new FileOutputStream(dist);\n\n    /* 获取输出字节流的通道 */\n    FileChannel fcout = fout.getChannel();\n\n    /* 为缓冲区分配 1024 个字节 */\n    ByteBuffer buffer = ByteBuffer.allocateDirect(1024);\n\n    while (true) {\n\n        /* 从输入通道中读取数据到缓冲区中 */\n        int r = fcin.read(buffer);\n\n        /* read() 返回 -1 表示 EOF */\n        if (r == -1) {\n            break;\n        }\n\n        /* 切换读写 */\n        buffer.flip();\n\n        /* 把缓冲区的内容写入输出文件中 */\n        fcout.write(buffer);\n\n        /* 清空缓冲区 */\n        buffer.clear();\n    }\n}\n\n\n\n# DirectBuffer\n\nNIO 还提供了一个可以直接访问物理内存的类 DirectBuffer。普通的 Buffer 分配的是 JVM 堆内存，而 DirectBuffer 是直接分配物理内存。\n\n数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而 DirectBuffer 则是直接将步骤简化为从内核空间复制到外部设备，减少了数据拷贝。\n\n这里拓展一点，由于 DirectBuffer 申请的是非 JVM 的物理内存，所以创建和销毁的代价很高。DirectBuffer 申请的内存并不是直接由 JVM 负责垃圾回收，但在 DirectBuffer 包装类被回收时，会通过 Java 引用机制来释放该内存块。\n\n\n# Selector(选择器)\n\nNIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。\n\nSelector 是 Java NIO 编程的基础。用于检查一个或多个 NIO Channel 的状态是否处于可读、可写。\n\nNIO 实现了 IO 多路复用中的 Reactor 模型：\n\n * 一个线程（Thread）使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件（accpet、read），如果某个 Channel 上面发生监听事件，这个 Channel 就处于就绪状态，然后进行 I/O 操作。\n\n * 通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。\n\n * 因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件具有更好的性能。\n\n需要注意的是，只有 SocketChannel 才能配置为非阻塞，而 FileChannel 不能，因为 FileChannel 配置非阻塞也没有意义。\n\n> 目前操作系统的 I/O 多路复用机制都使用了 epoll，相比传统的 select 机制，epoll 没有最大连接句柄 1024 的限制。所以 Selector 在理论上可以轮询成千上万的客户端。\n\n\n# 创建选择器\n\nSelector selector = Selector.open();\n\n\n\n# 将通道注册到选择器上\n\nServerSocketChannel ssChannel = ServerSocketChannel.open();\nssChannel.configureBlocking(false);\nssChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n\n通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。\n\n在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：\n\n * SelectionKey.OP_CONNECT\n * SelectionKey.OP_ACCEPT\n * SelectionKey.OP_READ\n * SelectionKey.OP_WRITE\n\n它们在 SelectionKey 的定义如下：\n\npublic static final int OP_READ = 1 << 0;\npublic static final int OP_WRITE = 1 << 2;\npublic static final int OP_CONNECT = 1 << 3;\npublic static final int OP_ACCEPT = 1 << 4;\n\n\n可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：\n\nint interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n\n\n\n# 监听事件\n\nint num = selector.select();\n\n\n使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。\n\n\n# 获取到达的事件\n\nSet<SelectionKey> keys = selector.selectedKeys();\nIterator<SelectionKey> keyIterator = keys.iterator();\nwhile (keyIterator.hasNext()) {\n    SelectionKey key = keyIterator.next();\n    if (key.isAcceptable()) {\n        // ...\n    } else if (key.isReadable()) {\n        // ...\n    }\n    keyIterator.remove();\n}\n\n\n\n# 事件循环\n\n因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。\n\nwhile (true) {\n    int num = selector.select();\n    Set<SelectionKey> keys = selector.selectedKeys();\n    Iterator<SelectionKey> keyIterator = keys.iterator();\n    while (keyIterator.hasNext()) {\n        SelectionKey key = keyIterator.next();\n        if (key.isAcceptable()) {\n            // ...\n        } else if (key.isReadable()) {\n            // ...\n        }\n        keyIterator.remove();\n    }\n}\n\n\n\n# 套接字 NIO 示例\n\npublic class NIOServer {\n\n    public static void main(String[] args) throws IOException {\n\n        Selector selector = Selector.open();\n\n        ServerSocketChannel ssChannel = ServerSocketChannel.open();\n        ssChannel.configureBlocking(false);\n        ssChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        ServerSocket serverSocket = ssChannel.socket();\n        InetSocketAddress address = new InetSocketAddress("127.0.0.1", 8888);\n        serverSocket.bind(address);\n\n        while (true) {\n\n            selector.select();\n            Set<SelectionKey> keys = selector.selectedKeys();\n            Iterator<SelectionKey> keyIterator = keys.iterator();\n\n            while (keyIterator.hasNext()) {\n\n                SelectionKey key = keyIterator.next();\n\n                if (key.isAcceptable()) {\n\n                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();\n\n                    // 服务器会为每个新连接创建一个 SocketChannel\n                    SocketChannel sChannel = ssChannel1.accept();\n                    sChannel.configureBlocking(false);\n\n                    // 这个新连接主要用于从客户端读取数据\n                    sChannel.register(selector, SelectionKey.OP_READ);\n\n                } else if (key.isReadable()) {\n\n                    SocketChannel sChannel = (SocketChannel) key.channel();\n                    System.out.println(readDataFromSocketChannel(sChannel));\n                    sChannel.close();\n                }\n\n                keyIterator.remove();\n            }\n        }\n    }\n\n    private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException {\n\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        StringBuilder data = new StringBuilder();\n\n        while (true) {\n\n            buffer.clear();\n            int n = sChannel.read(buffer);\n            if (n == -1) {\n                break;\n            }\n            buffer.flip();\n            int limit = buffer.limit();\n            char[] dst = new char[limit];\n            for (int i = 0; i < limit; i++) {\n                dst[i] = (char) buffer.get(i);\n            }\n            data.append(dst);\n            buffer.clear();\n        }\n        return data.toString();\n    }\n}\n\n\npublic class NIOClient {\n\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket("127.0.0.1", 8888);\n        OutputStream out = socket.getOutputStream();\n        String s = "hello world";\n        out.write(s.getBytes());\n        out.close();\n    }\n}\n\n\n\n# 内存映射文件\n\n内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。\n\n向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。\n\n下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。\n\nMappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);\n\n\n\n# NIO vs. BIO\n\nBIO 与 NIO 最重要的区别是数据打包和传输的方式：BIO 以流的方式处理数据，而 NIO 以块的方式处理数据。\n\n * 面向流的 BIO 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。\n * 面向块的 NIO 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 NIO 缺少一些面向流的 BIO 所具有的优雅性和简单性。\n\nBIO 模式：\n\n\n\nNIO 模式：\n\n\n\n\n# 参考资料\n\n * BIO,NIO,AIO 总结\n * Java NIO 浅析\n * JavaNIO Tutorial\n * IBM: NIO 入门',normalizedContent:'# java nio\n\n> 关键词：channel、buffer、selector、非阻塞、多路复用\n\n\n# nio 简介\n\nnio 是一种同步非阻塞的 i/o 模型，在 java 1.4 中引入了 nio 框架，对应 java.nio 包，提供了 channel 、selector、buffer 等抽象。\n\nnio 中的 n 可以理解为 non-blocking，不单纯是 new。它支持面向缓冲的，基于通道的 i/o 操作方法。 nio 提供了与传统 bio 模型中的 socket 和 serversocket 相对应的 socketchannel 和 serversocketchannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 i/o 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 nio 的非阻塞模式来开发。\n\n\n# nio 和 bio 的区别\n\n# non-blocking io(非阻塞)\n\nbio 是阻塞的，nio 是非阻塞的。\n\nbio 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。在此期间，该线程不能再干其他任何事。\n\nnio 使我们可以进行非阻塞 io 操作。比如说，单线程中从通道读取数据到 buffer，同时可以继续做别的事情，当数据读取到 buffer 中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。\n\n# buffer(缓冲区)\n\nbio 面向流(stream oriented)，而 nio 面向缓冲区(buffer oriented)。\n\nbuffer 是一个对象，它包含一些要写入或者要读出的数据。在 nio 类库中加入 buffer 对象，体现了 nio 与 bio 的一个重要区别。在面向流的 bio 中可以将数据直接写入或者将数据直接读到 stream 对象中。虽然 stream 中也有 buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 nio 却是直接读到 buffer 中进行操作。\n\n在 nio 厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读缓冲区中的数据; 在写入数据时，写入到缓冲区中。任何时候访问 nio 中的数据，都是通过缓冲区进行操作。\n\n最常用的缓冲区是 bytebuffer,一个 bytebuffer 提供了一组功能用于操作 byte 数组。除了 bytebuffer,还有其他的一些缓冲区，事实上，每一种 java 基本类型（除了 boolean 类型）都对应有一种缓冲区。\n\n# channel (通道)\n\nnio 通过 channel（通道） 进行读写。\n\n通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和 buffer 交互。因为 buffer，通道可以异步地读写。\n\n# selector (选择器)\n\nnio 有选择器，而 io 没有。\n\n选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。\n\n\n# nio 的基本流程\n\n通常来说 nio 中的所有 io 都是从 channel（通道） 开始的。\n\n * 从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。\n * 从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。\n\n\n# nio 核心组件\n\nnio 包含下面几个核心的组件：\n\n * channel(通道)\n * buffer(缓冲区)\n * selector(选择器)\n\n\n# channel(通道)\n\n通道（channel）是对 bio 中的流的模拟，可以通过它读写数据。\n\nchannel，类似在 linux 之类操作系统上看到的文件描述符，是 nio 中被用来支持批量式 io 操作的一种抽象。\n\nfile 或者 socket，通常被认为是比较高层次的抽象，而 channel 则是更加操作系统底层的一种抽象，这也使得 nio 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，dma（direct memory access）等。不同层次的抽象是相互关联的，我们可以通过 socket 获取 channel，反之亦然。\n\n通道与流的不同之处在于：\n\n * 流是单向的 - 一个流只能单纯的负责读或写。\n * 通道是双向的 - 一个通道可以同时用于读写。\n\n通道包括以下类型：\n\n * filechannel：从文件中读写数据；\n * datagramchannel：通过 udp 读写网络中数据；\n * socketchannel：通过 tcp 读写网络中数据；\n * serversocketchannel：可以监听新进来的 tcp 连接，对每一个新进来的连接都会创建一个 socketchannel。\n\n\n# buffer(缓冲区)\n\nnio 与传统 i/o 不同，它是基于块（block）的，它以块为基本单位处理数据。buffer 是一块连续的内存块，是 nio 读写数据的缓冲。buffer 可以将文件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。\n\n向 channel 读写的数据都必须先置于缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。\n\nbio 和 nio 已经很好地集成了，java.io.* 已经以 nio 为基础重新实现了，所以现在它可以利用 nio 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。\n\n缓冲区包括以下类型：\n\n * bytebuffer\n * charbuffer\n * shortbuffer\n * intbuffer\n * longbuffer\n * floatbuffer\n * doublebuffer\n\n\n# 缓冲区状态变量\n\n * capacity：最大容量；\n * position：当前已经读写的字节数；\n * limit：还可以读写的字节数。\n * mark：记录上一次 postion 的位置，默认是 0，算是一个便利性的考虑，往往不是必须 的。\n\n缓冲区状态变量的改变过程举例：\n\n 1. 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。\n 2. 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。\n 3. 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。\n 4. 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。\n 5. 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。\n\n\n# 文件 nio 示例\n\n以下展示了使用 nio 快速复制文件的实例：\n\npublic static void fastcopy(string src, string dist) throws ioexception {\n\n    /* 获得源文件的输入字节流 */\n    fileinputstream fin = new fileinputstream(src);\n\n    /* 获取输入字节流的文件通道 */\n    filechannel fcin = fin.getchannel();\n\n    /* 获取目标文件的输出字节流 */\n    fileoutputstream fout = new fileoutputstream(dist);\n\n    /* 获取输出字节流的通道 */\n    filechannel fcout = fout.getchannel();\n\n    /* 为缓冲区分配 1024 个字节 */\n    bytebuffer buffer = bytebuffer.allocatedirect(1024);\n\n    while (true) {\n\n        /* 从输入通道中读取数据到缓冲区中 */\n        int r = fcin.read(buffer);\n\n        /* read() 返回 -1 表示 eof */\n        if (r == -1) {\n            break;\n        }\n\n        /* 切换读写 */\n        buffer.flip();\n\n        /* 把缓冲区的内容写入输出文件中 */\n        fcout.write(buffer);\n\n        /* 清空缓冲区 */\n        buffer.clear();\n    }\n}\n\n\n\n# directbuffer\n\nnio 还提供了一个可以直接访问物理内存的类 directbuffer。普通的 buffer 分配的是 jvm 堆内存，而 directbuffer 是直接分配物理内存。\n\n数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而 directbuffer 则是直接将步骤简化为从内核空间复制到外部设备，减少了数据拷贝。\n\n这里拓展一点，由于 directbuffer 申请的是非 jvm 的物理内存，所以创建和销毁的代价很高。directbuffer 申请的内存并不是直接由 jvm 负责垃圾回收，但在 directbuffer 包装类被回收时，会通过 java 引用机制来释放该内存块。\n\n\n# selector(选择器)\n\nnio 常常被叫做非阻塞 io，主要是因为 nio 在网络通信中的非阻塞特性被广泛使用。\n\nselector 是 java nio 编程的基础。用于检查一个或多个 nio channel 的状态是否处于可读、可写。\n\nnio 实现了 io 多路复用中的 reactor 模型：\n\n * 一个线程（thread）使用一个选择器 selector 通过轮询的方式去监听多个通道 channel 上的事件（accpet、read），如果某个 channel 上面发生监听事件，这个 channel 就处于就绪状态，然后进行 i/o 操作。\n\n * 通过配置监听的通道 channel 为非阻塞，那么当 channel 上的 io 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 channel，找到 io 事件已经到达的 channel 执行。\n\n * 因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件具有更好的性能。\n\n需要注意的是，只有 socketchannel 才能配置为非阻塞，而 filechannel 不能，因为 filechannel 配置非阻塞也没有意义。\n\n> 目前操作系统的 i/o 多路复用机制都使用了 epoll，相比传统的 select 机制，epoll 没有最大连接句柄 1024 的限制。所以 selector 在理论上可以轮询成千上万的客户端。\n\n\n# 创建选择器\n\nselector selector = selector.open();\n\n\n\n# 将通道注册到选择器上\n\nserversocketchannel sschannel = serversocketchannel.open();\nsschannel.configureblocking(false);\nsschannel.register(selector, selectionkey.op_accept);\n\n\n通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。\n\n在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：\n\n * selectionkey.op_connect\n * selectionkey.op_accept\n * selectionkey.op_read\n * selectionkey.op_write\n\n它们在 selectionkey 的定义如下：\n\npublic static final int op_read = 1 << 0;\npublic static final int op_write = 1 << 2;\npublic static final int op_connect = 1 << 3;\npublic static final int op_accept = 1 << 4;\n\n\n可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：\n\nint interestset = selectionkey.op_read | selectionkey.op_write;\n\n\n\n# 监听事件\n\nint num = selector.select();\n\n\n使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。\n\n\n# 获取到达的事件\n\nset<selectionkey> keys = selector.selectedkeys();\niterator<selectionkey> keyiterator = keys.iterator();\nwhile (keyiterator.hasnext()) {\n    selectionkey key = keyiterator.next();\n    if (key.isacceptable()) {\n        // ...\n    } else if (key.isreadable()) {\n        // ...\n    }\n    keyiterator.remove();\n}\n\n\n\n# 事件循环\n\n因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。\n\nwhile (true) {\n    int num = selector.select();\n    set<selectionkey> keys = selector.selectedkeys();\n    iterator<selectionkey> keyiterator = keys.iterator();\n    while (keyiterator.hasnext()) {\n        selectionkey key = keyiterator.next();\n        if (key.isacceptable()) {\n            // ...\n        } else if (key.isreadable()) {\n            // ...\n        }\n        keyiterator.remove();\n    }\n}\n\n\n\n# 套接字 nio 示例\n\npublic class nioserver {\n\n    public static void main(string[] args) throws ioexception {\n\n        selector selector = selector.open();\n\n        serversocketchannel sschannel = serversocketchannel.open();\n        sschannel.configureblocking(false);\n        sschannel.register(selector, selectionkey.op_accept);\n\n        serversocket serversocket = sschannel.socket();\n        inetsocketaddress address = new inetsocketaddress("127.0.0.1", 8888);\n        serversocket.bind(address);\n\n        while (true) {\n\n            selector.select();\n            set<selectionkey> keys = selector.selectedkeys();\n            iterator<selectionkey> keyiterator = keys.iterator();\n\n            while (keyiterator.hasnext()) {\n\n                selectionkey key = keyiterator.next();\n\n                if (key.isacceptable()) {\n\n                    serversocketchannel sschannel1 = (serversocketchannel) key.channel();\n\n                    // 服务器会为每个新连接创建一个 socketchannel\n                    socketchannel schannel = sschannel1.accept();\n                    schannel.configureblocking(false);\n\n                    // 这个新连接主要用于从客户端读取数据\n                    schannel.register(selector, selectionkey.op_read);\n\n                } else if (key.isreadable()) {\n\n                    socketchannel schannel = (socketchannel) key.channel();\n                    system.out.println(readdatafromsocketchannel(schannel));\n                    schannel.close();\n                }\n\n                keyiterator.remove();\n            }\n        }\n    }\n\n    private static string readdatafromsocketchannel(socketchannel schannel) throws ioexception {\n\n        bytebuffer buffer = bytebuffer.allocate(1024);\n        stringbuilder data = new stringbuilder();\n\n        while (true) {\n\n            buffer.clear();\n            int n = schannel.read(buffer);\n            if (n == -1) {\n                break;\n            }\n            buffer.flip();\n            int limit = buffer.limit();\n            char[] dst = new char[limit];\n            for (int i = 0; i < limit; i++) {\n                dst[i] = (char) buffer.get(i);\n            }\n            data.append(dst);\n            buffer.clear();\n        }\n        return data.tostring();\n    }\n}\n\n\npublic class nioclient {\n\n    public static void main(string[] args) throws ioexception {\n        socket socket = new socket("127.0.0.1", 8888);\n        outputstream out = socket.getoutputstream();\n        string s = "hello world";\n        out.write(s.getbytes());\n        out.close();\n    }\n}\n\n\n\n# 内存映射文件\n\n内存映射文件 i/o 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 i/o 快得多。\n\n向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。\n\n下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 mappedbytebuffer，它是 bytebuffer 的子类。因此，可以像使用其他任何 bytebuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。\n\nmappedbytebuffer mbb = fc.map(filechannel.mapmode.read_write, 0, 1024);\n\n\n\n# nio vs. bio\n\nbio 与 nio 最重要的区别是数据打包和传输的方式：bio 以流的方式处理数据，而 nio 以块的方式处理数据。\n\n * 面向流的 bio 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 i/o 通常相当慢。\n * 面向块的 nio 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 nio 缺少一些面向流的 bio 所具有的优雅性和简单性。\n\nbio 模式：\n\n\n\nnio 模式：\n\n\n\n\n# 参考资料\n\n * bio,nio,aio 总结\n * java nio 浅析\n * javanio tutorial\n * ibm: nio 入门',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"深入理解 Java 序列化",frontmatter:{title:"深入理解 Java 序列化",categories:["编程","Java","JavaSE","IO"],tags:["Java","JavaSE","IO","序列化"],abbrlink:"663bb8d7",date:"2019-05-09T19:06:05.000Z",permalink:"/pages/287e58/"},regularPath:"/04.IO/03.Java%E5%BA%8F%E5%88%97%E5%8C%96.html",relativePath:"04.IO/03.Java序列化.md",key:"v-1a226c27",path:"/pages/287e58/",headers:[{level:2,title:"Java 序列化简介",slug:"java-序列化简介",normalizedTitle:"java 序列化简介",charIndex:107},{level:2,title:"Java 序列化和反序列化",slug:"java-序列化和反序列化",normalizedTitle:"java 序列化和反序列化",charIndex:397},{level:2,title:"Serializable 接口",slug:"serializable-接口",normalizedTitle:"serializable 接口",charIndex:2288},{level:3,title:"serialVersionUID",slug:"serialversionuid",normalizedTitle:"serialversionuid",charIndex:36},{level:3,title:"默认序列化机制",slug:"默认序列化机制",normalizedTitle:"默认序列化机制",charIndex:3876},{level:3,title:"transient",slug:"transient",normalizedTitle:"transient",charIndex:53},{level:2,title:"Externalizable 接口",slug:"externalizable-接口",normalizedTitle:"externalizable 接口",charIndex:4636},{level:3,title:"Externalizable 接口的替代方法",slug:"externalizable-接口的替代方法",normalizedTitle:"externalizable 接口的替代方法",charIndex:7170},{level:3,title:"readResolve() 方法",slug:"readresolve-方法",normalizedTitle:"readresolve() 方法",charIndex:8314},{level:2,title:"Java 序列化问题",slug:"java-序列化问题",normalizedTitle:"java 序列化问题",charIndex:11391},{level:2,title:"Java 序列化的缺陷",slug:"java-序列化的缺陷",normalizedTitle:"java 序列化的缺陷",charIndex:11684},{level:2,title:"序列化技术选型",slug:"序列化技术选型",normalizedTitle:"序列化技术选型",charIndex:12362},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:12620}],headersStr:"Java 序列化简介 Java 序列化和反序列化 Serializable 接口 serialVersionUID 默认序列化机制 transient Externalizable 接口 Externalizable 接口的替代方法 readResolve() 方法 Java 序列化问题 Java 序列化的缺陷 序列化技术选型 参考资料",content:'# 深入理解 Java 序列化\n\n> 关键词：Serializable、serialVersionUID、transient、Externalizable、writeObject、readObject\n\n\n\n\n# Java 序列化简介\n\n\n\n * 序列化（serialize） - 序列化是将对象转换为字节流。\n * 反序列化（deserialize） - 反序列化是将字节流转换为对象。\n * 序列化用途\n   * 序列化可以将对象的字节序列持久化——保存在内存、文件、数据库中。\n   * 在网络上传送对象的字节序列。\n   * RMI(远程方法调用)\n\n> 🔔 注意：使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。\n\n\n# Java 序列化和反序列化\n\nJava 通过对象输入输出流来实现序列化和反序列化：\n\n * java.io.ObjectOutputStream 类的 writeObject() 方法可以实现序列化；\n * java.io.ObjectInputStream 类的 readObject() 方法用于实现反序列化。\n\n序列化和反序列化示例：\n\npublic class SerializeDemo01 {\n    enum Sex {\n        MALE,\n        FEMALE\n    }\n\n\n    static class Person implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private String name = null;\n        private Integer age = null;\n        private Sex sex;\n\n        public Person() { }\n\n        public Person(String name, Integer age, Sex sex) {\n            this.name = name;\n            this.age = age;\n            this.sex = sex;\n        }\n\n        @Override\n        public String toString() {\n            return "Person{" + "name=\'" + name + \'\\\'\' + ", age=" + age + ", sex=" + sex + \'}\';\n        }\n    }\n\n    /**\n     * 序列化\n     */\n    private static void serialize(String filename) throws IOException {\n        File f = new File(filename); // 定义保存路径\n        OutputStream out = new FileOutputStream(f); // 文件输出流\n        ObjectOutputStream oos = new ObjectOutputStream(out); // 对象输出流\n        oos.writeObject(new Person("Jack", 30, Sex.MALE)); // 保存对象\n        oos.close();\n        out.close();\n    }\n\n    /**\n     * 反序列化\n     */\n    private static void deserialize(String filename) throws IOException, ClassNotFoundException {\n        File f = new File(filename); // 定义保存路径\n        InputStream in = new FileInputStream(f); // 文件输入流\n        ObjectInputStream ois = new ObjectInputStream(in); // 对象输入流\n        Object obj = ois.readObject(); // 读取对象\n        ois.close();\n        in.close();\n        System.out.println(obj);\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        final String filename = "d:/text.dat";\n        serialize(filename);\n        deserialize(filename);\n    }\n}\n// Output:\n// Person{name=\'Jack\', age=30, sex=MALE}\n\n\n\n# Serializable 接口\n\n被序列化的类必须属于 Enum、Array 和 Serializable 类型其中的任何一种，否则将抛出 NotSerializableException 异常。这是因为：在序列化操作过程中会对类型进行检查，如果不满足序列化类型要求，就会抛出异常。\n\n【示例】NotSerializableException 错误\n\npublic class UnSerializeDemo {\n    static class Person { // 其他内容略 }\n    // 其他内容略\n}\n\n\n输出：结果就是出现如下异常信息。\n\nException in thread "main" java.io.NotSerializableException:\n...\n\n\n\n# serialVersionUID\n\n请注意 serialVersionUID 字段，你可以在 Java 世界的无数类中看到这个字段。\n\nserialVersionUID 有什么作用，如何使用 serialVersionUID？\n\nserialVersionUID 是 Java 为每个序列化类产生的版本标识。它可以用来保证在反序列时，发送方发送的和接受方接收的是可兼容的对象。如果接收方接收的类的 serialVersionUID 与发送方发送的 serialVersionUID 不一致，会抛出 InvalidClassException。\n\n如果可序列化类没有显式声明 serialVersionUID，则序列化运行时将基于该类的各个方面计算该类的默认 serialVersionUID 值。尽管这样，还是建议在每一个序列化的类中显式指定 serialVersionUID 的值。因为不同的 jdk 编译很可能会生成不同的 serialVersionUID 默认值，从而导致在反序列化时抛出 InvalidClassExceptions 异常。\n\nserialVersionUID 字段必须是 static final long 类型。\n\n我们来举个例子：\n\n（1）有一个可序列化类 Person\n\npublic class Person implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String name;\n    private Integer age;\n    private String address;\n    // 构造方法、get、set 方法略\n}\n\n\n（2）开发过程中，对 Person 做了修改，增加了一个字段 email，如下：\n\npublic class Person implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String name;\n    private Integer age;\n    private String address;\n    private String email;\n    // 构造方法、get、set 方法略\n}\n\n\n由于这个类和老版本不兼容，我们需要修改版本号：\n\nprivate static final long serialVersionUID = 2L;\n\n\n再次进行反序列化，则会抛出 InvalidClassException 异常。\n\n综上所述，我们大概可以清楚：serialVersionUID 用于控制序列化版本是否兼容。若我们认为修改的可序列化类是向后兼容的，则不修改 serialVersionUID。\n\n\n# 默认序列化机制\n\n如果仅仅只是让某个类实现 Serializable 接口，而没有其它任何处理的话，那么就会使用默认序列化机制。\n\n使用默认机制，在序列化对象时，不仅会序列化当前对象本身，还会对其父类的字段以及该对象引用的其它对象也进行序列化。同样地，这些其它对象引用的另外对象也将被序列化，以此类推。所以，如果一个对象包含的成员变量是容器类对象，而这些容器所含有的元素也是容器类对象，那么这个序列化的过程就会较复杂，开销也较大。\n\n> 🔔 注意：这里的父类和引用对象既然要进行序列化，那么它们当然也要满足序列化要求：被序列化的类必须属于 Enum、Array 和 Serializable 类型其中的任何一种。\n\n\n# transient\n\n在现实应用中，有些时候不能使用默认序列化机制。比如，希望在序列化过程中忽略掉敏感数据，或者简化序列化过程。下面将介绍若干影响序列化的方法。\n\n当某个字段被声明为 transient 后，默认序列化机制就会忽略该字段的内容,该字段的内容在序列化后无法获得访问。\n\n我们将 SerializeDemo01 示例中的内部类 Person 的 age 字段声明为 transient，如下所示：\n\npublic class SerializeDemo02 {\n    static class Person implements Serializable {\n        transient private Integer age = null;\n        // 其他内容略\n    }\n    // 其他内容略\n}\n// Output:\n// name: Jack, age: null, sex: MALE\n\n\n从输出结果可以看出，age 字段没有被序列化。\n\n\n# Externalizable 接口\n\n无论是使用 transient 关键字，还是使用 writeObject() 和 readObject() 方法，其实都是基于 Serializable 接口的序列化。\n\nJDK 中提供了另一个序列化接口--Externalizable。\n\n可序列化类实现 Externalizable 接口之后，基于 Serializable 接口的默认序列化机制就会失效。\n\n我们来基于 SerializeDemo02 再次做一些改动，代码如下：\n\npublic class ExternalizeDemo01 {\n    static class Person implements Externalizable {\n        transient private Integer age = null;\n        // 其他内容略\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.defaultWriteObject();\n            out.writeInt(age);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n            in.defaultReadObject();\n            age = in.readInt();\n        }\n\n        @Override\n        public void writeExternal(ObjectOutput out) throws IOException { }\n\n        @Override\n        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { }\n    }\n     // 其他内容略\n}\n// Output:\n// call Person()\n// name: null, age: null, sex: null\n\n\n从该结果，一方面可以看出 Person 对象中任何一个字段都没有被序列化。另一方面，如果细心的话，还可以发现这此次序列化过程调用了 Person 类的无参构造方法。\n\n * Externalizable 继承于 Serializable，它增添了两个方法：writeExternal() 与 readExternal()。这两个方法在序列化和反序列化过程中会被自动调用，以便执行一些特殊操作。当使用该接口时，序列化的细节需要由程序员去完成。如上所示的代码，由于 writeExternal() 与 readExternal() 方法未作任何处理，那么该序列化行为将不会保存/读取任何一个字段。这也就是为什么输出结果中所有字段的值均为空。\n * 另外，若使用 Externalizable 进行序列化，当读取对象时，会调用被序列化类的无参构造方法去创建一个新的对象；然后再将被保存对象的字段的值分别填充到新对象中。这就是为什么在此次序列化过程中 Person 类的无参构造方法会被调用。由于这个原因，实现 Externalizable 接口的类必须要提供一个无参的构造方法，且它的访问权限为 public。\n\n对上述 Person 类作进一步的修改，使其能够对 name 与 age 字段进行序列化，但要忽略掉 gender 字段，如下代码所示：\n\npublic class ExternalizeDemo02 {\n    static class Person implements Externalizable {\n        transient private Integer age = null;\n        // 其他内容略\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.defaultWriteObject();\n            out.writeInt(age);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n            in.defaultReadObject();\n            age = in.readInt();\n        }\n\n        @Override\n        public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject(name);\n            out.writeInt(age);\n        }\n\n        @Override\n        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n            name = (String) in.readObject();\n            age = in.readInt();\n        }\n    }\n     // 其他内容略\n}\n// Output:\n// call Person()\n// name: Jack, age: 30, sex: null\n\n\n\n# Externalizable 接口的替代方法\n\n实现 Externalizable 接口可以控制序列化和反序列化的细节。它有一个替代方法：实现 Serializable 接口，并添加 writeObject(ObjectOutputStream out) 与 readObject(ObjectInputStream in) 方法。序列化和反序列化过程中会自动回调这两个方法。\n\n示例如下所示：\n\npublic class SerializeDemo03 {\n    static class Person implements Serializable {\n        transient private Integer age = null;\n        // 其他内容略\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.defaultWriteObject();\n            out.writeInt(age);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n            in.defaultReadObject();\n            age = in.readInt();\n        }\n        // 其他内容略\n    }\n    // 其他内容略\n}\n// Output:\n// name: Jack, age: 30, sex: MALE\n\n\n在 writeObject() 方法中会先调用 ObjectOutputStream 中的 defaultWriteObject() 方法，该方法会执行默认的序列化机制，如上节所述，此时会忽略掉 age 字段。然后再调用 writeInt() 方法显示地将 age 字段写入到 ObjectOutputStream 中。readObject() 的作用则是针对对象的读取，其原理与 writeObject() 方法相同。\n\n> 🔔 注意：writeObject() 与 readObject() 都是 private 方法，那么它们是如何被调用的呢？毫无疑问，是使用反射。详情可见 ObjectOutputStream 中的 writeSerialData 方法，以及 ObjectInputStream 中的 readSerialData 方法。\n\n\n# readResolve() 方法\n\n当我们使用 Singleton 模式时，应该是期望某个类的实例应该是唯一的，但如果该类是可序列化的，那么情况可能会略有不同。此时对第 2 节使用的 Person 类进行修改，使其实现 Singleton 模式，如下所示：\n\npublic class SerializeDemo04 {\n\n    enum Sex {\n        MALE, FEMALE\n    }\n\n    static class Person implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private String name = null;\n        transient private Integer age = null;\n        private Sex sex;\n        static final Person instatnce = new Person("Tom", 31, Sex.MALE);\n\n        private Person() {\n            System.out.println("call Person()");\n        }\n\n        private Person(String name, Integer age, Sex sex) {\n            this.name = name;\n            this.age = age;\n            this.sex = sex;\n        }\n\n        public static Person getInstance() {\n            return instatnce;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.defaultWriteObject();\n            out.writeInt(age);\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n            in.defaultReadObject();\n            age = in.readInt();\n        }\n\n        public String toString() {\n            return "name: " + this.name + ", age: " + this.age + ", sex: " + this.sex;\n        }\n    }\n\n    /**\n     * 序列化\n     */\n    private static void serialize(String filename) throws IOException {\n        File f = new File(filename); // 定义保存路径\n        OutputStream out = new FileOutputStream(f); // 文件输出流\n        ObjectOutputStream oos = new ObjectOutputStream(out); // 对象输出流\n        oos.writeObject(new Person("Jack", 30, Sex.MALE)); // 保存对象\n        oos.close();\n        out.close();\n    }\n\n    /**\n     * 反序列化\n     */\n    private static void deserialize(String filename) throws IOException, ClassNotFoundException {\n        File f = new File(filename); // 定义保存路径\n        InputStream in = new FileInputStream(f); // 文件输入流\n        ObjectInputStream ois = new ObjectInputStream(in); // 对象输入流\n        Object obj = ois.readObject(); // 读取对象\n        ois.close();\n        in.close();\n        System.out.println(obj);\n        System.out.println(obj == Person.getInstance());\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        final String filename = "d:/text.dat";\n        serialize(filename);\n        deserialize(filename);\n    }\n}\n// Output:\n// name: Jack, age: null, sex: MALE\n// false\n\n\n值得注意的是，从文件中获取的 Person 对象与 Person 类中的单例对象并不相等。为了能在单例类中仍然保持序列的特性，可以使用 readResolve() 方法。在该方法中直接返回 Person 的单例对象。我们在 SerializeDemo04 示例的基础上添加一个 readResolve 方法， 如下所示：\n\npublic class SerializeDemo05 {\n    // 其他内容略\n\n    static class Person implements Serializable {\n\n        // private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        //     in.defaultReadObject();\n        //     age = in.readInt();\n        // }\n\n        // 添加此方法\n        private Object readResolve() {\n            return instatnce;\n        }\n        // 其他内容略\n    }\n\n    // 其他内容略\n}\n// Output:\n// name: Tom, age: 31, sex: MALE\n// true\n\n\n\n# Java 序列化问题\n\nJava 的序列化能保证对象状态的持久保存，但是遇到一些对象结构复杂的情况还是难以处理，这里归纳一下：\n\n * 父类是 Serializable，所有子类都可以被序列化。\n * 子类是 Serializable ，父类不是，则子类可以正确序列化，但父类的属性不会被序列化（不报错，数据丢失）。\n * 如果序列化的属性是对象，则这个对象也必须是 Serializable ，否则报错。\n * 反序列化时，如果对象的属性有修改或删减，则修改的部分属性会丢失，但不会报错。\n * 反序列化时，如果 serialVersionUID 被修改，则反序列化会失败。\n\n\n# Java 序列化的缺陷\n\n * 无法跨语言：Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化。\n * 容易被攻击：对象是通过在 ObjectInputStream 上调用 readObject() 方法进行反序列化的，它可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化。这意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的。对于需要长时间进行反序列化的对象，不需要执行任何代码，也可以发起一次攻击。攻击者可以创建循环对象链，然后将序列化后的对象传输到程序中反序列化，这种情况会导致 hashCode 方法被调用次数呈次方爆发式增长, 从而引发栈溢出异常。例如下面这个案例就可以很好地说明。\n * 序列化后的流太大：Java 序列化中使用了 ObjectOutputStream 来实现对象转二进制编码，编码后的数组很大，非常影响存储和传输效率。\n * 序列化性能太差：Java 的序列化耗时比较大。序列化的速度也是体现序列化性能的重要指标，如果序列化的速度慢，就会影响网络通信的效率，从而增加系统的响应时间。\n * 序列化编程限制：\n   * Java 官方的序列化一定需要实现 Serializable 接口。\n   * Java 官方的序列化需要关注 serialVersionUID。\n\n\n# 序列化技术选型\n\n通过上一章节——Java 序列化的缺陷，我们了解到，Java 序列化方式存在许多缺陷。因此，建议使用第三方序列化工具来替代。\n\n当然我们还有更加优秀的一些序列化和反序列化的工具，根据不同的使用场景可以自行选择！\n\n * thrift、protobuf - 适用于对性能敏感，对开发体验要求不高。\n * hessian - 适用于对开发体验敏感，性能有要求。\n * jackson、gson、fastjson - 适用于对序列化后的数据要求有良好的可读性（转为 json 、xml 形式）。\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * 《Java 性能调优实战》\n * Java 序列化的高级认识\n * http://www.hollischuang.com/archives/1140\n * http://www.codenuclear.com/serialization-deserialization-java/\n * http://www.blogjava.net/jiangshachina/archive/2012/02/13/369898.html\n * https://agapple.iteye.com/blog/859052',normalizedContent:'# 深入理解 java 序列化\n\n> 关键词：serializable、serialversionuid、transient、externalizable、writeobject、readobject\n\n\n\n\n# java 序列化简介\n\n\n\n * 序列化（serialize） - 序列化是将对象转换为字节流。\n * 反序列化（deserialize） - 反序列化是将字节流转换为对象。\n * 序列化用途\n   * 序列化可以将对象的字节序列持久化——保存在内存、文件、数据库中。\n   * 在网络上传送对象的字节序列。\n   * rmi(远程方法调用)\n\n> 🔔 注意：使用 java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。\n\n\n# java 序列化和反序列化\n\njava 通过对象输入输出流来实现序列化和反序列化：\n\n * java.io.objectoutputstream 类的 writeobject() 方法可以实现序列化；\n * java.io.objectinputstream 类的 readobject() 方法用于实现反序列化。\n\n序列化和反序列化示例：\n\npublic class serializedemo01 {\n    enum sex {\n        male,\n        female\n    }\n\n\n    static class person implements serializable {\n        private static final long serialversionuid = 1l;\n        private string name = null;\n        private integer age = null;\n        private sex sex;\n\n        public person() { }\n\n        public person(string name, integer age, sex sex) {\n            this.name = name;\n            this.age = age;\n            this.sex = sex;\n        }\n\n        @override\n        public string tostring() {\n            return "person{" + "name=\'" + name + \'\\\'\' + ", age=" + age + ", sex=" + sex + \'}\';\n        }\n    }\n\n    /**\n     * 序列化\n     */\n    private static void serialize(string filename) throws ioexception {\n        file f = new file(filename); // 定义保存路径\n        outputstream out = new fileoutputstream(f); // 文件输出流\n        objectoutputstream oos = new objectoutputstream(out); // 对象输出流\n        oos.writeobject(new person("jack", 30, sex.male)); // 保存对象\n        oos.close();\n        out.close();\n    }\n\n    /**\n     * 反序列化\n     */\n    private static void deserialize(string filename) throws ioexception, classnotfoundexception {\n        file f = new file(filename); // 定义保存路径\n        inputstream in = new fileinputstream(f); // 文件输入流\n        objectinputstream ois = new objectinputstream(in); // 对象输入流\n        object obj = ois.readobject(); // 读取对象\n        ois.close();\n        in.close();\n        system.out.println(obj);\n    }\n\n    public static void main(string[] args) throws ioexception, classnotfoundexception {\n        final string filename = "d:/text.dat";\n        serialize(filename);\n        deserialize(filename);\n    }\n}\n// output:\n// person{name=\'jack\', age=30, sex=male}\n\n\n\n# serializable 接口\n\n被序列化的类必须属于 enum、array 和 serializable 类型其中的任何一种，否则将抛出 notserializableexception 异常。这是因为：在序列化操作过程中会对类型进行检查，如果不满足序列化类型要求，就会抛出异常。\n\n【示例】notserializableexception 错误\n\npublic class unserializedemo {\n    static class person { // 其他内容略 }\n    // 其他内容略\n}\n\n\n输出：结果就是出现如下异常信息。\n\nexception in thread "main" java.io.notserializableexception:\n...\n\n\n\n# serialversionuid\n\n请注意 serialversionuid 字段，你可以在 java 世界的无数类中看到这个字段。\n\nserialversionuid 有什么作用，如何使用 serialversionuid？\n\nserialversionuid 是 java 为每个序列化类产生的版本标识。它可以用来保证在反序列时，发送方发送的和接受方接收的是可兼容的对象。如果接收方接收的类的 serialversionuid 与发送方发送的 serialversionuid 不一致，会抛出 invalidclassexception。\n\n如果可序列化类没有显式声明 serialversionuid，则序列化运行时将基于该类的各个方面计算该类的默认 serialversionuid 值。尽管这样，还是建议在每一个序列化的类中显式指定 serialversionuid 的值。因为不同的 jdk 编译很可能会生成不同的 serialversionuid 默认值，从而导致在反序列化时抛出 invalidclassexceptions 异常。\n\nserialversionuid 字段必须是 static final long 类型。\n\n我们来举个例子：\n\n（1）有一个可序列化类 person\n\npublic class person implements serializable {\n    private static final long serialversionuid = 1l;\n    private string name;\n    private integer age;\n    private string address;\n    // 构造方法、get、set 方法略\n}\n\n\n（2）开发过程中，对 person 做了修改，增加了一个字段 email，如下：\n\npublic class person implements serializable {\n    private static final long serialversionuid = 1l;\n    private string name;\n    private integer age;\n    private string address;\n    private string email;\n    // 构造方法、get、set 方法略\n}\n\n\n由于这个类和老版本不兼容，我们需要修改版本号：\n\nprivate static final long serialversionuid = 2l;\n\n\n再次进行反序列化，则会抛出 invalidclassexception 异常。\n\n综上所述，我们大概可以清楚：serialversionuid 用于控制序列化版本是否兼容。若我们认为修改的可序列化类是向后兼容的，则不修改 serialversionuid。\n\n\n# 默认序列化机制\n\n如果仅仅只是让某个类实现 serializable 接口，而没有其它任何处理的话，那么就会使用默认序列化机制。\n\n使用默认机制，在序列化对象时，不仅会序列化当前对象本身，还会对其父类的字段以及该对象引用的其它对象也进行序列化。同样地，这些其它对象引用的另外对象也将被序列化，以此类推。所以，如果一个对象包含的成员变量是容器类对象，而这些容器所含有的元素也是容器类对象，那么这个序列化的过程就会较复杂，开销也较大。\n\n> 🔔 注意：这里的父类和引用对象既然要进行序列化，那么它们当然也要满足序列化要求：被序列化的类必须属于 enum、array 和 serializable 类型其中的任何一种。\n\n\n# transient\n\n在现实应用中，有些时候不能使用默认序列化机制。比如，希望在序列化过程中忽略掉敏感数据，或者简化序列化过程。下面将介绍若干影响序列化的方法。\n\n当某个字段被声明为 transient 后，默认序列化机制就会忽略该字段的内容,该字段的内容在序列化后无法获得访问。\n\n我们将 serializedemo01 示例中的内部类 person 的 age 字段声明为 transient，如下所示：\n\npublic class serializedemo02 {\n    static class person implements serializable {\n        transient private integer age = null;\n        // 其他内容略\n    }\n    // 其他内容略\n}\n// output:\n// name: jack, age: null, sex: male\n\n\n从输出结果可以看出，age 字段没有被序列化。\n\n\n# externalizable 接口\n\n无论是使用 transient 关键字，还是使用 writeobject() 和 readobject() 方法，其实都是基于 serializable 接口的序列化。\n\njdk 中提供了另一个序列化接口--externalizable。\n\n可序列化类实现 externalizable 接口之后，基于 serializable 接口的默认序列化机制就会失效。\n\n我们来基于 serializedemo02 再次做一些改动，代码如下：\n\npublic class externalizedemo01 {\n    static class person implements externalizable {\n        transient private integer age = null;\n        // 其他内容略\n\n        private void writeobject(objectoutputstream out) throws ioexception {\n            out.defaultwriteobject();\n            out.writeint(age);\n        }\n\n        private void readobject(objectinputstream in) throws ioexception, classnotfoundexception {\n            in.defaultreadobject();\n            age = in.readint();\n        }\n\n        @override\n        public void writeexternal(objectoutput out) throws ioexception { }\n\n        @override\n        public void readexternal(objectinput in) throws ioexception, classnotfoundexception { }\n    }\n     // 其他内容略\n}\n// output:\n// call person()\n// name: null, age: null, sex: null\n\n\n从该结果，一方面可以看出 person 对象中任何一个字段都没有被序列化。另一方面，如果细心的话，还可以发现这此次序列化过程调用了 person 类的无参构造方法。\n\n * externalizable 继承于 serializable，它增添了两个方法：writeexternal() 与 readexternal()。这两个方法在序列化和反序列化过程中会被自动调用，以便执行一些特殊操作。当使用该接口时，序列化的细节需要由程序员去完成。如上所示的代码，由于 writeexternal() 与 readexternal() 方法未作任何处理，那么该序列化行为将不会保存/读取任何一个字段。这也就是为什么输出结果中所有字段的值均为空。\n * 另外，若使用 externalizable 进行序列化，当读取对象时，会调用被序列化类的无参构造方法去创建一个新的对象；然后再将被保存对象的字段的值分别填充到新对象中。这就是为什么在此次序列化过程中 person 类的无参构造方法会被调用。由于这个原因，实现 externalizable 接口的类必须要提供一个无参的构造方法，且它的访问权限为 public。\n\n对上述 person 类作进一步的修改，使其能够对 name 与 age 字段进行序列化，但要忽略掉 gender 字段，如下代码所示：\n\npublic class externalizedemo02 {\n    static class person implements externalizable {\n        transient private integer age = null;\n        // 其他内容略\n\n        private void writeobject(objectoutputstream out) throws ioexception {\n            out.defaultwriteobject();\n            out.writeint(age);\n        }\n\n        private void readobject(objectinputstream in) throws ioexception, classnotfoundexception {\n            in.defaultreadobject();\n            age = in.readint();\n        }\n\n        @override\n        public void writeexternal(objectoutput out) throws ioexception {\n            out.writeobject(name);\n            out.writeint(age);\n        }\n\n        @override\n        public void readexternal(objectinput in) throws ioexception, classnotfoundexception {\n            name = (string) in.readobject();\n            age = in.readint();\n        }\n    }\n     // 其他内容略\n}\n// output:\n// call person()\n// name: jack, age: 30, sex: null\n\n\n\n# externalizable 接口的替代方法\n\n实现 externalizable 接口可以控制序列化和反序列化的细节。它有一个替代方法：实现 serializable 接口，并添加 writeobject(objectoutputstream out) 与 readobject(objectinputstream in) 方法。序列化和反序列化过程中会自动回调这两个方法。\n\n示例如下所示：\n\npublic class serializedemo03 {\n    static class person implements serializable {\n        transient private integer age = null;\n        // 其他内容略\n\n        private void writeobject(objectoutputstream out) throws ioexception {\n            out.defaultwriteobject();\n            out.writeint(age);\n        }\n\n        private void readobject(objectinputstream in) throws ioexception, classnotfoundexception {\n            in.defaultreadobject();\n            age = in.readint();\n        }\n        // 其他内容略\n    }\n    // 其他内容略\n}\n// output:\n// name: jack, age: 30, sex: male\n\n\n在 writeobject() 方法中会先调用 objectoutputstream 中的 defaultwriteobject() 方法，该方法会执行默认的序列化机制，如上节所述，此时会忽略掉 age 字段。然后再调用 writeint() 方法显示地将 age 字段写入到 objectoutputstream 中。readobject() 的作用则是针对对象的读取，其原理与 writeobject() 方法相同。\n\n> 🔔 注意：writeobject() 与 readobject() 都是 private 方法，那么它们是如何被调用的呢？毫无疑问，是使用反射。详情可见 objectoutputstream 中的 writeserialdata 方法，以及 objectinputstream 中的 readserialdata 方法。\n\n\n# readresolve() 方法\n\n当我们使用 singleton 模式时，应该是期望某个类的实例应该是唯一的，但如果该类是可序列化的，那么情况可能会略有不同。此时对第 2 节使用的 person 类进行修改，使其实现 singleton 模式，如下所示：\n\npublic class serializedemo04 {\n\n    enum sex {\n        male, female\n    }\n\n    static class person implements serializable {\n        private static final long serialversionuid = 1l;\n        private string name = null;\n        transient private integer age = null;\n        private sex sex;\n        static final person instatnce = new person("tom", 31, sex.male);\n\n        private person() {\n            system.out.println("call person()");\n        }\n\n        private person(string name, integer age, sex sex) {\n            this.name = name;\n            this.age = age;\n            this.sex = sex;\n        }\n\n        public static person getinstance() {\n            return instatnce;\n        }\n\n        private void writeobject(objectoutputstream out) throws ioexception {\n            out.defaultwriteobject();\n            out.writeint(age);\n        }\n\n        private void readobject(objectinputstream in) throws ioexception, classnotfoundexception {\n            in.defaultreadobject();\n            age = in.readint();\n        }\n\n        public string tostring() {\n            return "name: " + this.name + ", age: " + this.age + ", sex: " + this.sex;\n        }\n    }\n\n    /**\n     * 序列化\n     */\n    private static void serialize(string filename) throws ioexception {\n        file f = new file(filename); // 定义保存路径\n        outputstream out = new fileoutputstream(f); // 文件输出流\n        objectoutputstream oos = new objectoutputstream(out); // 对象输出流\n        oos.writeobject(new person("jack", 30, sex.male)); // 保存对象\n        oos.close();\n        out.close();\n    }\n\n    /**\n     * 反序列化\n     */\n    private static void deserialize(string filename) throws ioexception, classnotfoundexception {\n        file f = new file(filename); // 定义保存路径\n        inputstream in = new fileinputstream(f); // 文件输入流\n        objectinputstream ois = new objectinputstream(in); // 对象输入流\n        object obj = ois.readobject(); // 读取对象\n        ois.close();\n        in.close();\n        system.out.println(obj);\n        system.out.println(obj == person.getinstance());\n    }\n\n    public static void main(string[] args) throws ioexception, classnotfoundexception {\n        final string filename = "d:/text.dat";\n        serialize(filename);\n        deserialize(filename);\n    }\n}\n// output:\n// name: jack, age: null, sex: male\n// false\n\n\n值得注意的是，从文件中获取的 person 对象与 person 类中的单例对象并不相等。为了能在单例类中仍然保持序列的特性，可以使用 readresolve() 方法。在该方法中直接返回 person 的单例对象。我们在 serializedemo04 示例的基础上添加一个 readresolve 方法， 如下所示：\n\npublic class serializedemo05 {\n    // 其他内容略\n\n    static class person implements serializable {\n\n        // private void readobject(objectinputstream in) throws ioexception, classnotfoundexception {\n        //     in.defaultreadobject();\n        //     age = in.readint();\n        // }\n\n        // 添加此方法\n        private object readresolve() {\n            return instatnce;\n        }\n        // 其他内容略\n    }\n\n    // 其他内容略\n}\n// output:\n// name: tom, age: 31, sex: male\n// true\n\n\n\n# java 序列化问题\n\njava 的序列化能保证对象状态的持久保存，但是遇到一些对象结构复杂的情况还是难以处理，这里归纳一下：\n\n * 父类是 serializable，所有子类都可以被序列化。\n * 子类是 serializable ，父类不是，则子类可以正确序列化，但父类的属性不会被序列化（不报错，数据丢失）。\n * 如果序列化的属性是对象，则这个对象也必须是 serializable ，否则报错。\n * 反序列化时，如果对象的属性有修改或删减，则修改的部分属性会丢失，但不会报错。\n * 反序列化时，如果 serialversionuid 被修改，则反序列化会失败。\n\n\n# java 序列化的缺陷\n\n * 无法跨语言：java 序列化目前只适用基于 java 语言实现的框架，其它语言大部分都没有使用 java 的序列化框架，也没有实现 java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化。\n * 容易被攻击：对象是通过在 objectinputstream 上调用 readobject() 方法进行反序列化的，它可以将类路径上几乎所有实现了 serializable 接口的对象都实例化。这意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的。对于需要长时间进行反序列化的对象，不需要执行任何代码，也可以发起一次攻击。攻击者可以创建循环对象链，然后将序列化后的对象传输到程序中反序列化，这种情况会导致 hashcode 方法被调用次数呈次方爆发式增长, 从而引发栈溢出异常。例如下面这个案例就可以很好地说明。\n * 序列化后的流太大：java 序列化中使用了 objectoutputstream 来实现对象转二进制编码，编码后的数组很大，非常影响存储和传输效率。\n * 序列化性能太差：java 的序列化耗时比较大。序列化的速度也是体现序列化性能的重要指标，如果序列化的速度慢，就会影响网络通信的效率，从而增加系统的响应时间。\n * 序列化编程限制：\n   * java 官方的序列化一定需要实现 serializable 接口。\n   * java 官方的序列化需要关注 serialversionuid。\n\n\n# 序列化技术选型\n\n通过上一章节——java 序列化的缺陷，我们了解到，java 序列化方式存在许多缺陷。因此，建议使用第三方序列化工具来替代。\n\n当然我们还有更加优秀的一些序列化和反序列化的工具，根据不同的使用场景可以自行选择！\n\n * thrift、protobuf - 适用于对性能敏感，对开发体验要求不高。\n * hessian - 适用于对开发体验敏感，性能有要求。\n * jackson、gson、fastjson - 适用于对序列化后的数据要求有良好的可读性（转为 json 、xml 形式）。\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * 《java 性能调优实战》\n * java 序列化的高级认识\n * http://www.hollischuang.com/archives/1140\n * http://www.codenuclear.com/serialization-deserialization-java/\n * http://www.blogjava.net/jiangshachina/archive/2012/02/13/369898.html\n * https://agapple.iteye.com/blog/859052',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 网络编程",frontmatter:{title:"Java 网络编程",categories:["编程","Java","JavaSE","IO"],tags:["Java","JavaSE","IO","网络"],abbrlink:"3a3aa666",date:"2020-02-19T18:54:21.000Z",permalink:"/pages/e70be2/"},regularPath:"/04.IO/04.Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html",relativePath:"04.IO/04.Java网络编程.md",key:"v-ca7e680c",path:"/pages/e70be2/",headers:[{level:2,title:"Socket 和 ServerSocket",slug:"socket-和-serversocket",normalizedTitle:"socket 和 serversocket",charIndex:340},{level:3,title:"ServerSocket",slug:"serversocket",normalizedTitle:"serversocket",charIndex:26},{level:4,title:"ServerSocket 构造方法",slug:"serversocket-构造方法",normalizedTitle:"serversocket 构造方法",charIndex:1119},{level:4,title:"ServerSocket 常用方法",slug:"serversocket-常用方法",normalizedTitle:"serversocket 常用方法",charIndex:1571},{level:3,title:"Socket",slug:"socket",normalizedTitle:"socket",charIndex:19},{level:4,title:"Socket 构造方法",slug:"socket-构造方法",normalizedTitle:"socket 构造方法",charIndex:1125},{level:4,title:"Socket 常用方法",slug:"socket-常用方法",normalizedTitle:"socket 常用方法",charIndex:1577},{level:3,title:"Socket 通信示例",slug:"socket-通信示例",normalizedTitle:"socket 通信示例",charIndex:3432},{level:2,title:"DatagramSocket 和 DatagramPacket",slug:"datagramsocket-和-datagrampacket",normalizedTitle:"datagramsocket 和 datagrampacket",charIndex:4520},{level:2,title:"InetAddress",slug:"inetaddress",normalizedTitle:"inetaddress",charIndex:1505},{level:2,title:"URL",slug:"url",normalizedTitle:"url",charIndex:5825},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6286}],headersStr:"Socket 和 ServerSocket ServerSocket ServerSocket 构造方法 ServerSocket 常用方法 Socket Socket 构造方法 Socket 常用方法 Socket 通信示例 DatagramSocket 和 DatagramPacket InetAddress URL 参考资料",content:'# Java 网络编程\n\n> 关键词：Socket、ServerSocket、DatagramPacket、DatagramSocket\n> \n> 网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。\n> \n> java.net 包中提供了低层次的网络通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。\n> \n> java.net 包中提供了两种常见的网络协议的支持：\n> \n>  * TCP - TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP/ IP。\n>  * UDP - UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。\n\n\n# Socket 和 ServerSocket\n\n套接字（Socket）使用 TCP 提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。\n\nJava 通过 Socket 和 ServerSocket 实现对 TCP 的支持。Java 中的 Socket 通信可以简单理解为：java.net.Socket 代表客户端，java.net.ServerSocket 代表服务端，二者可以建立连接，然后通信。\n\n以下为 Socket 通信中建立建立的基本流程：\n\n * 服务器实例化一个 ServerSocket 对象，表示服务器绑定一个端口。\n * 服务器调用 ServerSocket 的 accept() 方法，该方法将一直等待，直到客户端连接到服务器的绑定端口（即监听端口）。\n * 服务器监听端口时，客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。\n * Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。\n * 在服务器端，accept() 方法返回服务器上一个新的 Socket 引用，该引用连接到客户端的 Socket 。\n\n连接建立后，可以通过使用 IO 流进行通信。每一个 Socket 都有一个输出流和一个输入流。客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。\n\nTCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送，以下是一些类提供的一套完整的有用的方法来实现 sockets。\n\n\n# ServerSocket\n\n服务器程序通过使用 java.net.ServerSocket 类以获取一个端口，并且监听客户端请求连接此端口的请求。\n\n# ServerSocket 构造方法\n\nServerSocket 有多个构造方法：\n\n方法                                                         描述\nServerSocket()                                             创建非绑定服务器套接字。\nServerSocket(int port)                                     创建绑定到特定端口的服务器套接字。\nServerSocket(int port, int backlog)                        利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。\nServerSocket(int port, int backlog, InetAddress address)   使用指定的端口、监听 backlog 和要绑定到的本地 IP 地址创建服务器。\n\n# ServerSocket 常用方法\n\n创建非绑定服务器套接字。 如果 ServerSocket 构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。\n\n这里有一些 ServerSocket 类的常用方法：\n\n方法                                           描述\nint getLocalPort()                           返回此套接字在其上侦听的端口。\nSocket accept()                              监听并接受到此套接字的连接。\nvoid setSoTimeout(int timeout)               通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。\nvoid bind(SocketAddress host, int backlog)   将 ServerSocket 绑定到特定地址（IP 地址和端口号）。\n\n\n# Socket\n\njava.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法 a 的返回值。\n\n# Socket 构造方法\n\nSocket 类有 5 个构造方法：\n\n方法                                                             描述\nSocket()                                                       通过系统默认类型的 SocketImpl 创建未连接套接字\nSocket(String host, int port)                                  创建一个流套接字并将其连接到指定主机上的指定端口号。\nSocket(InetAddress host, int port)                             创建一个流套接字并将其连接到指定 IP 地址的指定端口号。\nSocket(String host, int port, InetAddress localAddress, int    创建一个套接字并将其连接到指定远程主机上的指定远程端口。\nlocalPort)\nSocket(InetAddress host, int port, InetAddress localAddress,   创建一个套接字并将其连接到指定远程地址上的指定远程端口。\nint localPort)\n\n当 Socket 构造方法返回，并没有简单的实例化了一个 Socket 对象，它实际上会尝试连接到指定的服务器和端口。\n\n# Socket 常用方法\n\n下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个 Socket 对象，所以无论客户端还是服务端都能够调用这些方法。\n\n方法                                              描述\nvoid connect(SocketAddress host, int timeout)   将此套接字连接到服务器，并指定一个超时值。\nInetAddress getInetAddress()                    返回套接字连接的地址。\nint getPort()                                   返回此套接字连接到的远程端口。\nint getLocalPort()                              返回此套接字绑定到的本地端口。\nSocketAddress getRemoteSocketAddress()          返回此套接字连接的端点的地址，如果未连接则返回 null。\nInputStream getInputStream()                    返回此套接字的输入流。\nOutputStream getOutputStream()                  返回此套接字的输出流。\nvoid close()                                    关闭此套接字。\n\n\n# Socket 通信示例\n\n服务端示例：\n\npublic class HelloServer {\n\n    public static void main(String[] args) throws Exception {\n        // Socket 服务端\n        // 服务器在8888端口上监听\n        ServerSocket server = new ServerSocket(8888);\n        System.out.println("服务器运行中，等待客户端连接。");\n        // 得到连接，程序进入到阻塞状态\n        Socket client = server.accept();\n        // 打印流输出最方便\n        PrintStream out = new PrintStream(client.getOutputStream());\n        // 向客户端输出信息\n        out.println("hello world");\n        client.close();\n        server.close();\n        System.out.println("服务器已向客户端发送消息，退出。");\n    }\n\n}\n\n\n客户端示例：\n\npublic class HelloClient {\n\n    public static void main(String[] args) throws Exception {\n        // Socket 客户端\n        Socket client = new Socket("localhost", 8888);\n        InputStreamReader inputStreamReader = new InputStreamReader(client.getInputStream());\n        // 一次性接收完成\n        BufferedReader buf = new BufferedReader(inputStreamReader);\n        String str = buf.readLine();\n        buf.close();\n        client.close();\n        System.out.println("客户端接收到服务器消息：" + str + "，退出");\n    }\n\n}\n\n\n\n# DatagramSocket 和 DatagramPacket\n\nJava 通过 DatagramSocket 和 DatagramPacket 实现对 UDP 协议的支持。\n\n * DatagramPacket：数据包类\n * DatagramSocket：通信类\n\nUDP 服务端示例：\n\npublic class UDPServer {\n\n    public static void main(String[] args) throws Exception { // 所有异常抛出\n        String str = "hello World!!!";\n        DatagramSocket ds = new DatagramSocket(3000); // 服务端在3000端口上等待服务器发送信息\n        DatagramPacket dp =\n            new DatagramPacket(str.getBytes(), str.length(), InetAddress.getByName("localhost"), 9000); // 所有的信息使用buf保存\n        System.out.println("发送信息。");\n        ds.send(dp); // 发送信息出去\n        ds.close();\n    }\n\n}\n\n\nUDP 客户端示例：\n\npublic class UDPClient {\n\n    public static void main(String[] args) throws Exception { // 所有异常抛出\n        byte[] buf = new byte[1024]; // 开辟空间，以接收数据\n        DatagramSocket ds = new DatagramSocket(9000); // 客户端在9000端口上等待服务器发送信息\n        DatagramPacket dp = new DatagramPacket(buf, 1024); // 所有的信息使用buf保存\n        ds.receive(dp); // 接收数据\n        String str = new String(dp.getData(), 0, dp.getLength()) + "from " + dp.getAddress().getHostAddress() + "："\n            + dp.getPort();\n        System.out.println(str); // 输出内容\n    }\n\n}\n\n\n\n# InetAddress\n\nInetAddress 类表示互联网协议(IP)地址。\n\n没有公有的构造函数，只能通过静态方法来创建实例。\n\nInetAddress.getByName(String host);\nInetAddress.getByAddress(byte[] address);\n\n\n\n# URL\n\n可以直接从 URL 中读取字节流数据。\n\npublic static void main(String[] args) throws IOException {\n\n    URL url = new URL("http://www.baidu.com");\n\n    /* 字节流 */\n    InputStream is = url.openStream();\n\n    /* 字符流 */\n    InputStreamReader isr = new InputStreamReader(is, "utf-8");\n\n    /* 提供缓存功能 */\n    BufferedReader br = new BufferedReader(isr);\n\n    String line;\n    while ((line = br.readLine()) != null) {\n        System.out.println(line);\n    }\n\n    br.close();\n}\n\n\n\n# 参考资料\n\n * Java 网络编程',normalizedContent:'# java 网络编程\n\n> 关键词：socket、serversocket、datagrampacket、datagramsocket\n> \n> 网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。\n> \n> java.net 包中提供了低层次的网络通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。\n> \n> java.net 包中提供了两种常见的网络协议的支持：\n> \n>  * tcp - tcp 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 tcp/ ip。\n>  * udp - udp 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。\n\n\n# socket 和 serversocket\n\n套接字（socket）使用 tcp 提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。\n\njava 通过 socket 和 serversocket 实现对 tcp 的支持。java 中的 socket 通信可以简单理解为：java.net.socket 代表客户端，java.net.serversocket 代表服务端，二者可以建立连接，然后通信。\n\n以下为 socket 通信中建立建立的基本流程：\n\n * 服务器实例化一个 serversocket 对象，表示服务器绑定一个端口。\n * 服务器调用 serversocket 的 accept() 方法，该方法将一直等待，直到客户端连接到服务器的绑定端口（即监听端口）。\n * 服务器监听端口时，客户端实例化一个 socket 对象，指定服务器名称和端口号来请求连接。\n * socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 socket 对象能够与服务器进行通信。\n * 在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该引用连接到客户端的 socket 。\n\n连接建立后，可以通过使用 io 流进行通信。每一个 socket 都有一个输出流和一个输入流。客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。\n\ntcp 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送，以下是一些类提供的一套完整的有用的方法来实现 sockets。\n\n\n# serversocket\n\n服务器程序通过使用 java.net.serversocket 类以获取一个端口，并且监听客户端请求连接此端口的请求。\n\n# serversocket 构造方法\n\nserversocket 有多个构造方法：\n\n方法                                                         描述\nserversocket()                                             创建非绑定服务器套接字。\nserversocket(int port)                                     创建绑定到特定端口的服务器套接字。\nserversocket(int port, int backlog)                        利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。\nserversocket(int port, int backlog, inetaddress address)   使用指定的端口、监听 backlog 和要绑定到的本地 ip 地址创建服务器。\n\n# serversocket 常用方法\n\n创建非绑定服务器套接字。 如果 serversocket 构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。\n\n这里有一些 serversocket 类的常用方法：\n\n方法                                           描述\nint getlocalport()                           返回此套接字在其上侦听的端口。\nsocket accept()                              监听并接受到此套接字的连接。\nvoid setsotimeout(int timeout)               通过指定超时值启用/禁用 so_timeout，以毫秒为单位。\nvoid bind(socketaddress host, int backlog)   将 serversocket 绑定到特定地址（ip 地址和端口号）。\n\n\n# socket\n\njava.net.socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 socket 对象通过实例化 ，而 服务器获得一个 socket 对象则通过 accept() 方法 a 的返回值。\n\n# socket 构造方法\n\nsocket 类有 5 个构造方法：\n\n方法                                                             描述\nsocket()                                                       通过系统默认类型的 socketimpl 创建未连接套接字\nsocket(string host, int port)                                  创建一个流套接字并将其连接到指定主机上的指定端口号。\nsocket(inetaddress host, int port)                             创建一个流套接字并将其连接到指定 ip 地址的指定端口号。\nsocket(string host, int port, inetaddress localaddress, int    创建一个套接字并将其连接到指定远程主机上的指定远程端口。\nlocalport)\nsocket(inetaddress host, int port, inetaddress localaddress,   创建一个套接字并将其连接到指定远程地址上的指定远程端口。\nint localport)\n\n当 socket 构造方法返回，并没有简单的实例化了一个 socket 对象，它实际上会尝试连接到指定的服务器和端口。\n\n# socket 常用方法\n\n下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个 socket 对象，所以无论客户端还是服务端都能够调用这些方法。\n\n方法                                              描述\nvoid connect(socketaddress host, int timeout)   将此套接字连接到服务器，并指定一个超时值。\ninetaddress getinetaddress()                    返回套接字连接的地址。\nint getport()                                   返回此套接字连接到的远程端口。\nint getlocalport()                              返回此套接字绑定到的本地端口。\nsocketaddress getremotesocketaddress()          返回此套接字连接的端点的地址，如果未连接则返回 null。\ninputstream getinputstream()                    返回此套接字的输入流。\noutputstream getoutputstream()                  返回此套接字的输出流。\nvoid close()                                    关闭此套接字。\n\n\n# socket 通信示例\n\n服务端示例：\n\npublic class helloserver {\n\n    public static void main(string[] args) throws exception {\n        // socket 服务端\n        // 服务器在8888端口上监听\n        serversocket server = new serversocket(8888);\n        system.out.println("服务器运行中，等待客户端连接。");\n        // 得到连接，程序进入到阻塞状态\n        socket client = server.accept();\n        // 打印流输出最方便\n        printstream out = new printstream(client.getoutputstream());\n        // 向客户端输出信息\n        out.println("hello world");\n        client.close();\n        server.close();\n        system.out.println("服务器已向客户端发送消息，退出。");\n    }\n\n}\n\n\n客户端示例：\n\npublic class helloclient {\n\n    public static void main(string[] args) throws exception {\n        // socket 客户端\n        socket client = new socket("localhost", 8888);\n        inputstreamreader inputstreamreader = new inputstreamreader(client.getinputstream());\n        // 一次性接收完成\n        bufferedreader buf = new bufferedreader(inputstreamreader);\n        string str = buf.readline();\n        buf.close();\n        client.close();\n        system.out.println("客户端接收到服务器消息：" + str + "，退出");\n    }\n\n}\n\n\n\n# datagramsocket 和 datagrampacket\n\njava 通过 datagramsocket 和 datagrampacket 实现对 udp 协议的支持。\n\n * datagrampacket：数据包类\n * datagramsocket：通信类\n\nudp 服务端示例：\n\npublic class udpserver {\n\n    public static void main(string[] args) throws exception { // 所有异常抛出\n        string str = "hello world!!!";\n        datagramsocket ds = new datagramsocket(3000); // 服务端在3000端口上等待服务器发送信息\n        datagrampacket dp =\n            new datagrampacket(str.getbytes(), str.length(), inetaddress.getbyname("localhost"), 9000); // 所有的信息使用buf保存\n        system.out.println("发送信息。");\n        ds.send(dp); // 发送信息出去\n        ds.close();\n    }\n\n}\n\n\nudp 客户端示例：\n\npublic class udpclient {\n\n    public static void main(string[] args) throws exception { // 所有异常抛出\n        byte[] buf = new byte[1024]; // 开辟空间，以接收数据\n        datagramsocket ds = new datagramsocket(9000); // 客户端在9000端口上等待服务器发送信息\n        datagrampacket dp = new datagrampacket(buf, 1024); // 所有的信息使用buf保存\n        ds.receive(dp); // 接收数据\n        string str = new string(dp.getdata(), 0, dp.getlength()) + "from " + dp.getaddress().gethostaddress() + "："\n            + dp.getport();\n        system.out.println(str); // 输出内容\n    }\n\n}\n\n\n\n# inetaddress\n\ninetaddress 类表示互联网协议(ip)地址。\n\n没有公有的构造函数，只能通过静态方法来创建实例。\n\ninetaddress.getbyname(string host);\ninetaddress.getbyaddress(byte[] address);\n\n\n\n# url\n\n可以直接从 url 中读取字节流数据。\n\npublic static void main(string[] args) throws ioexception {\n\n    url url = new url("http://www.baidu.com");\n\n    /* 字节流 */\n    inputstream is = url.openstream();\n\n    /* 字符流 */\n    inputstreamreader isr = new inputstreamreader(is, "utf-8");\n\n    /* 提供缓存功能 */\n    bufferedreader br = new bufferedreader(isr);\n\n    string line;\n    while ((line = br.readline()) != null) {\n        system.out.println(line);\n    }\n\n    br.close();\n}\n\n\n\n# 参考资料\n\n * java 网络编程',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java IO 工具类",frontmatter:{title:"Java IO 工具类",categories:["编程","Java","JavaSE","IO"],tags:["Java","JavaSE","IO","工具类"],abbrlink:"1b6a0891",date:"2020-06-30T21:34:59.000Z",permalink:"/pages/e33faa/"},regularPath:"/04.IO/05.JavaIO%E5%B7%A5%E5%85%B7%E7%B1%BB.html",relativePath:"04.IO/05.JavaIO工具类.md",key:"v-78bf0d7d",path:"/pages/e33faa/",headers:[{level:2,title:"File",slug:"file",normalizedTitle:"file",charIndex:21},{level:3,title:"createNewFille",slug:"createnewfille",normalizedTitle:"createnewfille",charIndex:156},{level:3,title:"mkdir",slug:"mkdir",normalizedTitle:"mkdir",charIndex:398},{level:3,title:"delete",slug:"delete",normalizedTitle:"delete",charIndex:571},{level:3,title:"list 和 listFiles",slug:"list-和-listfiles",normalizedTitle:"list 和 listfiles",charIndex:722},{level:2,title:"RandomAccessFile",slug:"randomaccessfile",normalizedTitle:"randomaccessfile",charIndex:26},{level:3,title:"RandomAccessFile 写操作",slug:"randomaccessfile-写操作",normalizedTitle:"randomaccessfile 写操作",charIndex:1219},{level:3,title:"RandomAccessFile 读操作",slug:"randomaccessfile-读操作",normalizedTitle:"randomaccessfile 读操作",charIndex:2174},{level:2,title:"System",slug:"system",normalizedTitle:"system",charIndex:43},{level:2,title:"Scanner",slug:"scanner",normalizedTitle:"scanner",charIndex:50},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6811}],headersStr:"File createNewFille mkdir delete list 和 listFiles RandomAccessFile RandomAccessFile 写操作 RandomAccessFile 读操作 System Scanner 参考资料",content:'# Java IO 工具类\n\n> 关键词：File、RandomAccessFile、System、Scanner\n> \n> 本文介绍 Java IO 的一些常见工具类的用法和特性。\n\n\n# File\n\nFile 类是 java.io 包中唯一对文件本身进行操作的类。它可以对文件、目录进行增删查操作。\n\n\n# createNewFille\n\n可以使用 createNewFille() 方法创建一个新文件。\n\n注：\n\nWindows 中使用反斜杠表示目录的分隔符 \\。~~~~~~~~\n\nLinux 中使用正斜杠表示目录的分隔符 /。\n\n最好的做法是使用 File.separator 静态常量，可以根据所在操作系统选取对应的分隔符。\n\n【示例】创建文件\n\nFile f = new File(filename);\nboolean flag = f.createNewFile();\n\n\n\n# mkdir\n\n可以使用 mkdir() 来创建文件夹，但是如果要创建的目录的父路径不存在，则无法创建成功。\n\n如果要解决这个问题，可以使用 mkdirs()，当父路径不存在时，会连同上级目录都一并创建。\n\n【示例】创建目录\n\nFile f = new File(filename);\nboolean flag = f.mkdir();\n\n\n\n# delete\n\n可以使用 delete() 来删除文件或目录。\n\n需要注意的是，如果删除的是目录，且目录不为空，直接用 delete() 删除会失败。\n\n【示例】删除文件或目录\n\nFile f = new File(filename);\nboolean flag = f.delete();\n\n\n\n# list 和 listFiles\n\nFile 中给出了两种列出文件夹内容的方法：\n\n * list(): 列出全部名称，返回一个字符串数组。\n * listFiles(): 列出完整的路径，返回一个 File 对象数组。\n\nlist() 示例：\n\nFile f = new File(filename);\nString str[] = f.list();\n\n\nlistFiles() 示例：\n\nFile f = new File(filename);\nFile files[] = f.listFiles();\n\n\n\n# RandomAccessFile\n\n> 注：RandomAccessFile 类虽然可以实现对文件内容的读写操作，但是比较复杂。所以一般操作文件内容往往会使用字节流或字符流方式。\n\nRandomAccessFile 类是随机读取类，它是一个完全独立的类。\n\n它适用于由大小已知的记录组成的文件，所以我们可以使用 seek() 将记录从一处转移到另一处，然后读取或者修改记录。\n\n文件中记录的大小不一定都相同，只要能够确定哪些记录有多大以及它们在文件中的位置即可。\n\n\n# RandomAccessFile 写操作\n\n当用 rw 方式声明 RandomAccessFile 对象时，如果要写入的文件不存在，系统将自行创建。\n\nr 为只读；w 为只写；rw 为读写。\n\n【示例】文件随机读写\n\npublic class RandomAccessFileDemo01 {\n\n    public static void main(String args[]) throws IOException {\n        File f = new File("d:" + File.separator + "test.txt"); // 指定要操作的文件\n        RandomAccessFile rdf = null; // 声明RandomAccessFile类的对象\n        rdf = new RandomAccessFile(f, "rw");// 读写模式，如果文件不存在，会自动创建\n        String name = null;\n        int age = 0;\n        name = "zhangsan"; // 字符串长度为8\n        age = 30; // 数字的长度为4\n        rdf.writeBytes(name); // 将姓名写入文件之中\n        rdf.writeInt(age); // 将年龄写入文件之中\n        name = "lisi    "; // 字符串长度为8\n        age = 31; // 数字的长度为4\n        rdf.writeBytes(name); // 将姓名写入文件之中\n        rdf.writeInt(age); // 将年龄写入文件之中\n        name = "wangwu  "; // 字符串长度为8\n        age = 32; // 数字的长度为4\n        rdf.writeBytes(name); // 将姓名写入文件之中\n        rdf.writeInt(age); // 将年龄写入文件之中\n        rdf.close(); // 关闭\n    }\n}\n\n\n\n# RandomAccessFile 读操作\n\n读取是直接使用 r 的模式即可，以只读的方式打开文件。\n\n读取时所有的字符串只能按照 byte 数组方式读取出来，而且长度必须和写入时的固定大小相匹配。\n\npublic class RandomAccessFileDemo02 {\n\n    public static void main(String args[]) throws IOException {\n        File f = new File("d:" + File.separator + "test.txt");    // 指定要操作的文件\n        RandomAccessFile rdf = null;        // 声明RandomAccessFile类的对象\n        rdf = new RandomAccessFile(f, "r");// 以只读的方式打开文件\n        String name = null;\n        int age = 0;\n        byte b[] = new byte[8];    // 开辟byte数组\n        // 读取第二个人的信息，意味着要空出第一个人的信息\n        rdf.skipBytes(12);        // 跳过第一个人的信息\n        for (int i = 0; i < b.length; i++) {\n            b[i] = rdf.readByte();    // 读取一个字节\n        }\n        name = new String(b);    // 将读取出来的byte数组变为字符串\n        age = rdf.readInt();    // 读取数字\n        System.out.println("第二个人的信息 --\x3e 姓名：" + name + "；年龄：" + age);\n        // 读取第一个人的信息\n        rdf.seek(0);    // 指针回到文件的开头\n        for (int i = 0; i < b.length; i++) {\n            b[i] = rdf.readByte();    // 读取一个字节\n        }\n        name = new String(b);    // 将读取出来的byte数组变为字符串\n        age = rdf.readInt();    // 读取数字\n        System.out.println("第一个人的信息 --\x3e 姓名：" + name + "；年龄：" + age);\n        rdf.skipBytes(12);    // 空出第二个人的信息\n        for (int i = 0; i < b.length; i++) {\n            b[i] = rdf.readByte();    // 读取一个字节\n        }\n        name = new String(b);    // 将读取出来的byte数组变为字符串\n        age = rdf.readInt();    // 读取数字\n        System.out.println("第三个人的信息 --\x3e 姓名：" + name + "；年龄：" + age);\n        rdf.close();                // 关闭\n    }\n}\n\n\n\n# System\n\nSystem 类中提供了大量的静态方法，可以获取系统相关的信息或系统级操作，其中提供了三个常用于 IO 的静态成员：\n\n * System.out - 一个 PrintStream 流。System.out 一般会把你写到其中的数据输出到控制台上。System.out 通常仅用在类似命令行工具的控制台程序上。System.out 也经常用于打印程序的调试信息(尽管它可能并不是获取程序调试信息的最佳方式)。\n * System.err - 一个 PrintStream 流。System.err 与 System.out 的运行方式类似，但它更多的是用于打印错误文本。一些类似 Eclipse 的程序，为了让错误信息更加显眼，会将错误信息以红色文本的形式通过 System.err 输出到控制台上。\n * System.in - 一个典型的连接控制台程序和键盘输入的 InputStream 流。通常当数据通过命令行参数或者配置文件传递给命令行 Java 程序的时候，System.in 并不是很常用。图形界面程序通过界面传递参数给程序，这是一块单独的 Java IO 输入机制。\n\n【示例】重定向 System.out 输出流\n\nimport java.io.*;\npublic class SystemOutDemo {\n\n    public static void main(String args[]) throws Exception {\n        OutputStream out = new FileOutputStream("d:\\\\test.txt");\n        PrintStream ps = new PrintStream(out);\n        System.setOut(ps);\n        System.out.println("人生若只如初见，何事秋风悲画扇");\n        ps.close();\n        out.close();\n    }\n}\n\n\n【示例】重定向 System.err 输出流\n\npublic class SystemErrDemo {\n\n    public static void main(String args[]) throws IOException {\n        OutputStream bos = new ByteArrayOutputStream();        // 实例化\n        PrintStream ps = new PrintStream(bos);        // 实例化\n        System.setErr(ps);    // 输出重定向\n        System.err.print("此处有误");\n        System.out.println(bos);    // 输出内存中的数据\n    }\n}\n\n\n【示例】System.in 接受控制台输入信息\n\nimport java.io.*;\npublic class SystemInDemo {\n\n    public static void main(String args[]) throws IOException {\n        InputStream input = System.in;\n        StringBuffer buf = new StringBuffer();\n        System.out.print("请输入内容：");\n        int temp = 0;\n        while ((temp = input.read()) != -1) {\n            char c = (char) temp;\n            if (c == \'\\n\') {\n                break;\n            }\n            buf.append(c);\n        }\n        System.out.println("输入的内容为：" + buf);\n        input.close();\n    }\n}\n\n\n\n# Scanner\n\nScanner 可以获取用户的输入，并对数据进行校验。\n\n【示例】校验输入数据是否格式正确\n\nimport java.io.*;\npublic class ScannerDemo {\n\n    public static void main(String args[]) {\n        Scanner scan = new Scanner(System.in);    // 从键盘接收数据\n        int i = 0;\n        float f = 0.0f;\n        System.out.print("输入整数：");\n        if (scan.hasNextInt()) {    // 判断输入的是否是整数\n            i = scan.nextInt();    // 接收整数\n            System.out.println("整数数据：" + i);\n        } else {\n            System.out.println("输入的不是整数！");\n        }\n\n        System.out.print("输入小数：");\n        if (scan.hasNextFloat()) {    // 判断输入的是否是小数\n            f = scan.nextFloat();    // 接收小数\n            System.out.println("小数数据：" + f);\n        } else {\n            System.out.println("输入的不是小数！");\n        }\n\n        Date date = null;\n        String str = null;\n        System.out.print("输入日期（yyyy-MM-dd）：");\n        if (scan.hasNext("^\\\\d{4}-\\\\d{2}-\\\\d{2}$")) {    // 判断\n            str = scan.next("^\\\\d{4}-\\\\d{2}-\\\\d{2}$");    // 接收\n            try {\n                date = new SimpleDateFormat("yyyy-MM-dd").parse(str);\n            } catch (Exception e) {}\n        } else {\n            System.out.println("输入的日期格式错误！");\n        }\n        System.out.println(date);\n    }\n}\n\n\n输出：\n\n输入整数：20\n整数数据：20\n输入小数：3.2\n小数数据：3.2\n输入日期（yyyy-MM-dd）：1988-13-1\n输入的日期格式错误！\nnull\n\n\n\n# 参考资料\n\n * 《Java 编程思想（Thinking in java）》\n * 《Java 核心技术 卷 I 基础知识》\n * System 官方 API 手册',normalizedContent:'# java io 工具类\n\n> 关键词：file、randomaccessfile、system、scanner\n> \n> 本文介绍 java io 的一些常见工具类的用法和特性。\n\n\n# file\n\nfile 类是 java.io 包中唯一对文件本身进行操作的类。它可以对文件、目录进行增删查操作。\n\n\n# createnewfille\n\n可以使用 createnewfille() 方法创建一个新文件。\n\n注：\n\nwindows 中使用反斜杠表示目录的分隔符 \\。~~~~~~~~\n\nlinux 中使用正斜杠表示目录的分隔符 /。\n\n最好的做法是使用 file.separator 静态常量，可以根据所在操作系统选取对应的分隔符。\n\n【示例】创建文件\n\nfile f = new file(filename);\nboolean flag = f.createnewfile();\n\n\n\n# mkdir\n\n可以使用 mkdir() 来创建文件夹，但是如果要创建的目录的父路径不存在，则无法创建成功。\n\n如果要解决这个问题，可以使用 mkdirs()，当父路径不存在时，会连同上级目录都一并创建。\n\n【示例】创建目录\n\nfile f = new file(filename);\nboolean flag = f.mkdir();\n\n\n\n# delete\n\n可以使用 delete() 来删除文件或目录。\n\n需要注意的是，如果删除的是目录，且目录不为空，直接用 delete() 删除会失败。\n\n【示例】删除文件或目录\n\nfile f = new file(filename);\nboolean flag = f.delete();\n\n\n\n# list 和 listfiles\n\nfile 中给出了两种列出文件夹内容的方法：\n\n * list(): 列出全部名称，返回一个字符串数组。\n * listfiles(): 列出完整的路径，返回一个 file 对象数组。\n\nlist() 示例：\n\nfile f = new file(filename);\nstring str[] = f.list();\n\n\nlistfiles() 示例：\n\nfile f = new file(filename);\nfile files[] = f.listfiles();\n\n\n\n# randomaccessfile\n\n> 注：randomaccessfile 类虽然可以实现对文件内容的读写操作，但是比较复杂。所以一般操作文件内容往往会使用字节流或字符流方式。\n\nrandomaccessfile 类是随机读取类，它是一个完全独立的类。\n\n它适用于由大小已知的记录组成的文件，所以我们可以使用 seek() 将记录从一处转移到另一处，然后读取或者修改记录。\n\n文件中记录的大小不一定都相同，只要能够确定哪些记录有多大以及它们在文件中的位置即可。\n\n\n# randomaccessfile 写操作\n\n当用 rw 方式声明 randomaccessfile 对象时，如果要写入的文件不存在，系统将自行创建。\n\nr 为只读；w 为只写；rw 为读写。\n\n【示例】文件随机读写\n\npublic class randomaccessfiledemo01 {\n\n    public static void main(string args[]) throws ioexception {\n        file f = new file("d:" + file.separator + "test.txt"); // 指定要操作的文件\n        randomaccessfile rdf = null; // 声明randomaccessfile类的对象\n        rdf = new randomaccessfile(f, "rw");// 读写模式，如果文件不存在，会自动创建\n        string name = null;\n        int age = 0;\n        name = "zhangsan"; // 字符串长度为8\n        age = 30; // 数字的长度为4\n        rdf.writebytes(name); // 将姓名写入文件之中\n        rdf.writeint(age); // 将年龄写入文件之中\n        name = "lisi    "; // 字符串长度为8\n        age = 31; // 数字的长度为4\n        rdf.writebytes(name); // 将姓名写入文件之中\n        rdf.writeint(age); // 将年龄写入文件之中\n        name = "wangwu  "; // 字符串长度为8\n        age = 32; // 数字的长度为4\n        rdf.writebytes(name); // 将姓名写入文件之中\n        rdf.writeint(age); // 将年龄写入文件之中\n        rdf.close(); // 关闭\n    }\n}\n\n\n\n# randomaccessfile 读操作\n\n读取是直接使用 r 的模式即可，以只读的方式打开文件。\n\n读取时所有的字符串只能按照 byte 数组方式读取出来，而且长度必须和写入时的固定大小相匹配。\n\npublic class randomaccessfiledemo02 {\n\n    public static void main(string args[]) throws ioexception {\n        file f = new file("d:" + file.separator + "test.txt");    // 指定要操作的文件\n        randomaccessfile rdf = null;        // 声明randomaccessfile类的对象\n        rdf = new randomaccessfile(f, "r");// 以只读的方式打开文件\n        string name = null;\n        int age = 0;\n        byte b[] = new byte[8];    // 开辟byte数组\n        // 读取第二个人的信息，意味着要空出第一个人的信息\n        rdf.skipbytes(12);        // 跳过第一个人的信息\n        for (int i = 0; i < b.length; i++) {\n            b[i] = rdf.readbyte();    // 读取一个字节\n        }\n        name = new string(b);    // 将读取出来的byte数组变为字符串\n        age = rdf.readint();    // 读取数字\n        system.out.println("第二个人的信息 --\x3e 姓名：" + name + "；年龄：" + age);\n        // 读取第一个人的信息\n        rdf.seek(0);    // 指针回到文件的开头\n        for (int i = 0; i < b.length; i++) {\n            b[i] = rdf.readbyte();    // 读取一个字节\n        }\n        name = new string(b);    // 将读取出来的byte数组变为字符串\n        age = rdf.readint();    // 读取数字\n        system.out.println("第一个人的信息 --\x3e 姓名：" + name + "；年龄：" + age);\n        rdf.skipbytes(12);    // 空出第二个人的信息\n        for (int i = 0; i < b.length; i++) {\n            b[i] = rdf.readbyte();    // 读取一个字节\n        }\n        name = new string(b);    // 将读取出来的byte数组变为字符串\n        age = rdf.readint();    // 读取数字\n        system.out.println("第三个人的信息 --\x3e 姓名：" + name + "；年龄：" + age);\n        rdf.close();                // 关闭\n    }\n}\n\n\n\n# system\n\nsystem 类中提供了大量的静态方法，可以获取系统相关的信息或系统级操作，其中提供了三个常用于 io 的静态成员：\n\n * system.out - 一个 printstream 流。system.out 一般会把你写到其中的数据输出到控制台上。system.out 通常仅用在类似命令行工具的控制台程序上。system.out 也经常用于打印程序的调试信息(尽管它可能并不是获取程序调试信息的最佳方式)。\n * system.err - 一个 printstream 流。system.err 与 system.out 的运行方式类似，但它更多的是用于打印错误文本。一些类似 eclipse 的程序，为了让错误信息更加显眼，会将错误信息以红色文本的形式通过 system.err 输出到控制台上。\n * system.in - 一个典型的连接控制台程序和键盘输入的 inputstream 流。通常当数据通过命令行参数或者配置文件传递给命令行 java 程序的时候，system.in 并不是很常用。图形界面程序通过界面传递参数给程序，这是一块单独的 java io 输入机制。\n\n【示例】重定向 system.out 输出流\n\nimport java.io.*;\npublic class systemoutdemo {\n\n    public static void main(string args[]) throws exception {\n        outputstream out = new fileoutputstream("d:\\\\test.txt");\n        printstream ps = new printstream(out);\n        system.setout(ps);\n        system.out.println("人生若只如初见，何事秋风悲画扇");\n        ps.close();\n        out.close();\n    }\n}\n\n\n【示例】重定向 system.err 输出流\n\npublic class systemerrdemo {\n\n    public static void main(string args[]) throws ioexception {\n        outputstream bos = new bytearrayoutputstream();        // 实例化\n        printstream ps = new printstream(bos);        // 实例化\n        system.seterr(ps);    // 输出重定向\n        system.err.print("此处有误");\n        system.out.println(bos);    // 输出内存中的数据\n    }\n}\n\n\n【示例】system.in 接受控制台输入信息\n\nimport java.io.*;\npublic class systemindemo {\n\n    public static void main(string args[]) throws ioexception {\n        inputstream input = system.in;\n        stringbuffer buf = new stringbuffer();\n        system.out.print("请输入内容：");\n        int temp = 0;\n        while ((temp = input.read()) != -1) {\n            char c = (char) temp;\n            if (c == \'\\n\') {\n                break;\n            }\n            buf.append(c);\n        }\n        system.out.println("输入的内容为：" + buf);\n        input.close();\n    }\n}\n\n\n\n# scanner\n\nscanner 可以获取用户的输入，并对数据进行校验。\n\n【示例】校验输入数据是否格式正确\n\nimport java.io.*;\npublic class scannerdemo {\n\n    public static void main(string args[]) {\n        scanner scan = new scanner(system.in);    // 从键盘接收数据\n        int i = 0;\n        float f = 0.0f;\n        system.out.print("输入整数：");\n        if (scan.hasnextint()) {    // 判断输入的是否是整数\n            i = scan.nextint();    // 接收整数\n            system.out.println("整数数据：" + i);\n        } else {\n            system.out.println("输入的不是整数！");\n        }\n\n        system.out.print("输入小数：");\n        if (scan.hasnextfloat()) {    // 判断输入的是否是小数\n            f = scan.nextfloat();    // 接收小数\n            system.out.println("小数数据：" + f);\n        } else {\n            system.out.println("输入的不是小数！");\n        }\n\n        date date = null;\n        string str = null;\n        system.out.print("输入日期（yyyy-mm-dd）：");\n        if (scan.hasnext("^\\\\d{4}-\\\\d{2}-\\\\d{2}$")) {    // 判断\n            str = scan.next("^\\\\d{4}-\\\\d{2}-\\\\d{2}$");    // 接收\n            try {\n                date = new simpledateformat("yyyy-mm-dd").parse(str);\n            } catch (exception e) {}\n        } else {\n            system.out.println("输入的日期格式错误！");\n        }\n        system.out.println(date);\n    }\n}\n\n\n输出：\n\n输入整数：20\n整数数据：20\n输入小数：3.2\n小数数据：3.2\n输入日期（yyyy-mm-dd）：1988-13-1\n输入的日期格式错误！\nnull\n\n\n\n# 参考资料\n\n * 《java 编程思想（thinking in java）》\n * 《java 核心技术 卷 i 基础知识》\n * system 官方 api 手册',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java IO",frontmatter:{title:"Java IO",categories:["编程","Java","JavaSE","IO"],tags:["Java","JavaSE","IO"],abbrlink:"b4224212",date:"2020-06-04T13:51:01.000Z",hidden:!0,permalink:"/pages/8826bb/"},regularPath:"/04.IO/",relativePath:"04.IO/README.md",key:"v-c2d85758",path:"/pages/8826bb/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:14},{level:3,title:"Java IO 模型",slug:"java-io-模型",normalizedTitle:"java io 模型",charIndex:24},{level:3,title:"Java NIO",slug:"java-nio",normalizedTitle:"java nio",charIndex:87},{level:3,title:"Java 序列化",slug:"java-序列化",normalizedTitle:"java 序列化",charIndex:142},{level:3,title:"Java 网络编程",slug:"java-网络编程",normalizedTitle:"java 网络编程",charIndex:242},{level:3,title:"Java IO 工具类",slug:"java-io-工具类",normalizedTitle:"java io 工具类",charIndex:313},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:373},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:441}],headersStr:"📖 内容 Java IO 模型 Java NIO Java 序列化 Java 网络编程 Java IO 工具类 📚 资料 🚪 传送",content:"# Java IO\n\n\n# 📖 内容\n\n\n# Java IO 模型\n\n> 关键词：InputStream、OutputStream、Reader、Writer\n\n\n\n\n# Java NIO\n\n> 关键词：Channel、Buffer、Selector、非阻塞、多路复用\n\n\n\n\n# Java 序列化\n\n> 关键词：Serializable、serialVersionUID、transient、Externalizable、writeObject、readObject\n\n\n\n\n# Java 网络编程\n\n> 关键词：Socket、ServerSocket、DatagramPacket、DatagramSocket\n\n\n# Java IO 工具类\n\n> 关键词：File、RandomAccessFile、System、Scanner\n\n\n# 📚 资料\n\n * 《Java 编程思想（Thinking in java）》\n * 《Java 核心技术 卷 I 基础知识》\n\n\n# 🚪 传送\n\n◾ 🏠 JAVACORE 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"# java io\n\n\n# 📖 内容\n\n\n# java io 模型\n\n> 关键词：inputstream、outputstream、reader、writer\n\n\n\n\n# java nio\n\n> 关键词：channel、buffer、selector、非阻塞、多路复用\n\n\n\n\n# java 序列化\n\n> 关键词：serializable、serialversionuid、transient、externalizable、writeobject、readobject\n\n\n\n\n# java 网络编程\n\n> 关键词：socket、serversocket、datagrampacket、datagramsocket\n\n\n# java io 工具类\n\n> 关键词：file、randomaccessfile、system、scanner\n\n\n# 📚 资料\n\n * 《java 编程思想（thinking in java）》\n * 《java 核心技术 卷 i 基础知识》\n\n\n# 🚪 传送\n\n◾ 🏠 javacore 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java并发简介",frontmatter:{title:"Java并发简介",categories:["编程","Java","JavaSE","并发"],tags:["Java","JavaSE","并发"],abbrlink:"32d96a2b",date:"2019-05-06T15:33:13.000Z",permalink:"/pages/b39f82/"},regularPath:"/05.%E5%B9%B6%E5%8F%91/01.Java%E5%B9%B6%E5%8F%91%E7%AE%80%E4%BB%8B.html",relativePath:"05.并发/01.Java并发简介.md",key:"v-01edae99",path:"/pages/b39f82/",headers:[{level:2,title:"并发概念",slug:"并发概念",normalizedTitle:"并发概念",charIndex:247},{level:3,title:"并发和并行",slug:"并发和并行",normalizedTitle:"并发和并行",charIndex:308},{level:3,title:"同步和异步",slug:"同步和异步",normalizedTitle:"同步和异步",charIndex:588},{level:3,title:"阻塞和非阻塞",slug:"阻塞和非阻塞",normalizedTitle:"阻塞和非阻塞",charIndex:847},{level:3,title:"进程和线程",slug:"进程和线程",normalizedTitle:"进程和线程",charIndex:1048},{level:3,title:"竞态条件和临界区",slug:"竞态条件和临界区",normalizedTitle:"竞态条件和临界区",charIndex:1392},{level:3,title:"管程",slug:"管程",normalizedTitle:"管程",charIndex:1512},{level:2,title:"并发的特点",slug:"并发的特点",normalizedTitle:"并发的特点",charIndex:1680},{level:3,title:"提升资源利用率",slug:"提升资源利用率",normalizedTitle:"提升资源利用率",charIndex:2073},{level:3,title:"程序响应更快",slug:"程序响应更快",normalizedTitle:"程序响应更快",charIndex:2084},{level:3,title:"并发的问题",slug:"并发的问题",normalizedTitle:"并发的问题",charIndex:3311},{level:2,title:"安全性问题",slug:"安全性问题",normalizedTitle:"安全性问题",charIndex:3388},{level:3,title:"缓存导致的可见性问题",slug:"缓存导致的可见性问题",normalizedTitle:"缓存导致的可见性问题",charIndex:3675},{level:3,title:"线程切换带来的原子性问题",slug:"线程切换带来的原子性问题",normalizedTitle:"线程切换带来的原子性问题",charIndex:5196},{level:3,title:"编译优化带来的有序性问题",slug:"编译优化带来的有序性问题",normalizedTitle:"编译优化带来的有序性问题",charIndex:6342},{level:3,title:"保证并发安全的思路",slug:"保证并发安全的思路",normalizedTitle:"保证并发安全的思路",charIndex:7738},{level:4,title:"互斥同步（阻塞同步）",slug:"互斥同步-阻塞同步",normalizedTitle:"互斥同步（阻塞同步）",charIndex:7751},{level:4,title:"非阻塞同步",slug:"非阻塞同步",normalizedTitle:"非阻塞同步",charIndex:8100},{level:4,title:"无同步",slug:"无同步",normalizedTitle:"无同步",charIndex:8499},{level:2,title:"活跃性问题",slug:"活跃性问题",normalizedTitle:"活跃性问题",charIndex:3397},{level:3,title:"死锁（Deadlock）",slug:"死锁-deadlock",normalizedTitle:"死锁（deadlock）",charIndex:8765},{level:4,title:"什么是死锁",slug:"什么是死锁",normalizedTitle:"什么是死锁",charIndex:8781},{level:4,title:"避免死锁",slug:"避免死锁",normalizedTitle:"避免死锁",charIndex:8870},{level:3,title:"活锁（Livelock）",slug:"活锁-livelock",normalizedTitle:"活锁（livelock）",charIndex:9708},{level:4,title:"什么是活锁",slug:"什么是活锁",normalizedTitle:"什么是活锁",charIndex:9724},{level:4,title:"避免活锁",slug:"避免活锁",normalizedTitle:"避免活锁",charIndex:10017},{level:3,title:"饥饿（Starvation）",slug:"饥饿-starvation",normalizedTitle:"饥饿（starvation）",charIndex:10142},{level:4,title:"什么是饥饿",slug:"什么是饥饿",normalizedTitle:"什么是饥饿",charIndex:10160},{level:4,title:"解决饥饿",slug:"解决饥饿",normalizedTitle:"解决饥饿",charIndex:10399},{level:2,title:"性能问题",slug:"性能问题",normalizedTitle:"性能问题",charIndex:3406},{level:3,title:"上下文切换",slug:"上下文切换",normalizedTitle:"上下文切换",charIndex:42},{level:4,title:"什么是上下文切换？",slug:"什么是上下文切换",normalizedTitle:"什么是上下文切换？",charIndex:10743},{level:4,title:"减少上下文切换的方法",slug:"减少上下文切换的方法",normalizedTitle:"减少上下文切换的方法",charIndex:10848},{level:3,title:"资源限制",slug:"资源限制",normalizedTitle:"资源限制",charIndex:11110},{level:4,title:"什么是资源限制",slug:"什么是资源限制",normalizedTitle:"什么是资源限制",charIndex:11118},{level:4,title:"资源限制引发的问题",slug:"资源限制引发的问题",normalizedTitle:"资源限制引发的问题",charIndex:11169},{level:4,title:"如何解决资源限制的问题",slug:"如何解决资源限制的问题",normalizedTitle:"如何解决资源限制的问题",charIndex:11294},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:11402},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:11509}],headersStr:"并发概念 并发和并行 同步和异步 阻塞和非阻塞 进程和线程 竞态条件和临界区 管程 并发的特点 提升资源利用率 程序响应更快 并发的问题 安全性问题 缓存导致的可见性问题 线程切换带来的原子性问题 编译优化带来的有序性问题 保证并发安全的思路 互斥同步（阻塞同步） 非阻塞同步 无同步 活跃性问题 死锁（Deadlock） 什么是死锁 避免死锁 活锁（Livelock） 什么是活锁 避免活锁 饥饿（Starvation） 什么是饥饿 解决饥饿 性能问题 上下文切换 什么是上下文切换？ 减少上下文切换的方法 资源限制 什么是资源限制 资源限制引发的问题 如何解决资源限制的问题 小结 参考资料",content:"# Java 并发简介\n\n> 关键词：进程、线程、安全性、活跃性、性能、死锁、饥饿、上下文切换\n> \n> 摘要：并发编程并非 Java 语言所独有，而是一种成熟的编程范式，Java 只是用自己的方式实现了并发工作模型。学习 Java 并发编程，应该先熟悉并发的基本概念，然后进一步了解并发的特性以及其特性所面临的问题。掌握了这些，当学习 Java 并发工具时，才会明白它们各自是为了解决什么问题，为什么要这样设计。通过这样由点到面的学习方式，更容易融会贯通，将并发知识形成体系化。\n\n\n\n\n# 并发概念\n\n并发编程中有很多术语概念相近，容易让人混淆。本节内容通过对比分析，力求让读者清晰理解其概念以及差异。\n\n\n# 并发和并行\n\n并发和并行是最容易让新手费解的概念，那么如何理解二者呢？其最关键的差异在于：是否是同时发生：\n\n * 并发：是指具备处理多个任务的能力，但不一定要同时。\n * 并行：是指具备同时处理多个任务的能力。\n\n下面是我见过最生动的说明，摘自 并发与并行的区别是什么？——知乎的高票答案：\n\n * 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。\n * 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。\n * 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。\n\n\n# 同步和异步\n\n * 同步：是指在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。\n * 异步：则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。\n\n举例来说明：\n\n * 同步就像是打电话：不挂电话，通话不会结束。\n * 异步就像是发短信：发完短信后，就可以做其他事；当收到回复短信时，手机会通过铃声或振动来提醒。\n\n\n# 阻塞和非阻塞\n\n阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：\n\n * 阻塞：是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n * 非阻塞：是指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n\n举例来说明：\n\n * 阻塞调用就像是打电话，通话不结束，不能放下。\n * 非阻塞调用就像是发短信，发完短信后，就可以做其他事，短信来了，手机会提醒。\n\n\n# 进程和线程\n\n * 进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。进程可视为一个正在运行的程序。\n * 线程：线程是操作系统进行调度的基本单位。\n\n进程和线程的差异：\n\n * 一个程序至少有一个进程，一个进程至少有一个线程。\n * 线程比进程划分更细，所以执行开销更小，并发性更高\n * 进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。\n\n\n\nJVM 在单个进程中运行，JVM 中的线程共享属于该进程的堆。这就是为什么几个线程可以访问同一个对象。线程共享堆并拥有自己的堆栈空间。这是一个线程如何调用一个方法以及它的局部变量是如何保持线程安全的。但是堆不是线程安全的并且为了线程安全必须进行同步。\n\n\n# 竞态条件和临界区\n\n * 竞态条件（Race Condition）：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。\n\n * 临界区（Critical Sections）：导致竞态条件发生的代码区称作临界区。\n\n\n# 管程\n\n管程（Monitor），是指管理共享变量以及对共享变量的操作过程，让他们支持并发。\n\nJava 采用的是管程技术，synchronized 关键字及 wait()、notify()、notifyAll() 这三个方法都是管程的组成部分。而管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。\n\n\n# 并发的特点\n\n技术在进步，CPU、内存、I/O 设备的性能也在不断提高。但是，始终存在一个核心矛盾：CPU、内存、I/O 设备存在速度差异。CPU 远快于内存，内存远快于 I/O 设备。\n\n木桶短板理论告诉我们：一只木桶能装多少水，取决于最短的那块木板。同理，程序整体性能取决于最慢的操作（即 I/O 操作），所以单方面提高 CPU、内存的性能是无效的。\n\n\n\n为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：\n\n * CPU 增加了缓存，以均衡与内存的速度差异；\n * 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；\n * 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。\n\n其中，进程、线程使得计算机、程序有了并发处理任务的能力。\n\n并发的优点在于：\n\n * 提升资源利用率\n * 程序响应更快\n\n\n# 提升资源利用率\n\n想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要 5 秒，处理一个文件需要 2 秒。处理两个文件则需要：\n\n5秒读取文件A\n2秒处理文件A\n5秒读取文件B\n2秒处理文件B\n---------------------\n总共需要14秒\n\n\n从磁盘中读取文件的时候，大部分的 CPU 时间用于等待磁盘去读取数据。在这段时间里，CPU 非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用 CPU 资源。看下面的顺序：\n\n5秒读取文件A\n5秒读取文件B + 2秒处理文件A\n2秒处理文件B\n---------------------\n总共需要12秒\n\n\nCPU 等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU 会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU 大 部分时间是空闲的。\n\n总的说来，CPU 能够在等待 IO 的时候做一些其他的事情。这个不一定就是磁盘 IO。它也可以是网络的 IO，或者用户输入。通常情况下，网络和磁盘的 IO 比 CPU 和内存的 IO 慢的多。\n\n\n# 程序响应更快\n\n将一个单线程应用程序变成多线程应用程序的另一个常见的目的是实现一个响应更快的应用程序。设想一个服务器应用，它在某一个端口监听进来的请求。当一个请求到来时，它去处理这个请求，然后再返回去监听。\n\n服务器的流程如下所述：\n\nwhile(server is active) {\n    listen for request\n    process request\n}\n\n\n如果一个请求需要占用大量的时间来处理，在这段时间内新的客户端就无法发送请求给服务端。只有服务器在监听的时候，请求才能被接收。另一种设计是，监听线程把请求传递给工作者线程(worker thread)，然后立刻返回去监听。而工作者线程则能够处理这个请求并发送一个回复给客户端。这种设计如下所述：\n\nwhile(server is active) {\n    listen for request\n    hand request to worker thread\n}\n\n\n这种方式，服务端线程迅速地返回去监听。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。\n\n桌面应用也是同样如此。如果你点击一个按钮开始运行一个耗时的任务，这个线程既要执行任务又要更新窗口和按钮，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。相反，任务可以传递给工作者线程（worker thread)。当工作者线程在繁忙地处理任务的时候，窗口线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。窗口线程便可以更新应用程序窗口，并显示任务的结果。对用户而言，这种具有工作者线程设计的程序显得响应速度更快。\n\n\n# 并发的问题\n\n任何事物都有利弊，并发也不例外。\n\n我们知道了并发带来的好处：提升资源利用率、程序响应更快，同时也要认识到并发带来的问题，主要有：\n\n * 安全性问题\n * 活跃性问题\n * 性能问题\n\n下面会一一讲解。\n\n\n# 安全性问题\n\n并发最重要的问题是并发安全问题。\n\n并发安全：是指保证程序的正确性，使得并发处理结果符合预期。\n\n并发安全需要保证几个基本特性：\n\n * 可见性 - 是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。\n * 原子性 - 简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制（加锁：sychronized、Lock）实现。\n * 有序性 - 是保证线程内串行语义，避免指令重排等。\n\n\n# 缓存导致的可见性问题\n\n> 一个线程对共享变量的修改，另外一个线程能够立刻看到，称为 可见性。\n\n在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如在下面的图中，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。\n\n\n\n多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。比如下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。\n\n\n\n【示例】线程不安全的示例\n\n下面我们再用一段代码来验证一下多核场景下的可见性问题。下面的代码，每执行一次 add10K() 方法，都会循环 10000 次 count+=1 操作。在 calc() 方法中我们创建了两个线程，每个线程调用一次 add10K() 方法，我们来想一想执行 calc() 方法得到的结果应该是多少呢？\n\npublic class Test {\n  private long count = 0;\n  private void add10K() {\n    int idx = 0;\n    while(idx++ < 10000) {\n      count += 1;\n    }\n  }\n  public static long calc() {\n    final Test test = new Test();\n    // 创建两个线程，执行 add() 操作\n    Thread th1 = new Thread(()->{\n      test.add10K();\n    });\n    Thread th2 = new Thread(()->{\n      test.add10K();\n    });\n    // 启动两个线程\n    th1.start();\n    th2.start();\n    // 等待两个线程执行结束\n    th1.join();\n    th2.join();\n    return count;\n  }\n}\n\n\n直觉告诉我们应该是 20000，因为在单线程里调用两次 add10K() 方法，count 的值就是 20000，但实际上 calc() 的执行结果是个 10000 到 20000 之间的随机数。为什么呢？\n\n我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。这就是缓存的可见性问题。\n\n循环 10000 次 count+=1 操作如果改为循环 1 亿次，你会发现效果更明显，最终 count 的值接近 1 亿，而不是 2 亿。如果循环 10000 次，count 的值接近 20000，原因是两个线程不是同时启动的，有一个时差。\n\n\n\n\n# 线程切换带来的原子性问题\n\n由于 IO 太慢，早期的操作系统就发明了多进程，操作系统允许某个进程执行一小段时间（称为 时间片）。\n\n在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了。\n\n这里的进程在等待 IO 时之所以会释放 CPU 使用权，是为了让 CPU 在这段等待时间里可以做别的事情，这样一来 CPU 的使用率就上来了；此外，如果这时有另外一个进程也读文件，读文件的操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队的任务，就会立即启动下一个读操作，这样 IO 的使用率也上来了。\n\n早期的操作系统基于进程来调度 CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。\n\nJava 并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的 count += 1，至少需要三条 CPU 指令。\n\n * 指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；\n * 指令 2：之后，在寄存器中执行 +1 操作；\n * 指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。\n\n操作系统做任务切换，可以发生在任何一条CPU 指令执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。\n\n\n\n我们潜意识里面觉得 count+=1 这个操作是一个不可分割的整体，就像一个原子一样，线程的切换可以发生在 count+=1 之前，也可以发生在 count+=1 之后，但就是不会发生在中间。我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。\n\n\n# 编译优化带来的有序性问题\n\n那并发编程里还有没有其他有违直觉容易导致诡异 Bug 的技术呢？有的，就是有序性。顾名思义，有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 Bug。\n\n在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getInstance() 的方法中，我们首先判断 instance 是否为空，如果为空，则锁定 Singleton.class 并再次检查 instance 是否为空，如果还为空则创建 Singleton 的一个实例。\n\npublic class Singleton {\n  static Singleton instance;\n  static Singleton getInstance(){\n    if (instance == null) {\n      synchronized(Singleton.class) {\n        if (instance == null)\n          instance = new Singleton();\n        }\n    }\n    return instance;\n  }\n}\n\n\n假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。\n\n这看上去一切都很完美，无懈可击，但实际上这个 getInstance() 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：\n\n 1. 分配一块内存 M；\n 2. 在内存 M 上初始化 Singleton 对象；\n 3. 然后 M 的地址赋值给 instance 变量。\n\n但是实际上优化后的执行路径却是这样的：\n\n 1. 分配一块内存 M；\n 2. 将 M 的地址赋值给 instance 变量；\n 3. 最后在内存 M 上初始化 Singleton 对象。\n\n优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。\n\n\n\n\n# 保证并发安全的思路\n\n# 互斥同步（阻塞同步）\n\n互斥同步是最常见的并发正确性保障手段。\n\n同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只能被一个线程访问。\n\n互斥是实现同步的一种手段。临界区（Critical Sections）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。\n\n最典型的案例是使用 synchronized 或 Lock 。\n\n互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。\n\n# 非阻塞同步\n\n随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。\n\n为什么说乐观锁需要 硬件指令集的发展 才能进行？因为需要操作和冲突检测这两个步骤具备原子性。而这点是由硬件来完成，如果再使用互斥同步来保证就失去意义了。\n\n这类乐观锁指令常见的有：\n\n * 测试并设置（Test-and-Set）\n * 获取并增加（Fetch-and-Increment）\n * 交换（Swap）\n * 比较并交换（CAS）\n * 加载链接、条件存储（Load-linked / Store-Conditional）\n\nJava 典型应用场景：J.U.C 包中的原子类（基于 Unsafe 类的 CAS 操作）\n\n# 无同步\n\n要保证线程安全，不一定非要进行同步。同步只是保证共享数据争用时的正确性，如果一个方法本来就不涉及共享数据，那么自然无须同步。\n\nJava 中的 无同步方案 有：\n\n * 可重入代码 - 也叫纯代码。如果一个方法，它的 返回结果是可以预测的，即只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性，当然也是线程安全的。\n * 线程本地存储 - 使用 ThreadLocal 为共享变量在每个线程中都创建了一个本地副本，这个副本只能被当前线程访问，其他线程无法访问，那么自然是线程安全的。\n\n\n# 活跃性问题\n\n\n# 死锁（Deadlock）\n\n# 什么是死锁\n\n多个线程互相等待对方释放锁。\n\n死锁是当线程进入无限期等待状态时发生的情况，因为所请求的锁被另一个线程持有，而另一个线程又等待第一个线程持有的另一个锁。\n\n\n\n# 避免死锁\n\n（1）按序加锁\n\n当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。\n\n如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。\n\n按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。\n\n（2）超时释放锁\n\n另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。\n\n（3）死锁检测\n\n死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。\n\n每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph 等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。\n\n当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。\n\n如果检测出死锁，有两种处理手段：\n\n * 释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。\n * 一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。\n\n\n# 活锁（Livelock）\n\n# 什么是活锁\n\n活锁是一个递归的情况，两个或更多的线程会不断重复一个特定的代码逻辑。预期的逻辑通常为其他线程提供机会继续支持'this'线程。\n\n想象这样一个例子：两个人在狭窄的走廊里相遇，二者都很礼貌，试图移到旁边让对方先通过。但是他们最终在没有取得任何进展的情况下左右摇摆，因为他们都在同一时间向相同的方向移动。\n\n\n\n如图所示：两个线程想要通过一个 Worker 对象访问共享公共资源的情况，但是当他们看到另一个 Worker（在另一个线程上调用）也是“活动的”时，它们会尝试将该资源交给其他工作者并等待为它完成。如果最初我们让两名工作人员都活跃起来，他们将会面临活锁问题。\n\n# 避免活锁\n\n解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。由于等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“等待一个随机时间”的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中也用到了它。\n\n\n# 饥饿（Starvation）\n\n# 什么是饥饿\n\n * 高优先级线程吞噬所有的低优先级线程的 CPU 时间。\n * 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。\n * 线程在等待一个本身(在其上调用 wait())也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒。\n\n\n\n饥饿问题最经典的例子就是哲学家问题。如图所示：有五个哲学家用餐，每个人要获得两把叉子才可以就餐。当 2、4 就餐时，1、3、5 永远无法就餐，只能看着盘中的美食饥饿的等待着。\n\n# 解决饥饿\n\nJava 不可能实现 100% 的公平性，我们依然可以通过同步结构在线程间实现公平性的提高。\n\n有三种方案：\n\n * 保证资源充足\n * 公平地分配资源\n * 避免持有锁的线程长时间执行\n\n这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。\n\n那如何公平地分配资源呢？在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。\n\n\n# 性能问题\n\n并发执行一定比串行执行快吗？线程越多执行越快吗？\n\n答案是：并发不一定比串行快。因为有创建线程和线程上下文切换的开销。\n\n\n# 上下文切换\n\n# 什么是上下文切换？\n\n当 CPU 从执行一个线程切换到执行另一个线程时，CPU 需要保存当前线程的本地数据，程序指针等状态，并加载下一个要执行的线程的本地数据，程序指针等。这个开关被称为“上下文切换”。\n\n# 减少上下文切换的方法\n\n * 无锁并发编程 - 多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照 Hash 算法取模分段，不同的线程处理不同段的数据。\n * CAS 算法 - Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。\n * 使用最少线程 - 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。\n * 使用协程 - 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。\n\n\n# 资源限制\n\n# 什么是资源限制\n\n资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。\n\n# 资源限制引发的问题\n\n在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。\n\n# 如何解决资源限制的问题\n\n在资源限制情况下进行并发编程，根据不同的资源限制调整程序的并发度。\n\n * 对于硬件资源限制，可以考虑使用集群并行执行程序。\n * 对于软件资源限制，可以考虑使用资源池将资源复用。\n\n\n# 小结\n\n并发编程可以总结为三个核心问题：分工、同步、互斥。\n\n * 分工：是指如何高效地拆解任务并分配给线程。\n * 同步：是指线程之间如何协作。\n * 互斥：是指保证同一时刻只允许一个线程访问共享资源。\n\n\n# 参考资料\n\n * 《Java 并发编程实战》\n * 《Java 并发编程的艺术》\n * 《深入理解 Java 虚拟机》\n * 《Java 并发编程实战》\n * http://tutorials.jenkov.com/java-concurrency/benefits.html\n * https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/thread-deadlock.html\n * https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/thread-livelock.html\n * https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/thread-starvation.html\n * https://www.zhihu.com/question/33515481\n * https://blog.csdn.net/yaosiming2011/article/details/44280797",normalizedContent:"# java 并发简介\n\n> 关键词：进程、线程、安全性、活跃性、性能、死锁、饥饿、上下文切换\n> \n> 摘要：并发编程并非 java 语言所独有，而是一种成熟的编程范式，java 只是用自己的方式实现了并发工作模型。学习 java 并发编程，应该先熟悉并发的基本概念，然后进一步了解并发的特性以及其特性所面临的问题。掌握了这些，当学习 java 并发工具时，才会明白它们各自是为了解决什么问题，为什么要这样设计。通过这样由点到面的学习方式，更容易融会贯通，将并发知识形成体系化。\n\n\n\n\n# 并发概念\n\n并发编程中有很多术语概念相近，容易让人混淆。本节内容通过对比分析，力求让读者清晰理解其概念以及差异。\n\n\n# 并发和并行\n\n并发和并行是最容易让新手费解的概念，那么如何理解二者呢？其最关键的差异在于：是否是同时发生：\n\n * 并发：是指具备处理多个任务的能力，但不一定要同时。\n * 并行：是指具备同时处理多个任务的能力。\n\n下面是我见过最生动的说明，摘自 并发与并行的区别是什么？——知乎的高票答案：\n\n * 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。\n * 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。\n * 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。\n\n\n# 同步和异步\n\n * 同步：是指在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。\n * 异步：则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。\n\n举例来说明：\n\n * 同步就像是打电话：不挂电话，通话不会结束。\n * 异步就像是发短信：发完短信后，就可以做其他事；当收到回复短信时，手机会通过铃声或振动来提醒。\n\n\n# 阻塞和非阻塞\n\n阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：\n\n * 阻塞：是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n * 非阻塞：是指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n\n举例来说明：\n\n * 阻塞调用就像是打电话，通话不结束，不能放下。\n * 非阻塞调用就像是发短信，发完短信后，就可以做其他事，短信来了，手机会提醒。\n\n\n# 进程和线程\n\n * 进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。进程可视为一个正在运行的程序。\n * 线程：线程是操作系统进行调度的基本单位。\n\n进程和线程的差异：\n\n * 一个程序至少有一个进程，一个进程至少有一个线程。\n * 线程比进程划分更细，所以执行开销更小，并发性更高\n * 进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。\n\n\n\njvm 在单个进程中运行，jvm 中的线程共享属于该进程的堆。这就是为什么几个线程可以访问同一个对象。线程共享堆并拥有自己的堆栈空间。这是一个线程如何调用一个方法以及它的局部变量是如何保持线程安全的。但是堆不是线程安全的并且为了线程安全必须进行同步。\n\n\n# 竞态条件和临界区\n\n * 竞态条件（race condition）：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。\n\n * 临界区（critical sections）：导致竞态条件发生的代码区称作临界区。\n\n\n# 管程\n\n管程（monitor），是指管理共享变量以及对共享变量的操作过程，让他们支持并发。\n\njava 采用的是管程技术，synchronized 关键字及 wait()、notify()、notifyall() 这三个方法都是管程的组成部分。而管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。\n\n\n# 并发的特点\n\n技术在进步，cpu、内存、i/o 设备的性能也在不断提高。但是，始终存在一个核心矛盾：cpu、内存、i/o 设备存在速度差异。cpu 远快于内存，内存远快于 i/o 设备。\n\n木桶短板理论告诉我们：一只木桶能装多少水，取决于最短的那块木板。同理，程序整体性能取决于最慢的操作（即 i/o 操作），所以单方面提高 cpu、内存的性能是无效的。\n\n\n\n为了合理利用 cpu 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：\n\n * cpu 增加了缓存，以均衡与内存的速度差异；\n * 操作系统增加了进程、线程，以分时复用 cpu，进而均衡 cpu 与 i/o 设备的速度差异；\n * 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。\n\n其中，进程、线程使得计算机、程序有了并发处理任务的能力。\n\n并发的优点在于：\n\n * 提升资源利用率\n * 程序响应更快\n\n\n# 提升资源利用率\n\n想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要 5 秒，处理一个文件需要 2 秒。处理两个文件则需要：\n\n5秒读取文件a\n2秒处理文件a\n5秒读取文件b\n2秒处理文件b\n---------------------\n总共需要14秒\n\n\n从磁盘中读取文件的时候，大部分的 cpu 时间用于等待磁盘去读取数据。在这段时间里，cpu 非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用 cpu 资源。看下面的顺序：\n\n5秒读取文件a\n5秒读取文件b + 2秒处理文件a\n2秒处理文件b\n---------------------\n总共需要12秒\n\n\ncpu 等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，cpu 会去处理第一个文件。记住，在等待磁盘读取文件的时候，cpu 大 部分时间是空闲的。\n\n总的说来，cpu 能够在等待 io 的时候做一些其他的事情。这个不一定就是磁盘 io。它也可以是网络的 io，或者用户输入。通常情况下，网络和磁盘的 io 比 cpu 和内存的 io 慢的多。\n\n\n# 程序响应更快\n\n将一个单线程应用程序变成多线程应用程序的另一个常见的目的是实现一个响应更快的应用程序。设想一个服务器应用，它在某一个端口监听进来的请求。当一个请求到来时，它去处理这个请求，然后再返回去监听。\n\n服务器的流程如下所述：\n\nwhile(server is active) {\n    listen for request\n    process request\n}\n\n\n如果一个请求需要占用大量的时间来处理，在这段时间内新的客户端就无法发送请求给服务端。只有服务器在监听的时候，请求才能被接收。另一种设计是，监听线程把请求传递给工作者线程(worker thread)，然后立刻返回去监听。而工作者线程则能够处理这个请求并发送一个回复给客户端。这种设计如下所述：\n\nwhile(server is active) {\n    listen for request\n    hand request to worker thread\n}\n\n\n这种方式，服务端线程迅速地返回去监听。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。\n\n桌面应用也是同样如此。如果你点击一个按钮开始运行一个耗时的任务，这个线程既要执行任务又要更新窗口和按钮，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。相反，任务可以传递给工作者线程（worker thread)。当工作者线程在繁忙地处理任务的时候，窗口线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。窗口线程便可以更新应用程序窗口，并显示任务的结果。对用户而言，这种具有工作者线程设计的程序显得响应速度更快。\n\n\n# 并发的问题\n\n任何事物都有利弊，并发也不例外。\n\n我们知道了并发带来的好处：提升资源利用率、程序响应更快，同时也要认识到并发带来的问题，主要有：\n\n * 安全性问题\n * 活跃性问题\n * 性能问题\n\n下面会一一讲解。\n\n\n# 安全性问题\n\n并发最重要的问题是并发安全问题。\n\n并发安全：是指保证程序的正确性，使得并发处理结果符合预期。\n\n并发安全需要保证几个基本特性：\n\n * 可见性 - 是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。\n * 原子性 - 简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制（加锁：sychronized、lock）实现。\n * 有序性 - 是保证线程内串行语义，避免指令重排等。\n\n\n# 缓存导致的可见性问题\n\n> 一个线程对共享变量的修改，另外一个线程能够立刻看到，称为 可见性。\n\n在单核时代，所有的线程都是在一颗 cpu 上执行，cpu 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 cpu 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如在下面的图中，线程 a 和线程 b 都是操作同一个 cpu 里面的缓存，所以线程 a 更新了变量 v 的值，那么线程 b 之后再访问变量 v，得到的一定是 v 的最新值（线程 a 写过的值）。\n\n\n\n多核时代，每颗 cpu 都有自己的缓存，这时 cpu 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 cpu 上执行时，这些线程操作的是不同的 cpu 缓存。比如下图中，线程 a 操作的是 cpu-1 上的缓存，而线程 b 操作的是 cpu-2 上的缓存，很明显，这个时候线程 a 对变量 v 的操作对于线程 b 而言就不具备可见性了。\n\n\n\n【示例】线程不安全的示例\n\n下面我们再用一段代码来验证一下多核场景下的可见性问题。下面的代码，每执行一次 add10k() 方法，都会循环 10000 次 count+=1 操作。在 calc() 方法中我们创建了两个线程，每个线程调用一次 add10k() 方法，我们来想一想执行 calc() 方法得到的结果应该是多少呢？\n\npublic class test {\n  private long count = 0;\n  private void add10k() {\n    int idx = 0;\n    while(idx++ < 10000) {\n      count += 1;\n    }\n  }\n  public static long calc() {\n    final test test = new test();\n    // 创建两个线程，执行 add() 操作\n    thread th1 = new thread(()->{\n      test.add10k();\n    });\n    thread th2 = new thread(()->{\n      test.add10k();\n    });\n    // 启动两个线程\n    th1.start();\n    th2.start();\n    // 等待两个线程执行结束\n    th1.join();\n    th2.join();\n    return count;\n  }\n}\n\n\n直觉告诉我们应该是 20000，因为在单线程里调用两次 add10k() 方法，count 的值就是 20000，但实际上 calc() 的执行结果是个 10000 到 20000 之间的随机数。为什么呢？\n\n我们假设线程 a 和线程 b 同时开始执行，那么第一次都会将 count=0 读到各自的 cpu 缓存里，执行完 count+=1 之后，各自 cpu 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。之后由于各自的 cpu 缓存里都有了 count 的值，两个线程都是基于 cpu 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。这就是缓存的可见性问题。\n\n循环 10000 次 count+=1 操作如果改为循环 1 亿次，你会发现效果更明显，最终 count 的值接近 1 亿，而不是 2 亿。如果循环 10000 次，count 的值接近 20000，原因是两个线程不是同时启动的，有一个时差。\n\n\n\n\n# 线程切换带来的原子性问题\n\n由于 io 太慢，早期的操作系统就发明了多进程，操作系统允许某个进程执行一小段时间（称为 时间片）。\n\n在一个时间片内，如果一个进程进行一个 io 操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让 cpu 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 cpu 的使用权了。\n\n这里的进程在等待 io 时之所以会释放 cpu 使用权，是为了让 cpu 在这段等待时间里可以做别的事情，这样一来 cpu 的使用率就上来了；此外，如果这时有另外一个进程也读文件，读文件的操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队的任务，就会立即启动下一个读操作，这样 io 的使用率也上来了。\n\n早期的操作系统基于进程来调度 cpu，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。\n\njava 并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 cpu 指令完成，例如上面代码中的 count += 1，至少需要三条 cpu 指令。\n\n * 指令 1：首先，需要把变量 count 从内存加载到 cpu 的寄存器；\n * 指令 2：之后，在寄存器中执行 +1 操作；\n * 指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 cpu 缓存而不是内存）。\n\n操作系统做任务切换，可以发生在任何一条cpu 指令执行完，是的，是 cpu 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 a 在指令 1 执行完后做线程切换，线程 a 和线程 b 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。\n\n\n\n我们潜意识里面觉得 count+=1 这个操作是一个不可分割的整体，就像一个原子一样，线程的切换可以发生在 count+=1 之前，也可以发生在 count+=1 之后，但就是不会发生在中间。我们把一个或者多个操作在 cpu 执行的过程中不被中断的特性称为原子性。cpu 能保证的原子操作是 cpu 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。\n\n\n# 编译优化带来的有序性问题\n\n那并发编程里还有没有其他有违直觉容易导致诡异 bug 的技术呢？有的，就是有序性。顾名思义，有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 bug。\n\n在 java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getinstance() 的方法中，我们首先判断 instance 是否为空，如果为空，则锁定 singleton.class 并再次检查 instance 是否为空，如果还为空则创建 singleton 的一个实例。\n\npublic class singleton {\n  static singleton instance;\n  static singleton getinstance(){\n    if (instance == null) {\n      synchronized(singleton.class) {\n        if (instance == null)\n          instance = new singleton();\n        }\n    }\n    return instance;\n  }\n}\n\n\n假设有两个线程 a、b 同时调用 getinstance() 方法，他们会同时发现 instance == null ，于是同时对 singleton.class 加锁，此时 jvm 保证只有一个线程能够加锁成功（假设是线程 a），另外一个线程则会处于等待状态（假设是线程 b）；线程 a 会创建一个 singleton 实例，之后释放锁，锁释放后，线程 b 被唤醒，线程 b 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 b 检查 instance == null 时会发现，已经创建过 singleton 实例了，所以线程 b 不会再创建一个 singleton 实例。\n\n这看上去一切都很完美，无懈可击，但实际上这个 getinstance() 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：\n\n 1. 分配一块内存 m；\n 2. 在内存 m 上初始化 singleton 对象；\n 3. 然后 m 的地址赋值给 instance 变量。\n\n但是实际上优化后的执行路径却是这样的：\n\n 1. 分配一块内存 m；\n 2. 将 m 的地址赋值给 instance 变量；\n 3. 最后在内存 m 上初始化 singleton 对象。\n\n优化后会导致什么问题呢？我们假设线程 a 先执行 getinstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 b 上；如果此时线程 b 也执行 getinstance() 方法，那么线程 b 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。\n\n\n\n\n# 保证并发安全的思路\n\n# 互斥同步（阻塞同步）\n\n互斥同步是最常见的并发正确性保障手段。\n\n同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只能被一个线程访问。\n\n互斥是实现同步的一种手段。临界区（critical sections）、互斥量（mutex）和信号量（semaphore）都是主要的互斥实现方式。\n\n最典型的案例是使用 synchronized 或 lock 。\n\n互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。\n\n# 非阻塞同步\n\n随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。\n\n为什么说乐观锁需要 硬件指令集的发展 才能进行？因为需要操作和冲突检测这两个步骤具备原子性。而这点是由硬件来完成，如果再使用互斥同步来保证就失去意义了。\n\n这类乐观锁指令常见的有：\n\n * 测试并设置（test-and-set）\n * 获取并增加（fetch-and-increment）\n * 交换（swap）\n * 比较并交换（cas）\n * 加载链接、条件存储（load-linked / store-conditional）\n\njava 典型应用场景：j.u.c 包中的原子类（基于 unsafe 类的 cas 操作）\n\n# 无同步\n\n要保证线程安全，不一定非要进行同步。同步只是保证共享数据争用时的正确性，如果一个方法本来就不涉及共享数据，那么自然无须同步。\n\njava 中的 无同步方案 有：\n\n * 可重入代码 - 也叫纯代码。如果一个方法，它的 返回结果是可以预测的，即只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性，当然也是线程安全的。\n * 线程本地存储 - 使用 threadlocal 为共享变量在每个线程中都创建了一个本地副本，这个副本只能被当前线程访问，其他线程无法访问，那么自然是线程安全的。\n\n\n# 活跃性问题\n\n\n# 死锁（deadlock）\n\n# 什么是死锁\n\n多个线程互相等待对方释放锁。\n\n死锁是当线程进入无限期等待状态时发生的情况，因为所请求的锁被另一个线程持有，而另一个线程又等待第一个线程持有的另一个锁。\n\n\n\n# 避免死锁\n\n（1）按序加锁\n\n当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。\n\n如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。\n\n按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。\n\n（2）超时释放锁\n\n另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。\n\n（3）死锁检测\n\n死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。\n\n每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph 等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。\n\n当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。\n\n如果检测出死锁，有两种处理手段：\n\n * 释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。\n * 一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。\n\n\n# 活锁（livelock）\n\n# 什么是活锁\n\n活锁是一个递归的情况，两个或更多的线程会不断重复一个特定的代码逻辑。预期的逻辑通常为其他线程提供机会继续支持'this'线程。\n\n想象这样一个例子：两个人在狭窄的走廊里相遇，二者都很礼貌，试图移到旁边让对方先通过。但是他们最终在没有取得任何进展的情况下左右摇摆，因为他们都在同一时间向相同的方向移动。\n\n\n\n如图所示：两个线程想要通过一个 worker 对象访问共享公共资源的情况，但是当他们看到另一个 worker（在另一个线程上调用）也是“活动的”时，它们会尝试将该资源交给其他工作者并等待为它完成。如果最初我们让两名工作人员都活跃起来，他们将会面临活锁问题。\n\n# 避免活锁\n\n解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。由于等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“等待一个随机时间”的方案虽然很简单，却非常有效，raft 这样知名的分布式一致性算法中也用到了它。\n\n\n# 饥饿（starvation）\n\n# 什么是饥饿\n\n * 高优先级线程吞噬所有的低优先级线程的 cpu 时间。\n * 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。\n * 线程在等待一个本身(在其上调用 wait())也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒。\n\n\n\n饥饿问题最经典的例子就是哲学家问题。如图所示：有五个哲学家用餐，每个人要获得两把叉子才可以就餐。当 2、4 就餐时，1、3、5 永远无法就餐，只能看着盘中的美食饥饿的等待着。\n\n# 解决饥饿\n\njava 不可能实现 100% 的公平性，我们依然可以通过同步结构在线程间实现公平性的提高。\n\n有三种方案：\n\n * 保证资源充足\n * 公平地分配资源\n * 避免持有锁的线程长时间执行\n\n这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。\n\n那如何公平地分配资源呢？在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。\n\n\n# 性能问题\n\n并发执行一定比串行执行快吗？线程越多执行越快吗？\n\n答案是：并发不一定比串行快。因为有创建线程和线程上下文切换的开销。\n\n\n# 上下文切换\n\n# 什么是上下文切换？\n\n当 cpu 从执行一个线程切换到执行另一个线程时，cpu 需要保存当前线程的本地数据，程序指针等状态，并加载下一个要执行的线程的本地数据，程序指针等。这个开关被称为“上下文切换”。\n\n# 减少上下文切换的方法\n\n * 无锁并发编程 - 多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 id 按照 hash 算法取模分段，不同的线程处理不同段的数据。\n * cas 算法 - java 的 atomic 包使用 cas 算法来更新数据，而不需要加锁。\n * 使用最少线程 - 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。\n * 使用协程 - 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。\n\n\n# 资源限制\n\n# 什么是资源限制\n\n资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。\n\n# 资源限制引发的问题\n\n在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。\n\n# 如何解决资源限制的问题\n\n在资源限制情况下进行并发编程，根据不同的资源限制调整程序的并发度。\n\n * 对于硬件资源限制，可以考虑使用集群并行执行程序。\n * 对于软件资源限制，可以考虑使用资源池将资源复用。\n\n\n# 小结\n\n并发编程可以总结为三个核心问题：分工、同步、互斥。\n\n * 分工：是指如何高效地拆解任务并分配给线程。\n * 同步：是指线程之间如何协作。\n * 互斥：是指保证同一时刻只允许一个线程访问共享资源。\n\n\n# 参考资料\n\n * 《java 并发编程实战》\n * 《java 并发编程的艺术》\n * 《深入理解 java 虚拟机》\n * 《java 并发编程实战》\n * http://tutorials.jenkov.com/java-concurrency/benefits.html\n * https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/thread-deadlock.html\n * https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/thread-livelock.html\n * https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/thread-starvation.html\n * https://www.zhihu.com/question/33515481\n * https://blog.csdn.net/yaosiming2011/article/details/44280797",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java线程基础",frontmatter:{title:"Java线程基础",categories:["编程","Java","JavaSE","并发"],tags:["Java","JavaSE","并发","线程"],abbrlink:"ce588cc4",date:"2019-12-24T23:52:25.000Z",permalink:"/pages/1f74be/"},regularPath:"/05.%E5%B9%B6%E5%8F%91/02.Java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html",relativePath:"05.并发/02.Java线程基础.md",key:"v-7127b67f",path:"/pages/1f74be/",headers:[{level:2,title:"线程简介",slug:"线程简介",normalizedTitle:"线程简介",charIndex:104},{level:3,title:"什么是进程",slug:"什么是进程",normalizedTitle:"什么是进程",charIndex:113},{level:3,title:"什么是线程",slug:"什么是线程",normalizedTitle:"什么是线程",charIndex:217},{level:3,title:"进程和线程的区别",slug:"进程和线程的区别",normalizedTitle:"进程和线程的区别",charIndex:332},{level:2,title:"创建线程",slug:"创建线程",normalizedTitle:"创建线程",charIndex:443},{level:3,title:"Thread",slug:"thread",normalizedTitle:"thread",charIndex:19},{level:3,title:"Runnable",slug:"runnable",normalizedTitle:"runnable",charIndex:26},{level:3,title:"Callable、Future、FutureTask",slug:"callable、future、futuretask",normalizedTitle:"callable、future、futuretask",charIndex:2284},{level:4,title:"Callable",slug:"callable",normalizedTitle:"callable",charIndex:35},{level:4,title:"Future",slug:"future",normalizedTitle:"future",charIndex:44},{level:4,title:"FutureTask",slug:"futuretask",normalizedTitle:"futuretask",charIndex:2300},{level:4,title:"Callable + Future + FutureTask 示例",slug:"callable-future-futuretask-示例",normalizedTitle:"callable + future + futuretask 示例",charIndex:3865},{level:2,title:"线程基本用法",slug:"线程基本用法",normalizedTitle:"线程基本用法",charIndex:5079},{level:3,title:"线程休眠",slug:"线程休眠",normalizedTitle:"线程休眠",charIndex:5776},{level:3,title:"线程礼让",slug:"线程礼让",normalizedTitle:"线程礼让",charIndex:6860},{level:3,title:"终止线程",slug:"终止线程",normalizedTitle:"终止线程",charIndex:7716},{level:3,title:"守护线程",slug:"守护线程",normalizedTitle:"守护线程",charIndex:5452},{level:2,title:"线程通信",slug:"线程通信",normalizedTitle:"线程通信",charIndex:95},{level:3,title:"wait/notify/notifyAll",slug:"wait-notify-notifyall",normalizedTitle:"wait/notify/notifyall",charIndex:12221},{level:3,title:"join",slug:"join",normalizedTitle:"join",charIndex:73},{level:3,title:"管道",slug:"管道",normalizedTitle:"管道",charIndex:16662},{level:2,title:"线程生命周期",slug:"线程生命周期",normalizedTitle:"线程生命周期",charIndex:17845},{level:2,title:"线程常见问题",slug:"线程常见问题",normalizedTitle:"线程常见问题",charIndex:19356},{level:3,title:"sleep、yield、join 方法有什么区别",slug:"sleep、yield、join-方法有什么区别",normalizedTitle:"sleep、yield、join 方法有什么区别",charIndex:19367},{level:3,title:"为什么 sleep 和 yield 方法是静态的",slug:"为什么-sleep-和-yield-方法是静态的",normalizedTitle:"为什么 sleep 和 yield 方法是静态的",charIndex:19847},{level:3,title:"Java 线程是否按照线程优先级严格执行",slug:"java-线程是否按照线程优先级严格执行",normalizedTitle:"java 线程是否按照线程优先级严格执行",charIndex:20022},{level:3,title:"一个线程两次调用 start()方法会怎样",slug:"一个线程两次调用-start-方法会怎样",normalizedTitle:"一个线程两次调用 start()方法会怎样",charIndex:20147},{level:3,title:"start 和 run 方法有什么区别",slug:"start-和-run-方法有什么区别",normalizedTitle:"start 和 run 方法有什么区别",charIndex:20262},{level:3,title:"可以直接调用 Thread 类的 run 方法么",slug:"可以直接调用-thread-类的-run-方法么",normalizedTitle:"可以直接调用 thread 类的 run 方法么",charIndex:20347},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:20467}],headersStr:"线程简介 什么是进程 什么是线程 进程和线程的区别 创建线程 Thread Runnable Callable、Future、FutureTask Callable Future FutureTask Callable + Future + FutureTask 示例 线程基本用法 线程休眠 线程礼让 终止线程 守护线程 线程通信 wait/notify/notifyAll join 管道 线程生命周期 线程常见问题 sleep、yield、join 方法有什么区别 为什么 sleep 和 yield 方法是静态的 Java 线程是否按照线程优先级严格执行 一个线程两次调用 start()方法会怎样 start 和 run 方法有什么区别 可以直接调用 Thread 类的 run 方法么 参考资料",content:'# Java 线程基础\n\n> 关键词：Thread、Runnable、Callable、Future、wait、notify、notifyAll、join、sleep、yeild、线程状态、线程通信\n\n\n# 线程简介\n\n\n# 什么是进程\n\n简言之，进程可视为一个正在运行的程序。它是系统运行程序的基本单位，因此进程是动态的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。\n\n\n# 什么是线程\n\n线程是操作系统进行调度的基本单位。线程也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。\n\n\n# 进程和线程的区别\n\n * 一个程序至少有一个进程，一个进程至少有一个线程。\n * 线程比进程划分更细，所以执行开销更小，并发性更高。\n * 进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。\n\n\n# 创建线程\n\n创建线程有三种方式：\n\n * 继承 Thread 类\n * 实现 Runnable 接口\n * 实现 Callable 接口\n\n\n# Thread\n\n通过继承 Thread 类创建线程的步骤：\n\n 1. 定义 Thread 类的子类，并覆写该类的 run 方法。run 方法的方法体就代表了线程要完成的任务，因此把 run 方法称为执行体。\n 2. 创建 Thread 子类的实例，即创建了线程对象。\n 3. 调用线程对象的 start 方法来启动该线程。\n\npublic class ThreadDemo {\n\n    public static void main(String[] args) {\n        // 实例化对象\n        MyThread tA = new MyThread("Thread 线程-A");\n        MyThread tB = new MyThread("Thread 线程-B");\n        // 调用线程主体\n        tA.start();\n        tB.start();\n    }\n\n    static class MyThread extends Thread {\n\n        private int ticket = 5;\n\n        MyThread(String name) {\n            super(name);\n        }\n\n        @Override\n        public void run() {\n            while (ticket > 0) {\n                System.out.println(Thread.currentThread().getName() + " 卖出了第 " + ticket + " 张票");\n                ticket--;\n            }\n        }\n\n    }\n\n}\n\n\n\n# Runnable\n\n实现 Runnable 接口优于继承 Thread 类，因为：\n\n * Java 不支持多重继承，所有的类都只允许继承一个父类，但可以实现多个接口。如果继承了 Thread 类就无法继承其它类，这不利于扩展。\n * 类可能只要求可执行就行，继承整个 Thread 类开销过大。\n\n通过实现 Runnable 接口创建线程的步骤：\n\n 1. 定义 Runnable 接口的实现类，并覆写该接口的 run 方法。该 run 方法的方法体同样是该线程的线程执行体。\n 2. 创建 Runnable 实现类的实例，并以此实例作为 Thread 的 target 来创建 Thread 对象，该 Thread 对象才是真正的线程对象。\n 3. 调用线程对象的 start 方法来启动该线程。\n\npublic class RunnableDemo {\n\n    public static void main(String[] args) {\n        // 实例化对象\n        Thread tA = new Thread(new MyThread(), "Runnable 线程-A");\n        Thread tB = new Thread(new MyThread(), "Runnable 线程-B");\n        // 调用线程主体\n        tA.start();\n        tB.start();\n    }\n\n    static class MyThread implements Runnable {\n\n        private int ticket = 5;\n\n        @Override\n        public void run() {\n            while (ticket > 0) {\n                System.out.println(Thread.currentThread().getName() + " 卖出了第 " + ticket + " 张票");\n                ticket--;\n            }\n        }\n\n    }\n\n}\n\n\n\n# Callable、Future、FutureTask\n\n继承 Thread 类和实现 Runnable 接口这两种创建线程的方式都没有返回值。所以，线程执行完后，无法得到执行结果。但如果期望得到执行结果该怎么做？\n\n为了解决这个问题，Java 1.5 后，提供了 Callable 接口和 Future 接口，通过它们，可以在线程执行结束后，返回执行结果。\n\n# Callable\n\nCallable 接口只声明了一个方法，这个方法叫做 call()：\n\npublic interface Callable<V> {\n    /**\n     * Computes a result, or throws an exception if unable to do so.\n     *\n     * @return computed result\n     * @throws Exception if unable to compute a result\n     */\n    V call() throws Exception;\n}\n\n\n那么怎么使用 Callable 呢？一般情况下是配合 ExecutorService 来使用的，在 ExecutorService 接口中声明了若干个 submit 方法的重载版本：\n\n<T> Future<T> submit(Callable<T> task);\n<T> Future<T> submit(Runnable task, T result);\nFuture<?> submit(Runnable task);\n\n\n第一个 submit 方法里面的参数类型就是 Callable。\n\n# Future\n\nFuture 就是对于具体的 Callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过 get 方法获取执行结果，该方法会阻塞直到任务返回结果。\n\npublic interface Future<V> {\n    boolean cancel(boolean mayInterruptIfRunning);\n    boolean isCancelled();\n    boolean isDone();\n    V get() throws InterruptedException, ExecutionException;\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n\n\n# FutureTask\n\nFutureTask 类实现了 RunnableFuture 接口，RunnableFuture 继承了 Runnable 接口和 Future 接口。\n\n所以，FutureTask 既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。\n\npublic class FutureTask<V> implements RunnableFuture<V> {\n    // ...\n    public FutureTask(Callable<V> callable) {}\n    public FutureTask(Runnable runnable, V result) {}\n}\n\npublic interface RunnableFuture<V> extends Runnable, Future<V> {\n    void run();\n}\n\n\n事实上，FutureTask 是 Future 接口的一个唯一实现类。\n\n# Callable + Future + FutureTask 示例\n\n通过实现 Callable 接口创建线程的步骤：\n\n 1. 创建 Callable 接口的实现类，并实现 call 方法。该 call 方法将作为线程执行体，并且有返回值。\n 2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call 方法的返回值。\n 3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。\n 4. 调用 FutureTask 对象的 get 方法来获得线程执行结束后的返回值。\n\npublic class CallableDemo {\n\n    public static void main(String[] args) {\n        Callable<Long> callable = new MyThread();\n        FutureTask<Long> future = new FutureTask<>(callable);\n        new Thread(future, "Callable 线程").start();\n        try {\n            System.out.println("任务耗时：" + (future.get() / 1000000) + "毫秒");\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class MyThread implements Callable<Long> {\n\n        private int ticket = 10000;\n\n        @Override\n        public Long call() {\n            long begin = System.nanoTime();\n            while (ticket > 0) {\n                System.out.println(Thread.currentThread().getName() + " 卖出了第 " + ticket + " 张票");\n                ticket--;\n            }\n\n            long end = System.nanoTime();\n            return (end - begin);\n        }\n\n    }\n\n}\n\n\n\n# 线程基本用法\n\n线程（Thread）基本方法清单：\n\n方法              描述\nrun             线程的执行实体。\nstart           线程的启动方法。\ncurrentThread   返回对当前正在执行的线程对象的引用。\nsetName         设置线程名称。\ngetName         获取线程名称。\nsetPriority     设置线程优先级。Java 中的线程优先级的范围是 [1,10]，一般来说，高优先级的线程在运行时会具有优先权。可以通过\n                thread.setPriority(Thread.MAX_PRIORITY) 的方式设置，默认优先级为 5。\ngetPriority     获取线程优先级。\nsetDaemon       设置线程为守护线程。\nisDaemon        判断线程是否为守护线程。\nisAlive         判断线程是否启动。\ninterrupt       中断另一个线程的运行状态。\ninterrupted     测试当前线程是否已被中断。通过此方法可以清除线程的中断状态。换句话说，如果要连续调用此方法两次，则第二次调用将返回\n                false（除非当前线程在第一次调用清除其中断状态之后且在第二次调用检查其状态之前再次中断）。\njoin            可以使一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行。\nThread.sleep    静态方法。将当前正在执行的线程休眠。\nThread.yield    静态方法。将当前正在执行的线程暂停，让其他线程执行。\n\n\n# 线程休眠\n\n使用 Thread.sleep 方法可以使得当前正在执行的线程进入休眠状态。\n\n使用 Thread.sleep 需要向其传入一个整数值，这个值表示线程将要休眠的毫秒数。\n\nThread.sleep 方法可能会抛出 InterruptedException，因为异常不能跨线程传播回 main 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。\n\npublic class ThreadSleepDemo {\n\n    public static void main(String[] args) {\n        new Thread(new MyThread("线程A", 500)).start();\n        new Thread(new MyThread("线程B", 1000)).start();\n        new Thread(new MyThread("线程C", 1500)).start();\n    }\n\n    static class MyThread implements Runnable {\n\n        /** 线程名称 */\n        private String name;\n\n        /** 休眠时间 */\n        private int time;\n\n        private MyThread(String name, int time) {\n            this.name = name;\n            this.time = time;\n        }\n\n        @Override\n        public void run() {\n            try {\n                // 休眠指定的时间\n                Thread.sleep(this.time);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(this.name + "休眠" + this.time + "毫秒。");\n        }\n\n    }\n\n}\n\n\n\n# 线程礼让\n\nThread.yield 方法的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行 。\n\n该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。\n\npublic class ThreadYieldDemo {\n\n    public static void main(String[] args) {\n        MyThread t = new MyThread();\n        new Thread(t, "线程A").start();\n        new Thread(t, "线程B").start();\n    }\n\n    static class MyThread implements Runnable {\n\n        @Override\n        public void run() {\n            for (int i = 0; i < 5; i++) {\n                try {\n                    Thread.sleep(1000);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + "运行，i = " + i);\n                if (i == 2) {\n                    System.out.print("线程礼让：");\n                    Thread.yield();\n                }\n            }\n        }\n    }\n}\n\n\n\n# 终止线程\n\n> Thread 中的 stop 方法有缺陷，已废弃。\n> \n> 使用 Thread.stop 停止线程会导致它解锁所有已锁定的监视器（由于未经检查的 ThreadDeath 异常会在堆栈中传播，这是自然的结果）。 如果先前由这些监视器保护的任何对象处于不一致状态，则损坏的对象将对其他线程可见，从而可能导致任意行为。\n> \n> stop() 方法会真的杀死线程，不给线程喘息的机会，如果线程持有 ReentrantLock 锁，被 stop() 的线程并不会自动调用 ReentrantLock 的 unlock() 去释放锁，那其他线程就再也没机会获得 ReentrantLock 锁，这实在是太危险了。所以该方法就不建议使用了，类似的方法还有 suspend() 和 resume() 方法，这两个方法同样也都不建议使用了，所以这里也就不多介绍了。Thread.stop 的许多用法应由仅修改某些变量以指示目标线程应停止运行的代码代替。 目标线程应定期检查此变量，如果该变量指示要停止运行，则应按有序方式从其运行方法返回。如果目标线程等待很长时间（例如，在条件变量上），则应使用中断方法来中断等待。\n\n当一个线程运行时，另一个线程可以直接通过 interrupt 方法中断其运行状态。\n\npublic class ThreadInterruptDemo {\n\n    public static void main(String[] args) {\n        MyThread mt = new MyThread(); // 实例化Runnable子类对象\n        Thread t = new Thread(mt, "线程"); // 实例化Thread对象\n        t.start(); // 启动线程\n        try {\n            Thread.sleep(2000); // 线程休眠2秒\n        } catch (InterruptedException e) {\n            System.out.println("3、main线程休眠被终止");\n        }\n        t.interrupt(); // 中断线程执行\n    }\n\n    static class MyThread implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println("1、进入run()方法");\n            try {\n                Thread.sleep(10000); // 线程休眠10秒\n                System.out.println("2、已经完成了休眠");\n            } catch (InterruptedException e) {\n                System.out.println("3、MyThread线程休眠被终止");\n                return; // 返回调用处\n            }\n            System.out.println("4、run()方法正常结束");\n        }\n    }\n}\n\n\n如果一个线程的 run 方法执行一个无限循环，并且没有执行 sleep 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt 方法就无法使线程提前结束。\n\n但是调用 interrupt 方法会设置线程的中断标记，此时调用 interrupted 方法会返回 true。因此可以在循环体中使用 interrupted 方法来判断线程是否处于中断状态，从而提前结束线程。\n\n安全地终止线程有两种方法：\n\n * 定义 volatile 标志位，在 run 方法中使用标志位控制线程终止\n * 使用 interrupt 方法和 Thread.interrupted 方法配合使用来控制线程终止\n\n【示例】使用 volatile 标志位控制线程终止\n\npublic class ThreadStopDemo2 {\n\n    public static void main(String[] args) throws Exception {\n        MyTask task = new MyTask();\n        Thread thread = new Thread(task, "MyTask");\n        thread.start();\n        TimeUnit.MILLISECONDS.sleep(50);\n        task.cancel();\n    }\n\n    private static class MyTask implements Runnable {\n\n        private volatile boolean flag = true;\n\n        private volatile long count = 0L;\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getName() + " 线程启动");\n            while (flag) {\n                System.out.println(count++);\n            }\n            System.out.println(Thread.currentThread().getName() + " 线程终止");\n        }\n\n        /**\n         * 通过 volatile 标志位来控制线程终止\n         */\n        public void cancel() {\n            flag = false;\n        }\n\n    }\n\n}\n\n\n【示例】使用 interrupt 方法和 Thread.interrupted 方法配合使用来控制线程终止\n\npublic class ThreadStopDemo3 {\n\n    public static void main(String[] args) throws Exception {\n        MyTask task = new MyTask();\n        Thread thread = new Thread(task, "MyTask");\n        thread.start();\n        TimeUnit.MILLISECONDS.sleep(50);\n        thread.interrupt();\n    }\n\n    private static class MyTask implements Runnable {\n\n        private volatile long count = 0L;\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getName() + " 线程启动");\n            // 通过 Thread.interrupted 和 interrupt 配合来控制线程终止\n            while (!Thread.interrupted()) {\n                System.out.println(count++);\n            }\n            System.out.println(Thread.currentThread().getName() + " 线程终止");\n        }\n    }\n}\n\n\n\n# 守护线程\n\n什么是守护线程？\n\n * 守护线程（Daemon Thread）是在后台执行并且不会阻止 JVM 终止的线程。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。\n * 与守护线程（Daemon Thread）相反的，叫用户线程（User Thread），也就是非守护线程。\n\n为什么需要守护线程？\n\n * 守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。典型的应用就是垃圾回收器。\n\n如何使用守护线程？\n\n * 可以使用 isDaemon 方法判断线程是否为守护线程。\n * 可以使用 setDaemon 方法设置线程为守护线程。\n   * 正在运行的用户线程无法设置为守护线程，所以 setDaemon 必须在 thread.start 方法之前设置，否则会抛出 llegalThreadStateException 异常；\n   * 一个守护线程创建的子线程依然是守护线程。\n   * 不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。\n\npublic class ThreadDaemonDemo {\n\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyThread(), "线程");\n        t.setDaemon(true); // 此线程在后台运行\n        System.out.println("线程 t 是否是守护进程：" + t.isDaemon());\n        t.start(); // 启动线程\n    }\n\n    static class MyThread implements Runnable {\n\n        @Override\n        public void run() {\n            while (true) {\n                System.out.println(Thread.currentThread().getName() + "在运行。");\n            }\n        }\n    }\n}\n\n\n> 参考阅读：Java 中守护线程的总结\n\n\n# 线程通信\n\n> 当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。\n\n\n# wait/notify/notifyAll\n\n * wait - wait 会自动释放当前线程占有的对象锁，并请求操作系统挂起当前线程，让线程从 Running 状态转入 Waiting 状态，等待 notify / notifyAll 来唤醒。如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify 或者 notifyAll 来唤醒挂起的线程，造成死锁。\n * notify - 唤醒一个正在 Waiting 状态的线程，并让它拿到对象锁，具体唤醒哪一个线程由 JVM 控制 。\n * notifyAll - 唤醒所有正在 Waiting 状态的线程，接下来它们需要竞争对象锁。\n\n> 注意：\n> \n>  * wait、notify、notifyAll 都是 Object 类中的方法，而非 Thread。\n>  * wait、notify、notifyAll 只能用在 synchronized 方法或者 synchronized 代码块中使用，否则会在运行时抛出 IllegalMonitorStateException。\n> \n> 为什么 wait、notify、notifyAll 不定义在 Thread 中？为什么 wait、notify、notifyAll 要配合 synchronized 使用？\n> \n> 首先，需要了解几个基本知识点：\n> \n>  * 每一个 Java 对象都有一个与之对应的 监视器（monitor）\n>  * 每一个监视器里面都有一个 对象锁 、一个 等待队列、一个 同步队列\n> \n> 了解了以上概念，我们回过头来理解前面两个问题。\n> \n> 为什么这几个方法不定义在 Thread 中？\n> \n> 由于每个对象都拥有对象锁，让当前线程等待某个对象锁，自然应该基于这个对象（Object）来操作，而非使用当前线程（Thread）来操作。因为当前线程可能会等待多个线程的锁，如果基于线程（Thread）来操作，就非常复杂了。\n> \n> 为什么 wait、notify、notifyAll 要配合 synchronized 使用？\n> \n> 如果调用某个对象的 wait 方法，当前线程必须拥有这个对象的对象锁，因此调用 wait 方法必须在 synchronized 方法和 synchronized 代码块中。\n\n生产者、消费者模式是 wait、notify、notifyAll 的一个经典使用案例：\n\npublic class ThreadWaitNotifyDemo02 {\n\n    private static final int QUEUE_SIZE = 10;\n    private static final PriorityQueue<Integer> queue = new PriorityQueue<>(QUEUE_SIZE);\n\n    public static void main(String[] args) {\n        new Producer("生产者A").start();\n        new Producer("生产者B").start();\n        new Consumer("消费者A").start();\n        new Consumer("消费者B").start();\n    }\n\n    static class Consumer extends Thread {\n\n        Consumer(String name) {\n            super(name);\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                synchronized (queue) {\n                    while (queue.size() == 0) {\n                        try {\n                            System.out.println("队列空，等待数据");\n                            queue.wait();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                            queue.notifyAll();\n                        }\n                    }\n                    queue.poll(); // 每次移走队首元素\n                    queue.notifyAll();\n                    try {\n                        Thread.sleep(500);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + " 从队列取走一个元素，队列当前有：" + queue.size() + "个元素");\n                }\n            }\n        }\n    }\n\n    static class Producer extends Thread {\n\n        Producer(String name) {\n            super(name);\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                synchronized (queue) {\n                    while (queue.size() == QUEUE_SIZE) {\n                        try {\n                            System.out.println("队列满，等待有空余空间");\n                            queue.wait();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                            queue.notifyAll();\n                        }\n                    }\n                    queue.offer(1); // 每次插入一个元素\n                    queue.notifyAll();\n                    try {\n                        Thread.sleep(500);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + " 向队列取中插入一个元素，队列当前有：" + queue.size() + "个元素");\n                }\n            }\n        }\n    }\n}\n\n\n\n# join\n\n在线程操作中，可以使用 join 方法让一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行。\n\npublic class ThreadJoinDemo {\n\n    public static void main(String[] args) {\n        MyThread mt = new MyThread(); // 实例化Runnable子类对象\n        Thread t = new Thread(mt, "mythread"); // 实例化Thread对象\n        t.start(); // 启动线程\n        for (int i = 0; i < 50; i++) {\n            if (i > 10) {\n                try {\n                    t.join(); // 线程强制运行\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println("Main 线程运行 --\x3e " + i);\n        }\n    }\n\n    static class MyThread implements Runnable {\n\n        @Override\n        public void run() {\n            for (int i = 0; i < 50; i++) {\n                System.out.println(Thread.currentThread().getName() + " 运行，i = " + i); // 取得当前线程的名字\n            }\n        }\n    }\n}\n\n\n\n# 管道\n\n管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。 管道输入/输出流主要包括了如下 4 种具体实现：PipedOutputStream、PipedInputStream、PipedReader 和 PipedWriter，前两种面向字节，而后两种面向字符。\n\npublic class Piped {\n\n    public static void main(String[] args) throws Exception {\n        PipedWriter out = new PipedWriter();\n        PipedReader in = new PipedReader();\n        // 将输出流和输入流进行连接，否则在使用时会抛出IOException\n        out.connect(in);\n        Thread printThread = new Thread(new Print(in), "PrintThread");\n        printThread.start();\n        int receive = 0;\n        try {\n            while ((receive = System.in.read()) != -1) {\n                out.write(receive);\n            }\n        } finally {\n            out.close();\n        }\n    }\n\n    static class Print implements Runnable {\n\n        private PipedReader in;\n\n        Print(PipedReader in) {\n            this.in = in;\n        }\n\n        public void run() {\n            int receive = 0;\n            try {\n                while ((receive = in.read()) != -1) {\n                    System.out.print((char) receive);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n\n\n# 线程生命周期\n\n\n\njava.lang.Thread.State 中定义了 6 种不同的线程状态，在给定的一个时刻，线程只能处于其中的一个状态。\n\n以下是各状态的说明，以及状态间的联系：\n\n * 新建（New） - 尚未调用 start 方法的线程处于此状态。此状态意味着：创建的线程尚未启动。\n\n * 就绪（Runnable） - 已经调用了 start 方法的线程处于此状态。此状态意味着：线程已经在 JVM 中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。\n\n * 阻塞（Blocked） - 此状态意味着：线程处于被阻塞状态。表示线程在等待 synchronized 的隐式锁（Monitor lock）。synchronized 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，即处于阻塞状态。当占用 synchronized 隐式锁的线程释放锁，并且等待的线程获得 synchronized 隐式锁时，就又会从 BLOCKED 转换到 RUNNABLE 状态。\n\n * 等待（Waiting） - 此状态意味着：线程无限期等待，直到被其他线程显式地唤醒。 阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 synchronized 的隐式锁。而等待是主动的，通过调用 Object.wait 等方法进入。\n   \n   进入方法                                        退出方法\n   没有设置 Timeout 参数的 Object.wait 方法             Object.notify / Object.notifyAll\n   没有设置 Timeout 参数的 Thread.join 方法             被调用的线程执行完毕\n   LockSupport.park 方法（Java 并发包中的锁，都是基于它实现的）   LockSupport.unpark\n\n * 定时等待（Timed waiting） - 此状态意味着：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。\n   \n   进入方法                                                      退出方法\n   Thread.sleep 方法                                           时间结束\n   获得 synchronized 隐式锁的线程，调用设置了 Timeout 参数的 Object.wait 方法   时间结束 / Object.notify / Object.notifyAll\n   设置了 Timeout 参数的 Thread.join 方法                            时间结束 / 被调用的线程执行完毕\n   LockSupport.parkNanos 方法                                  LockSupport.unpark\n   LockSupport.parkUntil 方法                                  LockSupport.unpark\n\n * 终止(Terminated) - 线程执行完 run 方法，或者因异常退出了 run 方法。此状态意味着：线程结束了生命周期。\n\n\n# 线程常见问题\n\n\n# sleep、yield、join 方法有什么区别\n\n * yield 方法\n   * yield 方法会 让线程从 Running 状态转入 Runnable 状态。\n   * 当调用了 yield 方法后，只有与当前线程相同或更高优先级的Runnable 状态线程才会获得执行的机会。\n * sleep 方法\n   * sleep 方法会 让线程从 Running 状态转入 Waiting 状态。\n   * sleep 方法需要指定等待的时间，超过等待时间后，JVM 会将线程从 Waiting 状态转入 Runnable 状态。\n   * 当调用了 sleep 方法后，无论什么优先级的线程都可以得到执行机会。\n   * sleep 方法不会释放“锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。\n * join\n   * join 方法会 让线程从 Running 状态转入 Waiting 状态。\n   * 当调用了 join 方法后，当前线程必须等待调用 join 方法的线程结束后才能继续执行。\n\n\n# 为什么 sleep 和 yield 方法是静态的\n\nThread 类的 sleep 和 yield 方法将处理 Running 状态的线程。\n\n所以在其他处于非 Running 状态的线程上执行这两个方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。\n\n\n# Java 线程是否按照线程优先级严格执行\n\n即使设置了线程的优先级，也无法保证高优先级的线程一定先执行。\n\n原因在于线程优先级依赖于操作系统的支持，然而，不同的操作系统支持的线程优先级并不相同，不能很好的和 Java 中线程优先级一一对应。\n\n\n# 一个线程两次调用 start()方法会怎样\n\nJava 的线程是不允许启动两次的，第二次调用必然会抛出 IllegalThreadStateException，这是一种运行时异常，多次调用 start 被认为是编程错误。\n\n\n# start 和 run 方法有什么区别\n\n * run 方法是线程的执行体。\n * start 方法会启动线程，然后 JVM 会让这个线程去执行 run 方法。\n\n\n# 可以直接调用 Thread 类的 run 方法么\n\n * 可以。但是如果直接调用 Thread 的 run 方法，它的行为就会和普通的方法一样。\n * 为了在新的线程中执行我们的代码，必须使用 Thread 的 start 方法。\n\n\n# 参考资料\n\n * 《Java 并发编程实战》\n * 《Java 并发编程的艺术》\n * 进程和线程关系及区别\n * Java 线程中 yield 与 join 方法的区别\n * sleep()，wait()，yield()和 join()方法的区别\n * Java 并发编程：线程间协作的两种方式：wait、notify、notifyAll 和 Condition\n * Java 并发编程：Callable、Future 和 FutureTask\n * StackOverflow VisualVM - Thread States\n * Java 中守护线程的总结\n * Java 并发\n * Why must wait() always be in synchronized block',normalizedContent:'# java 线程基础\n\n> 关键词：thread、runnable、callable、future、wait、notify、notifyall、join、sleep、yeild、线程状态、线程通信\n\n\n# 线程简介\n\n\n# 什么是进程\n\n简言之，进程可视为一个正在运行的程序。它是系统运行程序的基本单位，因此进程是动态的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。\n\n\n# 什么是线程\n\n线程是操作系统进行调度的基本单位。线程也叫轻量级进程（light weight process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。\n\n\n# 进程和线程的区别\n\n * 一个程序至少有一个进程，一个进程至少有一个线程。\n * 线程比进程划分更细，所以执行开销更小，并发性更高。\n * 进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。\n\n\n# 创建线程\n\n创建线程有三种方式：\n\n * 继承 thread 类\n * 实现 runnable 接口\n * 实现 callable 接口\n\n\n# thread\n\n通过继承 thread 类创建线程的步骤：\n\n 1. 定义 thread 类的子类，并覆写该类的 run 方法。run 方法的方法体就代表了线程要完成的任务，因此把 run 方法称为执行体。\n 2. 创建 thread 子类的实例，即创建了线程对象。\n 3. 调用线程对象的 start 方法来启动该线程。\n\npublic class threaddemo {\n\n    public static void main(string[] args) {\n        // 实例化对象\n        mythread ta = new mythread("thread 线程-a");\n        mythread tb = new mythread("thread 线程-b");\n        // 调用线程主体\n        ta.start();\n        tb.start();\n    }\n\n    static class mythread extends thread {\n\n        private int ticket = 5;\n\n        mythread(string name) {\n            super(name);\n        }\n\n        @override\n        public void run() {\n            while (ticket > 0) {\n                system.out.println(thread.currentthread().getname() + " 卖出了第 " + ticket + " 张票");\n                ticket--;\n            }\n        }\n\n    }\n\n}\n\n\n\n# runnable\n\n实现 runnable 接口优于继承 thread 类，因为：\n\n * java 不支持多重继承，所有的类都只允许继承一个父类，但可以实现多个接口。如果继承了 thread 类就无法继承其它类，这不利于扩展。\n * 类可能只要求可执行就行，继承整个 thread 类开销过大。\n\n通过实现 runnable 接口创建线程的步骤：\n\n 1. 定义 runnable 接口的实现类，并覆写该接口的 run 方法。该 run 方法的方法体同样是该线程的线程执行体。\n 2. 创建 runnable 实现类的实例，并以此实例作为 thread 的 target 来创建 thread 对象，该 thread 对象才是真正的线程对象。\n 3. 调用线程对象的 start 方法来启动该线程。\n\npublic class runnabledemo {\n\n    public static void main(string[] args) {\n        // 实例化对象\n        thread ta = new thread(new mythread(), "runnable 线程-a");\n        thread tb = new thread(new mythread(), "runnable 线程-b");\n        // 调用线程主体\n        ta.start();\n        tb.start();\n    }\n\n    static class mythread implements runnable {\n\n        private int ticket = 5;\n\n        @override\n        public void run() {\n            while (ticket > 0) {\n                system.out.println(thread.currentthread().getname() + " 卖出了第 " + ticket + " 张票");\n                ticket--;\n            }\n        }\n\n    }\n\n}\n\n\n\n# callable、future、futuretask\n\n继承 thread 类和实现 runnable 接口这两种创建线程的方式都没有返回值。所以，线程执行完后，无法得到执行结果。但如果期望得到执行结果该怎么做？\n\n为了解决这个问题，java 1.5 后，提供了 callable 接口和 future 接口，通过它们，可以在线程执行结束后，返回执行结果。\n\n# callable\n\ncallable 接口只声明了一个方法，这个方法叫做 call()：\n\npublic interface callable<v> {\n    /**\n     * computes a result, or throws an exception if unable to do so.\n     *\n     * @return computed result\n     * @throws exception if unable to compute a result\n     */\n    v call() throws exception;\n}\n\n\n那么怎么使用 callable 呢？一般情况下是配合 executorservice 来使用的，在 executorservice 接口中声明了若干个 submit 方法的重载版本：\n\n<t> future<t> submit(callable<t> task);\n<t> future<t> submit(runnable task, t result);\nfuture<?> submit(runnable task);\n\n\n第一个 submit 方法里面的参数类型就是 callable。\n\n# future\n\nfuture 就是对于具体的 callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过 get 方法获取执行结果，该方法会阻塞直到任务返回结果。\n\npublic interface future<v> {\n    boolean cancel(boolean mayinterruptifrunning);\n    boolean iscancelled();\n    boolean isdone();\n    v get() throws interruptedexception, executionexception;\n    v get(long timeout, timeunit unit)\n        throws interruptedexception, executionexception, timeoutexception;\n}\n\n\n# futuretask\n\nfuturetask 类实现了 runnablefuture 接口，runnablefuture 继承了 runnable 接口和 future 接口。\n\n所以，futuretask 既可以作为 runnable 被线程执行，又可以作为 future 得到 callable 的返回值。\n\npublic class futuretask<v> implements runnablefuture<v> {\n    // ...\n    public futuretask(callable<v> callable) {}\n    public futuretask(runnable runnable, v result) {}\n}\n\npublic interface runnablefuture<v> extends runnable, future<v> {\n    void run();\n}\n\n\n事实上，futuretask 是 future 接口的一个唯一实现类。\n\n# callable + future + futuretask 示例\n\n通过实现 callable 接口创建线程的步骤：\n\n 1. 创建 callable 接口的实现类，并实现 call 方法。该 call 方法将作为线程执行体，并且有返回值。\n 2. 创建 callable 实现类的实例，使用 futuretask 类来包装 callable 对象，该 futuretask 对象封装了该 callable 对象的 call 方法的返回值。\n 3. 使用 futuretask 对象作为 thread 对象的 target 创建并启动新线程。\n 4. 调用 futuretask 对象的 get 方法来获得线程执行结束后的返回值。\n\npublic class callabledemo {\n\n    public static void main(string[] args) {\n        callable<long> callable = new mythread();\n        futuretask<long> future = new futuretask<>(callable);\n        new thread(future, "callable 线程").start();\n        try {\n            system.out.println("任务耗时：" + (future.get() / 1000000) + "毫秒");\n        } catch (interruptedexception | executionexception e) {\n            e.printstacktrace();\n        }\n    }\n\n    static class mythread implements callable<long> {\n\n        private int ticket = 10000;\n\n        @override\n        public long call() {\n            long begin = system.nanotime();\n            while (ticket > 0) {\n                system.out.println(thread.currentthread().getname() + " 卖出了第 " + ticket + " 张票");\n                ticket--;\n            }\n\n            long end = system.nanotime();\n            return (end - begin);\n        }\n\n    }\n\n}\n\n\n\n# 线程基本用法\n\n线程（thread）基本方法清单：\n\n方法              描述\nrun             线程的执行实体。\nstart           线程的启动方法。\ncurrentthread   返回对当前正在执行的线程对象的引用。\nsetname         设置线程名称。\ngetname         获取线程名称。\nsetpriority     设置线程优先级。java 中的线程优先级的范围是 [1,10]，一般来说，高优先级的线程在运行时会具有优先权。可以通过\n                thread.setpriority(thread.max_priority) 的方式设置，默认优先级为 5。\ngetpriority     获取线程优先级。\nsetdaemon       设置线程为守护线程。\nisdaemon        判断线程是否为守护线程。\nisalive         判断线程是否启动。\ninterrupt       中断另一个线程的运行状态。\ninterrupted     测试当前线程是否已被中断。通过此方法可以清除线程的中断状态。换句话说，如果要连续调用此方法两次，则第二次调用将返回\n                false（除非当前线程在第一次调用清除其中断状态之后且在第二次调用检查其状态之前再次中断）。\njoin            可以使一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行。\nthread.sleep    静态方法。将当前正在执行的线程休眠。\nthread.yield    静态方法。将当前正在执行的线程暂停，让其他线程执行。\n\n\n# 线程休眠\n\n使用 thread.sleep 方法可以使得当前正在执行的线程进入休眠状态。\n\n使用 thread.sleep 需要向其传入一个整数值，这个值表示线程将要休眠的毫秒数。\n\nthread.sleep 方法可能会抛出 interruptedexception，因为异常不能跨线程传播回 main 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。\n\npublic class threadsleepdemo {\n\n    public static void main(string[] args) {\n        new thread(new mythread("线程a", 500)).start();\n        new thread(new mythread("线程b", 1000)).start();\n        new thread(new mythread("线程c", 1500)).start();\n    }\n\n    static class mythread implements runnable {\n\n        /** 线程名称 */\n        private string name;\n\n        /** 休眠时间 */\n        private int time;\n\n        private mythread(string name, int time) {\n            this.name = name;\n            this.time = time;\n        }\n\n        @override\n        public void run() {\n            try {\n                // 休眠指定的时间\n                thread.sleep(this.time);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            system.out.println(this.name + "休眠" + this.time + "毫秒。");\n        }\n\n    }\n\n}\n\n\n\n# 线程礼让\n\nthread.yield 方法的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行 。\n\n该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。\n\npublic class threadyielddemo {\n\n    public static void main(string[] args) {\n        mythread t = new mythread();\n        new thread(t, "线程a").start();\n        new thread(t, "线程b").start();\n    }\n\n    static class mythread implements runnable {\n\n        @override\n        public void run() {\n            for (int i = 0; i < 5; i++) {\n                try {\n                    thread.sleep(1000);\n                } catch (exception e) {\n                    e.printstacktrace();\n                }\n                system.out.println(thread.currentthread().getname() + "运行，i = " + i);\n                if (i == 2) {\n                    system.out.print("线程礼让：");\n                    thread.yield();\n                }\n            }\n        }\n    }\n}\n\n\n\n# 终止线程\n\n> thread 中的 stop 方法有缺陷，已废弃。\n> \n> 使用 thread.stop 停止线程会导致它解锁所有已锁定的监视器（由于未经检查的 threaddeath 异常会在堆栈中传播，这是自然的结果）。 如果先前由这些监视器保护的任何对象处于不一致状态，则损坏的对象将对其他线程可见，从而可能导致任意行为。\n> \n> stop() 方法会真的杀死线程，不给线程喘息的机会，如果线程持有 reentrantlock 锁，被 stop() 的线程并不会自动调用 reentrantlock 的 unlock() 去释放锁，那其他线程就再也没机会获得 reentrantlock 锁，这实在是太危险了。所以该方法就不建议使用了，类似的方法还有 suspend() 和 resume() 方法，这两个方法同样也都不建议使用了，所以这里也就不多介绍了。thread.stop 的许多用法应由仅修改某些变量以指示目标线程应停止运行的代码代替。 目标线程应定期检查此变量，如果该变量指示要停止运行，则应按有序方式从其运行方法返回。如果目标线程等待很长时间（例如，在条件变量上），则应使用中断方法来中断等待。\n\n当一个线程运行时，另一个线程可以直接通过 interrupt 方法中断其运行状态。\n\npublic class threadinterruptdemo {\n\n    public static void main(string[] args) {\n        mythread mt = new mythread(); // 实例化runnable子类对象\n        thread t = new thread(mt, "线程"); // 实例化thread对象\n        t.start(); // 启动线程\n        try {\n            thread.sleep(2000); // 线程休眠2秒\n        } catch (interruptedexception e) {\n            system.out.println("3、main线程休眠被终止");\n        }\n        t.interrupt(); // 中断线程执行\n    }\n\n    static class mythread implements runnable {\n\n        @override\n        public void run() {\n            system.out.println("1、进入run()方法");\n            try {\n                thread.sleep(10000); // 线程休眠10秒\n                system.out.println("2、已经完成了休眠");\n            } catch (interruptedexception e) {\n                system.out.println("3、mythread线程休眠被终止");\n                return; // 返回调用处\n            }\n            system.out.println("4、run()方法正常结束");\n        }\n    }\n}\n\n\n如果一个线程的 run 方法执行一个无限循环，并且没有执行 sleep 等会抛出 interruptedexception 的操作，那么调用线程的 interrupt 方法就无法使线程提前结束。\n\n但是调用 interrupt 方法会设置线程的中断标记，此时调用 interrupted 方法会返回 true。因此可以在循环体中使用 interrupted 方法来判断线程是否处于中断状态，从而提前结束线程。\n\n安全地终止线程有两种方法：\n\n * 定义 volatile 标志位，在 run 方法中使用标志位控制线程终止\n * 使用 interrupt 方法和 thread.interrupted 方法配合使用来控制线程终止\n\n【示例】使用 volatile 标志位控制线程终止\n\npublic class threadstopdemo2 {\n\n    public static void main(string[] args) throws exception {\n        mytask task = new mytask();\n        thread thread = new thread(task, "mytask");\n        thread.start();\n        timeunit.milliseconds.sleep(50);\n        task.cancel();\n    }\n\n    private static class mytask implements runnable {\n\n        private volatile boolean flag = true;\n\n        private volatile long count = 0l;\n\n        @override\n        public void run() {\n            system.out.println(thread.currentthread().getname() + " 线程启动");\n            while (flag) {\n                system.out.println(count++);\n            }\n            system.out.println(thread.currentthread().getname() + " 线程终止");\n        }\n\n        /**\n         * 通过 volatile 标志位来控制线程终止\n         */\n        public void cancel() {\n            flag = false;\n        }\n\n    }\n\n}\n\n\n【示例】使用 interrupt 方法和 thread.interrupted 方法配合使用来控制线程终止\n\npublic class threadstopdemo3 {\n\n    public static void main(string[] args) throws exception {\n        mytask task = new mytask();\n        thread thread = new thread(task, "mytask");\n        thread.start();\n        timeunit.milliseconds.sleep(50);\n        thread.interrupt();\n    }\n\n    private static class mytask implements runnable {\n\n        private volatile long count = 0l;\n\n        @override\n        public void run() {\n            system.out.println(thread.currentthread().getname() + " 线程启动");\n            // 通过 thread.interrupted 和 interrupt 配合来控制线程终止\n            while (!thread.interrupted()) {\n                system.out.println(count++);\n            }\n            system.out.println(thread.currentthread().getname() + " 线程终止");\n        }\n    }\n}\n\n\n\n# 守护线程\n\n什么是守护线程？\n\n * 守护线程（daemon thread）是在后台执行并且不会阻止 jvm 终止的线程。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。\n * 与守护线程（daemon thread）相反的，叫用户线程（user thread），也就是非守护线程。\n\n为什么需要守护线程？\n\n * 守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。典型的应用就是垃圾回收器。\n\n如何使用守护线程？\n\n * 可以使用 isdaemon 方法判断线程是否为守护线程。\n * 可以使用 setdaemon 方法设置线程为守护线程。\n   * 正在运行的用户线程无法设置为守护线程，所以 setdaemon 必须在 thread.start 方法之前设置，否则会抛出 llegalthreadstateexception 异常；\n   * 一个守护线程创建的子线程依然是守护线程。\n   * 不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。\n\npublic class threaddaemondemo {\n\n    public static void main(string[] args) {\n        thread t = new thread(new mythread(), "线程");\n        t.setdaemon(true); // 此线程在后台运行\n        system.out.println("线程 t 是否是守护进程：" + t.isdaemon());\n        t.start(); // 启动线程\n    }\n\n    static class mythread implements runnable {\n\n        @override\n        public void run() {\n            while (true) {\n                system.out.println(thread.currentthread().getname() + "在运行。");\n            }\n        }\n    }\n}\n\n\n> 参考阅读：java 中守护线程的总结\n\n\n# 线程通信\n\n> 当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。\n\n\n# wait/notify/notifyall\n\n * wait - wait 会自动释放当前线程占有的对象锁，并请求操作系统挂起当前线程，让线程从 running 状态转入 waiting 状态，等待 notify / notifyall 来唤醒。如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify 或者 notifyall 来唤醒挂起的线程，造成死锁。\n * notify - 唤醒一个正在 waiting 状态的线程，并让它拿到对象锁，具体唤醒哪一个线程由 jvm 控制 。\n * notifyall - 唤醒所有正在 waiting 状态的线程，接下来它们需要竞争对象锁。\n\n> 注意：\n> \n>  * wait、notify、notifyall 都是 object 类中的方法，而非 thread。\n>  * wait、notify、notifyall 只能用在 synchronized 方法或者 synchronized 代码块中使用，否则会在运行时抛出 illegalmonitorstateexception。\n> \n> 为什么 wait、notify、notifyall 不定义在 thread 中？为什么 wait、notify、notifyall 要配合 synchronized 使用？\n> \n> 首先，需要了解几个基本知识点：\n> \n>  * 每一个 java 对象都有一个与之对应的 监视器（monitor）\n>  * 每一个监视器里面都有一个 对象锁 、一个 等待队列、一个 同步队列\n> \n> 了解了以上概念，我们回过头来理解前面两个问题。\n> \n> 为什么这几个方法不定义在 thread 中？\n> \n> 由于每个对象都拥有对象锁，让当前线程等待某个对象锁，自然应该基于这个对象（object）来操作，而非使用当前线程（thread）来操作。因为当前线程可能会等待多个线程的锁，如果基于线程（thread）来操作，就非常复杂了。\n> \n> 为什么 wait、notify、notifyall 要配合 synchronized 使用？\n> \n> 如果调用某个对象的 wait 方法，当前线程必须拥有这个对象的对象锁，因此调用 wait 方法必须在 synchronized 方法和 synchronized 代码块中。\n\n生产者、消费者模式是 wait、notify、notifyall 的一个经典使用案例：\n\npublic class threadwaitnotifydemo02 {\n\n    private static final int queue_size = 10;\n    private static final priorityqueue<integer> queue = new priorityqueue<>(queue_size);\n\n    public static void main(string[] args) {\n        new producer("生产者a").start();\n        new producer("生产者b").start();\n        new consumer("消费者a").start();\n        new consumer("消费者b").start();\n    }\n\n    static class consumer extends thread {\n\n        consumer(string name) {\n            super(name);\n        }\n\n        @override\n        public void run() {\n            while (true) {\n                synchronized (queue) {\n                    while (queue.size() == 0) {\n                        try {\n                            system.out.println("队列空，等待数据");\n                            queue.wait();\n                        } catch (interruptedexception e) {\n                            e.printstacktrace();\n                            queue.notifyall();\n                        }\n                    }\n                    queue.poll(); // 每次移走队首元素\n                    queue.notifyall();\n                    try {\n                        thread.sleep(500);\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                    system.out.println(thread.currentthread().getname() + " 从队列取走一个元素，队列当前有：" + queue.size() + "个元素");\n                }\n            }\n        }\n    }\n\n    static class producer extends thread {\n\n        producer(string name) {\n            super(name);\n        }\n\n        @override\n        public void run() {\n            while (true) {\n                synchronized (queue) {\n                    while (queue.size() == queue_size) {\n                        try {\n                            system.out.println("队列满，等待有空余空间");\n                            queue.wait();\n                        } catch (interruptedexception e) {\n                            e.printstacktrace();\n                            queue.notifyall();\n                        }\n                    }\n                    queue.offer(1); // 每次插入一个元素\n                    queue.notifyall();\n                    try {\n                        thread.sleep(500);\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                    system.out.println(thread.currentthread().getname() + " 向队列取中插入一个元素，队列当前有：" + queue.size() + "个元素");\n                }\n            }\n        }\n    }\n}\n\n\n\n# join\n\n在线程操作中，可以使用 join 方法让一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行。\n\npublic class threadjoindemo {\n\n    public static void main(string[] args) {\n        mythread mt = new mythread(); // 实例化runnable子类对象\n        thread t = new thread(mt, "mythread"); // 实例化thread对象\n        t.start(); // 启动线程\n        for (int i = 0; i < 50; i++) {\n            if (i > 10) {\n                try {\n                    t.join(); // 线程强制运行\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n            system.out.println("main 线程运行 --\x3e " + i);\n        }\n    }\n\n    static class mythread implements runnable {\n\n        @override\n        public void run() {\n            for (int i = 0; i < 50; i++) {\n                system.out.println(thread.currentthread().getname() + " 运行，i = " + i); // 取得当前线程的名字\n            }\n        }\n    }\n}\n\n\n\n# 管道\n\n管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。 管道输入/输出流主要包括了如下 4 种具体实现：pipedoutputstream、pipedinputstream、pipedreader 和 pipedwriter，前两种面向字节，而后两种面向字符。\n\npublic class piped {\n\n    public static void main(string[] args) throws exception {\n        pipedwriter out = new pipedwriter();\n        pipedreader in = new pipedreader();\n        // 将输出流和输入流进行连接，否则在使用时会抛出ioexception\n        out.connect(in);\n        thread printthread = new thread(new print(in), "printthread");\n        printthread.start();\n        int receive = 0;\n        try {\n            while ((receive = system.in.read()) != -1) {\n                out.write(receive);\n            }\n        } finally {\n            out.close();\n        }\n    }\n\n    static class print implements runnable {\n\n        private pipedreader in;\n\n        print(pipedreader in) {\n            this.in = in;\n        }\n\n        public void run() {\n            int receive = 0;\n            try {\n                while ((receive = in.read()) != -1) {\n                    system.out.print((char) receive);\n                }\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n}\n\n\n\n# 线程生命周期\n\n\n\njava.lang.thread.state 中定义了 6 种不同的线程状态，在给定的一个时刻，线程只能处于其中的一个状态。\n\n以下是各状态的说明，以及状态间的联系：\n\n * 新建（new） - 尚未调用 start 方法的线程处于此状态。此状态意味着：创建的线程尚未启动。\n\n * 就绪（runnable） - 已经调用了 start 方法的线程处于此状态。此状态意味着：线程已经在 jvm 中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。\n\n * 阻塞（blocked） - 此状态意味着：线程处于被阻塞状态。表示线程在等待 synchronized 的隐式锁（monitor lock）。synchronized 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，即处于阻塞状态。当占用 synchronized 隐式锁的线程释放锁，并且等待的线程获得 synchronized 隐式锁时，就又会从 blocked 转换到 runnable 状态。\n\n * 等待（waiting） - 此状态意味着：线程无限期等待，直到被其他线程显式地唤醒。 阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 synchronized 的隐式锁。而等待是主动的，通过调用 object.wait 等方法进入。\n   \n   进入方法                                        退出方法\n   没有设置 timeout 参数的 object.wait 方法             object.notify / object.notifyall\n   没有设置 timeout 参数的 thread.join 方法             被调用的线程执行完毕\n   locksupport.park 方法（java 并发包中的锁，都是基于它实现的）   locksupport.unpark\n\n * 定时等待（timed waiting） - 此状态意味着：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。\n   \n   进入方法                                                      退出方法\n   thread.sleep 方法                                           时间结束\n   获得 synchronized 隐式锁的线程，调用设置了 timeout 参数的 object.wait 方法   时间结束 / object.notify / object.notifyall\n   设置了 timeout 参数的 thread.join 方法                            时间结束 / 被调用的线程执行完毕\n   locksupport.parknanos 方法                                  locksupport.unpark\n   locksupport.parkuntil 方法                                  locksupport.unpark\n\n * 终止(terminated) - 线程执行完 run 方法，或者因异常退出了 run 方法。此状态意味着：线程结束了生命周期。\n\n\n# 线程常见问题\n\n\n# sleep、yield、join 方法有什么区别\n\n * yield 方法\n   * yield 方法会 让线程从 running 状态转入 runnable 状态。\n   * 当调用了 yield 方法后，只有与当前线程相同或更高优先级的runnable 状态线程才会获得执行的机会。\n * sleep 方法\n   * sleep 方法会 让线程从 running 状态转入 waiting 状态。\n   * sleep 方法需要指定等待的时间，超过等待时间后，jvm 会将线程从 waiting 状态转入 runnable 状态。\n   * 当调用了 sleep 方法后，无论什么优先级的线程都可以得到执行机会。\n   * sleep 方法不会释放“锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。\n * join\n   * join 方法会 让线程从 running 状态转入 waiting 状态。\n   * 当调用了 join 方法后，当前线程必须等待调用 join 方法的线程结束后才能继续执行。\n\n\n# 为什么 sleep 和 yield 方法是静态的\n\nthread 类的 sleep 和 yield 方法将处理 running 状态的线程。\n\n所以在其他处于非 running 状态的线程上执行这两个方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。\n\n\n# java 线程是否按照线程优先级严格执行\n\n即使设置了线程的优先级，也无法保证高优先级的线程一定先执行。\n\n原因在于线程优先级依赖于操作系统的支持，然而，不同的操作系统支持的线程优先级并不相同，不能很好的和 java 中线程优先级一一对应。\n\n\n# 一个线程两次调用 start()方法会怎样\n\njava 的线程是不允许启动两次的，第二次调用必然会抛出 illegalthreadstateexception，这是一种运行时异常，多次调用 start 被认为是编程错误。\n\n\n# start 和 run 方法有什么区别\n\n * run 方法是线程的执行体。\n * start 方法会启动线程，然后 jvm 会让这个线程去执行 run 方法。\n\n\n# 可以直接调用 thread 类的 run 方法么\n\n * 可以。但是如果直接调用 thread 的 run 方法，它的行为就会和普通的方法一样。\n * 为了在新的线程中执行我们的代码，必须使用 thread 的 start 方法。\n\n\n# 参考资料\n\n * 《java 并发编程实战》\n * 《java 并发编程的艺术》\n * 进程和线程关系及区别\n * java 线程中 yield 与 join 方法的区别\n * sleep()，wait()，yield()和 join()方法的区别\n * java 并发编程：线程间协作的两种方式：wait、notify、notifyall 和 condition\n * java 并发编程：callable、future 和 futuretask\n * stackoverflow visualvm - thread states\n * java 中守护线程的总结\n * java 并发\n * why must wait() always be in synchronized block',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java并发核心机制",frontmatter:{title:"Java并发核心机制",categories:["编程","Java","JavaSE","并发"],tags:["Java","JavaSE","并发"],abbrlink:"b9e487ed",date:"2019-12-25T22:19:09.000Z",permalink:"/pages/4a7f19/"},regularPath:"/05.%E5%B9%B6%E5%8F%91/03.Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6.html",relativePath:"05.并发/03.Java并发核心机制.md",key:"v-03ec984a",path:"/pages/4a7f19/",headers:[{level:2,title:"J.U.C 简介",slug:"j-u-c-简介",normalizedTitle:"j.u.c 简介",charIndex:86},{level:2,title:"synchronized",slug:"synchronized",normalizedTitle:"synchronized",charIndex:643},{level:3,title:"synchronized 的应用",slug:"synchronized-的应用",normalizedTitle:"synchronized 的应用",charIndex:1162},{level:4,title:"同步实例方法",slug:"同步实例方法",normalizedTitle:"同步实例方法",charIndex:1208},{level:4,title:"同步静态方法",slug:"同步静态方法",normalizedTitle:"同步静态方法",charIndex:1238},{level:4,title:"同步代码块",slug:"同步代码块",normalizedTitle:"同步代码块",charIndex:1275},{level:3,title:"synchronized 的原理",slug:"synchronized-的原理",normalizedTitle:"synchronized 的原理",charIndex:7147},{level:4,title:"同步代码块",slug:"同步代码块-2",normalizedTitle:"同步代码块",charIndex:1275},{level:4,title:"同步方法",slug:"同步方法",normalizedTitle:"同步方法",charIndex:1221},{level:4,title:"Monitor",slug:"monitor",normalizedTitle:"monitor",charIndex:7219},{level:3,title:"synchronized 的优化",slug:"synchronized-的优化",normalizedTitle:"synchronized 的优化",charIndex:8878},{level:4,title:"Java 对象头",slug:"java-对象头",normalizedTitle:"java 对象头",charIndex:8968},{level:4,title:"偏向锁",slug:"偏向锁",normalizedTitle:"偏向锁",charIndex:9193},{level:4,title:"轻量级锁",slug:"轻量级锁",normalizedTitle:"轻量级锁",charIndex:9242},{level:4,title:"锁消除 / 锁粗化",slug:"锁消除-锁粗化",normalizedTitle:"锁消除 / 锁粗化",charIndex:10118},{level:4,title:"自旋锁",slug:"自旋锁",normalizedTitle:"自旋锁",charIndex:11260},{level:3,title:"synchronized 的误区",slug:"synchronized-的误区",normalizedTitle:"synchronized 的误区",charIndex:11522},{level:4,title:"synchronized 使用范围不当导致的错误",slug:"synchronized-使用范围不当导致的错误",normalizedTitle:"synchronized 使用范围不当导致的错误",charIndex:11572},{level:4,title:"synchronized 保护对象不对导致的错误",slug:"synchronized-保护对象不对导致的错误",normalizedTitle:"synchronized 保护对象不对导致的错误",charIndex:13155},{level:4,title:"锁粒度导致的问题",slug:"锁粒度导致的问题",normalizedTitle:"锁粒度导致的问题",charIndex:14365},{level:2,title:"volatile",slug:"volatile",normalizedTitle:"volatile",charIndex:656},{level:3,title:"volatile 的要点",slug:"volatile-的要点",normalizedTitle:"volatile 的要点",charIndex:15720},{level:3,title:"volatile 的应用",slug:"volatile-的应用",normalizedTitle:"volatile 的应用",charIndex:15965},{level:3,title:"volatile 的原理",slug:"volatile-的原理",normalizedTitle:"volatile 的原理",charIndex:16689},{level:3,title:"volatile 的问题",slug:"volatile-的问题",normalizedTitle:"volatile 的问题",charIndex:16971},{level:2,title:"CAS",slug:"cas",normalizedTitle:"cas",charIndex:665},{level:3,title:"CAS 的要点",slug:"cas-的要点",normalizedTitle:"cas 的要点",charIndex:17150},{level:3,title:"CAS 的应用",slug:"cas-的应用",normalizedTitle:"cas 的应用",charIndex:17698},{level:4,title:"原子类",slug:"原子类",normalizedTitle:"原子类",charIndex:206},{level:4,title:"自旋锁",slug:"自旋锁-2",normalizedTitle:"自旋锁",charIndex:11260},{level:3,title:"CAS 的原理",slug:"cas-的原理",normalizedTitle:"cas 的原理",charIndex:21567},{level:3,title:"CAS 的问题",slug:"cas-的问题",normalizedTitle:"cas 的问题",charIndex:21726},{level:4,title:"ABA 问题",slug:"aba-问题",normalizedTitle:"aba 问题",charIndex:21818},{level:4,title:"循环时间长开销大",slug:"循环时间长开销大",normalizedTitle:"循环时间长开销大",charIndex:21828},{level:4,title:"只能保证一个共享变量的原子性",slug:"只能保证一个共享变量的原子性",normalizedTitle:"只能保证一个共享变量的原子性",charIndex:21840},{level:2,title:"ThreadLocal",slug:"threadlocal",normalizedTitle:"threadlocal",charIndex:669},{level:3,title:"ThreadLocal 的应用",slug:"threadlocal-的应用",normalizedTitle:"threadlocal 的应用",charIndex:22969},{level:3,title:"ThreadLocal 的原理",slug:"threadlocal-的原理",normalizedTitle:"threadlocal 的原理",charIndex:25355},{level:4,title:"存储结构",slug:"存储结构",normalizedTitle:"存储结构",charIndex:9143},{level:4,title:"如何解决 Hash 冲突",slug:"如何解决-hash-冲突",normalizedTitle:"如何解决 hash 冲突",charIndex:26045},{level:4,title:"内存泄漏问题",slug:"内存泄漏问题",normalizedTitle:"内存泄漏问题",charIndex:26329},{level:3,title:"ThreadLocal 的误区",slug:"threadlocal-的误区",normalizedTitle:"threadlocal 的误区",charIndex:26802},{level:4,title:"ThreadLocal 错误案例",slug:"threadlocal-错误案例",normalizedTitle:"threadlocal 错误案例",charIndex:26945},{level:4,title:"ThreadLocal 错误案例修正",slug:"threadlocal-错误案例修正",normalizedTitle:"threadlocal 错误案例修正",charIndex:28162},{level:3,title:"InheritableThreadLocal",slug:"inheritablethreadlocal",normalizedTitle:"inheritablethreadlocal",charIndex:28793},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:29013}],headersStr:"J.U.C 简介 synchronized synchronized 的应用 同步实例方法 同步静态方法 同步代码块 synchronized 的原理 同步代码块 同步方法 Monitor synchronized 的优化 Java 对象头 偏向锁 轻量级锁 锁消除 / 锁粗化 自旋锁 synchronized 的误区 synchronized 使用范围不当导致的错误 synchronized 保护对象不对导致的错误 锁粒度导致的问题 volatile volatile 的要点 volatile 的应用 volatile 的原理 volatile 的问题 CAS CAS 的要点 CAS 的应用 原子类 自旋锁 CAS 的原理 CAS 的问题 ABA 问题 循环时间长开销大 只能保证一个共享变量的原子性 ThreadLocal ThreadLocal 的应用 ThreadLocal 的原理 存储结构 如何解决 Hash 冲突 内存泄漏问题 ThreadLocal 的误区 ThreadLocal 错误案例 ThreadLocal 错误案例修正 InheritableThreadLocal 参考资料",content:'# Java 并发核心机制\n\n> Java 对于并发的支持主要汇聚在 java.util.concurrent，即 J.U.C。而 J.U.C 的核心是 AQS。\n\n\n# J.U.C 简介\n\nJava 的 java.util.concurrent 包（简称 J.U.C）中提供了大量并发工具类，是 Java 并发能力的主要体现（注意，不是全部，有部分并发能力的支持在其他包中）。从功能上，大致可以分为：\n\n * 原子类 - 如：AtomicInteger、AtomicIntegerArray、AtomicReference、AtomicStampedReference 等。\n * 锁 - 如：ReentrantLock、ReentrantReadWriteLock 等。\n * 并发容器 - 如：ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet 等。\n * 阻塞队列 - 如：ArrayBlockingQueue、LinkedBlockingQueue 等。\n * 非阻塞队列 - 如： ConcurrentLinkedQueue 、LinkedTransferQueue 等。\n * Executor 框架（线程池）- 如：ThreadPoolExecutor、Executors 等。\n\n我个人理解，Java 并发框架可以分为以下层次。\n\n\n\n由 Java 并发框架图不难看出，J.U.C 包中的工具类是基于 synchronized、volatile、CAS、ThreadLocal 这样的并发核心机制打造的。所以，要想深入理解 J.U.C 工具类的特性、为什么具有这样那样的特性，就必须先理解这些核心机制。\n\n\n# synchronized\n\n> synchronized 是 Java 中的关键字，是 利用锁的机制来实现互斥同步的。\n> \n> synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。\n> \n> 如果不需要 Lock 、ReadWriteLock 所提供的高级同步特性，应该优先考虑使用 synchronized ，理由如下：\n> \n>  * Java 1.6 以后，synchronized 做了大量的优化，其性能已经与 Lock 、ReadWriteLock 基本上持平。从趋势来看，Java 未来仍将继续优化 synchronized ，而不是 ReentrantLock 。\n>  * ReentrantLock 是 Oracle JDK 的 API，在其他版本的 JDK 中不一定支持；而 synchronized 是 JVM 的内置特性，所有 JDK 版本都提供支持。\n\n\n# synchronized 的应用\n\nsynchronized 有 3 种应用方式：\n\n * 同步实例方法 - 对于普通同步方法，锁是当前实例对象\n * 同步静态方法 - 对于静态同步方法，锁是当前类的 Class 对象\n * 同步代码块 - 对于同步方法块，锁是 synchonized 括号里配置的对象\n\n> 说明：\n> \n> 类似 Vector、Hashtable 这类同步类，就是使用 synchonized 修饰其重要方法，来保证其线程安全。\n> \n> 事实上，这类同步容器也非绝对的线程安全，当执行迭代器遍历，根据条件删除元素这种场景下，就可能出现线程不安全的情况。此外，Java 1.6 针对 synchonized 进行优化前，由于阻塞，其性能不高。\n> \n> 综上，这类同步容器，在现代 Java 程序中，已经渐渐不用了。\n\n# 同步实例方法\n\n❌ 错误示例 - 未同步的示例\n\npublic class NoSynchronizedDemo implements Runnable {\n\n    public static final int MAX = 100000;\n\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        NoSynchronizedDemo instance = new NoSynchronizedDemo();\n        Thread t1 = new Thread(instance);\n        Thread t2 = new Thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(count);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < MAX; i++) {\n            increase();\n        }\n    }\n\n    public void increase() {\n        count++;\n    }\n\n}\n// 输出结果: 小于 200000 的随机数字\n\n\nJava 实例方法同步是同步在拥有该方法的对象上。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。\n\npublic class SynchronizedDemo implements Runnable {\n\n    private static final int MAX = 100000;\n\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        SynchronizedDemo instance = new SynchronizedDemo();\n        Thread t1 = new Thread(instance);\n        Thread t2 = new Thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(count);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < MAX; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰普通方法\n     */\n    public synchronized void increase() {\n        count++;\n    }\n\n}\n\n\n【示例】错误示例\n\nclass Account {\n  private int balance;\n  // 转账\n  synchronized void transfer(\n      Account target, int amt){\n    if (this.balance > amt) {\n      this.balance -= amt;\n      target.balance += amt;\n    }\n  }\n}\n\n\n在这段代码中，临界区内有两个资源，分别是转出账户的余额 this.balance 和转入账户的余额 target.balance，并且用的是一把锁 this，符合我们前面提到的，多个资源可以用一把锁来保护，这看上去完全正确呀。真的是这样吗？可惜，这个方案仅仅是看似正确，为什么呢？\n\n问题就出在 this 这把锁上，this 这把锁可以保护自己的余额 this.balance，却保护不了别人的余额 target.balance，就像你不能用自家的锁来保护别人家的资产，也不能用自己的票来保护别人的座位一样。\n\n\n\n应该保证使用的锁能覆盖所有受保护资源。\n\n【示例】正确姿势\n\nclass Account {\n  private Object lock；\n  private int balance;\n  private Account();\n  // 创建 Account 时传入同一个 lock 对象\n  public Account(Object lock) {\n    this.lock = lock;\n  }\n  // 转账\n  void transfer(Account target, int amt){\n    // 此处检查所有对象共享的锁\n    synchronized(lock) {\n      if (this.balance > amt) {\n        this.balance -= amt;\n        target.balance += amt;\n      }\n    }\n  }\n}\n\n\n这个办法确实能解决问题，但是有点小瑕疵，它要求在创建 Account 对象的时候必须传入同一个对象，如果创建 Account 对象时，传入的 lock 不是同一个对象，那可就惨了，会出现锁自家门来保护他家资产的荒唐事。在真实的项目场景中，创建 Account 对象的代码很可能分散在多个工程中，传入共享的 lock 真的很难。\n\n上面的方案缺乏实践的可行性，我们需要更好的方案。还真有，就是用 Account.class 作为共享的锁。Account.class 是所有 Account 对象共享的，而且这个对象是 Java 虚拟机在加载 Account 类的时候创建的，所以我们不用担心它的唯一性。使用 Account.class 作为共享的锁，我们就无需在创建 Account 对象时传入了，代码更简单。\n\n【示例】正确姿势\n\nclass Account {\n  private int balance;\n  // 转账\n  void transfer(Account target, int amt){\n    synchronized(Account.class) {\n      if (this.balance > amt) {\n        this.balance -= amt;\n        target.balance += amt;\n      }\n    }\n  }\n}\n\n\n# 同步静态方法\n\n静态方法的同步是指同步在该方法所在的类对象上。因为在 JVM 中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。\n\n对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的哪个静态同步方法被调用，一个类只能由一个线程同时执行。\n\npublic class SynchronizedDemo2 implements Runnable {\n\n    private static final int MAX = 100000;\n\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        SynchronizedDemo2 instance = new SynchronizedDemo2();\n        Thread t1 = new Thread(instance);\n        Thread t2 = new Thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(count);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < MAX; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰静态方法\n     */\n    public synchronized static void increase() {\n        count++;\n    }\n\n}\n\n\n# 同步代码块\n\n有时你不需要同步整个方法，而是同步方法中的一部分。Java 可以对方法的一部分进行同步。\n\n@ThreadSafe\npublic class SynchronizedDemo05 implements Runnable {\n\n    private static final int MAX = 100000;\n\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        SynchronizedDemo05 instance = new SynchronizedDemo05();\n        Thread t1 = new Thread(instance);\n        Thread t2 = new Thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(count);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < MAX; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰代码块\n     */\n    public void increase() {\n        synchronized (this) {\n            count++;\n        }\n    }\n\n}\n\n\n注意 Java 同步块构造器用括号将对象括起来。在上例中，使用了 this，即为调用 increase 方法的实例本身。用括号括起来的对象叫做监视器对象。一次只有一个线程能够在同步于同一个监视器对象的 Java 方法内执行。\n\n如果是静态方法，就不能用 this 对象作为监视器对象了，而是使用 Class 对象，如下：\n\npublic class SynchronizedDemo3 implements Runnable {\n\n    private static final int MAX = 100000;\n\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        SynchronizedDemo3 instance = new SynchronizedDemo3();\n        Thread t1 = new Thread(instance);\n        Thread t2 = new Thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(count);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < MAX; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰代码块\n     */\n    public static void increase() {\n        synchronized (SynchronizedDemo3.class) {\n            count++;\n        }\n    }\n\n}\n\n\n\n# synchronized 的原理\n\nsynchronized 代码块是由一对 monitorenter 和 monitorexit 指令实现的，Monitor 对象是同步的基本实现单元。在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。\n\n如果 synchronized 明确制定了对象参数，那就是这个对象的引用；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是静态方法，去对对应的对象实例或 Class 对象来作为锁对象。\n\nsynchronized 同步块对同一线程来说是可重入的，不会出现锁死问题。\n\nsynchronized 同步块是互斥的，即已进入的线程执行完成前，会阻塞其他试图进入的线程。\n\n【示例】\n\npublic void foo(Object lock) {\n    synchronized (lock) {\n      lock.hashCode();\n    }\n  }\n  // 上面的 Java 代码将编译为下面的字节码\n  public void foo(java.lang.Object);\n    Code:\n       0: aload_1\n       1: dup\n       2: astore_2\n       3: monitorenter\n       4: aload_1\n       5: invokevirtual java/lang/Object.hashCode:()I\n       8: pop\n       9: aload_2\n      10: monitorexit\n      11: goto          19\n      14: astore_3\n      15: aload_2\n      16: monitorexit\n      17: aload_3\n      18: athrow\n      19: return\n    Exception table:\n       from    to  target type\n           4    11    14   any\n          14    17    14   any\n\n\n\n# 同步代码块\n\nsynchronized 在修饰同步代码块时，是由 monitorenter 和 monitorexit 指令来实现同步的。进入 monitorenter 指令后，线程将持有 Monitor 对象，退出 monitorenter 指令后，线程将释放该 Monitor 对象。\n\n# 同步方法\n\nsynchronized 修饰同步方法时，会设置一个 ACC_SYNCHRONIZED 标志。当方法调用时，调用指令将会检查该方法是否被设置 ACC_SYNCHRONIZED 访问标志。如果设置了该标志，执行线程将先持有 Monitor 对象，然后再执行方法。在该方法运行期间，其它线程将无法获取到该 Mointor 对象，当方法执行完成后，再释放该 Monitor 对象。\n\n# Monitor\n\n每个对象实例都会有一个 Monitor，Monitor 可以和对象一起创建、销毁。Monitor 是由 ObjectMonitor 实现，而 ObjectMonitor 是由 C++ 的 ObjectMonitor.hpp 文件实现。\n\n当多个线程同时访问一段同步代码时，多个线程会先被存放在 EntryList 集合中，处于 block 状态的线程，都会被加入到该列表。接下来当线程获取到对象的 Monitor 时，Monitor 是依靠底层操作系统的 Mutex Lock 来实现互斥的，线程申请 Mutex 成功，则持有该 Mutex，其它线程将无法获取到该 Mutex。\n\n如果线程调用 wait() 方法，就会释放当前持有的 Mutex，并且该线程会进入 WaitSet 集合中，等待下一次被唤醒。如果当前线程顺利执行完方法，也将释放 Mutex。\n\n\n# synchronized 的优化\n\n> Java 1.6 以后，synchronized 做了大量的优化，其性能已经与 Lock 、ReadWriteLock 基本上持平。\n\n# Java 对象头\n\n在 JDK1.6 JVM 中，对象实例在堆内存中被分为了三个部分：对象头、实例数据和对齐填充。其中 Java 对象头由 Mark Word、指向类的指针以及数组长度三部分组成。\n\nMark Word 记录了对象和锁有关的信息。Mark Word 在 64 位 JVM 中的长度是 64bit，我们可以一起看下 64 位 JVM 的存储结构是怎么样的。如下图所示：\n\n\n\n锁升级功能主要依赖于 Mark Word 中的锁标志位和是否偏向锁标志位，synchronized 同步锁就是从偏向锁开始的，随着竞争越来越激烈，偏向锁升级到轻量级锁，最终升级到重量级锁。\n\nJava 1.6 引入了偏向锁和轻量级锁，从而让 synchronized 拥有了四个状态：\n\n * 无锁状态（unlocked）\n * 偏向锁状态（biasble）\n * 轻量级锁状态（lightweight locked）\n * 重量级锁状态（inflated）\n\n当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现。\n\n当没有竞争出现时，默认会使用偏向锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。\n\n如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏向锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。\n\n# 偏向锁\n\n偏向锁的思想是偏向于第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。\n\n\n\n# 轻量级锁\n\n轻量级锁是相对于传统的重量级锁而言，它 使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。\n\n当尝试获取一个锁对象时，如果锁对象标记为 0|01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。\n\n\n\n# 锁消除 / 锁粗化\n\n除了锁升级优化，Java 还使用了编译器对锁进行优化。\n\n（1）锁消除\n\n锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。\n\nJIT 编译器在动态编译同步块的时候，借助了一种被称为逃逸分析的技术，来判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其它线程。\n\n确认是的话，那么 JIT 编译器在编译这个同步块的时候不会生成 synchronized 所表示的锁的申请与释放的机器码，即消除了锁的使用。在 Java7 之后的版本就不需要手动配置了，该操作可以自动实现。\n\n对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：\n\npublic static String concatString(String s1, String s2, String s3) {\n    return s1 + s2 + s3;\n}\n\n\nString 是一个不可变的类，编译器会对 String 的拼接自动优化。在 Java 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：\n\npublic static String concatString(String s1, String s2, String s3) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    sb.append(s3);\n    return sb.toString();\n}\n\n\n每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。\n\n（2）锁粗化\n\n锁粗化同理，就是在 JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。\n\n如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。\n\n上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。\n\n# 自旋锁\n\n互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。\n\n自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。\n\n在 Java 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。\n\n\n# synchronized 的误区\n\n> 示例摘自：《Java 业务开发常见错误 100 例》\n\n# synchronized 使用范围不当导致的错误\n\npublic class Interesting {\n\n    volatile int a = 1;\n    volatile int b = 1;\n\n    public static void main(String[] args) {\n        Interesting interesting = new Interesting();\n        new Thread(() -> interesting.add()).start();\n        new Thread(() -> interesting.compare()).start();\n    }\n\n    public synchronized void add() {\n        log.info("add start");\n        for (int i = 0; i < 10000; i++) {\n            a++;\n            b++;\n        }\n        log.info("add done");\n    }\n\n    public void compare() {\n        log.info("compare start");\n        for (int i = 0; i < 10000; i++) {\n            //a始终等于b吗？\n            if (a < b) {\n                log.info("a:{},b:{},{}", a, b, a > b);\n                //最后的a>b应该始终是false吗？\n            }\n        }\n        log.info("compare done");\n    }\n\n}\n\n\n【输出】\n\n16:05:25.541 [Thread-0] INFO io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - add start\n16:05:25.544 [Thread-0] INFO io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - add done\n16:05:25.544 [Thread-1] INFO io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - compare start\n16:05:25.544 [Thread-1] INFO io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - compare done\n\n\n之所以出现这种错乱，是因为两个线程是交错执行 add 和 compare 方法中的业务逻辑，而且这些业务逻辑不是原子性的：a++ 和 b++ 操作中可以穿插在 compare 方法的比较代码中；更需要注意的是，a<b 这种比较操作在字节码层面是加载 a、加载 b 和比较三步，代码虽然是一行但也不是原子性的。\n\n所以，正确的做法应该是，为 add 和 compare 都加上方法锁，确保 add 方法执行时，compare 无法读取 a 和 b：\n\npublic synchronized void add()\npublic synchronized void compare()\n\n\n所以，使用锁解决问题之前一定要理清楚，我们要保护的是什么逻辑，多线程执行的情况又是怎样的。\n\n# synchronized 保护对象不对导致的错误\n\n加锁前要清楚锁和被保护的对象是不是一个层面的。\n\n静态字段属于类，类级别的锁才能保护；而非静态字段属于类实例，实例级别的锁就可以保护。\n\npublic class synchronized错误使用示例2 {\n\n    public static void main(String[] args) {\n        synchronized错误使用示例2 demo = new synchronized错误使用示例2();\n        System.out.println(demo.wrong(1000000));\n        System.out.println(demo.right(1000000));\n    }\n\n    public int wrong(int count) {\n        Data.reset();\n        IntStream.rangeClosed(1, count).parallel().forEach(i -> new Data().wrong());\n        return Data.getCounter();\n    }\n\n    public int right(int count) {\n        Data.reset();\n        IntStream.rangeClosed(1, count).parallel().forEach(i -> new Data().right());\n        return Data.getCounter();\n    }\n\n    private static class Data {\n\n        @Getter\n        private static int counter = 0;\n        private static Object locker = new Object();\n\n        public static int reset() {\n            counter = 0;\n            return counter;\n        }\n\n        public synchronized void wrong() {\n            counter++;\n        }\n\n        public void right() {\n            synchronized (locker) {\n                counter++;\n            }\n        }\n\n    }\n\n}\n\n\nwrong 方法中试图对一个静态对象加对象级别的 synchronized 锁，并不能保证线程安全。\n\n# 锁粒度导致的问题\n\n要尽可能的缩小加锁的范围，这可以提高并发吞吐。\n\n如果精细化考虑了锁应用范围后，性能还无法满足需求的话，我们就要考虑另一个维度的粒度问题了，即：区分读写场景以及资源的访问冲突，考虑使用悲观方式的锁还是乐观方式的锁。\n\npublic class synchronized锁粒度不当 {\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.wrong();\n        demo.right();\n    }\n\n    private static class Demo {\n\n        private List<Integer> data = new ArrayList<>();\n\n        private void slow() {\n            try {\n                TimeUnit.MILLISECONDS.sleep(10);\n            } catch (InterruptedException e) {\n            }\n        }\n\n        public int wrong() {\n            long begin = System.currentTimeMillis();\n            IntStream.rangeClosed(1, 1000).parallel().forEach(i -> {\n                synchronized (this) {\n                    slow();\n                    data.add(i);\n                }\n            });\n            log.info("took:{}", System.currentTimeMillis() - begin);\n            return data.size();\n        }\n\n        public int right() {\n            long begin = System.currentTimeMillis();\n            IntStream.rangeClosed(1, 1000).parallel().forEach(i -> {\n                slow();\n                synchronized (data) {\n                    data.add(i);\n                }\n            });\n            log.info("took:{}", System.currentTimeMillis() - begin);\n            return data.size();\n        }\n\n    }\n\n}\n\n\n\n# volatile\n\n\n# volatile 的要点\n\nvolatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。\n\n被 volatile 修饰的变量，具备以下特性：\n\n * 线程可见性 - 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个共享变量，另外一个线程能读到这个修改的值。\n * 禁止指令重排序\n * 不保证原子性\n\n我们知道，线程安全需要具备：可见性、原子性、顺序性。volatile 不保证原子性，所以决定了它不能彻底地保证线程安全。\n\n\n# volatile 的应用\n\n如果 volatile 变量修饰符使用恰当的话，它比 synchronized 的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。但是，volatile 无法替代 synchronized ，因为 volatile 无法保证操作的原子性。\n\n通常来说，使用 volatile 必须具备以下 2 个条件：\n\n * 对变量的写操作不依赖于当前值\n * 该变量没有包含在具有其他变量的表达式中\n\n【示例】状态标记量\n\nvolatile boolean flag = false;\n\nwhile(!flag) {\n    doSomething();\n}\n\npublic void setFlag() {\n    flag = true;\n}\n\n\n【示例】双重锁实现线程安全的单例模式\n\nclass Singleton {\n    private volatile static Singleton instance = null;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n\n\n\n# volatile 的原理\n\n观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令。lock 前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供 3 个功能：\n\n * 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n * 它会强制将对缓存的修改操作立即写入主存；\n * 如果是写操作，它会导致其他 CPU 中对应的缓存行无效。\n\n\n# volatile 的问题\n\nvolatile 的要点中，已经提到，volatile 不保证原子性，所以 volatile 并不能保证线程安全。\n\n那么，如何做到线程安全呢？有两种方案：\n\n * volatile + synchronized - 可以参考：【示例】双重锁实现线程安全的单例模式\n * 使用原子类替代 volatile\n\n\n# CAS\n\n\n# CAS 的要点\n\n互斥同步是最常见的并发正确性保障手段。\n\n互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题，因此互斥同步也被称为阻塞同步。互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。\n\n随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。\n\n为什么说乐观锁需要 硬件指令集的发展 才能进行？因为需要操作和冲突检测这两个步骤具备原子性。而这点是由硬件来完成，如果再使用互斥同步来保证就失去意义了。硬件支持的原子性操作最典型的是：CAS。\n\nCAS（Compare and Swap），字面意思为比较并交换。CAS 有 3 个操作数，分别是：内存值 M，期望值 E，更新值 U。当且仅当内存值 M 和期望值 E 相等时，将内存值 M 修改为 U，否则什么都不做。\n\n\n# CAS 的应用\n\nCAS 只适用于线程冲突较少的情况。\n\nCAS 的典型应用场景是：\n\n * 原子类\n * 自旋锁\n\n# 原子类\n\n> 原子类是 CAS 在 Java 中最典型的应用。\n\n我们先来看一个常见的代码片段。\n\nif(a==b) {\n    a++;\n}\n\n\n如果 a++ 执行前， a 的值被修改了怎么办？还能得到预期值吗？出现该问题的原因是在并发环境下，以上代码片段不是原子操作，随时可能被其他线程所篡改。\n\n解决这种问题的最经典方式是应用原子类的 incrementAndGet 方法。\n\npublic class AtomicIntegerDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        final AtomicInteger count = new AtomicInteger(0);\n        for (int i = 0; i < 10; i++) {\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {\n                    count.incrementAndGet();\n                }\n            });\n        }\n\n        executorService.shutdown();\n        executorService.awaitTermination(3, TimeUnit.SECONDS);\n        System.out.println("Final Count is : " + count.get());\n    }\n\n}\n\n\nJ.U.C 包中提供了 AtomicBoolean、AtomicInteger、AtomicLong 分别针对 Boolean、Integer、Long 执行原子操作，操作和上面的示例大体相似，不做赘述。\n\n# 自旋锁\n\n利用原子类（本质上是 CAS），可以实现自旋锁。\n\n所谓自旋锁，是指线程反复检查锁变量是否可用，直到成功为止。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。\n\n示例：非线程安全示例\n\npublic class AtomicReferenceDemo {\n\n    private static int ticket = 10;\n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        for (int i = 0; i < 5; i++) {\n            executorService.execute(new MyThread());\n        }\n        executorService.shutdown();\n    }\n\n    static class MyThread implements Runnable {\n\n        @Override\n        public void run() {\n            while (ticket > 0) {\n                System.out.println(Thread.currentThread().getName() + " 卖出了第 " + ticket + " 张票");\n                ticket--;\n            }\n        }\n\n    }\n\n}\n\n\n输出结果：\n\npool-1-thread-2 卖出了第 10 张票\npool-1-thread-1 卖出了第 10 张票\npool-1-thread-3 卖出了第 10 张票\npool-1-thread-1 卖出了第 8 张票\npool-1-thread-2 卖出了第 9 张票\npool-1-thread-1 卖出了第 6 张票\npool-1-thread-3 卖出了第 7 张票\npool-1-thread-1 卖出了第 4 张票\npool-1-thread-2 卖出了第 5 张票\npool-1-thread-1 卖出了第 2 张票\npool-1-thread-3 卖出了第 3 张票\npool-1-thread-2 卖出了第 1 张票\n\n\n很明显，出现了重复售票的情况。\n\n【示例】使用自旋锁来保证线程安全\n\n可以通过自旋锁这种非阻塞同步来保证线程安全，下面使用 AtomicReference 来实现一个自旋锁。\n\npublic class AtomicReferenceDemo2 {\n\n    private static int ticket = 10;\n\n    public static void main(String[] args) {\n        threadSafeDemo();\n    }\n\n    private static void threadSafeDemo() {\n        SpinLock lock = new SpinLock();\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        for (int i = 0; i < 5; i++) {\n            executorService.execute(new MyThread(lock));\n        }\n        executorService.shutdown();\n    }\n\n    static class SpinLock {\n\n        private AtomicReference<Thread> atomicReference = new AtomicReference<>();\n\n        public void lock() {\n            Thread current = Thread.currentThread();\n            while (!atomicReference.compareAndSet(null, current)) {}\n        }\n\n        public void unlock() {\n            Thread current = Thread.currentThread();\n            atomicReference.compareAndSet(current, null);\n        }\n\n    }\n\n    static class MyThread implements Runnable {\n\n        private SpinLock lock;\n\n        public MyThread(SpinLock lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            while (ticket > 0) {\n                lock.lock();\n                if (ticket > 0) {\n                    System.out.println(Thread.currentThread().getName() + " 卖出了第 " + ticket + " 张票");\n                    ticket--;\n                }\n                lock.unlock();\n            }\n        }\n\n    }\n\n}\n\n\n输出结果：\n\npool-1-thread-2 卖出了第 10 张票\npool-1-thread-1 卖出了第 9 张票\npool-1-thread-3 卖出了第 8 张票\npool-1-thread-2 卖出了第 7 张票\npool-1-thread-3 卖出了第 6 张票\npool-1-thread-1 卖出了第 5 张票\npool-1-thread-2 卖出了第 4 张票\npool-1-thread-1 卖出了第 3 张票\npool-1-thread-3 卖出了第 2 张票\npool-1-thread-1 卖出了第 1 张票\n\n\n\n# CAS 的原理\n\nJava 主要利用 Unsafe 这个类提供的 CAS 操作。Unsafe 的 CAS 依赖的是 JVM 针对不同的操作系统实现的硬件指令 Atomic::cmpxchg。Atomic::cmpxchg 的实现使用了汇编的 CAS 操作，并使用 CPU 提供的 lock 信号保证其原子性。\n\n\n# CAS 的问题\n\n一般情况下，CAS 比锁性能更高。因为 CAS 是一种非阻塞算法，所以其避免了线程阻塞和唤醒的等待时间。\n\n但是，事物总会有利有弊，CAS 也存在三大问题：\n\n * ABA 问题\n * 循环时间长开销大\n * 只能保证一个共享变量的原子性\n\n# ABA 问题\n\n如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。\n\nJ.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。\n\n# 循环时间长开销大\n\n自旋 CAS （不断尝试，直到成功为止）如果长时间不成功，会给 CPU 带来非常大的执行开销。\n\n如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：\n\n * 它可以延迟流水线执行指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。\n * 它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。\n\n比较花费 CPU 资源，即使没有任何用也会做一些无用功。\n\n# 只能保证一个共享变量的原子性\n\n当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。\n\n或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量 i ＝ 2, j = a，合并一下 ij=2a，然后用 CAS 来操作 ij。从 Java 1.5 开始 JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。\n\n\n# ThreadLocal\n\n> ThreadLocal 是一个存储线程本地副本的工具类。\n> \n> 要保证线程安全，不一定非要进行同步。同步只是保证共享数据争用时的正确性，如果一个方法本来就不涉及共享数据，那么自然无须同步。\n> \n> Java 中的 无同步方案 有：\n> \n>  * 可重入代码 - 也叫纯代码。如果一个方法，它的 返回结果是可以预测的，即只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性，当然也是线程安全的。\n>  * 线程本地存储 - 使用 ThreadLocal 为共享变量在每个线程中都创建了一个本地副本，这个副本只能被当前线程访问，其他线程无法访问，那么自然是线程安全的。\n\n\n# ThreadLocal 的应用\n\nThreadLocal 的方法：\n\npublic class ThreadLocal<T> {\n    public T get() {}\n    public void set(T value) {}\n    public void remove() {}\n    public static <S> ThreadLocal<S> withInitial(Supplier<? extends S> supplier) {}\n}\n\n\n> 说明：\n> \n>  * get - 用于获取 ThreadLocal 在当前线程中保存的变量副本。\n>  * set - 用于设置当前线程中变量的副本。\n>  * remove - 用于删除当前线程中变量的副本。如果此线程局部变量随后被当前线程读取，则其值将通过调用其 initialValue 方法重新初始化，除非其值由中间线程中的当前线程设置。 这可能会导致当前线程中多次调用 initialValue 方法。\n>  * initialValue - 为 ThreadLocal 设置默认的 get 初始值，需要重写 initialValue 方法 。\n\nThreadLocal 常用于防止对可变的单例（Singleton）变量或全局变量进行共享。典型应用场景有：管理数据库连接、Session。\n\n【示例】数据库连接\n\nprivate static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {\n    @Override\n    public Connection initialValue() {\n        return DriverManager.getConnection(DB_URL);\n    }\n};\n\npublic static Connection getConnection() {\n    return connectionHolder.get();\n}\n\n\n【示例】Session 管理\n\nprivate static final ThreadLocal<Session> sessionHolder = new ThreadLocal<>();\n\npublic static Session getSession() {\n    Session session = (Session) sessionHolder.get();\n    try {\n        if (session == null) {\n            session = createSession();\n            sessionHolder.set(session);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return session;\n}\n\n\n【示例】完整使用 ThreadLocal 示例\n\npublic class ThreadLocalDemo {\n\n    private static ThreadLocal<Integer> threadLocal = new ThreadLocal<Integer>() {\n        @Override\n        protected Integer initialValue() {\n            return 0;\n        }\n    };\n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(10);\n        for (int i = 0; i < 10; i++) {\n            executorService.execute(new MyThread());\n        }\n        executorService.shutdown();\n    }\n\n    static class MyThread implements Runnable {\n\n        @Override\n        public void run() {\n            int count = threadLocal.get();\n            for (int i = 0; i < 10; i++) {\n                try {\n                    count++;\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            threadLocal.set(count);\n            threadLocal.remove();\n            System.out.println(Thread.currentThread().getName() + " : " + count);\n        }\n\n    }\n\n}\n\n\n全部输出 count = 10\n\n\n# ThreadLocal 的原理\n\n# 存储结构\n\nThread 类中维护着一个 ThreadLocal.ThreadLocalMap 类型的成员 threadLocals。这个成员就是用来存储当前线程独占的变量副本。\n\nThreadLocalMap 是 ThreadLocal 的内部类，它维护着一个 Entry 数组，Entry 继承了 WeakReference ，所以是弱引用。 Entry 用于保存键值对，其中：\n\n * key 是 ThreadLocal 对象；\n * value 是传递进来的对象（变量副本）。\n\npublic class Thread implements Runnable {\n    // ...\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n    // ...\n}\n\nstatic class ThreadLocalMap {\n    // ...\n    static class Entry extends WeakReference<ThreadLocal<?>> {\n        /** The value associated with this ThreadLocal. */\n        Object value;\n\n        Entry(ThreadLocal<?> k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n    // ...\n}\n\n\n# 如何解决 Hash 冲突\n\nThreadLocalMap 虽然是类似 Map 结构的数据结构，但它并没有实现 Map 接口。它不支持 Map 接口中的 next 方法，这意味着 ThreadLocalMap 中解决 Hash 冲突的方式并非 拉链表 方式。\n\n实际上，ThreadLocalMap 采用线性探测的方式来解决 Hash 冲突。所谓线性探测，就是根据初始 key 的 hashcode 值确定元素在 table 数组中的位置，如果发现这个位置上已经被其他的 key 值占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。\n\n# 内存泄漏问题\n\nThreadLocalMap 的 Entry 继承了 WeakReference，所以它的 key （ThreadLocal 对象）是弱引用，而 value （变量副本）是强引用。\n\n * 如果 ThreadLocal 对象没有外部强引用来引用它，那么 ThreadLocal 对象会在下次 GC 时被回收。\n * 此时，Entry 中的 key 已经被回收，但是 value 由于是强引用不会被垃圾收集器回收。如果创建 ThreadLocal 的线程一直持续运行，那么 value 就会一直得不到回收，产生内存泄露。\n\n那么如何避免内存泄漏呢？方法就是：使用 ThreadLocal 的 set 方法后，显示的调用 remove 方法 。\n\nThreadLocal<String> threadLocal = new ThreadLocal();\ntry {\n    threadLocal.set("xxx");\n    // ...\n} finally {\n    threadLocal.remove();\n}\n\n\n\n# ThreadLocal 的误区\n\n> 示例摘自：《Java 业务开发常见错误 100 例》\n\nThreadLocal 适用于变量在线程间隔离，而在方法或类间共享的场景。\n\n前文提到，ThreadLocal 是线程隔离的，那么是不是使用 ThreadLocal 就一定高枕无忧呢？\n\n# ThreadLocal 错误案例\n\n使用 Spring Boot 创建一个 Web 应用程序，使用 ThreadLocal 存放一个 Integer 的值，来暂且代表需要在线程中保存的用户信息，这个值初始是 null。\n\n    private ThreadLocal<Integer> currentUser = ThreadLocal.withInitial(() -> null);\n\n    @GetMapping("wrong")\n    public Map<String, String> wrong(@RequestParam("id") Integer userId) {\n        //设置用户信息之前先查询一次ThreadLocal中的用户信息\n        String before = Thread.currentThread().getName() + ":" + currentUser.get();\n        //设置用户信息到ThreadLocal\n        currentUser.set(userId);\n        //设置用户信息之后再查询一次ThreadLocal中的用户信息\n        String after = Thread.currentThread().getName() + ":" + currentUser.get();\n        //汇总输出两次查询结果\n        Map<String, String> result = new HashMap<>();\n        result.put("before", before);\n        result.put("after", after);\n        return result;\n    }\n\n\n【预期】从代码逻辑来看，我们预期第一次获取的值始终应该是 null。\n\n【实际】\n\n为了方便复现，将 Tomcat 工作线程设为 1：\n\nserver.tomcat.max-threads=1\n\n\n当访问 id = 1 时，符合预期\n\n\n\n当访问 id = 2 时，before 的应答不是 null，而是 1，不符合预期。\n\n\n\n【分析】实际情况和预期存在偏差。Spring Boot 程序运行在 Tomcat 中，执行程序的线程是 Tomcat 的工作线程，而 Tomcat 的工作线程是基于线程池的。线程池会重用固定的几个线程，一旦线程重用，那么很可能首次从 ThreadLocal 获取的值是之前其他用户的请求遗留的值。这时，ThreadLocal 中的用户信息就是其他用户的信息。\n\n并不能认为没有显式开启多线程就不会有线程安全问题。使用类似 ThreadLocal 工具来存放一些数据时，需要特别注意在代码运行完后，显式地去清空设置的数据。\n\n# ThreadLocal 错误案例修正\n\n    @GetMapping("right")\n    public Map<String, String> right(@RequestParam("id") Integer userId) {\n        String before = Thread.currentThread().getName() + ":" + currentUser.get();\n        currentUser.set(userId);\n        try {\n            String after = Thread.currentThread().getName() + ":" + currentUser.get();\n            Map<String, String> result = new HashMap<>();\n            result.put("before", before);\n            result.put("after", after);\n            return result;\n        } finally {\n            //在finally代码块中删除ThreadLocal中的数据，确保数据不串\n            currentUser.remove();\n        }\n    }\n\n\n\n# InheritableThreadLocal\n\nInheritableThreadLocal 类是 ThreadLocal 类的子类。\n\nThreadLocal 中每个线程拥有它自己独占的数据。与 ThreadLocal 不同的是，InheritableThreadLocal 允许一个线程以及该线程创建的所有子线程都可以访问它保存的数据。\n\n> 原理参考：Java 多线程：InheritableThreadLocal 实现原理\n\n\n# 参考资料\n\n * 《Java 并发编程实战》\n * 《Java 并发编程的艺术》\n * 《深入理解 Java 虚拟机》\n * 《Java 业务开发常见错误 100 例》\n * Java 并发编程：volatile 关键字解析\n * Java 并发编程：synchronized\n * 深入理解 Java 并发之 synchronized 实现原理\n * Java CAS 完全解读\n * Java 中 CAS 详解\n * ThreadLocal 终极篇\n * synchronized 实现原理及锁优化\n * Non-blocking Algorithms',normalizedContent:'# java 并发核心机制\n\n> java 对于并发的支持主要汇聚在 java.util.concurrent，即 j.u.c。而 j.u.c 的核心是 aqs。\n\n\n# j.u.c 简介\n\njava 的 java.util.concurrent 包（简称 j.u.c）中提供了大量并发工具类，是 java 并发能力的主要体现（注意，不是全部，有部分并发能力的支持在其他包中）。从功能上，大致可以分为：\n\n * 原子类 - 如：atomicinteger、atomicintegerarray、atomicreference、atomicstampedreference 等。\n * 锁 - 如：reentrantlock、reentrantreadwritelock 等。\n * 并发容器 - 如：concurrenthashmap、copyonwritearraylist、copyonwritearrayset 等。\n * 阻塞队列 - 如：arrayblockingqueue、linkedblockingqueue 等。\n * 非阻塞队列 - 如： concurrentlinkedqueue 、linkedtransferqueue 等。\n * executor 框架（线程池）- 如：threadpoolexecutor、executors 等。\n\n我个人理解，java 并发框架可以分为以下层次。\n\n\n\n由 java 并发框架图不难看出，j.u.c 包中的工具类是基于 synchronized、volatile、cas、threadlocal 这样的并发核心机制打造的。所以，要想深入理解 j.u.c 工具类的特性、为什么具有这样那样的特性，就必须先理解这些核心机制。\n\n\n# synchronized\n\n> synchronized 是 java 中的关键字，是 利用锁的机制来实现互斥同步的。\n> \n> synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。\n> \n> 如果不需要 lock 、readwritelock 所提供的高级同步特性，应该优先考虑使用 synchronized ，理由如下：\n> \n>  * java 1.6 以后，synchronized 做了大量的优化，其性能已经与 lock 、readwritelock 基本上持平。从趋势来看，java 未来仍将继续优化 synchronized ，而不是 reentrantlock 。\n>  * reentrantlock 是 oracle jdk 的 api，在其他版本的 jdk 中不一定支持；而 synchronized 是 jvm 的内置特性，所有 jdk 版本都提供支持。\n\n\n# synchronized 的应用\n\nsynchronized 有 3 种应用方式：\n\n * 同步实例方法 - 对于普通同步方法，锁是当前实例对象\n * 同步静态方法 - 对于静态同步方法，锁是当前类的 class 对象\n * 同步代码块 - 对于同步方法块，锁是 synchonized 括号里配置的对象\n\n> 说明：\n> \n> 类似 vector、hashtable 这类同步类，就是使用 synchonized 修饰其重要方法，来保证其线程安全。\n> \n> 事实上，这类同步容器也非绝对的线程安全，当执行迭代器遍历，根据条件删除元素这种场景下，就可能出现线程不安全的情况。此外，java 1.6 针对 synchonized 进行优化前，由于阻塞，其性能不高。\n> \n> 综上，这类同步容器，在现代 java 程序中，已经渐渐不用了。\n\n# 同步实例方法\n\n❌ 错误示例 - 未同步的示例\n\npublic class nosynchronizeddemo implements runnable {\n\n    public static final int max = 100000;\n\n    private static int count = 0;\n\n    public static void main(string[] args) throws interruptedexception {\n        nosynchronizeddemo instance = new nosynchronizeddemo();\n        thread t1 = new thread(instance);\n        thread t2 = new thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        system.out.println(count);\n    }\n\n    @override\n    public void run() {\n        for (int i = 0; i < max; i++) {\n            increase();\n        }\n    }\n\n    public void increase() {\n        count++;\n    }\n\n}\n// 输出结果: 小于 200000 的随机数字\n\n\njava 实例方法同步是同步在拥有该方法的对象上。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。\n\npublic class synchronizeddemo implements runnable {\n\n    private static final int max = 100000;\n\n    private static int count = 0;\n\n    public static void main(string[] args) throws interruptedexception {\n        synchronizeddemo instance = new synchronizeddemo();\n        thread t1 = new thread(instance);\n        thread t2 = new thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        system.out.println(count);\n    }\n\n    @override\n    public void run() {\n        for (int i = 0; i < max; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰普通方法\n     */\n    public synchronized void increase() {\n        count++;\n    }\n\n}\n\n\n【示例】错误示例\n\nclass account {\n  private int balance;\n  // 转账\n  synchronized void transfer(\n      account target, int amt){\n    if (this.balance > amt) {\n      this.balance -= amt;\n      target.balance += amt;\n    }\n  }\n}\n\n\n在这段代码中，临界区内有两个资源，分别是转出账户的余额 this.balance 和转入账户的余额 target.balance，并且用的是一把锁 this，符合我们前面提到的，多个资源可以用一把锁来保护，这看上去完全正确呀。真的是这样吗？可惜，这个方案仅仅是看似正确，为什么呢？\n\n问题就出在 this 这把锁上，this 这把锁可以保护自己的余额 this.balance，却保护不了别人的余额 target.balance，就像你不能用自家的锁来保护别人家的资产，也不能用自己的票来保护别人的座位一样。\n\n\n\n应该保证使用的锁能覆盖所有受保护资源。\n\n【示例】正确姿势\n\nclass account {\n  private object lock；\n  private int balance;\n  private account();\n  // 创建 account 时传入同一个 lock 对象\n  public account(object lock) {\n    this.lock = lock;\n  }\n  // 转账\n  void transfer(account target, int amt){\n    // 此处检查所有对象共享的锁\n    synchronized(lock) {\n      if (this.balance > amt) {\n        this.balance -= amt;\n        target.balance += amt;\n      }\n    }\n  }\n}\n\n\n这个办法确实能解决问题，但是有点小瑕疵，它要求在创建 account 对象的时候必须传入同一个对象，如果创建 account 对象时，传入的 lock 不是同一个对象，那可就惨了，会出现锁自家门来保护他家资产的荒唐事。在真实的项目场景中，创建 account 对象的代码很可能分散在多个工程中，传入共享的 lock 真的很难。\n\n上面的方案缺乏实践的可行性，我们需要更好的方案。还真有，就是用 account.class 作为共享的锁。account.class 是所有 account 对象共享的，而且这个对象是 java 虚拟机在加载 account 类的时候创建的，所以我们不用担心它的唯一性。使用 account.class 作为共享的锁，我们就无需在创建 account 对象时传入了，代码更简单。\n\n【示例】正确姿势\n\nclass account {\n  private int balance;\n  // 转账\n  void transfer(account target, int amt){\n    synchronized(account.class) {\n      if (this.balance > amt) {\n        this.balance -= amt;\n        target.balance += amt;\n      }\n    }\n  }\n}\n\n\n# 同步静态方法\n\n静态方法的同步是指同步在该方法所在的类对象上。因为在 jvm 中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。\n\n对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的哪个静态同步方法被调用，一个类只能由一个线程同时执行。\n\npublic class synchronizeddemo2 implements runnable {\n\n    private static final int max = 100000;\n\n    private static int count = 0;\n\n    public static void main(string[] args) throws interruptedexception {\n        synchronizeddemo2 instance = new synchronizeddemo2();\n        thread t1 = new thread(instance);\n        thread t2 = new thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        system.out.println(count);\n    }\n\n    @override\n    public void run() {\n        for (int i = 0; i < max; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰静态方法\n     */\n    public synchronized static void increase() {\n        count++;\n    }\n\n}\n\n\n# 同步代码块\n\n有时你不需要同步整个方法，而是同步方法中的一部分。java 可以对方法的一部分进行同步。\n\n@threadsafe\npublic class synchronizeddemo05 implements runnable {\n\n    private static final int max = 100000;\n\n    private static int count = 0;\n\n    public static void main(string[] args) throws interruptedexception {\n        synchronizeddemo05 instance = new synchronizeddemo05();\n        thread t1 = new thread(instance);\n        thread t2 = new thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        system.out.println(count);\n    }\n\n    @override\n    public void run() {\n        for (int i = 0; i < max; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰代码块\n     */\n    public void increase() {\n        synchronized (this) {\n            count++;\n        }\n    }\n\n}\n\n\n注意 java 同步块构造器用括号将对象括起来。在上例中，使用了 this，即为调用 increase 方法的实例本身。用括号括起来的对象叫做监视器对象。一次只有一个线程能够在同步于同一个监视器对象的 java 方法内执行。\n\n如果是静态方法，就不能用 this 对象作为监视器对象了，而是使用 class 对象，如下：\n\npublic class synchronizeddemo3 implements runnable {\n\n    private static final int max = 100000;\n\n    private static int count = 0;\n\n    public static void main(string[] args) throws interruptedexception {\n        synchronizeddemo3 instance = new synchronizeddemo3();\n        thread t1 = new thread(instance);\n        thread t2 = new thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        system.out.println(count);\n    }\n\n    @override\n    public void run() {\n        for (int i = 0; i < max; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰代码块\n     */\n    public static void increase() {\n        synchronized (synchronizeddemo3.class) {\n            count++;\n        }\n    }\n\n}\n\n\n\n# synchronized 的原理\n\nsynchronized 代码块是由一对 monitorenter 和 monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。\n\n如果 synchronized 明确制定了对象参数，那就是这个对象的引用；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是静态方法，去对对应的对象实例或 class 对象来作为锁对象。\n\nsynchronized 同步块对同一线程来说是可重入的，不会出现锁死问题。\n\nsynchronized 同步块是互斥的，即已进入的线程执行完成前，会阻塞其他试图进入的线程。\n\n【示例】\n\npublic void foo(object lock) {\n    synchronized (lock) {\n      lock.hashcode();\n    }\n  }\n  // 上面的 java 代码将编译为下面的字节码\n  public void foo(java.lang.object);\n    code:\n       0: aload_1\n       1: dup\n       2: astore_2\n       3: monitorenter\n       4: aload_1\n       5: invokevirtual java/lang/object.hashcode:()i\n       8: pop\n       9: aload_2\n      10: monitorexit\n      11: goto          19\n      14: astore_3\n      15: aload_2\n      16: monitorexit\n      17: aload_3\n      18: athrow\n      19: return\n    exception table:\n       from    to  target type\n           4    11    14   any\n          14    17    14   any\n\n\n\n# 同步代码块\n\nsynchronized 在修饰同步代码块时，是由 monitorenter 和 monitorexit 指令来实现同步的。进入 monitorenter 指令后，线程将持有 monitor 对象，退出 monitorenter 指令后，线程将释放该 monitor 对象。\n\n# 同步方法\n\nsynchronized 修饰同步方法时，会设置一个 acc_synchronized 标志。当方法调用时，调用指令将会检查该方法是否被设置 acc_synchronized 访问标志。如果设置了该标志，执行线程将先持有 monitor 对象，然后再执行方法。在该方法运行期间，其它线程将无法获取到该 mointor 对象，当方法执行完成后，再释放该 monitor 对象。\n\n# monitor\n\n每个对象实例都会有一个 monitor，monitor 可以和对象一起创建、销毁。monitor 是由 objectmonitor 实现，而 objectmonitor 是由 c++ 的 objectmonitor.hpp 文件实现。\n\n当多个线程同时访问一段同步代码时，多个线程会先被存放在 entrylist 集合中，处于 block 状态的线程，都会被加入到该列表。接下来当线程获取到对象的 monitor 时，monitor 是依靠底层操作系统的 mutex lock 来实现互斥的，线程申请 mutex 成功，则持有该 mutex，其它线程将无法获取到该 mutex。\n\n如果线程调用 wait() 方法，就会释放当前持有的 mutex，并且该线程会进入 waitset 集合中，等待下一次被唤醒。如果当前线程顺利执行完方法，也将释放 mutex。\n\n\n# synchronized 的优化\n\n> java 1.6 以后，synchronized 做了大量的优化，其性能已经与 lock 、readwritelock 基本上持平。\n\n# java 对象头\n\n在 jdk1.6 jvm 中，对象实例在堆内存中被分为了三个部分：对象头、实例数据和对齐填充。其中 java 对象头由 mark word、指向类的指针以及数组长度三部分组成。\n\nmark word 记录了对象和锁有关的信息。mark word 在 64 位 jvm 中的长度是 64bit，我们可以一起看下 64 位 jvm 的存储结构是怎么样的。如下图所示：\n\n\n\n锁升级功能主要依赖于 mark word 中的锁标志位和是否偏向锁标志位，synchronized 同步锁就是从偏向锁开始的，随着竞争越来越激烈，偏向锁升级到轻量级锁，最终升级到重量级锁。\n\njava 1.6 引入了偏向锁和轻量级锁，从而让 synchronized 拥有了四个状态：\n\n * 无锁状态（unlocked）\n * 偏向锁状态（biasble）\n * 轻量级锁状态（lightweight locked）\n * 重量级锁状态（inflated）\n\n当 jvm 检测到不同的竞争状况时，会自动切换到适合的锁实现。\n\n当没有竞争出现时，默认会使用偏向锁。jvm 会利用 cas 操作（compare and swap），在对象头上的 mark word 部分设置线程 id，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。\n\n如果有另外的线程试图锁定某个已经被偏斜过的对象，jvm 就需要撤销（revoke）偏向锁，并切换到轻量级锁实现。轻量级锁依赖 cas 操作 mark word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。\n\n# 偏向锁\n\n偏向锁的思想是偏向于第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 cas 操作也不再需要。\n\n\n\n# 轻量级锁\n\n轻量级锁是相对于传统的重量级锁而言，它 使用 cas 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 cas 操作进行同步，如果 cas 失败了再改用互斥量进行同步。\n\n当尝试获取一个锁对象时，如果锁对象标记为 0|01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 lock record，然后使用 cas 操作将对象的 mark word 更新为 lock record 指针。如果 cas 操作成功了，那么线程就获取了该对象上的锁，并且对象的 mark word 的锁标记变为 00，表示该对象处于轻量级锁状态。\n\n\n\n# 锁消除 / 锁粗化\n\n除了锁升级优化，java 还使用了编译器对锁进行优化。\n\n（1）锁消除\n\n锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。\n\njit 编译器在动态编译同步块的时候，借助了一种被称为逃逸分析的技术，来判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其它线程。\n\n确认是的话，那么 jit 编译器在编译这个同步块的时候不会生成 synchronized 所表示的锁的申请与释放的机器码，即消除了锁的使用。在 java7 之后的版本就不需要手动配置了，该操作可以自动实现。\n\n对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：\n\npublic static string concatstring(string s1, string s2, string s3) {\n    return s1 + s2 + s3;\n}\n\n\nstring 是一个不可变的类，编译器会对 string 的拼接自动优化。在 java 1.5 之前，会转化为 stringbuffer 对象的连续 append() 操作：\n\npublic static string concatstring(string s1, string s2, string s3) {\n    stringbuffer sb = new stringbuffer();\n    sb.append(s1);\n    sb.append(s2);\n    sb.append(s3);\n    return sb.tostring();\n}\n\n\n每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatstring() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatstring() 方法之外，其他线程无法访问到它，因此可以进行消除。\n\n（2）锁粗化\n\n锁粗化同理，就是在 jit 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 jit 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。\n\n如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。\n\n上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。\n\n# 自旋锁\n\n互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。\n\n自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 cpu 时间，它只适用于共享数据的锁定状态很短的场景。\n\n在 java 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。\n\n\n# synchronized 的误区\n\n> 示例摘自：《java 业务开发常见错误 100 例》\n\n# synchronized 使用范围不当导致的错误\n\npublic class interesting {\n\n    volatile int a = 1;\n    volatile int b = 1;\n\n    public static void main(string[] args) {\n        interesting interesting = new interesting();\n        new thread(() -> interesting.add()).start();\n        new thread(() -> interesting.compare()).start();\n    }\n\n    public synchronized void add() {\n        log.info("add start");\n        for (int i = 0; i < 10000; i++) {\n            a++;\n            b++;\n        }\n        log.info("add done");\n    }\n\n    public void compare() {\n        log.info("compare start");\n        for (int i = 0; i < 10000; i++) {\n            //a始终等于b吗？\n            if (a < b) {\n                log.info("a:{},b:{},{}", a, b, a > b);\n                //最后的a>b应该始终是false吗？\n            }\n        }\n        log.info("compare done");\n    }\n\n}\n\n\n【输出】\n\n16:05:25.541 [thread-0] info io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - add start\n16:05:25.544 [thread-0] info io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - add done\n16:05:25.544 [thread-1] info io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - compare start\n16:05:25.544 [thread-1] info io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - compare done\n\n\n之所以出现这种错乱，是因为两个线程是交错执行 add 和 compare 方法中的业务逻辑，而且这些业务逻辑不是原子性的：a++ 和 b++ 操作中可以穿插在 compare 方法的比较代码中；更需要注意的是，a<b 这种比较操作在字节码层面是加载 a、加载 b 和比较三步，代码虽然是一行但也不是原子性的。\n\n所以，正确的做法应该是，为 add 和 compare 都加上方法锁，确保 add 方法执行时，compare 无法读取 a 和 b：\n\npublic synchronized void add()\npublic synchronized void compare()\n\n\n所以，使用锁解决问题之前一定要理清楚，我们要保护的是什么逻辑，多线程执行的情况又是怎样的。\n\n# synchronized 保护对象不对导致的错误\n\n加锁前要清楚锁和被保护的对象是不是一个层面的。\n\n静态字段属于类，类级别的锁才能保护；而非静态字段属于类实例，实例级别的锁就可以保护。\n\npublic class synchronized错误使用示例2 {\n\n    public static void main(string[] args) {\n        synchronized错误使用示例2 demo = new synchronized错误使用示例2();\n        system.out.println(demo.wrong(1000000));\n        system.out.println(demo.right(1000000));\n    }\n\n    public int wrong(int count) {\n        data.reset();\n        intstream.rangeclosed(1, count).parallel().foreach(i -> new data().wrong());\n        return data.getcounter();\n    }\n\n    public int right(int count) {\n        data.reset();\n        intstream.rangeclosed(1, count).parallel().foreach(i -> new data().right());\n        return data.getcounter();\n    }\n\n    private static class data {\n\n        @getter\n        private static int counter = 0;\n        private static object locker = new object();\n\n        public static int reset() {\n            counter = 0;\n            return counter;\n        }\n\n        public synchronized void wrong() {\n            counter++;\n        }\n\n        public void right() {\n            synchronized (locker) {\n                counter++;\n            }\n        }\n\n    }\n\n}\n\n\nwrong 方法中试图对一个静态对象加对象级别的 synchronized 锁，并不能保证线程安全。\n\n# 锁粒度导致的问题\n\n要尽可能的缩小加锁的范围，这可以提高并发吞吐。\n\n如果精细化考虑了锁应用范围后，性能还无法满足需求的话，我们就要考虑另一个维度的粒度问题了，即：区分读写场景以及资源的访问冲突，考虑使用悲观方式的锁还是乐观方式的锁。\n\npublic class synchronized锁粒度不当 {\n\n    public static void main(string[] args) {\n        demo demo = new demo();\n        demo.wrong();\n        demo.right();\n    }\n\n    private static class demo {\n\n        private list<integer> data = new arraylist<>();\n\n        private void slow() {\n            try {\n                timeunit.milliseconds.sleep(10);\n            } catch (interruptedexception e) {\n            }\n        }\n\n        public int wrong() {\n            long begin = system.currenttimemillis();\n            intstream.rangeclosed(1, 1000).parallel().foreach(i -> {\n                synchronized (this) {\n                    slow();\n                    data.add(i);\n                }\n            });\n            log.info("took:{}", system.currenttimemillis() - begin);\n            return data.size();\n        }\n\n        public int right() {\n            long begin = system.currenttimemillis();\n            intstream.rangeclosed(1, 1000).parallel().foreach(i -> {\n                slow();\n                synchronized (data) {\n                    data.add(i);\n                }\n            });\n            log.info("took:{}", system.currenttimemillis() - begin);\n            return data.size();\n        }\n\n    }\n\n}\n\n\n\n# volatile\n\n\n# volatile 的要点\n\nvolatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。\n\n被 volatile 修饰的变量，具备以下特性：\n\n * 线程可见性 - 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个共享变量，另外一个线程能读到这个修改的值。\n * 禁止指令重排序\n * 不保证原子性\n\n我们知道，线程安全需要具备：可见性、原子性、顺序性。volatile 不保证原子性，所以决定了它不能彻底地保证线程安全。\n\n\n# volatile 的应用\n\n如果 volatile 变量修饰符使用恰当的话，它比 synchronized 的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。但是，volatile 无法替代 synchronized ，因为 volatile 无法保证操作的原子性。\n\n通常来说，使用 volatile 必须具备以下 2 个条件：\n\n * 对变量的写操作不依赖于当前值\n * 该变量没有包含在具有其他变量的表达式中\n\n【示例】状态标记量\n\nvolatile boolean flag = false;\n\nwhile(!flag) {\n    dosomething();\n}\n\npublic void setflag() {\n    flag = true;\n}\n\n\n【示例】双重锁实现线程安全的单例模式\n\nclass singleton {\n    private volatile static singleton instance = null;\n\n    private singleton() {}\n\n    public static singleton getinstance() {\n        if(instance==null) {\n            synchronized (singleton.class) {\n                if(instance==null)\n                    instance = new singleton();\n            }\n        }\n        return instance;\n    }\n}\n\n\n\n# volatile 的原理\n\n观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令。lock 前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供 3 个功能：\n\n * 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n * 它会强制将对缓存的修改操作立即写入主存；\n * 如果是写操作，它会导致其他 cpu 中对应的缓存行无效。\n\n\n# volatile 的问题\n\nvolatile 的要点中，已经提到，volatile 不保证原子性，所以 volatile 并不能保证线程安全。\n\n那么，如何做到线程安全呢？有两种方案：\n\n * volatile + synchronized - 可以参考：【示例】双重锁实现线程安全的单例模式\n * 使用原子类替代 volatile\n\n\n# cas\n\n\n# cas 的要点\n\n互斥同步是最常见的并发正确性保障手段。\n\n互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题，因此互斥同步也被称为阻塞同步。互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。\n\n随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。\n\n为什么说乐观锁需要 硬件指令集的发展 才能进行？因为需要操作和冲突检测这两个步骤具备原子性。而这点是由硬件来完成，如果再使用互斥同步来保证就失去意义了。硬件支持的原子性操作最典型的是：cas。\n\ncas（compare and swap），字面意思为比较并交换。cas 有 3 个操作数，分别是：内存值 m，期望值 e，更新值 u。当且仅当内存值 m 和期望值 e 相等时，将内存值 m 修改为 u，否则什么都不做。\n\n\n# cas 的应用\n\ncas 只适用于线程冲突较少的情况。\n\ncas 的典型应用场景是：\n\n * 原子类\n * 自旋锁\n\n# 原子类\n\n> 原子类是 cas 在 java 中最典型的应用。\n\n我们先来看一个常见的代码片段。\n\nif(a==b) {\n    a++;\n}\n\n\n如果 a++ 执行前， a 的值被修改了怎么办？还能得到预期值吗？出现该问题的原因是在并发环境下，以上代码片段不是原子操作，随时可能被其他线程所篡改。\n\n解决这种问题的最经典方式是应用原子类的 incrementandget 方法。\n\npublic class atomicintegerdemo {\n\n    public static void main(string[] args) throws interruptedexception {\n        executorservice executorservice = executors.newfixedthreadpool(3);\n        final atomicinteger count = new atomicinteger(0);\n        for (int i = 0; i < 10; i++) {\n            executorservice.execute(new runnable() {\n                @override\n                public void run() {\n                    count.incrementandget();\n                }\n            });\n        }\n\n        executorservice.shutdown();\n        executorservice.awaittermination(3, timeunit.seconds);\n        system.out.println("final count is : " + count.get());\n    }\n\n}\n\n\nj.u.c 包中提供了 atomicboolean、atomicinteger、atomiclong 分别针对 boolean、integer、long 执行原子操作，操作和上面的示例大体相似，不做赘述。\n\n# 自旋锁\n\n利用原子类（本质上是 cas），可以实现自旋锁。\n\n所谓自旋锁，是指线程反复检查锁变量是否可用，直到成功为止。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。\n\n示例：非线程安全示例\n\npublic class atomicreferencedemo {\n\n    private static int ticket = 10;\n\n    public static void main(string[] args) {\n        executorservice executorservice = executors.newfixedthreadpool(3);\n        for (int i = 0; i < 5; i++) {\n            executorservice.execute(new mythread());\n        }\n        executorservice.shutdown();\n    }\n\n    static class mythread implements runnable {\n\n        @override\n        public void run() {\n            while (ticket > 0) {\n                system.out.println(thread.currentthread().getname() + " 卖出了第 " + ticket + " 张票");\n                ticket--;\n            }\n        }\n\n    }\n\n}\n\n\n输出结果：\n\npool-1-thread-2 卖出了第 10 张票\npool-1-thread-1 卖出了第 10 张票\npool-1-thread-3 卖出了第 10 张票\npool-1-thread-1 卖出了第 8 张票\npool-1-thread-2 卖出了第 9 张票\npool-1-thread-1 卖出了第 6 张票\npool-1-thread-3 卖出了第 7 张票\npool-1-thread-1 卖出了第 4 张票\npool-1-thread-2 卖出了第 5 张票\npool-1-thread-1 卖出了第 2 张票\npool-1-thread-3 卖出了第 3 张票\npool-1-thread-2 卖出了第 1 张票\n\n\n很明显，出现了重复售票的情况。\n\n【示例】使用自旋锁来保证线程安全\n\n可以通过自旋锁这种非阻塞同步来保证线程安全，下面使用 atomicreference 来实现一个自旋锁。\n\npublic class atomicreferencedemo2 {\n\n    private static int ticket = 10;\n\n    public static void main(string[] args) {\n        threadsafedemo();\n    }\n\n    private static void threadsafedemo() {\n        spinlock lock = new spinlock();\n        executorservice executorservice = executors.newfixedthreadpool(3);\n        for (int i = 0; i < 5; i++) {\n            executorservice.execute(new mythread(lock));\n        }\n        executorservice.shutdown();\n    }\n\n    static class spinlock {\n\n        private atomicreference<thread> atomicreference = new atomicreference<>();\n\n        public void lock() {\n            thread current = thread.currentthread();\n            while (!atomicreference.compareandset(null, current)) {}\n        }\n\n        public void unlock() {\n            thread current = thread.currentthread();\n            atomicreference.compareandset(current, null);\n        }\n\n    }\n\n    static class mythread implements runnable {\n\n        private spinlock lock;\n\n        public mythread(spinlock lock) {\n            this.lock = lock;\n        }\n\n        @override\n        public void run() {\n            while (ticket > 0) {\n                lock.lock();\n                if (ticket > 0) {\n                    system.out.println(thread.currentthread().getname() + " 卖出了第 " + ticket + " 张票");\n                    ticket--;\n                }\n                lock.unlock();\n            }\n        }\n\n    }\n\n}\n\n\n输出结果：\n\npool-1-thread-2 卖出了第 10 张票\npool-1-thread-1 卖出了第 9 张票\npool-1-thread-3 卖出了第 8 张票\npool-1-thread-2 卖出了第 7 张票\npool-1-thread-3 卖出了第 6 张票\npool-1-thread-1 卖出了第 5 张票\npool-1-thread-2 卖出了第 4 张票\npool-1-thread-1 卖出了第 3 张票\npool-1-thread-3 卖出了第 2 张票\npool-1-thread-1 卖出了第 1 张票\n\n\n\n# cas 的原理\n\njava 主要利用 unsafe 这个类提供的 cas 操作。unsafe 的 cas 依赖的是 jvm 针对不同的操作系统实现的硬件指令 atomic::cmpxchg。atomic::cmpxchg 的实现使用了汇编的 cas 操作，并使用 cpu 提供的 lock 信号保证其原子性。\n\n\n# cas 的问题\n\n一般情况下，cas 比锁性能更高。因为 cas 是一种非阻塞算法，所以其避免了线程阻塞和唤醒的等待时间。\n\n但是，事物总会有利有弊，cas 也存在三大问题：\n\n * aba 问题\n * 循环时间长开销大\n * 只能保证一个共享变量的原子性\n\n# aba 问题\n\n如果一个变量初次读取的时候是 a 值，它的值被改成了 b，后来又被改回为 a，那 cas 操作就会误认为它从来没有被改变过。\n\nj.u.c 包提供了一个带有标记的原子引用类 atomicstampedreference 来解决这个问题，它可以通过控制变量值的版本来保证 cas 的正确性。大部分情况下 aba 问题不会影响程序并发的正确性，如果需要解决 aba 问题，改用传统的互斥同步可能会比原子类更高效。\n\n# 循环时间长开销大\n\n自旋 cas （不断尝试，直到成功为止）如果长时间不成功，会给 cpu 带来非常大的执行开销。\n\n如果 jvm 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：\n\n * 它可以延迟流水线执行指令（de-pipeline）,使 cpu 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。\n * 它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 cpu 流水线被清空（cpu pipeline flush），从而提高 cpu 的执行效率。\n\n比较花费 cpu 资源，即使没有任何用也会做一些无用功。\n\n# 只能保证一个共享变量的原子性\n\n当对一个共享变量执行操作时，我们可以使用循环 cas 的方式来保证原子操作，但是对多个共享变量操作时，循环 cas 就无法保证操作的原子性，这个时候就可以用锁。\n\n或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量 i ＝ 2, j = a，合并一下 ij=2a，然后用 cas 来操作 ij。从 java 1.5 开始 jdk 提供了 atomicreference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 cas 操作。\n\n\n# threadlocal\n\n> threadlocal 是一个存储线程本地副本的工具类。\n> \n> 要保证线程安全，不一定非要进行同步。同步只是保证共享数据争用时的正确性，如果一个方法本来就不涉及共享数据，那么自然无须同步。\n> \n> java 中的 无同步方案 有：\n> \n>  * 可重入代码 - 也叫纯代码。如果一个方法，它的 返回结果是可以预测的，即只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性，当然也是线程安全的。\n>  * 线程本地存储 - 使用 threadlocal 为共享变量在每个线程中都创建了一个本地副本，这个副本只能被当前线程访问，其他线程无法访问，那么自然是线程安全的。\n\n\n# threadlocal 的应用\n\nthreadlocal 的方法：\n\npublic class threadlocal<t> {\n    public t get() {}\n    public void set(t value) {}\n    public void remove() {}\n    public static <s> threadlocal<s> withinitial(supplier<? extends s> supplier) {}\n}\n\n\n> 说明：\n> \n>  * get - 用于获取 threadlocal 在当前线程中保存的变量副本。\n>  * set - 用于设置当前线程中变量的副本。\n>  * remove - 用于删除当前线程中变量的副本。如果此线程局部变量随后被当前线程读取，则其值将通过调用其 initialvalue 方法重新初始化，除非其值由中间线程中的当前线程设置。 这可能会导致当前线程中多次调用 initialvalue 方法。\n>  * initialvalue - 为 threadlocal 设置默认的 get 初始值，需要重写 initialvalue 方法 。\n\nthreadlocal 常用于防止对可变的单例（singleton）变量或全局变量进行共享。典型应用场景有：管理数据库连接、session。\n\n【示例】数据库连接\n\nprivate static threadlocal<connection> connectionholder = new threadlocal<connection>() {\n    @override\n    public connection initialvalue() {\n        return drivermanager.getconnection(db_url);\n    }\n};\n\npublic static connection getconnection() {\n    return connectionholder.get();\n}\n\n\n【示例】session 管理\n\nprivate static final threadlocal<session> sessionholder = new threadlocal<>();\n\npublic static session getsession() {\n    session session = (session) sessionholder.get();\n    try {\n        if (session == null) {\n            session = createsession();\n            sessionholder.set(session);\n        }\n    } catch (exception e) {\n        e.printstacktrace();\n    }\n    return session;\n}\n\n\n【示例】完整使用 threadlocal 示例\n\npublic class threadlocaldemo {\n\n    private static threadlocal<integer> threadlocal = new threadlocal<integer>() {\n        @override\n        protected integer initialvalue() {\n            return 0;\n        }\n    };\n\n    public static void main(string[] args) {\n        executorservice executorservice = executors.newfixedthreadpool(10);\n        for (int i = 0; i < 10; i++) {\n            executorservice.execute(new mythread());\n        }\n        executorservice.shutdown();\n    }\n\n    static class mythread implements runnable {\n\n        @override\n        public void run() {\n            int count = threadlocal.get();\n            for (int i = 0; i < 10; i++) {\n                try {\n                    count++;\n                    thread.sleep(100);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n            threadlocal.set(count);\n            threadlocal.remove();\n            system.out.println(thread.currentthread().getname() + " : " + count);\n        }\n\n    }\n\n}\n\n\n全部输出 count = 10\n\n\n# threadlocal 的原理\n\n# 存储结构\n\nthread 类中维护着一个 threadlocal.threadlocalmap 类型的成员 threadlocals。这个成员就是用来存储当前线程独占的变量副本。\n\nthreadlocalmap 是 threadlocal 的内部类，它维护着一个 entry 数组，entry 继承了 weakreference ，所以是弱引用。 entry 用于保存键值对，其中：\n\n * key 是 threadlocal 对象；\n * value 是传递进来的对象（变量副本）。\n\npublic class thread implements runnable {\n    // ...\n    threadlocal.threadlocalmap threadlocals = null;\n    // ...\n}\n\nstatic class threadlocalmap {\n    // ...\n    static class entry extends weakreference<threadlocal<?>> {\n        /** the value associated with this threadlocal. */\n        object value;\n\n        entry(threadlocal<?> k, object v) {\n            super(k);\n            value = v;\n        }\n    }\n    // ...\n}\n\n\n# 如何解决 hash 冲突\n\nthreadlocalmap 虽然是类似 map 结构的数据结构，但它并没有实现 map 接口。它不支持 map 接口中的 next 方法，这意味着 threadlocalmap 中解决 hash 冲突的方式并非 拉链表 方式。\n\n实际上，threadlocalmap 采用线性探测的方式来解决 hash 冲突。所谓线性探测，就是根据初始 key 的 hashcode 值确定元素在 table 数组中的位置，如果发现这个位置上已经被其他的 key 值占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。\n\n# 内存泄漏问题\n\nthreadlocalmap 的 entry 继承了 weakreference，所以它的 key （threadlocal 对象）是弱引用，而 value （变量副本）是强引用。\n\n * 如果 threadlocal 对象没有外部强引用来引用它，那么 threadlocal 对象会在下次 gc 时被回收。\n * 此时，entry 中的 key 已经被回收，但是 value 由于是强引用不会被垃圾收集器回收。如果创建 threadlocal 的线程一直持续运行，那么 value 就会一直得不到回收，产生内存泄露。\n\n那么如何避免内存泄漏呢？方法就是：使用 threadlocal 的 set 方法后，显示的调用 remove 方法 。\n\nthreadlocal<string> threadlocal = new threadlocal();\ntry {\n    threadlocal.set("xxx");\n    // ...\n} finally {\n    threadlocal.remove();\n}\n\n\n\n# threadlocal 的误区\n\n> 示例摘自：《java 业务开发常见错误 100 例》\n\nthreadlocal 适用于变量在线程间隔离，而在方法或类间共享的场景。\n\n前文提到，threadlocal 是线程隔离的，那么是不是使用 threadlocal 就一定高枕无忧呢？\n\n# threadlocal 错误案例\n\n使用 spring boot 创建一个 web 应用程序，使用 threadlocal 存放一个 integer 的值，来暂且代表需要在线程中保存的用户信息，这个值初始是 null。\n\n    private threadlocal<integer> currentuser = threadlocal.withinitial(() -> null);\n\n    @getmapping("wrong")\n    public map<string, string> wrong(@requestparam("id") integer userid) {\n        //设置用户信息之前先查询一次threadlocal中的用户信息\n        string before = thread.currentthread().getname() + ":" + currentuser.get();\n        //设置用户信息到threadlocal\n        currentuser.set(userid);\n        //设置用户信息之后再查询一次threadlocal中的用户信息\n        string after = thread.currentthread().getname() + ":" + currentuser.get();\n        //汇总输出两次查询结果\n        map<string, string> result = new hashmap<>();\n        result.put("before", before);\n        result.put("after", after);\n        return result;\n    }\n\n\n【预期】从代码逻辑来看，我们预期第一次获取的值始终应该是 null。\n\n【实际】\n\n为了方便复现，将 tomcat 工作线程设为 1：\n\nserver.tomcat.max-threads=1\n\n\n当访问 id = 1 时，符合预期\n\n\n\n当访问 id = 2 时，before 的应答不是 null，而是 1，不符合预期。\n\n\n\n【分析】实际情况和预期存在偏差。spring boot 程序运行在 tomcat 中，执行程序的线程是 tomcat 的工作线程，而 tomcat 的工作线程是基于线程池的。线程池会重用固定的几个线程，一旦线程重用，那么很可能首次从 threadlocal 获取的值是之前其他用户的请求遗留的值。这时，threadlocal 中的用户信息就是其他用户的信息。\n\n并不能认为没有显式开启多线程就不会有线程安全问题。使用类似 threadlocal 工具来存放一些数据时，需要特别注意在代码运行完后，显式地去清空设置的数据。\n\n# threadlocal 错误案例修正\n\n    @getmapping("right")\n    public map<string, string> right(@requestparam("id") integer userid) {\n        string before = thread.currentthread().getname() + ":" + currentuser.get();\n        currentuser.set(userid);\n        try {\n            string after = thread.currentthread().getname() + ":" + currentuser.get();\n            map<string, string> result = new hashmap<>();\n            result.put("before", before);\n            result.put("after", after);\n            return result;\n        } finally {\n            //在finally代码块中删除threadlocal中的数据，确保数据不串\n            currentuser.remove();\n        }\n    }\n\n\n\n# inheritablethreadlocal\n\ninheritablethreadlocal 类是 threadlocal 类的子类。\n\nthreadlocal 中每个线程拥有它自己独占的数据。与 threadlocal 不同的是，inheritablethreadlocal 允许一个线程以及该线程创建的所有子线程都可以访问它保存的数据。\n\n> 原理参考：java 多线程：inheritablethreadlocal 实现原理\n\n\n# 参考资料\n\n * 《java 并发编程实战》\n * 《java 并发编程的艺术》\n * 《深入理解 java 虚拟机》\n * 《java 业务开发常见错误 100 例》\n * java 并发编程：volatile 关键字解析\n * java 并发编程：synchronized\n * 深入理解 java 并发之 synchronized 实现原理\n * java cas 完全解读\n * java 中 cas 详解\n * threadlocal 终极篇\n * synchronized 实现原理及锁优化\n * non-blocking algorithms',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java锁",frontmatter:{title:"Java锁",categories:["编程","Java","JavaSE","并发"],tags:["Java","JavaSE","并发","锁"],abbrlink:"6216bb38",date:"2019-12-26T23:11:52.000Z",permalink:"/pages/37bf7b/"},regularPath:"/05.%E5%B9%B6%E5%8F%91/04.Java%E9%94%81.html",relativePath:"05.并发/04.Java锁.md",key:"v-2d65902d",path:"/pages/37bf7b/",headers:[{level:2,title:"并发锁简介",slug:"并发锁简介",normalizedTitle:"并发锁简介",charIndex:283},{level:3,title:"可重入锁",slug:"可重入锁",normalizedTitle:"可重入锁",charIndex:462},{level:3,title:"公平锁与非公平锁",slug:"公平锁与非公平锁",normalizedTitle:"公平锁与非公平锁",charIndex:1496},{level:3,title:"独享锁与共享锁",slug:"独享锁与共享锁",normalizedTitle:"独享锁与共享锁",charIndex:1779},{level:3,title:"悲观锁与乐观锁",slug:"悲观锁与乐观锁",normalizedTitle:"悲观锁与乐观锁",charIndex:2031},{level:3,title:"偏向锁、轻量级锁、重量级锁",slug:"偏向锁、轻量级锁、重量级锁",normalizedTitle:"偏向锁、轻量级锁、重量级锁",charIndex:2412},{level:3,title:"分段锁",slug:"分段锁",normalizedTitle:"分段锁",charIndex:2873},{level:3,title:"显示锁和内置锁",slug:"显示锁和内置锁",normalizedTitle:"显示锁和内置锁",charIndex:3334},{level:2,title:"Lock 和 Condition",slug:"lock-和-condition",normalizedTitle:"lock 和 condition",charIndex:74},{level:3,title:"为何引入 Lock 和 Condition",slug:"为何引入-lock-和-condition",normalizedTitle:"为何引入 lock 和 condition",charIndex:4560},{level:3,title:"Lock 接口",slug:"lock-接口",normalizedTitle:"lock 接口",charIndex:5389},{level:3,title:"Condition",slug:"condition",normalizedTitle:"condition",charIndex:81},{level:4,title:"Condition 的特性",slug:"condition-的特性",normalizedTitle:"condition 的特性",charIndex:6559},{level:4,title:"Condition 的用法",slug:"condition-的用法",normalizedTitle:"condition 的用法",charIndex:7264},{level:2,title:"ReentrantLock",slug:"reentrantlock",normalizedTitle:"reentrantlock",charIndex:548},{level:3,title:"ReentrantLock 的特性",slug:"reentrantlock-的特性",normalizedTitle:"reentrantlock 的特性",charIndex:10255},{level:3,title:"ReentrantLock 的用法",slug:"reentrantlock-的用法",normalizedTitle:"reentrantlock 的用法",charIndex:10518},{level:4,title:"ReentrantLock 的构造方法",slug:"reentrantlock-的构造方法",normalizedTitle:"reentrantlock 的构造方法",charIndex:10580},{level:4,title:"lock 和 unlock 方法",slug:"lock-和-unlock-方法",normalizedTitle:"lock 和 unlock 方法",charIndex:10819},{level:4,title:"tryLock 方法",slug:"trylock-方法",normalizedTitle:"trylock 方法",charIndex:13217},{level:4,title:"lockInterruptibly 方法",slug:"lockinterruptibly-方法",normalizedTitle:"lockinterruptibly 方法",charIndex:14432},{level:4,title:"newCondition 方法",slug:"newcondition-方法",normalizedTitle:"newcondition 方法",charIndex:15415},{level:3,title:"ReentrantLock 的原理",slug:"reentrantlock-的原理",normalizedTitle:"reentrantlock 的原理",charIndex:15519},{level:4,title:"ReentrantLock 的可见性",slug:"reentrantlock-的可见性",normalizedTitle:"reentrantlock 的可见性",charIndex:15540},{level:4,title:"ReentrantLock 的数据结构",slug:"reentrantlock-的数据结构",normalizedTitle:"reentrantlock 的数据结构",charIndex:16208},{level:4,title:"ReentrantLock 的获取锁和释放锁",slug:"reentrantlock-的获取锁和释放锁",normalizedTitle:"reentrantlock 的获取锁和释放锁",charIndex:16531},{level:4,title:"公平锁和非公平锁",slug:"公平锁和非公平锁",normalizedTitle:"公平锁和非公平锁",charIndex:10369},{level:2,title:"ReentrantReadWriteLock",slug:"reentrantreadwritelock",normalizedTitle:"reentrantreadwritelock",charIndex:563},{level:3,title:"ReentrantReadWriteLock 的特性",slug:"reentrantreadwritelock-的特性",normalizedTitle:"reentrantreadwritelock 的特性",charIndex:18942},{level:3,title:"ReentrantReadWriteLock 的用法",slug:"reentrantreadwritelock-的用法",normalizedTitle:"reentrantreadwritelock 的用法",charIndex:20092},{level:4,title:"ReentrantReadWriteLock 的构造方法",slug:"reentrantreadwritelock-的构造方法",normalizedTitle:"reentrantreadwritelock 的构造方法",charIndex:20172},{level:4,title:"ReentrantReadWriteLock 的使用实例",slug:"reentrantreadwritelock-的使用实例",normalizedTitle:"reentrantreadwritelock 的使用实例",charIndex:20622},{level:3,title:"ReentrantReadWriteLock 的原理",slug:"reentrantreadwritelock-的原理",normalizedTitle:"reentrantreadwritelock 的原理",charIndex:23667},{level:4,title:"ReentrantReadWriteLock 的数据结构",slug:"reentrantreadwritelock-的数据结构",normalizedTitle:"reentrantreadwritelock 的数据结构",charIndex:23755},{level:4,title:"ReentrantReadWriteLock 的获取锁和释放锁",slug:"reentrantreadwritelock-的获取锁和释放锁",normalizedTitle:"reentrantreadwritelock 的获取锁和释放锁",charIndex:24528},{level:2,title:"StampedLock",slug:"stampedlock",normalizedTitle:"stampedlock",charIndex:25042},{level:2,title:"AQS",slug:"aqs",normalizedTitle:"aqs",charIndex:56},{level:3,title:"AQS 的要点",slug:"aqs-的要点",normalizedTitle:"aqs 的要点",charIndex:26932},{level:3,title:"AQS 的应用",slug:"aqs-的应用",normalizedTitle:"aqs 的应用",charIndex:27163},{level:4,title:"独享锁 API",slug:"独享锁-api",normalizedTitle:"独享锁 api",charIndex:27195},{level:4,title:"共享锁 API",slug:"共享锁-api",normalizedTitle:"共享锁 api",charIndex:27616},{level:3,title:"AQS 的原理",slug:"aqs-的原理",normalizedTitle:"aqs 的原理",charIndex:17047},{level:4,title:"AQS 的数据结构",slug:"aqs-的数据结构",normalizedTitle:"aqs 的数据结构",charIndex:28318},{level:4,title:"独占锁的获取和释放",slug:"独占锁的获取和释放",normalizedTitle:"独占锁的获取和释放",charIndex:29972},{level:5,title:"获取独占锁",slug:"获取独占锁",normalizedTitle:"获取独占锁",charIndex:18223},{level:5,title:"释放独占锁",slug:"释放独占锁",normalizedTitle:"释放独占锁",charIndex:16991},{level:5,title:"获取可中断的独占锁",slug:"获取可中断的独占锁",normalizedTitle:"获取可中断的独占锁",charIndex:16757},{level:5,title:"获取超时等待式的独占锁",slug:"获取超时等待式的独占锁",normalizedTitle:"获取超时等待式的独占锁",charIndex:16902},{level:4,title:"共享锁的获取和释放",slug:"共享锁的获取和释放",normalizedTitle:"共享锁的获取和释放",charIndex:30746},{level:5,title:"获取共享锁",slug:"获取共享锁",normalizedTitle:"获取共享锁",charIndex:24645},{level:5,title:"释放共享锁",slug:"释放共享锁",normalizedTitle:"释放共享锁",charIndex:24730},{level:5,title:"获取可中断的共享锁",slug:"获取可中断的共享锁",normalizedTitle:"获取可中断的共享锁",charIndex:27916},{level:5,title:"获取超时等待式的共享锁",slug:"获取超时等待式的共享锁",normalizedTitle:"获取超时等待式的共享锁",charIndex:31270},{level:2,title:"死锁",slug:"死锁",normalizedTitle:"死锁",charIndex:540},{level:3,title:"什么是死锁",slug:"什么是死锁",normalizedTitle:"什么是死锁",charIndex:31402},{level:3,title:"如何定位死锁",slug:"如何定位死锁",normalizedTitle:"如何定位死锁",charIndex:31560},{level:3,title:"如何避免死锁",slug:"如何避免死锁",normalizedTitle:"如何避免死锁",charIndex:31801},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:32088}],headersStr:"并发锁简介 可重入锁 公平锁与非公平锁 独享锁与共享锁 悲观锁与乐观锁 偏向锁、轻量级锁、重量级锁 分段锁 显示锁和内置锁 Lock 和 Condition 为何引入 Lock 和 Condition Lock 接口 Condition Condition 的特性 Condition 的用法 ReentrantLock ReentrantLock 的特性 ReentrantLock 的用法 ReentrantLock 的构造方法 lock 和 unlock 方法 tryLock 方法 lockInterruptibly 方法 newCondition 方法 ReentrantLock 的原理 ReentrantLock 的可见性 ReentrantLock 的数据结构 ReentrantLock 的获取锁和释放锁 公平锁和非公平锁 ReentrantReadWriteLock ReentrantReadWriteLock 的特性 ReentrantReadWriteLock 的用法 ReentrantReadWriteLock 的构造方法 ReentrantReadWriteLock 的使用实例 ReentrantReadWriteLock 的原理 ReentrantReadWriteLock 的数据结构 ReentrantReadWriteLock 的获取锁和释放锁 StampedLock AQS AQS 的要点 AQS 的应用 独享锁 API 共享锁 API AQS 的原理 AQS 的数据结构 独占锁的获取和释放 获取独占锁 释放独占锁 获取可中断的独占锁 获取超时等待式的独占锁 共享锁的获取和释放 获取共享锁 释放共享锁 获取可中断的共享锁 获取超时等待式的共享锁 死锁 什么是死锁 如何定位死锁 如何避免死锁 参考资料",content:'# 深入理解 Java 并发锁\n\n> 本文先阐述 Java 中各种锁的概念。\n> \n> 然后，介绍锁的核心实现 AQS。\n> \n> 然后，重点介绍 Lock 和 Condition 两个接口及其实现。并发编程有两个核心问题：同步和互斥。\n> \n> 互斥，即同一时刻只允许一个线程访问共享资源；\n> \n> 同步，即线程之间如何通信、协作。\n> \n> 这两大问题，管程（sychronized）都是能够解决的。J.U.C 包还提供了 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题。\n\n\n# 并发锁简介\n\n确保线程安全最常见的做法是利用锁机制（Lock、sychronized）来对共享数据做互斥同步，这样在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，那么操作必然是原子性的，线程安全的。\n\n在工作、面试中，经常会听到各种五花八门的锁，听的人云里雾里。锁的概念术语很多，它们是针对不同的问题所提出的，通过简单的梳理，也不难理解。\n\n\n# 可重入锁\n\n可重入锁，顾名思义，指的是线程可以重复获取同一把锁。即同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁。\n\n可重入锁可以在一定程度上避免死锁。\n\n * ReentrantLock 、ReentrantReadWriteLock 是可重入锁。这点，从其命名也不难看出。\n * synchronized 也是一个可重入锁。\n\n【示例】synchronized 的可重入示例\n\nsynchronized void setA() throws Exception{\n    Thread.sleep(1000);\n    setB();\n}\n\nsynchronized void setB() throws Exception{\n    Thread.sleep(1000);\n}\n\n\n上面的代码就是一个典型场景：如果使用的锁不是可重入锁的话，setB 可能不会被当前线程执行，从而造成死锁。\n\n【示例】ReentrantLock 的可重入示例\n\nclass Task {\n\n    private int value;\n    private final Lock lock = new ReentrantLock();\n\n    public Task() {\n        this.value = 0;\n    }\n\n    public int get() {\n        // 获取锁\n        lock.lock();\n        try {\n            return value;\n        } finally {\n            // 保证锁能释放\n            lock.unlock();\n        }\n    }\n\n    public void addOne() {\n        // 获取锁\n        lock.lock();\n        try {\n            // 注意：此处已经成功获取锁，进入 get 方法后，又尝试获取锁，\n            // 如果锁不是可重入的，会导致死锁\n            value = 1 + get();\n        } finally {\n            // 保证锁能释放\n            lock.unlock();\n        }\n    }\n\n}\n\n\n\n# 公平锁与非公平锁\n\n * 公平锁 - 公平锁是指 多线程按照申请锁的顺序来获取锁。\n * 非公平锁 - 非公平锁是指 多线程不按照申请锁的顺序来获取锁 。这就可能会出现优先级反转（后来者居上）或者饥饿现象（某线程总是抢不过别的线程，导致始终无法执行）。\n\n公平锁为了保证线程申请顺序，势必要付出一定的性能代价，因此其吞吐量一般低于非公平锁。\n\n公平锁与非公平锁 在 Java 中的典型实现：\n\n * synchronized 只支持非公平锁。\n * ReentrantLock 、ReentrantReadWriteLock，默认是非公平锁，但支持公平锁。\n\n\n# 独享锁与共享锁\n\n独享锁与共享锁是一种广义上的说法，从实际用途上来看，也常被称为互斥锁与读写锁。\n\n * 独享锁 - 独享锁是指 锁一次只能被一个线程所持有。\n * 共享锁 - 共享锁是指 锁可被多个线程所持有。\n\n独享锁与共享锁在 Java 中的典型实现：\n\n * synchronized 、ReentrantLock 只支持独享锁。\n * ReentrantReadWriteLock 其写锁是独享锁，其读锁是共享锁。读锁是共享锁使得并发读是非常高效的，读写，写读 ，写写的过程是互斥的。\n\n\n# 悲观锁与乐观锁\n\n乐观锁与悲观锁不是指具体的什么类型的锁，而是处理并发同步的策略。\n\n * 悲观锁 - 悲观锁对于并发采取悲观的态度，认为：不加锁的并发操作一定会出问题。悲观锁适合写操作频繁的场景。\n * 乐观锁 - 乐观锁对于并发采取乐观的态度，认为：不加锁的并发操作也没什么问题。对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用不断尝试更新的方式更新数据。乐观锁适合读多写少的场景。\n\n悲观锁与乐观锁在 Java 中的典型实现：\n\n * 悲观锁在 Java 中的应用就是通过使用 synchronized 和 Lock 显示加锁来进行互斥同步，这是一种阻塞同步。\n\n * 乐观锁在 Java 中的应用就是采用 CAS 机制（CAS 操作通过 Unsafe 类提供，但这个类不直接暴露为 API，所以都是间接使用，如各种原子类）。\n\n\n# 偏向锁、轻量级锁、重量级锁\n\n所谓轻量级锁与重量级锁，指的是锁控制粒度的粗细。显然，控制粒度越细，阻塞开销越小，并发性也就越高。\n\nJava 1.6 以前，重量级锁一般指的是 synchronized ，而轻量级锁指的是 volatile。\n\nJava 1.6 以后，针对 synchronized 做了大量优化，引入 4 种锁状态： 无锁状态、偏向锁、轻量级锁和重量级锁。锁可以单向的从偏向锁升级到轻量级锁，再从轻量级锁升级到重量级锁 。\n\n * 偏向锁 - 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。\n\n * 轻量级锁 - 是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。\n\n * 重量级锁 - 是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。\n\n\n# 分段锁\n\n分段锁其实是一种锁的设计，并不是具体的一种锁。所谓分段锁，就是把锁的对象分成多段，每段独立控制，使得锁粒度更细，减少阻塞开销，从而提高并发性。这其实很好理解，就像高速公路上的收费站，如果只有一个收费口，那所有的车只能排成一条队缴费；如果有多个收费口，就可以分流了。\n\nHashtable 使用 synchronized 修饰方法来保证线程安全性，那么面对线程的访问，Hashtable 就会锁住整个对象，所有的其它线程只能等待，这种阻塞方式的吞吐量显然很低。\n\nJava 1.7 以前的 ConcurrentHashMap 就是分段锁的典型案例。ConcurrentHashMap 维护了一个 Segment 数组，一般称为分段桶。\n\nfinal Segment<K,V>[] segments;\n\n\n当有线程访问 ConcurrentHashMap 的数据时，ConcurrentHashMap 会先根据 hashCode 计算出数据在哪个桶（即哪个 Segment），然后锁住这个 Segment。\n\n\n# 显示锁和内置锁\n\nJava 1.5 之前，协调对共享对象的访问时可以使用的机制只有 synchronized 和 volatile。这两个都属于内置锁，即锁的申请和释放都是由 JVM 所控制。\n\nJava 1.5 之后，增加了新的机制：ReentrantLock、ReentrantReadWriteLock ，这类锁的申请和释放都可以由程序所控制，所以常被称为显示锁。\n\n> 💡 synchronized 的用法和原理可以参考：Java 并发基础机制 - synchronized 。\n> \n> 🔔 注意：如果不需要 ReentrantLock、ReentrantReadWriteLock 所提供的高级同步特性，应该优先考虑使用 synchronized 。理由如下：\n> \n>  * Java 1.6 以后，synchronized 做了大量的优化，其性能已经与 ReentrantLock、ReentrantReadWriteLock 基本上持平。\n>  * 从趋势来看，Java 未来更可能会优化 synchronized ，而不是 ReentrantLock、ReentrantReadWriteLock ，因为 synchronized 是 JVM 内置属性，它能执行一些优化。\n>  * ReentrantLock、ReentrantReadWriteLock 申请和释放锁都是由程序控制，如果使用不当，可能造成死锁，这是很危险的。\n\n以下对比一下显示锁和内置锁的差异：\n\n * 主动获取锁和释放锁\n   * synchronized 不能主动获取锁和释放锁。获取锁和释放锁都是 JVM 控制的。\n   * ReentrantLock 可以主动获取锁和释放锁。（如果忘记释放锁，就可能产生死锁）。\n * 响应中断\n   * synchronized 不能响应中断。\n   * ReentrantLock 可以响应中断。\n * 超时机制\n   * synchronized 没有超时机制。\n   * ReentrantLock 有超时机制。ReentrantLock 可以设置超时时间，超时后自动释放锁，避免一直等待。\n * 支持公平锁\n   * synchronized 只支持非公平锁。\n   * ReentrantLock 支持非公平锁和公平锁。\n * 是否支持共享\n   * 被 synchronized 修饰的方法或代码块，只能被一个线程访问（独享）。如果这个线程被阻塞，其他线程也只能等待\n   * ReentrantLock 可以基于 Condition 灵活的控制同步条件。\n * 是否支持读写分离\n   * synchronized 不支持读写锁分离；\n   * ReentrantReadWriteLock 支持读写锁，从而使阻塞读写的操作分开，有效提高并发性。\n\n\n# Lock 和 Condition\n\n\n# 为何引入 Lock 和 Condition\n\n并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。这两大问题，管程都是能够解决的。Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题。\n\nsynchronized 是管程的一种实现，既然如此，何必再提供 Lock 和 Condition。\n\nJDK 1.6 以前，synchronized 还没有做优化，性能远低于 Lock。但是，性能不是引入 Lock 的最重要因素。真正关键在于：synchronized 使用不当，可能会出现死锁。\n\nsynchronized 无法通过破坏不可抢占条件来避免死锁。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。\n\n与内置锁 synchronized 不同的是，Lock 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作，所有获取锁、释放锁的操作都是显式的操作。\n\n * 能够响应中断。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。\n * 支持超时。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。\n * 非阻塞地获取锁。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。\n\n\n# Lock 接口\n\nLock 的接口定义如下：\n\npublic interface Lock {\n    void lock();\n    void lockInterruptibly() throws InterruptedException;\n    boolean tryLock();\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n    void unlock();\n    Condition newCondition();\n}\n\n\n * lock() - 获取锁。\n * unlock() - 释放锁。\n * tryLock() - 尝试获取锁，仅在调用时锁未被另一个线程持有的情况下，才获取该锁。\n * tryLock(long time, TimeUnit unit) - 和 tryLock() 类似，区别仅在于限定时间，如果限定时间内未获取到锁，视为失败。\n * lockInterruptibly() - 锁未被另一个线程持有，且线程没有被中断的情况下，才能获取锁。\n * newCondition() - 返回一个绑定到 Lock 对象上的 Condition 实例。\n\n\n# Condition\n\nCondition 实现了管程模型里面的条件变量。\n\n前文中提过 Lock 接口中 有一个 newCondition() 方法用于返回一个绑定到 Lock 对象上的 Condition 实例。Condition 是什么？有什么作用？本节将一一讲解。\n\n在单线程中，一段代码的执行可能依赖于某个状态，如果不满足状态条件，代码就不会被执行（典型的场景，如：if ... else ...）。在并发环境中，当一个线程判断某个状态条件时，其状态可能是由于其他线程的操作而改变，这时就需要有一定的协调机制来确保在同一时刻，数据只能被一个线程锁修改，且修改的数据状态被所有线程所感知。\n\nJava 1.5 之前，主要是利用 Object 类中的 wait、notify、notifyAll 配合 synchronized 来进行线程间通信（如果不了解其特性，可以参考：Java 线程基础 - wait/notify/notifyAll）。\n\nwait、notify、notifyAll 需要配合 synchronized 使用，不适用于 Lock。而使用 Lock 的线程，彼此间通信应该使用 Condition 。这可以理解为，什么样的锁配什么样的钥匙。内置锁（synchronized）配合内置条件队列（wait、notify、notifyAll ），显式锁（Lock）配合显式条件队列（Condition ）。\n\n# Condition 的特性\n\nCondition 接口定义如下：\n\npublic interface Condition {\n    void await() throws InterruptedException;\n    void awaitUninterruptibly();\n    long awaitNanos(long nanosTimeout) throws InterruptedException;\n    boolean await(long time, TimeUnit unit) throws InterruptedException;\n    boolean awaitUntil(Date deadline) throws InterruptedException;\n    void signal();\n    void signalAll();\n}\n\n\n其中，await、signal、signalAll 与 wait、notify、notifyAll 相对应，功能也相似。除此以外，Condition 相比内置条件队列（ wait、notify、notifyAll ），提供了更为丰富的功能：\n\n * 每个锁（Lock）上可以存在多个 Condition，这意味着锁的状态条件可以有多个。\n * 支持公平的或非公平的队列操作。\n * 支持可中断的条件等待，相关方法：awaitUninterruptibly() 。\n * 支持可定时的等待，相关方法：awaitNanos(long) 、await(long, TimeUnit)、awaitUntil(Date)。\n\n# Condition 的用法\n\n这里以 Condition 来实现一个消费者、生产者模式。\n\n> 🔔 注意：事实上，解决此类问题使用 CountDownLatch、Semaphore 等工具更为便捷、安全。想了解详情，可以参考 Java 并发工具类 。\n\n产品类\n\nclass Message {\n\n    private final Lock lock = new ReentrantLock();\n\n    private final Condition producedMsg = lock.newCondition();\n\n    private final Condition consumedMsg = lock.newCondition();\n\n    private String message;\n\n    private boolean state;\n\n    private boolean end;\n\n    public void consume() {\n        //lock\n        lock.lock();\n        try {\n            // no new message wait for new message\n            while (!state) { producedMsg.await(); }\n\n            System.out.println("consume message : " + message);\n            state = false;\n            // message consumed, notify waiting thread\n            consumedMsg.signal();\n        } catch (InterruptedException ie) {\n            System.out.println("Thread interrupted - viewMessage");\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void produce(String message) {\n        lock.lock();\n        try {\n            // last message not consumed, wait for it be consumed\n            while (state) { consumedMsg.await(); }\n\n            System.out.println("produce msg: " + message);\n            this.message = message;\n            state = true;\n            // new message added, notify waiting thread\n            producedMsg.signal();\n        } catch (InterruptedException ie) {\n            System.out.println("Thread interrupted - publishMessage");\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public boolean isEnd() {\n        return end;\n    }\n\n    public void setEnd(boolean end) {\n        this.end = end;\n    }\n\n}\n\n\n消费者\n\nclass MessageConsumer implements Runnable {\n\n    private Message message;\n\n    public MessageConsumer(Message msg) {\n        message = msg;\n    }\n\n    @Override\n    public void run() {\n        while (!message.isEnd()) { message.consume(); }\n    }\n\n}\n\n\n生产者\n\nclass MessageProducer implements Runnable {\n\n    private Message message;\n\n    public MessageProducer(Message msg) {\n        message = msg;\n    }\n\n    @Override\n    public void run() {\n        produce();\n    }\n\n    public void produce() {\n        List<String> msgs = new ArrayList<>();\n        msgs.add("Begin");\n        msgs.add("Msg1");\n        msgs.add("Msg2");\n\n        for (String msg : msgs) {\n            message.produce(msg);\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        message.produce("End");\n        message.setEnd(true);\n    }\n\n}\n\n\n测试\n\npublic class LockConditionDemo {\n\n    public static void main(String[] args) {\n        Message msg = new Message();\n        Thread producer = new Thread(new MessageProducer(msg));\n        Thread consumer = new Thread(new MessageConsumer(msg));\n        producer.start();\n        consumer.start();\n    }\n}\n\n\n\n# ReentrantLock\n\nReentrantLock 类是 Lock 接口的具体实现，与内置锁 synchronized 相同的是，它是一个可重入锁。\n\n\n# ReentrantLock 的特性\n\nReentrantLock 的特性如下：\n\n * ReentrantLock 提供了与 synchronized 相同的互斥性、内存可见性和可重入性。\n * ReentrantLock 支持公平锁和非公平锁（默认）两种模式。\n * ReentrantLock 实现了 Lock 接口，支持了 synchronized 所不具备的灵活性。\n   * synchronized 无法中断一个正在等待获取锁的线程\n   * synchronized 无法在请求获取一个锁时无休止地等待\n\n\n# ReentrantLock 的用法\n\n前文了解了 ReentrantLock 的特性，接下来，我们要讲述其具体用法。\n\n# ReentrantLock 的构造方法\n\nReentrantLock 有两个构造方法：\n\npublic ReentrantLock() {}\npublic ReentrantLock(boolean fair) {}\n\n\n * ReentrantLock() - 默认构造方法会初始化一个非公平锁（NonfairSync）；\n * ReentrantLock(boolean) - new ReentrantLock(true) 会初始化一个公平锁（FairSync）。\n\n# lock 和 unlock 方法\n\n * lock() - 无条件获取锁。如果当前线程无法获取锁，则当前线程进入休眠状态不可用，直至当前线程获取到锁。如果该锁没有被另一个线程持有，则获取该锁并立即返回，将锁的持有计数设置为 1。\n * unlock() - 用于释放锁。\n\n> 🔔 注意：请务必牢记，获取锁操作 lock() 必须在 try catch 块中进行，并且将释放锁操作 unlock() 放在 finally 块中进行，以保证锁一定被被释放，防止死锁的发生。\n\n示例：ReentrantLock 的基本操作\n\npublic class ReentrantLockDemo {\n\n    public static void main(String[] args) {\n        Task task = new Task();\n        MyThread tA = new MyThread("Thread-A", task);\n        MyThread tB = new MyThread("Thread-B", task);\n        MyThread tC = new MyThread("Thread-C", task);\n        tA.start();\n        tB.start();\n        tC.start();\n    }\n\n    static class MyThread extends Thread {\n\n        private Task task;\n\n        public MyThread(String name, Task task) {\n            super(name);\n            this.task = task;\n        }\n\n        @Override\n        public void run() {\n            task.execute();\n        }\n\n    }\n\n    static class Task {\n\n        private ReentrantLock lock = new ReentrantLock();\n\n        public void execute() {\n            lock.lock();\n            try {\n                for (int i = 0; i < 3; i++) {\n                    System.out.println(lock.toString());\n\n                    // 查询当前线程 hold 住此锁的次数\n                    System.out.println("\\t holdCount: " + lock.getHoldCount());\n\n                    // 查询正等待获取此锁的线程数\n                    System.out.println("\\t queuedLength: " + lock.getQueueLength());\n\n                    // 是否为公平锁\n                    System.out.println("\\t isFair: " + lock.isFair());\n\n                    // 是否被锁住\n                    System.out.println("\\t isLocked: " + lock.isLocked());\n\n                    // 是否被当前线程持有锁\n                    System.out.println("\\t isHeldByCurrentThread: " + lock.isHeldByCurrentThread());\n\n                    try {\n                        Thread.sleep(500);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            } finally {\n                lock.unlock();\n            }\n        }\n\n    }\n\n}\n\n\n输出结果：\n\njava.util.concurrent.locks.ReentrantLock@64fcd88a[Locked by thread Thread-A]\n\t holdCount: 1\n\t queuedLength: 2\n\t isFair: false\n\t isLocked: true\n\t isHeldByCurrentThread: true\njava.util.concurrent.locks.ReentrantLock@64fcd88a[Locked by thread Thread-C]\n\t holdCount: 1\n\t queuedLength: 1\n\t isFair: false\n\t isLocked: true\n\t isHeldByCurrentThread: true\n// ...\n\n\n# tryLock 方法\n\n与无条件获取锁相比，tryLock 有更完善的容错机制。\n\n * tryLock() - 可轮询获取锁。如果成功，则返回 true；如果失败，则返回 false。也就是说，这个方法无论成败都会立即返回，获取不到锁（锁已被其他线程获取）时不会一直等待。\n * tryLock(long, TimeUnit) - 可定时获取锁。和 tryLock() 类似，区别仅在于这个方法在获取不到锁时会等待一定的时间，在时间期限之内如果还获取不到锁，就返回 false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回 true。\n\n示例：ReentrantLock 的 tryLock() 操作\n\n修改上个示例中的 execute() 方法\n\npublic void execute() {\n    if (lock.tryLock()) {\n        try {\n            for (int i = 0; i < 3; i++) {\n               // 略...\n            }\n        } finally {\n            lock.unlock();\n        }\n    } else {\n        System.out.println(Thread.currentThread().getName() + " 获取锁失败");\n    }\n}\n\n\n示例：ReentrantLock 的 tryLock(long, TimeUnit) 操作\n\n修改上个示例中的 execute() 方法\n\npublic void execute() {\n    try {\n        if (lock.tryLock(2, TimeUnit.SECONDS)) {\n            try {\n                for (int i = 0; i < 3; i++) {\n                    // 略...\n                }\n            } finally {\n                lock.unlock();\n            }\n        } else {\n            System.out.println(Thread.currentThread().getName() + " 获取锁失败");\n        }\n    } catch (InterruptedException e) {\n        System.out.println(Thread.currentThread().getName() + " 获取锁超时");\n        e.printStackTrace();\n    }\n}\n\n\n# lockInterruptibly 方法\n\n * lockInterruptibly() - 可中断获取锁。可中断获取锁可以在获得锁的同时保持对中断的响应。可中断获取锁比其它获取锁的方式稍微复杂一些，需要两个 try-catch 块（如果在获取锁的操作中抛出了 InterruptedException ，那么可以使用标准的 try-finally 加锁模式）。\n   * 举例来说：假设有两个线程同时通过 lock.lockInterruptibly() 获取某个锁时，若线程 A 获取到了锁，则线程 B 只能等待。若此时对线程 B 调用 threadB.interrupt() 方法能够中断线程 B 的等待过程。由于 lockInterruptibly() 的声明中抛出了异常，所以 lock.lockInterruptibly() 必须放在 try 块中或者在调用 lockInterruptibly() 的方法外声明抛出 InterruptedException。\n\n> 🔔 注意：当一个线程获取了锁之后，是不会被 interrupt() 方法中断的。单独调用 interrupt() 方法不能中断正在运行状态中的线程，只能中断阻塞状态中的线程。因此当通过 lockInterruptibly() 方法获取某个锁时，如果未获取到锁，只有在等待的状态下，才可以响应中断。\n\n示例：ReentrantLock 的 lockInterruptibly() 操作\n\n修改上个示例中的 execute() 方法\n\npublic void execute() {\n    try {\n        lock.lockInterruptibly();\n\n        for (int i = 0; i < 3; i++) {\n            // 略...\n        }\n    } catch (InterruptedException e) {\n        System.out.println(Thread.currentThread().getName() + "被中断");\n        e.printStackTrace();\n    } finally {\n        lock.unlock();\n    }\n}\n\n\n# newCondition 方法\n\nnewCondition() - 返回一个绑定到 Lock 对象上的 Condition 实例。Condition 的特性和具体方法请阅读下文 Condition。\n\n\n# ReentrantLock 的原理\n\n# ReentrantLock 的可见性\n\nclass X {\n  private final Lock rtl =\n  new ReentrantLock();\n  int value;\n  public void addOne() {\n    // 获取锁\n    rtl.lock();\n    try {\n      value+=1;\n    } finally {\n      // 保证锁能释放\n      rtl.unlock();\n    }\n  }\n}\n\n\nReentrantLock，内部持有一个 volatile 的成员变量 state，获取锁的时候，会读写 state 的值；解锁的时候，也会读写 state 的值（简化后的代码如下面所示）。也就是说，在执行 value+=1 之前，程序先读写了一次 volatile 变量 state，在执行 value+=1 之后，又读写了一次 volatile 变量 state。根据相关的 Happens-Before 规则：\n\n 1. 顺序性规则：对于线程 T1，value+=1 Happens-Before 释放锁的操作 unlock()；\n 2. volatile 变量规则：由于 state = 1 会先读取 state，所以线程 T1 的 unlock() 操作 Happens-Before 线程 T2 的 lock() 操作；\n 3. 传递性规则：线程 T1 的 value+=1 Happens-Before 线程 T2 的 lock() 操作。\n\n# ReentrantLock 的数据结构\n\n阅读 ReentrantLock 的源码，可以发现它有一个核心字段：\n\nprivate final Sync sync;\n\n\n * sync - 内部抽象类 ReentrantLock.Sync 对象，Sync 继承自 AQS。它有两个子类：\n * ReentrantLock.FairSync - 公平锁。\n * ReentrantLock.NonfairSync - 非公平锁。\n\n查看源码可以发现，ReentrantLock 实现 Lock 接口其实是调用 ReentrantLock.FairSync 或 ReentrantLock.NonfairSync 中各自的实现，这里不一一列举。\n\n# ReentrantLock 的获取锁和释放锁\n\nReentrantLock 获取锁和释放锁的接口，从表象看，是调用 ReentrantLock.FairSync 或 ReentrantLock.NonfairSync 中各自的实现；从本质上看，是基于 AQS 的实现。\n\n仔细阅读源码很容易发现：\n\n * void lock() 调用 Sync 的 lock() 方法。\n\n * void lockInterruptibly() 直接调用 AQS 的 获取可中断的独占锁 方法 lockInterruptibly()。\n\n * boolean tryLock() 调用 Sync 的 nonfairTryAcquire() 。\n\n * boolean tryLock(long time, TimeUnit unit) 直接调用 AQS 的 获取超时等待式的独占锁 方法 tryAcquireNanos(int arg, long nanosTimeout)。\n\n * void unlock() 直接调用 AQS 的 释放独占锁 方法 release(int arg) 。\n\n直接调用 AQS 接口的方法就不再赘述了，其原理在 [AQS 的原理](#AQS 的原理) 中已经用很大篇幅进行过讲解。\n\nnonfairTryAcquire 方法源码如下：\n\n// 公平锁和非公平锁都会用这个方法区尝试获取锁\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n         // 如果同步状态为0，将其设为 acquires，并设置当前线程为排它线程\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error("Maximum lock count exceeded");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n处理流程很简单：\n\n * 如果同步状态为 0，设置同步状态设为 acquires，并设置当前线程为排它线程，然后返回 true，获取锁成功。\n * 如果同步状态不为 0 且当前线程为排它线程，设置同步状态为当前状态值+acquires 值，然后返回 true，获取锁成功。\n * 否则，返回 false，获取锁失败。\n\n# 公平锁和非公平锁\n\nReentrantLock 这个类有两个构造函数，一个是无参构造函数，一个是传入 fair 参数的构造函数。fair 参数代表的是锁的公平策略，如果传入 true 就表示需要构造一个公平锁，反之则表示要构造一个非公平锁。\n\n锁都对应着一个等待队列，如果一个线程没有获得锁，就会进入等待队列，当有线程释放锁的时候，就需要从等待队列中唤醒一个等待的线程。如果是公平锁，唤醒的策略就是谁等待的时间长，就唤醒谁，很公平；如果是非公平锁，则不提供这个公平保证，有可能等待时间短的线程反而先被唤醒。\n\nlock 方法在公平锁和非公平锁中的实现：\n\n二者的区别仅在于申请非公平锁时，如果同步状态为 0，尝试将其设为 1，如果成功，直接将当前线程置为排它线程；否则和公平锁一样，调用 AQS 获取独占锁方法 acquire。\n\n// 非公平锁实现\nfinal void lock() {\n    if (compareAndSetState(0, 1))\n    // 如果同步状态为0，将其设为1，并设置当前线程为排它线程\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n    // 调用 AQS 获取独占锁方法 acquire\n        acquire(1);\n}\n\n// 公平锁实现\nfinal void lock() {\n    // 调用 AQS 获取独占锁方法 acquire\n    acquire(1);\n}\n\n\n\n# ReentrantReadWriteLock\n\nReadWriteLock 适用于读多写少的场景。\n\nReentrantReadWriteLock 类是 ReadWriteLock 接口的具体实现，它是一个可重入的读写锁。ReentrantReadWriteLock 维护了一对读写锁，将读写锁分开，有利于提高并发效率。\n\n读写锁，并不是 Java 语言特有的，而是一个广为使用的通用技术，所有的读写锁都遵守以下三条基本原则：\n\n * 允许多个线程同时读共享变量；\n * 只允许一个线程写共享变量；\n * 如果一个写线程正在执行写操作，此时禁止读线程读共享变量。\n\n读写锁与互斥锁的一个重要区别就是读写锁允许多个线程同时读共享变量，而互斥锁是不允许的，这是读写锁在读多写少场景下性能优于互斥锁的关键。但读写锁的写操作是互斥的，当一个线程在写共享变量的时候，是不允许其他线程执行写操作和读操作。\n\n\n# ReentrantReadWriteLock 的特性\n\nReentrantReadWriteLock 的特性如下：\n\n * ReentrantReadWriteLock 适用于读多写少的场景。如果是写多读少的场景，由于 ReentrantReadWriteLock 其内部实现比 ReentrantLock 复杂，性能可能反而要差一些。如果存在这样的问题，需要具体问题具体分析。由于 ReentrantReadWriteLock 的读写锁（ReadLock、WriteLock）都实现了 Lock 接口，所以要替换为 ReentrantLock 也较为容易。\n * ReentrantReadWriteLock 实现了 ReadWriteLock 接口，支持了 ReentrantLock 所不具备的读写锁分离。ReentrantReadWriteLock 维护了一对读写锁（ReadLock、WriteLock）。将读写锁分开，有利于提高并发效率。ReentrantReadWriteLock 的加锁策略是：允许多个读操作并发执行，但每次只允许一个写操作。\n * ReentrantReadWriteLock 为读写锁都提供了可重入的加锁语义。\n * ReentrantReadWriteLock 支持公平锁和非公平锁（默认）两种模式。\n\nReadWriteLock 接口定义如下：\n\npublic interface ReadWriteLock {\n    Lock readLock();\n    Lock writeLock();\n}\n\n\n * readLock - 返回用于读操作的锁（ReadLock）。\n * writeLock - 返回用于写操作的锁（WriteLock）。\n\n在读写锁和写入锁之间的交互可以采用多种实现方式，ReadWriteLock 的一些可选实现包括：\n\n * 释放优先 - 当一个写入操作释放写锁，并且队列中同时存在读线程和写线程，那么应该优先选择读线程、写线程，还是最先发出请求的线程？\n * 读线程插队 - 如果锁是由读线程持有，但有写线程正在等待，那么新到达的读线程能否立即获得访问权，还是应该在写线程后面等待？如果允许读线程插队到写线程之前，那么将提高并发性，但可能造成线程饥饿问题。\n * 重入性 - 读锁和写锁是否是可重入的？\n * 降级 - 如果一个线程持有写入锁，那么它能否在不释放该锁的情况下获得读锁？这可能会使得写锁被降级为读锁，同时不允许其他写线程修改被保护的资源。\n * 升级 - 读锁能否优先于其他正在等待的读线程和写线程而升级为一个写锁？在大多数的读写锁实现中并不支持升级，因为如果没有显式的升级操作，那么很容易造成死锁。\n\n\n# ReentrantReadWriteLock 的用法\n\n前文了解了 ReentrantReadWriteLock 的特性，接下来，我们要讲述其具体用法。\n\n# ReentrantReadWriteLock 的构造方法\n\nReentrantReadWriteLock 和 ReentrantLock 一样，也有两个构造方法，且用法相似。\n\npublic ReentrantReadWriteLock() {}\npublic ReentrantReadWriteLock(boolean fair) {}\n\n\n * ReentrantReadWriteLock() - 默认构造方法会初始化一个非公平锁（NonfairSync）。在非公平的锁中，线程获得锁的顺序是不确定的。写线程降级为读线程是可以的，但读线程升级为写线程是不可以的（这样会导致死锁）。\n * ReentrantReadWriteLock(boolean) - new ReentrantLock(true) 会初始化一个公平锁（FairSync）。对于公平锁，等待时间最长的线程将优先获得锁。如果这个锁是读线程持有，则另一个线程请求写锁，那么其他读线程都不能获得读锁，直到写线程释放写锁。\n\n# ReentrantReadWriteLock 的使用实例\n\n在 ReentrantReadWriteLock 的特性 中已经介绍过，ReentrantReadWriteLock 的读写锁（ReadLock、WriteLock）都实现了 Lock 接口，所以其各自独立的使用方式与 ReentrantLock 一样，这里不再赘述。\n\nReentrantReadWriteLock 与 ReentrantLock 用法上的差异，主要在于读写锁的配合使用。本文以一个典型使用场景来进行讲解。\n\n【示例】基于 ReadWriteLock 实现一个简单的泛型无界缓存\n\n/**\n * 简单的无界缓存实现\n * <p>\n * 使用 WeakHashMap 存储键值对。WeakHashMap 中存储的对象是弱引用，JVM GC 时会自动清除没有被引用的弱引用对象。\n */\nstatic class UnboundedCache<K, V> {\n\n    private final Map<K, V> cacheMap = new WeakHashMap<>();\n\n    private final ReadWriteLock cacheLock = new ReentrantReadWriteLock();\n\n    public V get(K key) {\n        cacheLock.readLock().lock();\n        V value;\n        try {\n            value = cacheMap.get(key);\n            String log = String.format("%s 读数据 %s:%s", Thread.currentThread().getName(), key, value);\n            System.out.println(log);\n        } finally {\n            cacheLock.readLock().unlock();\n        }\n        return value;\n    }\n\n    public V put(K key, V value) {\n        cacheLock.writeLock().lock();\n        try {\n            cacheMap.put(key, value);\n            String log = String.format("%s 写入数据 %s:%s", Thread.currentThread().getName(), key, value);\n            System.out.println(log);\n        } finally {\n            cacheLock.writeLock().unlock();\n        }\n        return value;\n    }\n\n    public V remove(K key) {\n        cacheLock.writeLock().lock();\n        try {\n            return cacheMap.remove(key);\n        } finally {\n            cacheLock.writeLock().unlock();\n        }\n    }\n\n    public void clear() {\n        cacheLock.writeLock().lock();\n        try {\n            this.cacheMap.clear();\n        } finally {\n            cacheLock.writeLock().unlock();\n        }\n    }\n\n}\n\n\n说明：\n\n * 使用 WeakHashMap 而不是 HashMap 来存储键值对。WeakHashMap 中存储的对象是弱引用，JVM GC 时会自动清除没有被引用的弱引用对象。\n * 向 Map 写数据前加写锁，写完后，释放写锁。\n * 向 Map 读数据前加读锁，读完后，释放读锁。\n\n测试其线程安全性：\n\n/**\n * @author <a href="mailto:forbreak@163.com">Zhang Peng</a>\n * @since 2020-01-01\n */\npublic class ReentrantReadWriteLockDemo {\n\n    static UnboundedCache<Integer, Integer> cache = new UnboundedCache<>();\n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        for (int i = 0; i < 20; i++) {\n            executorService.execute(new MyThread());\n            cache.get(0);\n        }\n        executorService.shutdown();\n    }\n\n    /** 线程任务每次向缓存中写入 3 个随机值，key 固定 */\n    static class MyThread implements Runnable {\n\n        @Override\n        public void run() {\n            Random random = new Random();\n            for (int i = 0; i < 3; i++) {\n                cache.put(i, random.nextInt(100));\n            }\n        }\n\n    }\n\n}\n\n\n说明：示例中，通过线程池启动 20 个并发任务。任务每次向缓存中写入 3 个随机值，key 固定；然后主线程每次固定读取缓存中第一个 key 的值。\n\n输出结果：\n\nmain 读数据 0:null\npool-1-thread-1 写入数据 0:16\npool-1-thread-1 写入数据 1:58\npool-1-thread-1 写入数据 2:50\nmain 读数据 0:16\npool-1-thread-1 写入数据 0:85\npool-1-thread-1 写入数据 1:76\npool-1-thread-1 写入数据 2:46\npool-1-thread-2 写入数据 0:21\npool-1-thread-2 写入数据 1:41\npool-1-thread-2 写入数据 2:63\nmain 读数据 0:21\nmain 读数据 0:21\n// ...\n\n\n\n# ReentrantReadWriteLock 的原理\n\n前面了解了 ReentrantLock 的原理，理解 ReentrantReadWriteLock 就容易多了。\n\n# ReentrantReadWriteLock 的数据结构\n\n阅读 ReentrantReadWriteLock 的源码，可以发现它有三个核心字段：\n\n/** Inner class providing readlock */\nprivate final ReentrantReadWriteLock.ReadLock readerLock;\n/** Inner class providing writelock */\nprivate final ReentrantReadWriteLock.WriteLock writerLock;\n/** Performs all synchronization mechanics */\nfinal Sync sync;\n\npublic ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }\npublic ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }\n\n\n * sync - 内部类 ReentrantReadWriteLock.Sync 对象。与 ReentrantLock 类似，它有两个子类：ReentrantReadWriteLock.FairSync 和 ReentrantReadWriteLock.NonfairSync ，分别表示公平锁和非公平锁的实现。\n * readerLock - 内部类 ReentrantReadWriteLock.ReadLock 对象，这是一把读锁。\n * writerLock - 内部类 ReentrantReadWriteLock.WriteLock 对象，这是一把写锁。\n\n# ReentrantReadWriteLock 的获取锁和释放锁\n\npublic static class ReadLock implements Lock, java.io.Serializable {\n\n    // 调用 AQS 获取共享锁方法\n    public void lock() {\n        sync.acquireShared(1);\n    }\n\n    // 调用 AQS 释放共享锁方法\n    public void unlock() {\n        sync.releaseShared(1);\n    }\n}\n\npublic static class WriteLock implements Lock, java.io.Serializable {\n\n    // 调用 AQS 获取独占锁方法\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    // 调用 AQS 释放独占锁方法\n    public void unlock() {\n        sync.release(1);\n    }\n}\n\n\n\n# StampedLock\n\nReadWriteLock 支持两种模式：一种是读锁，一种是写锁。而 StampedLock 支持三种模式，分别是：写锁、悲观读锁和乐观读。其中，写锁、悲观读锁的语义和 ReadWriteLock 的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。不同的是：StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。\n\n> 注意这里，用的是“乐观读”这个词，而不是“乐观读锁”，是要提醒你，乐观读这个操作是无锁的，所以相比较 ReadWriteLock 的读锁，乐观读的性能更好一些。\n\nStampedLock 的性能之所以比 ReadWriteLock 还要好，其关键是 StampedLock 支持乐观读的方式。\n\n * ReadWriteLock 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；\n * 而 StampedLock 提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。\n\n对于读多写少的场景 StampedLock 性能很好，简单的应用场景基本上可以替代 ReadWriteLock，但是StampedLock 的功能仅仅是 ReadWriteLock 的子集，在使用的时候，还是有几个地方需要注意一下。\n\n * StampedLock 不支持重入\n * StampedLock 的悲观读锁、写锁都不支持条件变量。\n * 如果线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升。使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()。\n\n【示例】StampedLock 阻塞时，调用 interrupt() 导致 CPU 飙升\n\nfinal StampedLock lock\n  = new StampedLock();\nThread T1 = new Thread(()->{\n  // 获取写锁\n  lock.writeLock();\n  // 永远阻塞在此处，不释放写锁\n  LockSupport.park();\n});\nT1.start();\n// 保证 T1 获取写锁\nThread.sleep(100);\nThread T2 = new Thread(()->\n  // 阻塞在悲观读锁\n  lock.readLock()\n);\nT2.start();\n// 保证 T2 阻塞在读锁\nThread.sleep(100);\n// 中断线程 T2\n// 会导致线程 T2 所在 CPU 飙升\nT2.interrupt();\nT2.join();\n\n\n【示例】StampedLock 读模板：\n\nfinal StampedLock sl =\n  new StampedLock();\n\n// 乐观读\nlong stamp =\n  sl.tryOptimisticRead();\n// 读入方法局部变量\n......\n// 校验 stamp\nif (!sl.validate(stamp)){\n  // 升级为悲观读锁\n  stamp = sl.readLock();\n  try {\n    // 读入方法局部变量\n    .....\n  } finally {\n    // 释放悲观读锁\n    sl.unlockRead(stamp);\n  }\n}\n// 使用方法局部变量执行业务操作\n......\n\n\n【示例】StampedLock 写模板：\n\nlong stamp = sl.writeLock();\ntry {\n  // 写共享变量\n  ......\n} finally {\n  sl.unlockWrite(stamp);\n}\n\n\n\n# AQS\n\n> AbstractQueuedSynchronizer（简称 AQS）是队列同步器，顾名思义，其主要作用是处理同步。它是并发锁和很多同步工具类的实现基石（如 ReentrantLock、ReentrantReadWriteLock、CountDownLatch、Semaphore、FutureTask 等）。\n\n\n# AQS 的要点\n\nAQS 提供了对独享锁与共享锁的支持。\n\n在 java.util.concurrent.locks 包中的相关锁（常用的有 ReentrantLock、 ReadWriteLock）都是基于 AQS 来实现。这些锁都没有直接继承 AQS，而是定义了一个 Sync 类去继承 AQS。为什么要这样呢？因为锁面向的是使用用户，而同步器面向的则是线程控制，那么在锁的实现中聚合同步器而不是直接继承 AQS 就可以很好的隔离二者所关注的事情。\n\n\n# AQS 的应用\n\nAQS 提供了对独享锁与共享锁的支持。\n\n# 独享锁 API\n\n获取、释放独享锁的主要 API 如下：\n\npublic final void acquire(int arg)\npublic final void acquireInterruptibly(int arg)\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)\npublic final boolean release(int arg)\n\n\n * acquire - 获取独占锁。\n * acquireInterruptibly - 获取可中断的独占锁。\n * tryAcquireNanos - 尝试在指定时间内获取可中断的独占锁。在以下三种情况下回返回：\n   * 在超时时间内，当前线程成功获取了锁；\n   * 当前线程在超时时间内被中断；\n   * 超时时间结束，仍未获得锁返回 false。\n * release - 释放独占锁。\n\n# 共享锁 API\n\n获取、释放共享锁的主要 API 如下：\n\npublic final void acquireShared(int arg)\npublic final void acquireSharedInterruptibly(int arg)\npublic final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)\npublic final boolean releaseShared(int arg)\n\n\n * acquireShared - 获取共享锁。\n * acquireSharedInterruptibly - 获取可中断的共享锁。\n * tryAcquireSharedNanos - 尝试在指定时间内获取可中断的共享锁。\n * release - 释放共享锁。\n\n\n# AQS 的原理\n\n> ASQ 原理要点：\n> \n>  * AQS 使用一个整型的 volatile 变量来 维护同步状态。状态的意义由子类赋予。\n>  * AQS 维护了一个 FIFO 的双链表，用来存储获取锁失败的线程。\n> \n> AQS 围绕同步状态提供两种基本操作“获取”和“释放”，并提供一系列判断和处理方法，简单说几点：\n> \n>  * state 是独占的，还是共享的；\n>  * state 被获取后，其他线程需要等待；\n>  * state 被释放后，唤醒等待线程；\n>  * 线程等不及时，如何退出等待。\n> \n> 至于线程是否可以获得 state，如何释放 state，就不是 AQS 关心的了，要由子类具体实现。\n\n# AQS 的数据结构\n\n阅读 AQS 的源码，可以发现：AQS 继承自 AbstractOwnableSynchronize。\n\npublic abstract class AbstractQueuedSynchronizer\n    extends AbstractOwnableSynchronizer\n    implements java.io.Serializable {\n\n    /** 等待队列的队头，懒加载。只能通过 setHead 方法修改。 */\n    private transient volatile Node head;\n    /** 等待队列的队尾，懒加载。只能通过 enq 方法添加新的等待节点。*/\n    private transient volatile Node tail;\n    /** 同步状态 */\n    private volatile int state;\n}\n\n\n * state - AQS 使用一个整型的 volatile 变量来 维护同步状态。\n   * 这个整数状态的意义由子类来赋予，如ReentrantLock 中该状态值表示所有者线程已经重复获取该锁的次数，Semaphore 中该状态值表示剩余的许可数量。\n * head 和 tail - AQS 维护了一个 Node 类型（AQS 的内部类）的双链表来完成同步状态的管理。这个双链表是一个双向的 FIFO 队列，通过 head 和 tail 指针进行访问。当 有线程获取锁失败后，就被添加到队列末尾。\n\n\n\n再来看一下 Node 的源码\n\nstatic final class Node {\n    /** 该等待同步的节点处于共享模式 */\n    static final Node SHARED = new Node();\n    /** 该等待同步的节点处于独占模式 */\n    static final Node EXCLUSIVE = null;\n\n    /** 线程等待状态，状态值有: 0、1、-1、-2、-3 */\n    volatile int waitStatus;\n    static final int CANCELLED =  1;\n    static final int SIGNAL    = -1;\n    static final int CONDITION = -2;\n    static final int PROPAGATE = -3;\n\n    /** 前驱节点 */\n    volatile Node prev;\n    /** 后继节点 */\n    volatile Node next;\n    /** 等待锁的线程 */\n    volatile Thread thread;\n\n  \t/** 和节点是否共享有关 */\n    Node nextWaiter;\n}\n\n\n很显然，Node 是一个双链表结构。\n\n * waitStatus - Node 使用一个整型的 volatile 变量来 维护 AQS 同步队列中线程节点的状态。waitStatus 有五个状态值：\n   * CANCELLED(1) - 此状态表示：该节点的线程可能由于超时或被中断而 处于被取消(作废)状态，一旦处于这个状态，表示这个节点应该从等待队列中移除。\n   * SIGNAL(-1) - 此状态表示：后继节点会被挂起，因此在当前节点释放锁或被取消之后，必须唤醒(unparking)其后继结点。\n   * CONDITION(-2) - 此状态表示：该节点的线程 处于等待条件状态，不会被当作是同步队列上的节点，直到被唤醒(signal)，设置其值为 0，再重新进入阻塞状态。\n   * PROPAGATE(-3) - 此状态表示：下一个 acquireShared 应无条件传播。\n   * 0 - 非以上状态。\n\n# 独占锁的获取和释放\n\n# 获取独占锁\n\nAQS 中使用 acquire(int arg) 方法获取独占锁，其大致流程如下：\n\n 1. 先尝试获取同步状态，如果获取同步状态成功，则结束方法，直接返回。\n 2. 如果获取同步状态不成功，AQS 会不断尝试利用 CAS 操作将当前线程插入等待同步队列的队尾，直到成功为止。\n 3. 接着，不断尝试为等待队列中的线程节点获取独占锁。\n\n\n\n\n\n详细流程可以用下图来表示，请结合源码来理解（一图胜千言）：\n\n\n\n# 释放独占锁\n\nAQS 中使用 release(int arg) 方法释放独占锁，其大致流程如下：\n\n 1. 先尝试获取解锁线程的同步状态，如果获取同步状态不成功，则结束方法，直接返回。\n 2. 如果获取同步状态成功，AQS 会尝试唤醒当前线程节点的后继节点。\n\n# 获取可中断的独占锁\n\nAQS 中使用 acquireInterruptibly(int arg) 方法获取可中断的独占锁。\n\nacquireInterruptibly(int arg) 实现方式相较于获取独占锁方法（ acquire）非常相似，区别仅在于它会通过 Thread.interrupted 检测当前线程是否被中断，如果是，则立即抛出中断异常（InterruptedException）。\n\n# 获取超时等待式的独占锁\n\nAQS 中使用 tryAcquireNanos(int arg) 方法获取超时等待的独占锁。\n\ndoAcquireNanos 的实现方式 相较于获取独占锁方法（ acquire）非常相似，区别在于它会根据超时时间和当前时间计算出截止时间。在获取锁的流程中，会不断判断是否超时，如果超时，直接返回 false；如果没超时，则用 LockSupport.parkNanos 来阻塞当前线程。\n\n# 共享锁的获取和释放\n\n# 获取共享锁\n\nAQS 中使用 acquireShared(int arg) 方法获取共享锁。\n\nacquireShared 方法和 acquire 方法的逻辑很相似，区别仅在于自旋的条件以及节点出队的操作有所不同。\n\n成功获得共享锁的条件如下：\n\n * tryAcquireShared(arg) 返回值大于等于 0 （这意味着共享锁的 permit 还没有用完）。\n * 当前节点的前驱节点是头结点。\n\n# 释放共享锁\n\nAQS 中使用 releaseShared(int arg) 方法释放共享锁。\n\nreleaseShared 首先会尝试释放同步状态，如果成功，则解锁一个或多个后继线程节点。释放共享锁和释放独享锁流程大体相似，区别在于：\n\n对于独享模式，如果需要 SIGNAL，释放仅相当于调用头节点的 unparkSuccessor。\n\n# 获取可中断的共享锁\n\nAQS 中使用 acquireSharedInterruptibly(int arg) 方法获取可中断的共享锁。\n\nacquireSharedInterruptibly 方法与 acquireInterruptibly 几乎一致，不再赘述。\n\n# 获取超时等待式的共享锁\n\nAQS 中使用 tryAcquireSharedNanos(int arg) 方法获取超时等待式的共享锁。\n\ntryAcquireSharedNanos 方法与 tryAcquireNanos 几乎一致，不再赘述。\n\n\n# 死锁\n\n\n# 什么是死锁\n\n死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也 可能出现死锁。通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。\n\n\n# 如何定位死锁\n\n定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。\n\n如果我们是开发自己的管理工具，需要用更加程序化的方式扫描服务进程、定位死锁，可以考虑使用 Java 提供的标准管理 API，ThreadMXBean，其直接就提供了 findDeadlockedThreads() 方法用于定位。\n\n\n# 如何避免死锁\n\n基本上死锁的发生是因为：\n\n * 互斥，类似 Java 中 Monitor 都是独占的。\n * 长期保持互斥，在使用结束之前，不会释放，也不能被其他线程抢占。\n * 循环依赖，多个个体之间出现了锁的循环依赖，彼此依赖上一环释放锁。\n\n由此，我们可以分析出避免死锁的思路和方法。\n\n（1）避免一个线程同时获取多个锁。\n\n避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。\n\n尝试使用定时锁 lock.tryLock(timeout)，避免锁一直不能释放。\n\n对于数据库锁，加锁和解锁必须在一个数据库连接中里，否则会出现解锁失败的情况。\n\n\n# 参考资料\n\n * 《Java 并发编程实战》\n * 《Java 并发编程的艺术》\n * Java 并发编程：Lock\n * 深入学习 java 同步器 AQS\n * AbstractQueuedSynchronizer 框架\n * Java 中的锁分类',normalizedContent:'# 深入理解 java 并发锁\n\n> 本文先阐述 java 中各种锁的概念。\n> \n> 然后，介绍锁的核心实现 aqs。\n> \n> 然后，重点介绍 lock 和 condition 两个接口及其实现。并发编程有两个核心问题：同步和互斥。\n> \n> 互斥，即同一时刻只允许一个线程访问共享资源；\n> \n> 同步，即线程之间如何通信、协作。\n> \n> 这两大问题，管程（sychronized）都是能够解决的。j.u.c 包还提供了 lock 和 condition 两个接口来实现管程，其中 lock 用于解决互斥问题，condition 用于解决同步问题。\n\n\n# 并发锁简介\n\n确保线程安全最常见的做法是利用锁机制（lock、sychronized）来对共享数据做互斥同步，这样在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，那么操作必然是原子性的，线程安全的。\n\n在工作、面试中，经常会听到各种五花八门的锁，听的人云里雾里。锁的概念术语很多，它们是针对不同的问题所提出的，通过简单的梳理，也不难理解。\n\n\n# 可重入锁\n\n可重入锁，顾名思义，指的是线程可以重复获取同一把锁。即同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁。\n\n可重入锁可以在一定程度上避免死锁。\n\n * reentrantlock 、reentrantreadwritelock 是可重入锁。这点，从其命名也不难看出。\n * synchronized 也是一个可重入锁。\n\n【示例】synchronized 的可重入示例\n\nsynchronized void seta() throws exception{\n    thread.sleep(1000);\n    setb();\n}\n\nsynchronized void setb() throws exception{\n    thread.sleep(1000);\n}\n\n\n上面的代码就是一个典型场景：如果使用的锁不是可重入锁的话，setb 可能不会被当前线程执行，从而造成死锁。\n\n【示例】reentrantlock 的可重入示例\n\nclass task {\n\n    private int value;\n    private final lock lock = new reentrantlock();\n\n    public task() {\n        this.value = 0;\n    }\n\n    public int get() {\n        // 获取锁\n        lock.lock();\n        try {\n            return value;\n        } finally {\n            // 保证锁能释放\n            lock.unlock();\n        }\n    }\n\n    public void addone() {\n        // 获取锁\n        lock.lock();\n        try {\n            // 注意：此处已经成功获取锁，进入 get 方法后，又尝试获取锁，\n            // 如果锁不是可重入的，会导致死锁\n            value = 1 + get();\n        } finally {\n            // 保证锁能释放\n            lock.unlock();\n        }\n    }\n\n}\n\n\n\n# 公平锁与非公平锁\n\n * 公平锁 - 公平锁是指 多线程按照申请锁的顺序来获取锁。\n * 非公平锁 - 非公平锁是指 多线程不按照申请锁的顺序来获取锁 。这就可能会出现优先级反转（后来者居上）或者饥饿现象（某线程总是抢不过别的线程，导致始终无法执行）。\n\n公平锁为了保证线程申请顺序，势必要付出一定的性能代价，因此其吞吐量一般低于非公平锁。\n\n公平锁与非公平锁 在 java 中的典型实现：\n\n * synchronized 只支持非公平锁。\n * reentrantlock 、reentrantreadwritelock，默认是非公平锁，但支持公平锁。\n\n\n# 独享锁与共享锁\n\n独享锁与共享锁是一种广义上的说法，从实际用途上来看，也常被称为互斥锁与读写锁。\n\n * 独享锁 - 独享锁是指 锁一次只能被一个线程所持有。\n * 共享锁 - 共享锁是指 锁可被多个线程所持有。\n\n独享锁与共享锁在 java 中的典型实现：\n\n * synchronized 、reentrantlock 只支持独享锁。\n * reentrantreadwritelock 其写锁是独享锁，其读锁是共享锁。读锁是共享锁使得并发读是非常高效的，读写，写读 ，写写的过程是互斥的。\n\n\n# 悲观锁与乐观锁\n\n乐观锁与悲观锁不是指具体的什么类型的锁，而是处理并发同步的策略。\n\n * 悲观锁 - 悲观锁对于并发采取悲观的态度，认为：不加锁的并发操作一定会出问题。悲观锁适合写操作频繁的场景。\n * 乐观锁 - 乐观锁对于并发采取乐观的态度，认为：不加锁的并发操作也没什么问题。对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用不断尝试更新的方式更新数据。乐观锁适合读多写少的场景。\n\n悲观锁与乐观锁在 java 中的典型实现：\n\n * 悲观锁在 java 中的应用就是通过使用 synchronized 和 lock 显示加锁来进行互斥同步，这是一种阻塞同步。\n\n * 乐观锁在 java 中的应用就是采用 cas 机制（cas 操作通过 unsafe 类提供，但这个类不直接暴露为 api，所以都是间接使用，如各种原子类）。\n\n\n# 偏向锁、轻量级锁、重量级锁\n\n所谓轻量级锁与重量级锁，指的是锁控制粒度的粗细。显然，控制粒度越细，阻塞开销越小，并发性也就越高。\n\njava 1.6 以前，重量级锁一般指的是 synchronized ，而轻量级锁指的是 volatile。\n\njava 1.6 以后，针对 synchronized 做了大量优化，引入 4 种锁状态： 无锁状态、偏向锁、轻量级锁和重量级锁。锁可以单向的从偏向锁升级到轻量级锁，再从轻量级锁升级到重量级锁 。\n\n * 偏向锁 - 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。\n\n * 轻量级锁 - 是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。\n\n * 重量级锁 - 是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。\n\n\n# 分段锁\n\n分段锁其实是一种锁的设计，并不是具体的一种锁。所谓分段锁，就是把锁的对象分成多段，每段独立控制，使得锁粒度更细，减少阻塞开销，从而提高并发性。这其实很好理解，就像高速公路上的收费站，如果只有一个收费口，那所有的车只能排成一条队缴费；如果有多个收费口，就可以分流了。\n\nhashtable 使用 synchronized 修饰方法来保证线程安全性，那么面对线程的访问，hashtable 就会锁住整个对象，所有的其它线程只能等待，这种阻塞方式的吞吐量显然很低。\n\njava 1.7 以前的 concurrenthashmap 就是分段锁的典型案例。concurrenthashmap 维护了一个 segment 数组，一般称为分段桶。\n\nfinal segment<k,v>[] segments;\n\n\n当有线程访问 concurrenthashmap 的数据时，concurrenthashmap 会先根据 hashcode 计算出数据在哪个桶（即哪个 segment），然后锁住这个 segment。\n\n\n# 显示锁和内置锁\n\njava 1.5 之前，协调对共享对象的访问时可以使用的机制只有 synchronized 和 volatile。这两个都属于内置锁，即锁的申请和释放都是由 jvm 所控制。\n\njava 1.5 之后，增加了新的机制：reentrantlock、reentrantreadwritelock ，这类锁的申请和释放都可以由程序所控制，所以常被称为显示锁。\n\n> 💡 synchronized 的用法和原理可以参考：java 并发基础机制 - synchronized 。\n> \n> 🔔 注意：如果不需要 reentrantlock、reentrantreadwritelock 所提供的高级同步特性，应该优先考虑使用 synchronized 。理由如下：\n> \n>  * java 1.6 以后，synchronized 做了大量的优化，其性能已经与 reentrantlock、reentrantreadwritelock 基本上持平。\n>  * 从趋势来看，java 未来更可能会优化 synchronized ，而不是 reentrantlock、reentrantreadwritelock ，因为 synchronized 是 jvm 内置属性，它能执行一些优化。\n>  * reentrantlock、reentrantreadwritelock 申请和释放锁都是由程序控制，如果使用不当，可能造成死锁，这是很危险的。\n\n以下对比一下显示锁和内置锁的差异：\n\n * 主动获取锁和释放锁\n   * synchronized 不能主动获取锁和释放锁。获取锁和释放锁都是 jvm 控制的。\n   * reentrantlock 可以主动获取锁和释放锁。（如果忘记释放锁，就可能产生死锁）。\n * 响应中断\n   * synchronized 不能响应中断。\n   * reentrantlock 可以响应中断。\n * 超时机制\n   * synchronized 没有超时机制。\n   * reentrantlock 有超时机制。reentrantlock 可以设置超时时间，超时后自动释放锁，避免一直等待。\n * 支持公平锁\n   * synchronized 只支持非公平锁。\n   * reentrantlock 支持非公平锁和公平锁。\n * 是否支持共享\n   * 被 synchronized 修饰的方法或代码块，只能被一个线程访问（独享）。如果这个线程被阻塞，其他线程也只能等待\n   * reentrantlock 可以基于 condition 灵活的控制同步条件。\n * 是否支持读写分离\n   * synchronized 不支持读写锁分离；\n   * reentrantreadwritelock 支持读写锁，从而使阻塞读写的操作分开，有效提高并发性。\n\n\n# lock 和 condition\n\n\n# 为何引入 lock 和 condition\n\n并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。这两大问题，管程都是能够解决的。java sdk 并发包通过 lock 和 condition 两个接口来实现管程，其中 lock 用于解决互斥问题，condition 用于解决同步问题。\n\nsynchronized 是管程的一种实现，既然如此，何必再提供 lock 和 condition。\n\njdk 1.6 以前，synchronized 还没有做优化，性能远低于 lock。但是，性能不是引入 lock 的最重要因素。真正关键在于：synchronized 使用不当，可能会出现死锁。\n\nsynchronized 无法通过破坏不可抢占条件来避免死锁。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。\n\n与内置锁 synchronized 不同的是，lock 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作，所有获取锁、释放锁的操作都是显式的操作。\n\n * 能够响应中断。synchronized 的问题是，持有锁 a 后，如果尝试获取锁 b 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 a。这样就破坏了不可抢占条件了。\n * 支持超时。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。\n * 非阻塞地获取锁。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。\n\n\n# lock 接口\n\nlock 的接口定义如下：\n\npublic interface lock {\n    void lock();\n    void lockinterruptibly() throws interruptedexception;\n    boolean trylock();\n    boolean trylock(long time, timeunit unit) throws interruptedexception;\n    void unlock();\n    condition newcondition();\n}\n\n\n * lock() - 获取锁。\n * unlock() - 释放锁。\n * trylock() - 尝试获取锁，仅在调用时锁未被另一个线程持有的情况下，才获取该锁。\n * trylock(long time, timeunit unit) - 和 trylock() 类似，区别仅在于限定时间，如果限定时间内未获取到锁，视为失败。\n * lockinterruptibly() - 锁未被另一个线程持有，且线程没有被中断的情况下，才能获取锁。\n * newcondition() - 返回一个绑定到 lock 对象上的 condition 实例。\n\n\n# condition\n\ncondition 实现了管程模型里面的条件变量。\n\n前文中提过 lock 接口中 有一个 newcondition() 方法用于返回一个绑定到 lock 对象上的 condition 实例。condition 是什么？有什么作用？本节将一一讲解。\n\n在单线程中，一段代码的执行可能依赖于某个状态，如果不满足状态条件，代码就不会被执行（典型的场景，如：if ... else ...）。在并发环境中，当一个线程判断某个状态条件时，其状态可能是由于其他线程的操作而改变，这时就需要有一定的协调机制来确保在同一时刻，数据只能被一个线程锁修改，且修改的数据状态被所有线程所感知。\n\njava 1.5 之前，主要是利用 object 类中的 wait、notify、notifyall 配合 synchronized 来进行线程间通信（如果不了解其特性，可以参考：java 线程基础 - wait/notify/notifyall）。\n\nwait、notify、notifyall 需要配合 synchronized 使用，不适用于 lock。而使用 lock 的线程，彼此间通信应该使用 condition 。这可以理解为，什么样的锁配什么样的钥匙。内置锁（synchronized）配合内置条件队列（wait、notify、notifyall ），显式锁（lock）配合显式条件队列（condition ）。\n\n# condition 的特性\n\ncondition 接口定义如下：\n\npublic interface condition {\n    void await() throws interruptedexception;\n    void awaituninterruptibly();\n    long awaitnanos(long nanostimeout) throws interruptedexception;\n    boolean await(long time, timeunit unit) throws interruptedexception;\n    boolean awaituntil(date deadline) throws interruptedexception;\n    void signal();\n    void signalall();\n}\n\n\n其中，await、signal、signalall 与 wait、notify、notifyall 相对应，功能也相似。除此以外，condition 相比内置条件队列（ wait、notify、notifyall ），提供了更为丰富的功能：\n\n * 每个锁（lock）上可以存在多个 condition，这意味着锁的状态条件可以有多个。\n * 支持公平的或非公平的队列操作。\n * 支持可中断的条件等待，相关方法：awaituninterruptibly() 。\n * 支持可定时的等待，相关方法：awaitnanos(long) 、await(long, timeunit)、awaituntil(date)。\n\n# condition 的用法\n\n这里以 condition 来实现一个消费者、生产者模式。\n\n> 🔔 注意：事实上，解决此类问题使用 countdownlatch、semaphore 等工具更为便捷、安全。想了解详情，可以参考 java 并发工具类 。\n\n产品类\n\nclass message {\n\n    private final lock lock = new reentrantlock();\n\n    private final condition producedmsg = lock.newcondition();\n\n    private final condition consumedmsg = lock.newcondition();\n\n    private string message;\n\n    private boolean state;\n\n    private boolean end;\n\n    public void consume() {\n        //lock\n        lock.lock();\n        try {\n            // no new message wait for new message\n            while (!state) { producedmsg.await(); }\n\n            system.out.println("consume message : " + message);\n            state = false;\n            // message consumed, notify waiting thread\n            consumedmsg.signal();\n        } catch (interruptedexception ie) {\n            system.out.println("thread interrupted - viewmessage");\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void produce(string message) {\n        lock.lock();\n        try {\n            // last message not consumed, wait for it be consumed\n            while (state) { consumedmsg.await(); }\n\n            system.out.println("produce msg: " + message);\n            this.message = message;\n            state = true;\n            // new message added, notify waiting thread\n            producedmsg.signal();\n        } catch (interruptedexception ie) {\n            system.out.println("thread interrupted - publishmessage");\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public boolean isend() {\n        return end;\n    }\n\n    public void setend(boolean end) {\n        this.end = end;\n    }\n\n}\n\n\n消费者\n\nclass messageconsumer implements runnable {\n\n    private message message;\n\n    public messageconsumer(message msg) {\n        message = msg;\n    }\n\n    @override\n    public void run() {\n        while (!message.isend()) { message.consume(); }\n    }\n\n}\n\n\n生产者\n\nclass messageproducer implements runnable {\n\n    private message message;\n\n    public messageproducer(message msg) {\n        message = msg;\n    }\n\n    @override\n    public void run() {\n        produce();\n    }\n\n    public void produce() {\n        list<string> msgs = new arraylist<>();\n        msgs.add("begin");\n        msgs.add("msg1");\n        msgs.add("msg2");\n\n        for (string msg : msgs) {\n            message.produce(msg);\n            try {\n                thread.sleep(100);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n\n        message.produce("end");\n        message.setend(true);\n    }\n\n}\n\n\n测试\n\npublic class lockconditiondemo {\n\n    public static void main(string[] args) {\n        message msg = new message();\n        thread producer = new thread(new messageproducer(msg));\n        thread consumer = new thread(new messageconsumer(msg));\n        producer.start();\n        consumer.start();\n    }\n}\n\n\n\n# reentrantlock\n\nreentrantlock 类是 lock 接口的具体实现，与内置锁 synchronized 相同的是，它是一个可重入锁。\n\n\n# reentrantlock 的特性\n\nreentrantlock 的特性如下：\n\n * reentrantlock 提供了与 synchronized 相同的互斥性、内存可见性和可重入性。\n * reentrantlock 支持公平锁和非公平锁（默认）两种模式。\n * reentrantlock 实现了 lock 接口，支持了 synchronized 所不具备的灵活性。\n   * synchronized 无法中断一个正在等待获取锁的线程\n   * synchronized 无法在请求获取一个锁时无休止地等待\n\n\n# reentrantlock 的用法\n\n前文了解了 reentrantlock 的特性，接下来，我们要讲述其具体用法。\n\n# reentrantlock 的构造方法\n\nreentrantlock 有两个构造方法：\n\npublic reentrantlock() {}\npublic reentrantlock(boolean fair) {}\n\n\n * reentrantlock() - 默认构造方法会初始化一个非公平锁（nonfairsync）；\n * reentrantlock(boolean) - new reentrantlock(true) 会初始化一个公平锁（fairsync）。\n\n# lock 和 unlock 方法\n\n * lock() - 无条件获取锁。如果当前线程无法获取锁，则当前线程进入休眠状态不可用，直至当前线程获取到锁。如果该锁没有被另一个线程持有，则获取该锁并立即返回，将锁的持有计数设置为 1。\n * unlock() - 用于释放锁。\n\n> 🔔 注意：请务必牢记，获取锁操作 lock() 必须在 try catch 块中进行，并且将释放锁操作 unlock() 放在 finally 块中进行，以保证锁一定被被释放，防止死锁的发生。\n\n示例：reentrantlock 的基本操作\n\npublic class reentrantlockdemo {\n\n    public static void main(string[] args) {\n        task task = new task();\n        mythread ta = new mythread("thread-a", task);\n        mythread tb = new mythread("thread-b", task);\n        mythread tc = new mythread("thread-c", task);\n        ta.start();\n        tb.start();\n        tc.start();\n    }\n\n    static class mythread extends thread {\n\n        private task task;\n\n        public mythread(string name, task task) {\n            super(name);\n            this.task = task;\n        }\n\n        @override\n        public void run() {\n            task.execute();\n        }\n\n    }\n\n    static class task {\n\n        private reentrantlock lock = new reentrantlock();\n\n        public void execute() {\n            lock.lock();\n            try {\n                for (int i = 0; i < 3; i++) {\n                    system.out.println(lock.tostring());\n\n                    // 查询当前线程 hold 住此锁的次数\n                    system.out.println("\\t holdcount: " + lock.getholdcount());\n\n                    // 查询正等待获取此锁的线程数\n                    system.out.println("\\t queuedlength: " + lock.getqueuelength());\n\n                    // 是否为公平锁\n                    system.out.println("\\t isfair: " + lock.isfair());\n\n                    // 是否被锁住\n                    system.out.println("\\t islocked: " + lock.islocked());\n\n                    // 是否被当前线程持有锁\n                    system.out.println("\\t isheldbycurrentthread: " + lock.isheldbycurrentthread());\n\n                    try {\n                        thread.sleep(500);\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                }\n            } finally {\n                lock.unlock();\n            }\n        }\n\n    }\n\n}\n\n\n输出结果：\n\njava.util.concurrent.locks.reentrantlock@64fcd88a[locked by thread thread-a]\n\t holdcount: 1\n\t queuedlength: 2\n\t isfair: false\n\t islocked: true\n\t isheldbycurrentthread: true\njava.util.concurrent.locks.reentrantlock@64fcd88a[locked by thread thread-c]\n\t holdcount: 1\n\t queuedlength: 1\n\t isfair: false\n\t islocked: true\n\t isheldbycurrentthread: true\n// ...\n\n\n# trylock 方法\n\n与无条件获取锁相比，trylock 有更完善的容错机制。\n\n * trylock() - 可轮询获取锁。如果成功，则返回 true；如果失败，则返回 false。也就是说，这个方法无论成败都会立即返回，获取不到锁（锁已被其他线程获取）时不会一直等待。\n * trylock(long, timeunit) - 可定时获取锁。和 trylock() 类似，区别仅在于这个方法在获取不到锁时会等待一定的时间，在时间期限之内如果还获取不到锁，就返回 false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回 true。\n\n示例：reentrantlock 的 trylock() 操作\n\n修改上个示例中的 execute() 方法\n\npublic void execute() {\n    if (lock.trylock()) {\n        try {\n            for (int i = 0; i < 3; i++) {\n               // 略...\n            }\n        } finally {\n            lock.unlock();\n        }\n    } else {\n        system.out.println(thread.currentthread().getname() + " 获取锁失败");\n    }\n}\n\n\n示例：reentrantlock 的 trylock(long, timeunit) 操作\n\n修改上个示例中的 execute() 方法\n\npublic void execute() {\n    try {\n        if (lock.trylock(2, timeunit.seconds)) {\n            try {\n                for (int i = 0; i < 3; i++) {\n                    // 略...\n                }\n            } finally {\n                lock.unlock();\n            }\n        } else {\n            system.out.println(thread.currentthread().getname() + " 获取锁失败");\n        }\n    } catch (interruptedexception e) {\n        system.out.println(thread.currentthread().getname() + " 获取锁超时");\n        e.printstacktrace();\n    }\n}\n\n\n# lockinterruptibly 方法\n\n * lockinterruptibly() - 可中断获取锁。可中断获取锁可以在获得锁的同时保持对中断的响应。可中断获取锁比其它获取锁的方式稍微复杂一些，需要两个 try-catch 块（如果在获取锁的操作中抛出了 interruptedexception ，那么可以使用标准的 try-finally 加锁模式）。\n   * 举例来说：假设有两个线程同时通过 lock.lockinterruptibly() 获取某个锁时，若线程 a 获取到了锁，则线程 b 只能等待。若此时对线程 b 调用 threadb.interrupt() 方法能够中断线程 b 的等待过程。由于 lockinterruptibly() 的声明中抛出了异常，所以 lock.lockinterruptibly() 必须放在 try 块中或者在调用 lockinterruptibly() 的方法外声明抛出 interruptedexception。\n\n> 🔔 注意：当一个线程获取了锁之后，是不会被 interrupt() 方法中断的。单独调用 interrupt() 方法不能中断正在运行状态中的线程，只能中断阻塞状态中的线程。因此当通过 lockinterruptibly() 方法获取某个锁时，如果未获取到锁，只有在等待的状态下，才可以响应中断。\n\n示例：reentrantlock 的 lockinterruptibly() 操作\n\n修改上个示例中的 execute() 方法\n\npublic void execute() {\n    try {\n        lock.lockinterruptibly();\n\n        for (int i = 0; i < 3; i++) {\n            // 略...\n        }\n    } catch (interruptedexception e) {\n        system.out.println(thread.currentthread().getname() + "被中断");\n        e.printstacktrace();\n    } finally {\n        lock.unlock();\n    }\n}\n\n\n# newcondition 方法\n\nnewcondition() - 返回一个绑定到 lock 对象上的 condition 实例。condition 的特性和具体方法请阅读下文 condition。\n\n\n# reentrantlock 的原理\n\n# reentrantlock 的可见性\n\nclass x {\n  private final lock rtl =\n  new reentrantlock();\n  int value;\n  public void addone() {\n    // 获取锁\n    rtl.lock();\n    try {\n      value+=1;\n    } finally {\n      // 保证锁能释放\n      rtl.unlock();\n    }\n  }\n}\n\n\nreentrantlock，内部持有一个 volatile 的成员变量 state，获取锁的时候，会读写 state 的值；解锁的时候，也会读写 state 的值（简化后的代码如下面所示）。也就是说，在执行 value+=1 之前，程序先读写了一次 volatile 变量 state，在执行 value+=1 之后，又读写了一次 volatile 变量 state。根据相关的 happens-before 规则：\n\n 1. 顺序性规则：对于线程 t1，value+=1 happens-before 释放锁的操作 unlock()；\n 2. volatile 变量规则：由于 state = 1 会先读取 state，所以线程 t1 的 unlock() 操作 happens-before 线程 t2 的 lock() 操作；\n 3. 传递性规则：线程 t1 的 value+=1 happens-before 线程 t2 的 lock() 操作。\n\n# reentrantlock 的数据结构\n\n阅读 reentrantlock 的源码，可以发现它有一个核心字段：\n\nprivate final sync sync;\n\n\n * sync - 内部抽象类 reentrantlock.sync 对象，sync 继承自 aqs。它有两个子类：\n * reentrantlock.fairsync - 公平锁。\n * reentrantlock.nonfairsync - 非公平锁。\n\n查看源码可以发现，reentrantlock 实现 lock 接口其实是调用 reentrantlock.fairsync 或 reentrantlock.nonfairsync 中各自的实现，这里不一一列举。\n\n# reentrantlock 的获取锁和释放锁\n\nreentrantlock 获取锁和释放锁的接口，从表象看，是调用 reentrantlock.fairsync 或 reentrantlock.nonfairsync 中各自的实现；从本质上看，是基于 aqs 的实现。\n\n仔细阅读源码很容易发现：\n\n * void lock() 调用 sync 的 lock() 方法。\n\n * void lockinterruptibly() 直接调用 aqs 的 获取可中断的独占锁 方法 lockinterruptibly()。\n\n * boolean trylock() 调用 sync 的 nonfairtryacquire() 。\n\n * boolean trylock(long time, timeunit unit) 直接调用 aqs 的 获取超时等待式的独占锁 方法 tryacquirenanos(int arg, long nanostimeout)。\n\n * void unlock() 直接调用 aqs 的 释放独占锁 方法 release(int arg) 。\n\n直接调用 aqs 接口的方法就不再赘述了，其原理在 [aqs 的原理](#aqs 的原理) 中已经用很大篇幅进行过讲解。\n\nnonfairtryacquire 方法源码如下：\n\n// 公平锁和非公平锁都会用这个方法区尝试获取锁\nfinal boolean nonfairtryacquire(int acquires) {\n    final thread current = thread.currentthread();\n    int c = getstate();\n    if (c == 0) {\n        if (compareandsetstate(0, acquires)) {\n         // 如果同步状态为0，将其设为 acquires，并设置当前线程为排它线程\n            setexclusiveownerthread(current);\n            return true;\n        }\n    }\n    else if (current == getexclusiveownerthread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new error("maximum lock count exceeded");\n        setstate(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n处理流程很简单：\n\n * 如果同步状态为 0，设置同步状态设为 acquires，并设置当前线程为排它线程，然后返回 true，获取锁成功。\n * 如果同步状态不为 0 且当前线程为排它线程，设置同步状态为当前状态值+acquires 值，然后返回 true，获取锁成功。\n * 否则，返回 false，获取锁失败。\n\n# 公平锁和非公平锁\n\nreentrantlock 这个类有两个构造函数，一个是无参构造函数，一个是传入 fair 参数的构造函数。fair 参数代表的是锁的公平策略，如果传入 true 就表示需要构造一个公平锁，反之则表示要构造一个非公平锁。\n\n锁都对应着一个等待队列，如果一个线程没有获得锁，就会进入等待队列，当有线程释放锁的时候，就需要从等待队列中唤醒一个等待的线程。如果是公平锁，唤醒的策略就是谁等待的时间长，就唤醒谁，很公平；如果是非公平锁，则不提供这个公平保证，有可能等待时间短的线程反而先被唤醒。\n\nlock 方法在公平锁和非公平锁中的实现：\n\n二者的区别仅在于申请非公平锁时，如果同步状态为 0，尝试将其设为 1，如果成功，直接将当前线程置为排它线程；否则和公平锁一样，调用 aqs 获取独占锁方法 acquire。\n\n// 非公平锁实现\nfinal void lock() {\n    if (compareandsetstate(0, 1))\n    // 如果同步状态为0，将其设为1，并设置当前线程为排它线程\n        setexclusiveownerthread(thread.currentthread());\n    else\n    // 调用 aqs 获取独占锁方法 acquire\n        acquire(1);\n}\n\n// 公平锁实现\nfinal void lock() {\n    // 调用 aqs 获取独占锁方法 acquire\n    acquire(1);\n}\n\n\n\n# reentrantreadwritelock\n\nreadwritelock 适用于读多写少的场景。\n\nreentrantreadwritelock 类是 readwritelock 接口的具体实现，它是一个可重入的读写锁。reentrantreadwritelock 维护了一对读写锁，将读写锁分开，有利于提高并发效率。\n\n读写锁，并不是 java 语言特有的，而是一个广为使用的通用技术，所有的读写锁都遵守以下三条基本原则：\n\n * 允许多个线程同时读共享变量；\n * 只允许一个线程写共享变量；\n * 如果一个写线程正在执行写操作，此时禁止读线程读共享变量。\n\n读写锁与互斥锁的一个重要区别就是读写锁允许多个线程同时读共享变量，而互斥锁是不允许的，这是读写锁在读多写少场景下性能优于互斥锁的关键。但读写锁的写操作是互斥的，当一个线程在写共享变量的时候，是不允许其他线程执行写操作和读操作。\n\n\n# reentrantreadwritelock 的特性\n\nreentrantreadwritelock 的特性如下：\n\n * reentrantreadwritelock 适用于读多写少的场景。如果是写多读少的场景，由于 reentrantreadwritelock 其内部实现比 reentrantlock 复杂，性能可能反而要差一些。如果存在这样的问题，需要具体问题具体分析。由于 reentrantreadwritelock 的读写锁（readlock、writelock）都实现了 lock 接口，所以要替换为 reentrantlock 也较为容易。\n * reentrantreadwritelock 实现了 readwritelock 接口，支持了 reentrantlock 所不具备的读写锁分离。reentrantreadwritelock 维护了一对读写锁（readlock、writelock）。将读写锁分开，有利于提高并发效率。reentrantreadwritelock 的加锁策略是：允许多个读操作并发执行，但每次只允许一个写操作。\n * reentrantreadwritelock 为读写锁都提供了可重入的加锁语义。\n * reentrantreadwritelock 支持公平锁和非公平锁（默认）两种模式。\n\nreadwritelock 接口定义如下：\n\npublic interface readwritelock {\n    lock readlock();\n    lock writelock();\n}\n\n\n * readlock - 返回用于读操作的锁（readlock）。\n * writelock - 返回用于写操作的锁（writelock）。\n\n在读写锁和写入锁之间的交互可以采用多种实现方式，readwritelock 的一些可选实现包括：\n\n * 释放优先 - 当一个写入操作释放写锁，并且队列中同时存在读线程和写线程，那么应该优先选择读线程、写线程，还是最先发出请求的线程？\n * 读线程插队 - 如果锁是由读线程持有，但有写线程正在等待，那么新到达的读线程能否立即获得访问权，还是应该在写线程后面等待？如果允许读线程插队到写线程之前，那么将提高并发性，但可能造成线程饥饿问题。\n * 重入性 - 读锁和写锁是否是可重入的？\n * 降级 - 如果一个线程持有写入锁，那么它能否在不释放该锁的情况下获得读锁？这可能会使得写锁被降级为读锁，同时不允许其他写线程修改被保护的资源。\n * 升级 - 读锁能否优先于其他正在等待的读线程和写线程而升级为一个写锁？在大多数的读写锁实现中并不支持升级，因为如果没有显式的升级操作，那么很容易造成死锁。\n\n\n# reentrantreadwritelock 的用法\n\n前文了解了 reentrantreadwritelock 的特性，接下来，我们要讲述其具体用法。\n\n# reentrantreadwritelock 的构造方法\n\nreentrantreadwritelock 和 reentrantlock 一样，也有两个构造方法，且用法相似。\n\npublic reentrantreadwritelock() {}\npublic reentrantreadwritelock(boolean fair) {}\n\n\n * reentrantreadwritelock() - 默认构造方法会初始化一个非公平锁（nonfairsync）。在非公平的锁中，线程获得锁的顺序是不确定的。写线程降级为读线程是可以的，但读线程升级为写线程是不可以的（这样会导致死锁）。\n * reentrantreadwritelock(boolean) - new reentrantlock(true) 会初始化一个公平锁（fairsync）。对于公平锁，等待时间最长的线程将优先获得锁。如果这个锁是读线程持有，则另一个线程请求写锁，那么其他读线程都不能获得读锁，直到写线程释放写锁。\n\n# reentrantreadwritelock 的使用实例\n\n在 reentrantreadwritelock 的特性 中已经介绍过，reentrantreadwritelock 的读写锁（readlock、writelock）都实现了 lock 接口，所以其各自独立的使用方式与 reentrantlock 一样，这里不再赘述。\n\nreentrantreadwritelock 与 reentrantlock 用法上的差异，主要在于读写锁的配合使用。本文以一个典型使用场景来进行讲解。\n\n【示例】基于 readwritelock 实现一个简单的泛型无界缓存\n\n/**\n * 简单的无界缓存实现\n * <p>\n * 使用 weakhashmap 存储键值对。weakhashmap 中存储的对象是弱引用，jvm gc 时会自动清除没有被引用的弱引用对象。\n */\nstatic class unboundedcache<k, v> {\n\n    private final map<k, v> cachemap = new weakhashmap<>();\n\n    private final readwritelock cachelock = new reentrantreadwritelock();\n\n    public v get(k key) {\n        cachelock.readlock().lock();\n        v value;\n        try {\n            value = cachemap.get(key);\n            string log = string.format("%s 读数据 %s:%s", thread.currentthread().getname(), key, value);\n            system.out.println(log);\n        } finally {\n            cachelock.readlock().unlock();\n        }\n        return value;\n    }\n\n    public v put(k key, v value) {\n        cachelock.writelock().lock();\n        try {\n            cachemap.put(key, value);\n            string log = string.format("%s 写入数据 %s:%s", thread.currentthread().getname(), key, value);\n            system.out.println(log);\n        } finally {\n            cachelock.writelock().unlock();\n        }\n        return value;\n    }\n\n    public v remove(k key) {\n        cachelock.writelock().lock();\n        try {\n            return cachemap.remove(key);\n        } finally {\n            cachelock.writelock().unlock();\n        }\n    }\n\n    public void clear() {\n        cachelock.writelock().lock();\n        try {\n            this.cachemap.clear();\n        } finally {\n            cachelock.writelock().unlock();\n        }\n    }\n\n}\n\n\n说明：\n\n * 使用 weakhashmap 而不是 hashmap 来存储键值对。weakhashmap 中存储的对象是弱引用，jvm gc 时会自动清除没有被引用的弱引用对象。\n * 向 map 写数据前加写锁，写完后，释放写锁。\n * 向 map 读数据前加读锁，读完后，释放读锁。\n\n测试其线程安全性：\n\n/**\n * @author <a href="mailto:forbreak@163.com">zhang peng</a>\n * @since 2020-01-01\n */\npublic class reentrantreadwritelockdemo {\n\n    static unboundedcache<integer, integer> cache = new unboundedcache<>();\n\n    public static void main(string[] args) {\n        executorservice executorservice = executors.newcachedthreadpool();\n        for (int i = 0; i < 20; i++) {\n            executorservice.execute(new mythread());\n            cache.get(0);\n        }\n        executorservice.shutdown();\n    }\n\n    /** 线程任务每次向缓存中写入 3 个随机值，key 固定 */\n    static class mythread implements runnable {\n\n        @override\n        public void run() {\n            random random = new random();\n            for (int i = 0; i < 3; i++) {\n                cache.put(i, random.nextint(100));\n            }\n        }\n\n    }\n\n}\n\n\n说明：示例中，通过线程池启动 20 个并发任务。任务每次向缓存中写入 3 个随机值，key 固定；然后主线程每次固定读取缓存中第一个 key 的值。\n\n输出结果：\n\nmain 读数据 0:null\npool-1-thread-1 写入数据 0:16\npool-1-thread-1 写入数据 1:58\npool-1-thread-1 写入数据 2:50\nmain 读数据 0:16\npool-1-thread-1 写入数据 0:85\npool-1-thread-1 写入数据 1:76\npool-1-thread-1 写入数据 2:46\npool-1-thread-2 写入数据 0:21\npool-1-thread-2 写入数据 1:41\npool-1-thread-2 写入数据 2:63\nmain 读数据 0:21\nmain 读数据 0:21\n// ...\n\n\n\n# reentrantreadwritelock 的原理\n\n前面了解了 reentrantlock 的原理，理解 reentrantreadwritelock 就容易多了。\n\n# reentrantreadwritelock 的数据结构\n\n阅读 reentrantreadwritelock 的源码，可以发现它有三个核心字段：\n\n/** inner class providing readlock */\nprivate final reentrantreadwritelock.readlock readerlock;\n/** inner class providing writelock */\nprivate final reentrantreadwritelock.writelock writerlock;\n/** performs all synchronization mechanics */\nfinal sync sync;\n\npublic reentrantreadwritelock.writelock writelock() { return writerlock; }\npublic reentrantreadwritelock.readlock  readlock()  { return readerlock; }\n\n\n * sync - 内部类 reentrantreadwritelock.sync 对象。与 reentrantlock 类似，它有两个子类：reentrantreadwritelock.fairsync 和 reentrantreadwritelock.nonfairsync ，分别表示公平锁和非公平锁的实现。\n * readerlock - 内部类 reentrantreadwritelock.readlock 对象，这是一把读锁。\n * writerlock - 内部类 reentrantreadwritelock.writelock 对象，这是一把写锁。\n\n# reentrantreadwritelock 的获取锁和释放锁\n\npublic static class readlock implements lock, java.io.serializable {\n\n    // 调用 aqs 获取共享锁方法\n    public void lock() {\n        sync.acquireshared(1);\n    }\n\n    // 调用 aqs 释放共享锁方法\n    public void unlock() {\n        sync.releaseshared(1);\n    }\n}\n\npublic static class writelock implements lock, java.io.serializable {\n\n    // 调用 aqs 获取独占锁方法\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    // 调用 aqs 释放独占锁方法\n    public void unlock() {\n        sync.release(1);\n    }\n}\n\n\n\n# stampedlock\n\nreadwritelock 支持两种模式：一种是读锁，一种是写锁。而 stampedlock 支持三种模式，分别是：写锁、悲观读锁和乐观读。其中，写锁、悲观读锁的语义和 readwritelock 的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。不同的是：stampedlock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。\n\n> 注意这里，用的是“乐观读”这个词，而不是“乐观读锁”，是要提醒你，乐观读这个操作是无锁的，所以相比较 readwritelock 的读锁，乐观读的性能更好一些。\n\nstampedlock 的性能之所以比 readwritelock 还要好，其关键是 stampedlock 支持乐观读的方式。\n\n * readwritelock 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；\n * 而 stampedlock 提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。\n\n对于读多写少的场景 stampedlock 性能很好，简单的应用场景基本上可以替代 readwritelock，但是stampedlock 的功能仅仅是 readwritelock 的子集，在使用的时候，还是有几个地方需要注意一下。\n\n * stampedlock 不支持重入\n * stampedlock 的悲观读锁、写锁都不支持条件变量。\n * 如果线程阻塞在 stampedlock 的 readlock() 或者 writelock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 cpu 飙升。使用 stampedlock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readlockinterruptibly() 和写锁 writelockinterruptibly()。\n\n【示例】stampedlock 阻塞时，调用 interrupt() 导致 cpu 飙升\n\nfinal stampedlock lock\n  = new stampedlock();\nthread t1 = new thread(()->{\n  // 获取写锁\n  lock.writelock();\n  // 永远阻塞在此处，不释放写锁\n  locksupport.park();\n});\nt1.start();\n// 保证 t1 获取写锁\nthread.sleep(100);\nthread t2 = new thread(()->\n  // 阻塞在悲观读锁\n  lock.readlock()\n);\nt2.start();\n// 保证 t2 阻塞在读锁\nthread.sleep(100);\n// 中断线程 t2\n// 会导致线程 t2 所在 cpu 飙升\nt2.interrupt();\nt2.join();\n\n\n【示例】stampedlock 读模板：\n\nfinal stampedlock sl =\n  new stampedlock();\n\n// 乐观读\nlong stamp =\n  sl.tryoptimisticread();\n// 读入方法局部变量\n......\n// 校验 stamp\nif (!sl.validate(stamp)){\n  // 升级为悲观读锁\n  stamp = sl.readlock();\n  try {\n    // 读入方法局部变量\n    .....\n  } finally {\n    // 释放悲观读锁\n    sl.unlockread(stamp);\n  }\n}\n// 使用方法局部变量执行业务操作\n......\n\n\n【示例】stampedlock 写模板：\n\nlong stamp = sl.writelock();\ntry {\n  // 写共享变量\n  ......\n} finally {\n  sl.unlockwrite(stamp);\n}\n\n\n\n# aqs\n\n> abstractqueuedsynchronizer（简称 aqs）是队列同步器，顾名思义，其主要作用是处理同步。它是并发锁和很多同步工具类的实现基石（如 reentrantlock、reentrantreadwritelock、countdownlatch、semaphore、futuretask 等）。\n\n\n# aqs 的要点\n\naqs 提供了对独享锁与共享锁的支持。\n\n在 java.util.concurrent.locks 包中的相关锁（常用的有 reentrantlock、 readwritelock）都是基于 aqs 来实现。这些锁都没有直接继承 aqs，而是定义了一个 sync 类去继承 aqs。为什么要这样呢？因为锁面向的是使用用户，而同步器面向的则是线程控制，那么在锁的实现中聚合同步器而不是直接继承 aqs 就可以很好的隔离二者所关注的事情。\n\n\n# aqs 的应用\n\naqs 提供了对独享锁与共享锁的支持。\n\n# 独享锁 api\n\n获取、释放独享锁的主要 api 如下：\n\npublic final void acquire(int arg)\npublic final void acquireinterruptibly(int arg)\npublic final boolean tryacquirenanos(int arg, long nanostimeout)\npublic final boolean release(int arg)\n\n\n * acquire - 获取独占锁。\n * acquireinterruptibly - 获取可中断的独占锁。\n * tryacquirenanos - 尝试在指定时间内获取可中断的独占锁。在以下三种情况下回返回：\n   * 在超时时间内，当前线程成功获取了锁；\n   * 当前线程在超时时间内被中断；\n   * 超时时间结束，仍未获得锁返回 false。\n * release - 释放独占锁。\n\n# 共享锁 api\n\n获取、释放共享锁的主要 api 如下：\n\npublic final void acquireshared(int arg)\npublic final void acquiresharedinterruptibly(int arg)\npublic final boolean tryacquiresharednanos(int arg, long nanostimeout)\npublic final boolean releaseshared(int arg)\n\n\n * acquireshared - 获取共享锁。\n * acquiresharedinterruptibly - 获取可中断的共享锁。\n * tryacquiresharednanos - 尝试在指定时间内获取可中断的共享锁。\n * release - 释放共享锁。\n\n\n# aqs 的原理\n\n> asq 原理要点：\n> \n>  * aqs 使用一个整型的 volatile 变量来 维护同步状态。状态的意义由子类赋予。\n>  * aqs 维护了一个 fifo 的双链表，用来存储获取锁失败的线程。\n> \n> aqs 围绕同步状态提供两种基本操作“获取”和“释放”，并提供一系列判断和处理方法，简单说几点：\n> \n>  * state 是独占的，还是共享的；\n>  * state 被获取后，其他线程需要等待；\n>  * state 被释放后，唤醒等待线程；\n>  * 线程等不及时，如何退出等待。\n> \n> 至于线程是否可以获得 state，如何释放 state，就不是 aqs 关心的了，要由子类具体实现。\n\n# aqs 的数据结构\n\n阅读 aqs 的源码，可以发现：aqs 继承自 abstractownablesynchronize。\n\npublic abstract class abstractqueuedsynchronizer\n    extends abstractownablesynchronizer\n    implements java.io.serializable {\n\n    /** 等待队列的队头，懒加载。只能通过 sethead 方法修改。 */\n    private transient volatile node head;\n    /** 等待队列的队尾，懒加载。只能通过 enq 方法添加新的等待节点。*/\n    private transient volatile node tail;\n    /** 同步状态 */\n    private volatile int state;\n}\n\n\n * state - aqs 使用一个整型的 volatile 变量来 维护同步状态。\n   * 这个整数状态的意义由子类来赋予，如reentrantlock 中该状态值表示所有者线程已经重复获取该锁的次数，semaphore 中该状态值表示剩余的许可数量。\n * head 和 tail - aqs 维护了一个 node 类型（aqs 的内部类）的双链表来完成同步状态的管理。这个双链表是一个双向的 fifo 队列，通过 head 和 tail 指针进行访问。当 有线程获取锁失败后，就被添加到队列末尾。\n\n\n\n再来看一下 node 的源码\n\nstatic final class node {\n    /** 该等待同步的节点处于共享模式 */\n    static final node shared = new node();\n    /** 该等待同步的节点处于独占模式 */\n    static final node exclusive = null;\n\n    /** 线程等待状态，状态值有: 0、1、-1、-2、-3 */\n    volatile int waitstatus;\n    static final int cancelled =  1;\n    static final int signal    = -1;\n    static final int condition = -2;\n    static final int propagate = -3;\n\n    /** 前驱节点 */\n    volatile node prev;\n    /** 后继节点 */\n    volatile node next;\n    /** 等待锁的线程 */\n    volatile thread thread;\n\n  \t/** 和节点是否共享有关 */\n    node nextwaiter;\n}\n\n\n很显然，node 是一个双链表结构。\n\n * waitstatus - node 使用一个整型的 volatile 变量来 维护 aqs 同步队列中线程节点的状态。waitstatus 有五个状态值：\n   * cancelled(1) - 此状态表示：该节点的线程可能由于超时或被中断而 处于被取消(作废)状态，一旦处于这个状态，表示这个节点应该从等待队列中移除。\n   * signal(-1) - 此状态表示：后继节点会被挂起，因此在当前节点释放锁或被取消之后，必须唤醒(unparking)其后继结点。\n   * condition(-2) - 此状态表示：该节点的线程 处于等待条件状态，不会被当作是同步队列上的节点，直到被唤醒(signal)，设置其值为 0，再重新进入阻塞状态。\n   * propagate(-3) - 此状态表示：下一个 acquireshared 应无条件传播。\n   * 0 - 非以上状态。\n\n# 独占锁的获取和释放\n\n# 获取独占锁\n\naqs 中使用 acquire(int arg) 方法获取独占锁，其大致流程如下：\n\n 1. 先尝试获取同步状态，如果获取同步状态成功，则结束方法，直接返回。\n 2. 如果获取同步状态不成功，aqs 会不断尝试利用 cas 操作将当前线程插入等待同步队列的队尾，直到成功为止。\n 3. 接着，不断尝试为等待队列中的线程节点获取独占锁。\n\n\n\n\n\n详细流程可以用下图来表示，请结合源码来理解（一图胜千言）：\n\n\n\n# 释放独占锁\n\naqs 中使用 release(int arg) 方法释放独占锁，其大致流程如下：\n\n 1. 先尝试获取解锁线程的同步状态，如果获取同步状态不成功，则结束方法，直接返回。\n 2. 如果获取同步状态成功，aqs 会尝试唤醒当前线程节点的后继节点。\n\n# 获取可中断的独占锁\n\naqs 中使用 acquireinterruptibly(int arg) 方法获取可中断的独占锁。\n\nacquireinterruptibly(int arg) 实现方式相较于获取独占锁方法（ acquire）非常相似，区别仅在于它会通过 thread.interrupted 检测当前线程是否被中断，如果是，则立即抛出中断异常（interruptedexception）。\n\n# 获取超时等待式的独占锁\n\naqs 中使用 tryacquirenanos(int arg) 方法获取超时等待的独占锁。\n\ndoacquirenanos 的实现方式 相较于获取独占锁方法（ acquire）非常相似，区别在于它会根据超时时间和当前时间计算出截止时间。在获取锁的流程中，会不断判断是否超时，如果超时，直接返回 false；如果没超时，则用 locksupport.parknanos 来阻塞当前线程。\n\n# 共享锁的获取和释放\n\n# 获取共享锁\n\naqs 中使用 acquireshared(int arg) 方法获取共享锁。\n\nacquireshared 方法和 acquire 方法的逻辑很相似，区别仅在于自旋的条件以及节点出队的操作有所不同。\n\n成功获得共享锁的条件如下：\n\n * tryacquireshared(arg) 返回值大于等于 0 （这意味着共享锁的 permit 还没有用完）。\n * 当前节点的前驱节点是头结点。\n\n# 释放共享锁\n\naqs 中使用 releaseshared(int arg) 方法释放共享锁。\n\nreleaseshared 首先会尝试释放同步状态，如果成功，则解锁一个或多个后继线程节点。释放共享锁和释放独享锁流程大体相似，区别在于：\n\n对于独享模式，如果需要 signal，释放仅相当于调用头节点的 unparksuccessor。\n\n# 获取可中断的共享锁\n\naqs 中使用 acquiresharedinterruptibly(int arg) 方法获取可中断的共享锁。\n\nacquiresharedinterruptibly 方法与 acquireinterruptibly 几乎一致，不再赘述。\n\n# 获取超时等待式的共享锁\n\naqs 中使用 tryacquiresharednanos(int arg) 方法获取超时等待式的共享锁。\n\ntryacquiresharednanos 方法与 tryacquirenanos 几乎一致，不再赘述。\n\n\n# 死锁\n\n\n# 什么是死锁\n\n死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也 可能出现死锁。通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。\n\n\n# 如何定位死锁\n\n定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 jconsole 甚至可以在图形界面进行有限的死锁检测。\n\n如果我们是开发自己的管理工具，需要用更加程序化的方式扫描服务进程、定位死锁，可以考虑使用 java 提供的标准管理 api，threadmxbean，其直接就提供了 finddeadlockedthreads() 方法用于定位。\n\n\n# 如何避免死锁\n\n基本上死锁的发生是因为：\n\n * 互斥，类似 java 中 monitor 都是独占的。\n * 长期保持互斥，在使用结束之前，不会释放，也不能被其他线程抢占。\n * 循环依赖，多个个体之间出现了锁的循环依赖，彼此依赖上一环释放锁。\n\n由此，我们可以分析出避免死锁的思路和方法。\n\n（1）避免一个线程同时获取多个锁。\n\n避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。\n\n尝试使用定时锁 lock.trylock(timeout)，避免锁一直不能释放。\n\n对于数据库锁，加锁和解锁必须在一个数据库连接中里，否则会出现解锁失败的情况。\n\n\n# 参考资料\n\n * 《java 并发编程实战》\n * 《java 并发编程的艺术》\n * java 并发编程：lock\n * 深入学习 java 同步器 aqs\n * abstractqueuedsynchronizer 框架\n * java 中的锁分类',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java原子类",frontmatter:{title:"Java原子类",categories:["编程","Java","JavaSE","并发"],tags:["Java","JavaSE","并发","原子类"],abbrlink:"42cd3065",date:"2019-12-26T23:11:52.000Z",permalink:"/pages/c29e3a/"},regularPath:"/05.%E5%B9%B6%E5%8F%91/05.Java%E5%8E%9F%E5%AD%90%E7%B1%BB.html",relativePath:"05.并发/05.Java原子类.md",key:"v-04c588a5",path:"/pages/c29e3a/",headers:[{level:2,title:"原子变量类简介",slug:"原子变量类简介",normalizedTitle:"原子变量类简介",charIndex:17},{level:3,title:"为何需要原子变量类",slug:"为何需要原子变量类",normalizedTitle:"为何需要原子变量类",charIndex:29},{level:3,title:"原子变量类的作用",slug:"原子变量类的作用",normalizedTitle:"原子变量类的作用",charIndex:402},{level:2,title:"基本类型",slug:"基本类型",normalizedTitle:"基本类型",charIndex:595},{level:3,title:"`AtomicInteger` 用法",slug:"atomicinteger-用法",normalizedTitle:"<code>atomicinteger</code> 用法",charIndex:null},{level:3,title:"`AtomicInteger` 实现",slug:"atomicinteger-实现",normalizedTitle:"<code>atomicinteger</code> 实现",charIndex:null},{level:2,title:"引用类型",slug:"引用类型",normalizedTitle:"引用类型",charIndex:684},{level:2,title:"数组类型",slug:"数组类型",normalizedTitle:"数组类型",charIndex:812},{level:2,title:"属性更新器类型",slug:"属性更新器类型",normalizedTitle:"属性更新器类型",charIndex:924},{level:2,title:"原子化的累加器",slug:"原子化的累加器",normalizedTitle:"原子化的累加器",charIndex:11748},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:12230}],headersStr:"原子变量类简介 为何需要原子变量类 原子变量类的作用 基本类型 `AtomicInteger` 用法 `AtomicInteger` 实现 引用类型 数组类型 属性更新器类型 原子化的累加器 参考资料",content:'# Java 原子变量类\n\n\n# 原子变量类简介\n\n\n# 为何需要原子变量类\n\n保证线程安全是 Java 并发编程必须要解决的重要问题。Java 从原子性、可见性、有序性这三大特性入手，确保多线程的数据一致性。\n\n * 确保线程安全最常见的做法是利用锁机制（Lock、sychronized）来对共享数据做互斥同步，这样在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，那么操作必然是原子性的，线程安全的。互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题。\n * volatile 是轻量级的锁（自然比普通锁性能要好），它保证了共享变量在多线程中的可见性，但无法保证原子性。所以，它只能在一些特定场景下使用。\n * 为了兼顾原子性以及锁带来的性能问题，Java 引入了 CAS （主要体现在 Unsafe 类）来实现非阻塞同步（也叫乐观锁）。并基于 CAS ，提供了一套原子工具类。\n\n\n# 原子变量类的作用\n\n原子变量类 比锁的粒度更细，更轻量级，并且对于在多处理器系统上实现高性能的并发代码来说是非常关键的。原子变量将发生竞争的范围缩小到单个变量上。\n\n原子变量类相当于一种泛化的 volatile 变量，能够支持原子的、有条件的读/改/写操作。\n\n原子类在内部使用 CAS 指令（基于硬件的支持）来实现同步。这些指令通常比锁更快。\n\n原子变量类可以分为 4 组：\n\n * 基本类型\n   * AtomicBoolean - 布尔类型原子类\n   * AtomicInteger - 整型原子类\n   * AtomicLong - 长整型原子类\n * 引用类型\n   * AtomicReference - 引用类型原子类\n   * AtomicMarkableReference - 带有标记位的引用类型原子类\n   * AtomicStampedReference - 带有版本号的引用类型原子类\n * 数组类型\n   * AtomicIntegerArray - 整形数组原子类\n   * AtomicLongArray - 长整型数组原子类\n   * AtomicReferenceArray - 引用类型数组原子类\n * 属性更新器类型\n   * AtomicIntegerFieldUpdater - 整型字段的原子更新器。\n   * AtomicLongFieldUpdater - 长整型字段的原子更新器。\n   * AtomicReferenceFieldUpdater - 原子更新引用类型里的字段。\n\n> 这里不对 CAS、volatile、互斥同步做深入探讨。如果想了解更多细节，不妨参考：Java 并发核心机制\n\n\n# 基本类型\n\n这一类型的原子类是针对 Java 基本类型进行操作。\n\n * AtomicBoolean - 布尔类型原子类\n * AtomicInteger - 整型原子类\n * AtomicLong - 长整型原子类\n\n以上类都支持 CAS（compare-and-swap）技术，此外，AtomicInteger、AtomicLong 还支持算术运算。\n\n> 💡 提示：\n> \n> 虽然 Java 只提供了 AtomicBoolean 、AtomicInteger、AtomicLong，但是可以模拟其他基本类型的原子变量。要想模拟其他基本类型的原子变量，可以将 short 或 byte 等类型与 int 类型进行转换，以及使用 Float.floatToIntBits 、Double.doubleToLongBits 来转换浮点数。\n> \n> 由于 AtomicBoolean、AtomicInteger、AtomicLong 实现方式、使用方式都相近，所以本文仅针对 AtomicInteger 进行介绍。\n\n\n# AtomicInteger 用法\n\npublic final int get() // 获取当前值\npublic final int getAndSet(int newValue) // 获取当前值，并设置新值\npublic final int getAndIncrement()// 获取当前值，并自增\npublic final int getAndDecrement() // 获取当前值，并自减\npublic final int getAndAdd(int delta) // 获取当前值，并加上预期值\nboolean compareAndSet(int expect, int update) // 如果输入值（update）等于预期值，将该值设置为输入值\npublic final void lazySet(int newValue) // 最终设置为 newValue，使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。\n\n\nAtomicInteger 使用示例：\n\npublic class AtomicIntegerDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService executorService = Executors.newFixedThreadPool(5);\n        AtomicInteger count = new AtomicInteger(0);\n        for (int i = 0; i < 1000; i++) {\n            executorService.submit((Runnable) () -> {\n                System.out.println(Thread.currentThread().getName() + " count=" + count.get());\n                count.incrementAndGet();\n            });\n        }\n\n        executorService.shutdown();\n        executorService.awaitTermination(30, TimeUnit.SECONDS);\n        System.out.println("Final Count is : " + count.get());\n    }\n}\n\n\n\n# AtomicInteger 实现\n\n阅读 AtomicInteger 源码，可以看到如下定义：\n\nprivate static final Unsafe unsafe = Unsafe.getUnsafe();\nprivate static final long valueOffset;\n\nstatic {\n\ttry {\n\t\tvalueOffset = unsafe.objectFieldOffset\n\t\t\t(AtomicInteger.class.getDeclaredField("value"));\n\t} catch (Exception ex) { throw new Error(ex); }\n}\n\nprivate volatile int value;\n\n\n> 说明：\n> \n>  * value - value 属性使用 volatile 修饰，使得对 value 的修改在并发环境下对所有线程可见。\n>  * valueOffset - value 属性的偏移量，通过这个偏移量可以快速定位到 value 字段，这个是实现 AtomicInteger 的关键。\n>  * unsafe - Unsafe 类型的属性，它为 AtomicInteger 提供了 CAS 操作。\n\n\n# 引用类型\n\nJava 数据类型分为 基本数据类型 和 引用数据类型 两大类（不了解 Java 数据类型划分可以参考： Java 基本数据类型 ）。\n\n上一节中提到了针对基本数据类型的原子类，那么如果想针对引用类型做原子操作怎么办？Java 也提供了相关的原子类：\n\n * AtomicReference - 引用类型原子类\n * AtomicMarkableReference - 带有标记位的引用类型原子类\n * AtomicStampedReference - 带有版本号的引用类型原子类\n\n> AtomicStampedReference 类在引用类型原子类中，彻底地解决了 ABA 问题，其它的 CAS 能力与另外两个类相近，所以最具代表性。因此，本节只针对 AtomicStampedReference 进行说明。\n\n示例：基于 AtomicReference 实现一个简单的自旋锁\n\npublic class AtomicReferenceDemo2 {\n\n    private static int ticket = 10;\n\n    public static void main(String[] args) {\n        threadSafeDemo();\n    }\n\n    private static void threadSafeDemo() {\n        SpinLock lock = new SpinLock();\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        for (int i = 0; i < 5; i++) {\n            executorService.execute(new MyThread(lock));\n        }\n        executorService.shutdown();\n    }\n\n    /**\n     * 基于 {@link AtomicReference} 实现的简单自旋锁\n     */\n    static class SpinLock {\n\n        private AtomicReference<Thread> atomicReference = new AtomicReference<>();\n\n        public void lock() {\n            Thread current = Thread.currentThread();\n            while (!atomicReference.compareAndSet(null, current)) {}\n        }\n\n        public void unlock() {\n            Thread current = Thread.currentThread();\n            atomicReference.compareAndSet(current, null);\n        }\n\n    }\n\n    /**\n     * 利用自旋锁 {@link SpinLock} 并发处理数据\n     */\n    static class MyThread implements Runnable {\n\n        private SpinLock lock;\n\n        public MyThread(SpinLock lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            while (ticket > 0) {\n                lock.lock();\n                if (ticket > 0) {\n                    System.out.println(Thread.currentThread().getName() + " 卖出了第 " + ticket + " 张票");\n                    ticket--;\n                }\n                lock.unlock();\n            }\n        }\n\n    }\n\n}\n\n\n原子类的实现基于 CAS 机制，而 CAS 存在 ABA 问题（不了解 ABA 问题，可以参考：Java 并发基础机制 - CAS 的问题）。正是为了解决 ABA 问题，才有了 AtomicMarkableReference 和 AtomicStampedReference。\n\nAtomicMarkableReference 使用一个布尔值作为标记，修改时在 true / false 之间切换。这种策略不能根本上解决 ABA 问题，但是可以降低 ABA 发生的几率。常用于缓存或者状态描述这样的场景。\n\npublic class AtomicMarkableReferenceDemo {\n\n    private final static String INIT_TEXT = "abc";\n\n    public static void main(String[] args) throws InterruptedException {\n\n        final AtomicMarkableReference<String> amr = new AtomicMarkableReference<>(INIT_TEXT, false);\n\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        for (int i = 0; i < 10; i++) {\n            executorService.submit(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(Math.abs((int) (Math.random() * 100)));\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n\n                    String name = Thread.currentThread().getName();\n                    if (amr.compareAndSet(INIT_TEXT, name, amr.isMarked(), !amr.isMarked())) {\n                        System.out.println(Thread.currentThread().getName() + " 修改了对象！");\n                        System.out.println("新的对象为：" + amr.getReference());\n                    }\n                }\n            });\n        }\n\n        executorService.shutdown();\n        executorService.awaitTermination(3, TimeUnit.SECONDS);\n    }\n\n}\n\n\nAtomicStampedReference 使用一个整型值做为版本号，每次更新前先比较版本号，如果一致，才进行修改。通过这种策略，可以根本上解决 ABA 问题。\n\npublic class AtomicStampedReferenceDemo {\n\n    private final static String INIT_REF = "pool-1-thread-3";\n\n    private final static AtomicStampedReference<String> asr = new AtomicStampedReference<>(INIT_REF, 0);\n\n    public static void main(String[] args) throws InterruptedException {\n\n        System.out.println("初始对象为：" + asr.getReference());\n\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        for (int i = 0; i < 3; i++) {\n            executorService.execute(new MyThread());\n        }\n\n        executorService.shutdown();\n        executorService.awaitTermination(3, TimeUnit.SECONDS);\n    }\n\n    static class MyThread implements Runnable {\n\n        @Override\n        public void run() {\n            try {\n                Thread.sleep(Math.abs((int) (Math.random() * 100)));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            final int stamp = asr.getStamp();\n            if (asr.compareAndSet(INIT_REF, Thread.currentThread().getName(), stamp, stamp + 1)) {\n                System.out.println(Thread.currentThread().getName() + " 修改了对象！");\n                System.out.println("新的对象为：" + asr.getReference());\n            }\n        }\n\n    }\n\n}\n\n\n\n# 数组类型\n\nJava 提供了以下针对数组的原子类：\n\n * AtomicIntegerArray - 整形数组原子类\n * AtomicLongArray - 长整型数组原子类\n * AtomicReferenceArray - 引用类型数组原子类\n\n已经有了针对基本类型和引用类型的原子类，为什么还要提供针对数组的原子类呢？\n\n数组类型的原子类为 数组元素 提供了 volatile 类型的访问语义，这是普通数组所不具备的特性——volatile 类型的数组仅在数组引用上具有 volatile 语义。\n\n示例：AtomicIntegerArray 使用示例（AtomicLongArray 、AtomicReferenceArray 使用方式也类似）\n\npublic class AtomicIntegerArrayDemo {\n\n    private static AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(10);\n\n    public static void main(final String[] arguments) throws InterruptedException {\n\n        System.out.println("Init Values: ");\n        for (int i = 0; i < atomicIntegerArray.length(); i++) {\n            atomicIntegerArray.set(i, i);\n            System.out.print(atomicIntegerArray.get(i) + " ");\n        }\n        System.out.println();\n\n        Thread t1 = new Thread(new Increment());\n        Thread t2 = new Thread(new Compare());\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.println("Final Values: ");\n        for (int i = 0; i < atomicIntegerArray.length(); i++) {\n            System.out.print(atomicIntegerArray.get(i) + " ");\n        }\n        System.out.println();\n    }\n\n    static class Increment implements Runnable {\n\n        @Override\n        public void run() {\n\n            for (int i = 0; i < atomicIntegerArray.length(); i++) {\n                int value = atomicIntegerArray.incrementAndGet(i);\n                System.out.println(Thread.currentThread().getName() + ", index = " + i + ", value = " + value);\n            }\n        }\n\n    }\n\n    static class Compare implements Runnable {\n\n        @Override\n        public void run() {\n            for (int i = 0; i < atomicIntegerArray.length(); i++) {\n                boolean swapped = atomicIntegerArray.compareAndSet(i, 2, 3);\n                if (swapped) {\n                    System.out.println(Thread.currentThread().getName() + " swapped, index = " + i + ", value = 3");\n                }\n            }\n        }\n\n    }\n\n}\n\n\n\n# 属性更新器类型\n\n更新器类支持基于反射机制的更新字段值的原子操作。\n\n * AtomicIntegerFieldUpdater - 整型字段的原子更新器。\n * AtomicLongFieldUpdater - 长整型字段的原子更新器。\n * AtomicReferenceFieldUpdater - 原子更新引用类型里的字段。\n\n这些类的使用有一定限制：\n\n * 因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater() 创建一个更新器，并且需要设置想要更新的类和属性。\n * 字段必须是 volatile 类型的；\n * 不能作用于静态变量（static）；\n * 不能作用于常量（final）；\n\npublic class AtomicReferenceFieldUpdaterDemo {\n\n    static User user = new User("begin");\n\n    static AtomicReferenceFieldUpdater<User, String> updater =\n        AtomicReferenceFieldUpdater.newUpdater(User.class, String.class, "name");\n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        for (int i = 0; i < 5; i++) {\n            executorService.execute(new MyThread());\n        }\n        executorService.shutdown();\n    }\n\n    static class MyThread implements Runnable {\n\n        @Override\n        public void run() {\n            if (updater.compareAndSet(user, "begin", "end")) {\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + " 已修改 name = " + user.getName());\n            } else {\n                System.out.println(Thread.currentThread().getName() + " 已被其他线程修改");\n            }\n        }\n\n    }\n\n    static class User {\n\n        volatile String name;\n\n        public User(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public User setName(String name) {\n            this.name = name;\n            return this;\n        }\n\n    }\n\n}\n\n\n\n# 原子化的累加器\n\nDoubleAccumulator、DoubleAdder、LongAccumulator 和 LongAdder，这四个类仅仅用来执行累加操作，相比原子化的基本数据类型，速度更快，但是不支持 compareAndSet() 方法。如果你仅仅需要累加操作，使用原子化的累加器性能会更好，代价就是会消耗更多的内存空间。\n\nLongAdder 内部由一个 base 变量和一个 cell[] 数组组成。\n\n * 当只有一个写线程，没有竞争的情况下，LongAdder 会直接使用 base 变量作为原子操作变量，通过 CAS 操作修改变量；\n * 当有多个写线程竞争的情况下，除了占用 base 变量的一个写线程之外，其它各个线程会将修改的变量写入到自己的槽 cell[] 数组中。\n\n我们可以发现，LongAdder 在操作后的返回值只是一个近似准确的数值，但是 LongAdder 最终返回的是一个准确的数值， 所以在一些对实时性要求比较高的场景下，LongAdder 并不能取代 AtomicInteger 或 AtomicLong。\n\n\n# 参考资料\n\n * 《Java 并发编程实战》\n * 《Java 并发编程的艺术》\n * JUC 中的原子类\n * http://tutorials.jenkov.com/java-util-concurrent/atomicinteger.html\n * http://tutorials.jenkov.com/java-util-concurrent/atomicintegerarray.html\n * http://tutorials.jenkov.com/java-util-concurrent/atomicreference.html\n * http://tutorials.jenkov.com/java-util-concurrent/atomicstampedreference.htm',normalizedContent:'# java 原子变量类\n\n\n# 原子变量类简介\n\n\n# 为何需要原子变量类\n\n保证线程安全是 java 并发编程必须要解决的重要问题。java 从原子性、可见性、有序性这三大特性入手，确保多线程的数据一致性。\n\n * 确保线程安全最常见的做法是利用锁机制（lock、sychronized）来对共享数据做互斥同步，这样在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，那么操作必然是原子性的，线程安全的。互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题。\n * volatile 是轻量级的锁（自然比普通锁性能要好），它保证了共享变量在多线程中的可见性，但无法保证原子性。所以，它只能在一些特定场景下使用。\n * 为了兼顾原子性以及锁带来的性能问题，java 引入了 cas （主要体现在 unsafe 类）来实现非阻塞同步（也叫乐观锁）。并基于 cas ，提供了一套原子工具类。\n\n\n# 原子变量类的作用\n\n原子变量类 比锁的粒度更细，更轻量级，并且对于在多处理器系统上实现高性能的并发代码来说是非常关键的。原子变量将发生竞争的范围缩小到单个变量上。\n\n原子变量类相当于一种泛化的 volatile 变量，能够支持原子的、有条件的读/改/写操作。\n\n原子类在内部使用 cas 指令（基于硬件的支持）来实现同步。这些指令通常比锁更快。\n\n原子变量类可以分为 4 组：\n\n * 基本类型\n   * atomicboolean - 布尔类型原子类\n   * atomicinteger - 整型原子类\n   * atomiclong - 长整型原子类\n * 引用类型\n   * atomicreference - 引用类型原子类\n   * atomicmarkablereference - 带有标记位的引用类型原子类\n   * atomicstampedreference - 带有版本号的引用类型原子类\n * 数组类型\n   * atomicintegerarray - 整形数组原子类\n   * atomiclongarray - 长整型数组原子类\n   * atomicreferencearray - 引用类型数组原子类\n * 属性更新器类型\n   * atomicintegerfieldupdater - 整型字段的原子更新器。\n   * atomiclongfieldupdater - 长整型字段的原子更新器。\n   * atomicreferencefieldupdater - 原子更新引用类型里的字段。\n\n> 这里不对 cas、volatile、互斥同步做深入探讨。如果想了解更多细节，不妨参考：java 并发核心机制\n\n\n# 基本类型\n\n这一类型的原子类是针对 java 基本类型进行操作。\n\n * atomicboolean - 布尔类型原子类\n * atomicinteger - 整型原子类\n * atomiclong - 长整型原子类\n\n以上类都支持 cas（compare-and-swap）技术，此外，atomicinteger、atomiclong 还支持算术运算。\n\n> 💡 提示：\n> \n> 虽然 java 只提供了 atomicboolean 、atomicinteger、atomiclong，但是可以模拟其他基本类型的原子变量。要想模拟其他基本类型的原子变量，可以将 short 或 byte 等类型与 int 类型进行转换，以及使用 float.floattointbits 、double.doubletolongbits 来转换浮点数。\n> \n> 由于 atomicboolean、atomicinteger、atomiclong 实现方式、使用方式都相近，所以本文仅针对 atomicinteger 进行介绍。\n\n\n# atomicinteger 用法\n\npublic final int get() // 获取当前值\npublic final int getandset(int newvalue) // 获取当前值，并设置新值\npublic final int getandincrement()// 获取当前值，并自增\npublic final int getanddecrement() // 获取当前值，并自减\npublic final int getandadd(int delta) // 获取当前值，并加上预期值\nboolean compareandset(int expect, int update) // 如果输入值（update）等于预期值，将该值设置为输入值\npublic final void lazyset(int newvalue) // 最终设置为 newvalue，使用 lazyset 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。\n\n\natomicinteger 使用示例：\n\npublic class atomicintegerdemo {\n\n    public static void main(string[] args) throws interruptedexception {\n        executorservice executorservice = executors.newfixedthreadpool(5);\n        atomicinteger count = new atomicinteger(0);\n        for (int i = 0; i < 1000; i++) {\n            executorservice.submit((runnable) () -> {\n                system.out.println(thread.currentthread().getname() + " count=" + count.get());\n                count.incrementandget();\n            });\n        }\n\n        executorservice.shutdown();\n        executorservice.awaittermination(30, timeunit.seconds);\n        system.out.println("final count is : " + count.get());\n    }\n}\n\n\n\n# atomicinteger 实现\n\n阅读 atomicinteger 源码，可以看到如下定义：\n\nprivate static final unsafe unsafe = unsafe.getunsafe();\nprivate static final long valueoffset;\n\nstatic {\n\ttry {\n\t\tvalueoffset = unsafe.objectfieldoffset\n\t\t\t(atomicinteger.class.getdeclaredfield("value"));\n\t} catch (exception ex) { throw new error(ex); }\n}\n\nprivate volatile int value;\n\n\n> 说明：\n> \n>  * value - value 属性使用 volatile 修饰，使得对 value 的修改在并发环境下对所有线程可见。\n>  * valueoffset - value 属性的偏移量，通过这个偏移量可以快速定位到 value 字段，这个是实现 atomicinteger 的关键。\n>  * unsafe - unsafe 类型的属性，它为 atomicinteger 提供了 cas 操作。\n\n\n# 引用类型\n\njava 数据类型分为 基本数据类型 和 引用数据类型 两大类（不了解 java 数据类型划分可以参考： java 基本数据类型 ）。\n\n上一节中提到了针对基本数据类型的原子类，那么如果想针对引用类型做原子操作怎么办？java 也提供了相关的原子类：\n\n * atomicreference - 引用类型原子类\n * atomicmarkablereference - 带有标记位的引用类型原子类\n * atomicstampedreference - 带有版本号的引用类型原子类\n\n> atomicstampedreference 类在引用类型原子类中，彻底地解决了 aba 问题，其它的 cas 能力与另外两个类相近，所以最具代表性。因此，本节只针对 atomicstampedreference 进行说明。\n\n示例：基于 atomicreference 实现一个简单的自旋锁\n\npublic class atomicreferencedemo2 {\n\n    private static int ticket = 10;\n\n    public static void main(string[] args) {\n        threadsafedemo();\n    }\n\n    private static void threadsafedemo() {\n        spinlock lock = new spinlock();\n        executorservice executorservice = executors.newfixedthreadpool(3);\n        for (int i = 0; i < 5; i++) {\n            executorservice.execute(new mythread(lock));\n        }\n        executorservice.shutdown();\n    }\n\n    /**\n     * 基于 {@link atomicreference} 实现的简单自旋锁\n     */\n    static class spinlock {\n\n        private atomicreference<thread> atomicreference = new atomicreference<>();\n\n        public void lock() {\n            thread current = thread.currentthread();\n            while (!atomicreference.compareandset(null, current)) {}\n        }\n\n        public void unlock() {\n            thread current = thread.currentthread();\n            atomicreference.compareandset(current, null);\n        }\n\n    }\n\n    /**\n     * 利用自旋锁 {@link spinlock} 并发处理数据\n     */\n    static class mythread implements runnable {\n\n        private spinlock lock;\n\n        public mythread(spinlock lock) {\n            this.lock = lock;\n        }\n\n        @override\n        public void run() {\n            while (ticket > 0) {\n                lock.lock();\n                if (ticket > 0) {\n                    system.out.println(thread.currentthread().getname() + " 卖出了第 " + ticket + " 张票");\n                    ticket--;\n                }\n                lock.unlock();\n            }\n        }\n\n    }\n\n}\n\n\n原子类的实现基于 cas 机制，而 cas 存在 aba 问题（不了解 aba 问题，可以参考：java 并发基础机制 - cas 的问题）。正是为了解决 aba 问题，才有了 atomicmarkablereference 和 atomicstampedreference。\n\natomicmarkablereference 使用一个布尔值作为标记，修改时在 true / false 之间切换。这种策略不能根本上解决 aba 问题，但是可以降低 aba 发生的几率。常用于缓存或者状态描述这样的场景。\n\npublic class atomicmarkablereferencedemo {\n\n    private final static string init_text = "abc";\n\n    public static void main(string[] args) throws interruptedexception {\n\n        final atomicmarkablereference<string> amr = new atomicmarkablereference<>(init_text, false);\n\n        executorservice executorservice = executors.newfixedthreadpool(3);\n        for (int i = 0; i < 10; i++) {\n            executorservice.submit(new runnable() {\n                @override\n                public void run() {\n                    try {\n                        thread.sleep(math.abs((int) (math.random() * 100)));\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n\n                    string name = thread.currentthread().getname();\n                    if (amr.compareandset(init_text, name, amr.ismarked(), !amr.ismarked())) {\n                        system.out.println(thread.currentthread().getname() + " 修改了对象！");\n                        system.out.println("新的对象为：" + amr.getreference());\n                    }\n                }\n            });\n        }\n\n        executorservice.shutdown();\n        executorservice.awaittermination(3, timeunit.seconds);\n    }\n\n}\n\n\natomicstampedreference 使用一个整型值做为版本号，每次更新前先比较版本号，如果一致，才进行修改。通过这种策略，可以根本上解决 aba 问题。\n\npublic class atomicstampedreferencedemo {\n\n    private final static string init_ref = "pool-1-thread-3";\n\n    private final static atomicstampedreference<string> asr = new atomicstampedreference<>(init_ref, 0);\n\n    public static void main(string[] args) throws interruptedexception {\n\n        system.out.println("初始对象为：" + asr.getreference());\n\n        executorservice executorservice = executors.newfixedthreadpool(3);\n        for (int i = 0; i < 3; i++) {\n            executorservice.execute(new mythread());\n        }\n\n        executorservice.shutdown();\n        executorservice.awaittermination(3, timeunit.seconds);\n    }\n\n    static class mythread implements runnable {\n\n        @override\n        public void run() {\n            try {\n                thread.sleep(math.abs((int) (math.random() * 100)));\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n\n            final int stamp = asr.getstamp();\n            if (asr.compareandset(init_ref, thread.currentthread().getname(), stamp, stamp + 1)) {\n                system.out.println(thread.currentthread().getname() + " 修改了对象！");\n                system.out.println("新的对象为：" + asr.getreference());\n            }\n        }\n\n    }\n\n}\n\n\n\n# 数组类型\n\njava 提供了以下针对数组的原子类：\n\n * atomicintegerarray - 整形数组原子类\n * atomiclongarray - 长整型数组原子类\n * atomicreferencearray - 引用类型数组原子类\n\n已经有了针对基本类型和引用类型的原子类，为什么还要提供针对数组的原子类呢？\n\n数组类型的原子类为 数组元素 提供了 volatile 类型的访问语义，这是普通数组所不具备的特性——volatile 类型的数组仅在数组引用上具有 volatile 语义。\n\n示例：atomicintegerarray 使用示例（atomiclongarray 、atomicreferencearray 使用方式也类似）\n\npublic class atomicintegerarraydemo {\n\n    private static atomicintegerarray atomicintegerarray = new atomicintegerarray(10);\n\n    public static void main(final string[] arguments) throws interruptedexception {\n\n        system.out.println("init values: ");\n        for (int i = 0; i < atomicintegerarray.length(); i++) {\n            atomicintegerarray.set(i, i);\n            system.out.print(atomicintegerarray.get(i) + " ");\n        }\n        system.out.println();\n\n        thread t1 = new thread(new increment());\n        thread t2 = new thread(new compare());\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        system.out.println("final values: ");\n        for (int i = 0; i < atomicintegerarray.length(); i++) {\n            system.out.print(atomicintegerarray.get(i) + " ");\n        }\n        system.out.println();\n    }\n\n    static class increment implements runnable {\n\n        @override\n        public void run() {\n\n            for (int i = 0; i < atomicintegerarray.length(); i++) {\n                int value = atomicintegerarray.incrementandget(i);\n                system.out.println(thread.currentthread().getname() + ", index = " + i + ", value = " + value);\n            }\n        }\n\n    }\n\n    static class compare implements runnable {\n\n        @override\n        public void run() {\n            for (int i = 0; i < atomicintegerarray.length(); i++) {\n                boolean swapped = atomicintegerarray.compareandset(i, 2, 3);\n                if (swapped) {\n                    system.out.println(thread.currentthread().getname() + " swapped, index = " + i + ", value = 3");\n                }\n            }\n        }\n\n    }\n\n}\n\n\n\n# 属性更新器类型\n\n更新器类支持基于反射机制的更新字段值的原子操作。\n\n * atomicintegerfieldupdater - 整型字段的原子更新器。\n * atomiclongfieldupdater - 长整型字段的原子更新器。\n * atomicreferencefieldupdater - 原子更新引用类型里的字段。\n\n这些类的使用有一定限制：\n\n * 因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newupdater() 创建一个更新器，并且需要设置想要更新的类和属性。\n * 字段必须是 volatile 类型的；\n * 不能作用于静态变量（static）；\n * 不能作用于常量（final）；\n\npublic class atomicreferencefieldupdaterdemo {\n\n    static user user = new user("begin");\n\n    static atomicreferencefieldupdater<user, string> updater =\n        atomicreferencefieldupdater.newupdater(user.class, string.class, "name");\n\n    public static void main(string[] args) {\n        executorservice executorservice = executors.newfixedthreadpool(3);\n        for (int i = 0; i < 5; i++) {\n            executorservice.execute(new mythread());\n        }\n        executorservice.shutdown();\n    }\n\n    static class mythread implements runnable {\n\n        @override\n        public void run() {\n            if (updater.compareandset(user, "begin", "end")) {\n                try {\n                    timeunit.seconds.sleep(1);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n                system.out.println(thread.currentthread().getname() + " 已修改 name = " + user.getname());\n            } else {\n                system.out.println(thread.currentthread().getname() + " 已被其他线程修改");\n            }\n        }\n\n    }\n\n    static class user {\n\n        volatile string name;\n\n        public user(string name) {\n            this.name = name;\n        }\n\n        public string getname() {\n            return name;\n        }\n\n        public user setname(string name) {\n            this.name = name;\n            return this;\n        }\n\n    }\n\n}\n\n\n\n# 原子化的累加器\n\ndoubleaccumulator、doubleadder、longaccumulator 和 longadder，这四个类仅仅用来执行累加操作，相比原子化的基本数据类型，速度更快，但是不支持 compareandset() 方法。如果你仅仅需要累加操作，使用原子化的累加器性能会更好，代价就是会消耗更多的内存空间。\n\nlongadder 内部由一个 base 变量和一个 cell[] 数组组成。\n\n * 当只有一个写线程，没有竞争的情况下，longadder 会直接使用 base 变量作为原子操作变量，通过 cas 操作修改变量；\n * 当有多个写线程竞争的情况下，除了占用 base 变量的一个写线程之外，其它各个线程会将修改的变量写入到自己的槽 cell[] 数组中。\n\n我们可以发现，longadder 在操作后的返回值只是一个近似准确的数值，但是 longadder 最终返回的是一个准确的数值， 所以在一些对实时性要求比较高的场景下，longadder 并不能取代 atomicinteger 或 atomiclong。\n\n\n# 参考资料\n\n * 《java 并发编程实战》\n * 《java 并发编程的艺术》\n * juc 中的原子类\n * http://tutorials.jenkov.com/java-util-concurrent/atomicinteger.html\n * http://tutorials.jenkov.com/java-util-concurrent/atomicintegerarray.html\n * http://tutorials.jenkov.com/java-util-concurrent/atomicreference.html\n * http://tutorials.jenkov.com/java-util-concurrent/atomicstampedreference.htm',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java并发和容器",frontmatter:{title:"Java并发和容器",categories:["编程","Java","JavaSE","并发"],tags:["Java","JavaSE","并发","容器"],abbrlink:"7ea96e03",date:"2020-02-02T17:54:36.000Z",permalink:"/pages/3038c4/"},regularPath:"/05.%E5%B9%B6%E5%8F%91/06.Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%AE%B9%E5%99%A8.html",relativePath:"05.并发/06.Java并发和容器.md",key:"v-3ce16de3",path:"/pages/3038c4/",headers:[{level:2,title:"同步容器",slug:"同步容器",normalizedTitle:"同步容器",charIndex:17},{level:3,title:"同步容器简介",slug:"同步容器简介",normalizedTitle:"同步容器简介",charIndex:26},{level:3,title:"同步容器的问题",slug:"同步容器的问题",normalizedTitle:"同步容器的问题",charIndex:422},{level:4,title:"性能问题",slug:"性能问题",normalizedTitle:"性能问题",charIndex:577},{level:4,title:"安全问题",slug:"安全问题",normalizedTitle:"安全问题",charIndex:705},{level:2,title:"并发容器简介",slug:"并发容器简介",normalizedTitle:"并发容器简介",charIndex:3568},{level:3,title:"并发场景下的 Map",slug:"并发场景下的-map",normalizedTitle:"并发场景下的 map",charIndex:5134},{level:3,title:"并发场景下的 List",slug:"并发场景下的-list",normalizedTitle:"并发场景下的 list",charIndex:5273},{level:2,title:"Map",slug:"map",normalizedTitle:"map",charIndex:295},{level:3,title:"ConcurrentHashMap",slug:"concurrenthashmap",normalizedTitle:"concurrenthashmap",charIndex:3745},{level:4,title:"ConcurrentHashMap 的特性",slug:"concurrenthashmap-的特性",normalizedTitle:"concurrenthashmap 的特性",charIndex:5753},{level:4,title:"ConcurrentHashMap 的用法",slug:"concurrenthashmap-的用法",normalizedTitle:"concurrenthashmap 的用法",charIndex:6817},{level:4,title:"ConcurrentHashMap 的原理",slug:"concurrenthashmap-的原理",normalizedTitle:"concurrenthashmap 的原理",charIndex:7846},{level:5,title:"Java 1.7 的实现",slug:"java-1-7-的实现",normalizedTitle:"java 1.7 的实现",charIndex:8084},{level:5,title:"Java 1.8 的实现",slug:"java-1-8-的实现",normalizedTitle:"java 1.8 的实现",charIndex:9128},{level:4,title:"ConcurrentHashMap 的实战",slug:"concurrenthashmap-的实战",normalizedTitle:"concurrenthashmap 的实战",charIndex:12578},{level:5,title:"ConcurrentHashMap 错误示例",slug:"concurrenthashmap-错误示例",normalizedTitle:"concurrenthashmap 错误示例",charIndex:12633},{level:5,title:"ConcurrentHashMap 错误示例修正 1.0 版",slug:"concurrenthashmap-错误示例修正-1-0-版",normalizedTitle:"concurrenthashmap 错误示例修正 1.0 版",charIndex:14383},{level:5,title:"ConcurrentHashMap 错误示例修正 2.0 版",slug:"concurrenthashmap-错误示例修正-2-0-版",normalizedTitle:"concurrenthashmap 错误示例修正 2.0 版",charIndex:15938},{level:2,title:"List",slug:"list",normalizedTitle:"list",charIndex:109},{level:3,title:"CopyOnWriteArrayList",slug:"copyonwritearraylist",normalizedTitle:"copyonwritearraylist",charIndex:3884},{level:4,title:"CopyOnWriteArrayList 原理",slug:"copyonwritearraylist-原理",normalizedTitle:"copyonwritearraylist 原理",charIndex:18896},{level:4,title:"CopyOnWriteArrayList 示例",slug:"copyonwritearraylist-示例",normalizedTitle:"copyonwritearraylist 示例",charIndex:21225},{level:4,title:"CopyOnWriteArrayList 实战",slug:"copyonwritearraylist-实战",normalizedTitle:"copyonwritearraylist 实战",charIndex:22649},{level:2,title:"Set",slug:"set",normalizedTitle:"set",charIndex:3937},{level:2,title:"Queue",slug:"queue",normalizedTitle:"queue",charIndex:4066},{level:3,title:"BlockingQueue",slug:"blockingqueue",normalizedTitle:"blockingqueue",charIndex:4191},{level:3,title:"PriorityBlockingQueue 类",slug:"priorityblockingqueue-类",normalizedTitle:"priorityblockingqueue 类",charIndex:26648},{level:4,title:"PriorityBlockingQueue 要点",slug:"priorityblockingqueue-要点",normalizedTitle:"priorityblockingqueue 要点",charIndex:26827},{level:4,title:"PriorityBlockingQueue 原理",slug:"priorityblockingqueue-原理",normalizedTitle:"priorityblockingqueue 原理",charIndex:27126},{level:3,title:"ArrayBlockingQueue 类",slug:"arrayblockingqueue-类",normalizedTitle:"arrayblockingqueue 类",charIndex:27434},{level:4,title:"ArrayBlockingQueue 要点",slug:"arrayblockingqueue-要点",normalizedTitle:"arrayblockingqueue 要点",charIndex:27495},{level:4,title:"ArrayBlockingQueue 原理",slug:"arrayblockingqueue-原理",normalizedTitle:"arrayblockingqueue 原理",charIndex:28076},{level:3,title:"LinkedBlockingQueue 类",slug:"linkedblockingqueue-类",normalizedTitle:"linkedblockingqueue 类",charIndex:28769},{level:4,title:"LinkedBlockingQueue 要点",slug:"linkedblockingqueue-要点",normalizedTitle:"linkedblockingqueue 要点",charIndex:28928},{level:4,title:"LinkedBlockingQueue 原理",slug:"linkedblockingqueue-原理",normalizedTitle:"linkedblockingqueue 原理",charIndex:29306},{level:3,title:"SynchronousQueue 类",slug:"synchronousqueue-类",normalizedTitle:"synchronousqueue 类",charIndex:30175},{level:3,title:"ConcurrentLinkedDeque 类",slug:"concurrentlinkeddeque-类",normalizedTitle:"concurrentlinkeddeque 类",charIndex:30899},{level:3,title:"Queue 的并发应用",slug:"queue-的并发应用",normalizedTitle:"queue 的并发应用",charIndex:31044},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:31566}],headersStr:"同步容器 同步容器简介 同步容器的问题 性能问题 安全问题 并发容器简介 并发场景下的 Map 并发场景下的 List Map ConcurrentHashMap ConcurrentHashMap 的特性 ConcurrentHashMap 的用法 ConcurrentHashMap 的原理 Java 1.7 的实现 Java 1.8 的实现 ConcurrentHashMap 的实战 ConcurrentHashMap 错误示例 ConcurrentHashMap 错误示例修正 1.0 版 ConcurrentHashMap 错误示例修正 2.0 版 List CopyOnWriteArrayList CopyOnWriteArrayList 原理 CopyOnWriteArrayList 示例 CopyOnWriteArrayList 实战 Set Queue BlockingQueue PriorityBlockingQueue 类 PriorityBlockingQueue 要点 PriorityBlockingQueue 原理 ArrayBlockingQueue 类 ArrayBlockingQueue 要点 ArrayBlockingQueue 原理 LinkedBlockingQueue 类 LinkedBlockingQueue 要点 LinkedBlockingQueue 原理 SynchronousQueue 类 ConcurrentLinkedDeque 类 Queue 的并发应用 参考资料",content:'# Java 并发和容器\n\n\n# 同步容器\n\n\n# 同步容器简介\n\n在 Java 中，同步容器主要包括 2 类：\n\n * Vector、Stack、Hashtable\n   * Vector - Vector 实现了 List 接口。Vector 实际上就是一个数组，和 ArrayList 类似。但是 Vector 中的方法都是 synchronized 方法，即进行了同步措施。\n   * Stack - Stack 也是一个同步容器，它的方法也用 synchronized 进行了同步，它实际上是继承于 Vector 类。\n   * Hashtable- Hashtable 实现了 Map 接口，它和 HashMap 很相似，但是 Hashtable 进行了同步处理，而 HashMap 没有。\n * Collections 类中提供的静态工厂方法创建的类（由 Collections.synchronizedXXX 等方法）\n\n\n# 同步容器的问题\n\n同步容器的同步原理就是在其 get、set、size 等主要方法上用 synchronized 修饰。 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。\n\n> 想详细了解 synchronized 用法和原理可以参考：Java 并发核心机制\n\n# 性能问题\n\nsynchronized 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 synchronized 的容器性能要差很多。\n\n> 注：尤其是在 Java 1.6 没有对 synchronized 进行优化前，阻塞开销很高。\n\n# 安全问题\n\n同步容器真的绝对安全吗？\n\n其实也未必。在做复合操作（非原子操作）时，仍然需要加锁来保护。常见复合操作如下：\n\n * 迭代：反复访问元素，直到遍历完全部元素；\n * 跳转：根据指定顺序寻找当前元素的下一个（下 n 个）元素；\n * 条件运算：例如若没有则添加等；\n\n❌ 不安全的示例\n\npublic class VectorDemo {\n\n    static Vector<Integer> vector = new Vector<>();\n\n    public static void main(String[] args) {\n        while (true) {\n            vector.clear();\n\n            for (int i = 0; i < 10; i++) {\n                vector.add(i);\n            }\n\n            Thread thread1 = new Thread() {\n                @Override\n                public void run() {\n                    for (int i = 0; i < vector.size(); i++) {\n                        vector.remove(i);\n                    }\n                }\n            };\n\n            Thread thread2 = new Thread() {\n                @Override\n                public void run() {\n                    for (int i = 0; i < vector.size(); i++) {\n                        vector.get(i);\n                    }\n                }\n            };\n\n            thread1.start();\n            thread2.start();\n\n            while (Thread.activeCount() > 10) {\n                System.out.println("同时存在 10 个以上线程，退出");\n                return;\n            }\n        }\n    }\n\n}\n\n\n以上程序执行时可能会出现数组越界错误。\n\nVector 是线程安全的，那为什么还会报这个错？\n\n这是因为，对于 Vector，虽然能保证每一个时刻只能有一个线程访问它，但是不排除这种可能：\n\n当某个线程在某个时刻执行这句时：\n\nfor(int i=0;i<vector.size();i++)\n    vector.get(i);\n\n\n假若此时 vector 的 size 方法返回的是 10，i 的值为 9\n\n然后另外一个线程执行了这句：\n\nfor(int i=0;i<vector.size();i++)\n    vector.remove(i);\n\n\n将下标为 9 的元素删除了。\n\n那么通过 get 方法访问下标为 9 的元素肯定就会出问题了。\n\n✔ 安全示例\n\n因此为了保证线程安全，必须在方法调用端做额外的同步措施，如下面所示：\n\npublic class VectorDemo2 {\n\n    static Vector<Integer> vector = new Vector<Integer>();\n\n    public static void main(String[] args) {\n        while (true) {\n            for (int i = 0; i < 10; i++) {\n                vector.add(i);\n            }\n\n            Thread thread1 = new Thread() {\n                @Override\n                public void run() {\n                    synchronized (VectorDemo2.class) {   //进行额外的同步\n                        for (int i = 0; i < vector.size(); i++) {\n                            vector.remove(i);\n                        }\n                    }\n                }\n            };\n\n            Thread thread2 = new Thread() {\n                @Override\n                public void run() {\n                    synchronized (VectorDemo2.class) {\n                        for (int i = 0; i < vector.size(); i++) {\n                            vector.get(i);\n                        }\n                    }\n                }\n            };\n\n            thread1.start();\n            thread2.start();\n\n            while (Thread.activeCount() > 10) {\n                System.out.println("同时存在 10 个以上线程，退出");\n                return;\n            }\n        }\n    }\n\n}\n\n\nConcurrentModificationException 异常\n\n在对 Vector 等容器并发地进行迭代修改时，会报 ConcurrentModificationException 异常，关于这个异常将会在后续文章中讲述。\n\n但是在并发容器中不会出现这个问题。\n\n\n# 并发容器简介\n\n同步容器将所有对容器状态的访问都串行化，以保证线程安全性，这种策略会严重降低并发性。\n\nJava 1.5 后提供了多种并发容器，使用并发容器来替代同步容器，可以极大地提高伸缩性并降低风险。\n\nJ.U.C 包中提供了几个非常有用的并发容器作为线程安全的容器：\n\n并发容器                    对应的普通容器     描述\nConcurrentHashMap       HashMap     Java 1.8 之前采用分段锁机制细化锁粒度，降低阻塞，从而提高并发性；Java 1.8 之后基于 CAS 实现。\nConcurrentSkipListMap   SortedMap   基于跳表实现的\nCopyOnWriteArrayList    ArrayList   \nCopyOnWriteArraySet     Set         基于 CopyOnWriteArrayList 实现。\nConcurrentSkipListSet   SortedSet   基于 ConcurrentSkipListMap 实现。\nConcurrentLinkedQueue   Queue       线程安全的无界队列。底层采用单链表。支持 FIFO。\nConcurrentLinkedDeque   Deque       线程安全的无界双端队列。底层采用双向链表。支持 FIFO 和 FILO。\nArrayBlockingQueue      Queue       数组实现的阻塞队列。\nLinkedBlockingQueue     Queue       链表实现的阻塞队列。\nLinkedBlockingDeque     Deque       双向链表实现的双端阻塞队列。\n\nJ.U.C 包中提供的并发容器命名一般分为三类：\n\n * Concurrent\n   * 这类型的锁竞争相对于 CopyOnWrite 要高一些，但写操作代价要小一些。\n   * 此外，Concurrent 往往提供了较低的遍历一致性，即：当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。代价就是，在获取容器大小 size() ，容器是否为空等方法，不一定完全精确，但这是为了获取并发吞吐量的设计取舍，可以理解。与之相比，如果是使用同步容器，就会出现 fail-fast 问题，即：检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历。\n * CopyOnWrite - 一个线程写，多个线程读。读操作时不加锁，写操作时通过在副本上加锁保证并发安全，空间开销较大。\n * Blocking - 内部实现一般是基于锁，提供阻塞队列的能力。\n\n❌ 错误示例，产生 ConcurrentModificationException 异常：\n\npublic void removeKeys(Map<String, Object> map, final String... keys) {\n    map.keySet().removeIf(key -> ArrayUtil.contains(keys, key));\n}\n\n\n❌ 错误示例，产生 ConcurrentModificationException 异常：\n\npublic static <K, V> Map<K, V> removeKeys(Map<String, Object> map, final String... keys) {\n\tfor (K key : keys) {\n\t\tmap.remove(key);\n\t}\n\treturn map;\n}\n\n\n\n# 并发场景下的 Map\n\n如果对数据有强一致要求，则需使用 Hashtable；在大部分场景通常都是弱一致性的情况下，使用 ConcurrentHashMap 即可；如果数据量在千万级别，且存在大量增删改操作，则可以考虑使用 ConcurrentSkipListMap。\n\n\n# 并发场景下的 List\n\n读多写少用 CopyOnWriteArrayList。\n\n写多读少用 ConcurrentLinkedQueue ，但由于是无界的，要有容量限制，避免无限膨胀，导致内存溢出。\n\n\n# Map\n\nMap 接口的两个实现是 ConcurrentHashMap 和 ConcurrentSkipListMap，它们从应用的角度来看，主要区别在于ConcurrentHashMap 的 key 是无序的，而 ConcurrentSkipListMap 的 key 是有序的。所以如果你需要保证 key 的顺序，就只能使用 ConcurrentSkipListMap。\n\n使用 ConcurrentHashMap 和 ConcurrentSkipListMap 需要注意的地方是，它们的 key 和 value 都不能为空，否则会抛出NullPointerException这个运行时异常。\n\n\n# ConcurrentHashMap\n\nConcurrentHashMap 是线程安全的 HashMap ，用于替代 Hashtable。\n\n# ConcurrentHashMap 的特性\n\nConcurrentHashMap 实现了 ConcurrentMap 接口，而 ConcurrentMap 接口扩展了 Map 接口。\n\npublic class ConcurrentHashMap<K,V> extends AbstractMap<K,V>\n    implements ConcurrentMap<K,V>, Serializable {\n    // ...\n}\n\n\nConcurrentHashMap 的实现包含了 HashMap 所有的基本特性，如：数据结构、读写策略等。\n\nConcurrentHashMap 没有实现对 Map 加锁以提供独占访问。因此无法通过在客户端加锁的方式来创建新的原子操作。但是，一些常见的复合操作，如：“若没有则添加”、“若相等则移除”、“若相等则替换”，都已经实现为原子操作，并且是围绕 ConcurrentMap 的扩展接口而实现。\n\npublic interface ConcurrentMap<K, V> extends Map<K, V> {\n\n    // 仅当 K 没有相应的映射值才插入\n    V putIfAbsent(K key, V value);\n\n    // 仅当 K 被映射到 V 时才移除\n    boolean remove(Object key, Object value);\n\n    // 仅当 K 被映射到 oldValue 时才替换为 newValue\n    boolean replace(K key, V oldValue, V newValue);\n\n    // 仅当 K 被映射到某个值时才替换为 newValue\n    V replace(K key, V value);\n}\n\n\n不同于 Hashtable，ConcurrentHashMap 提供的迭代器不会抛出 ConcurrentModificationException，因此不需要在迭代过程中对容器加锁。\n\n> 🔔 注意：一些需要对整个 Map 进行计算的方法，如 size 和 isEmpty ，由于返回的结果在计算时可能已经过期，所以并非实时的精确值。这是一种策略上的权衡，在并发环境下，这类方法由于总在不断变化，所以获取其实时精确值的意义不大。ConcurrentHashMap 弱化这类方法，以换取更重要操作（如：get、put、containesKey、remove 等）的性能。\n\n# ConcurrentHashMap 的用法\n\n示例：不会出现 ConcurrentModificationException\n\nConcurrentHashMap 的基本操作与 HashMap 的用法基本一样。不同于 HashMap、Hashtable，ConcurrentHashMap 提供的迭代器不会抛出 ConcurrentModificationException，因此不需要在迭代过程中对容器加锁。\n\npublic class ConcurrentHashMapDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        // HashMap 在并发迭代访问时会抛出 ConcurrentModificationException 异常\n        // Map<Integer, Character> map = new HashMap<>();\n        Map<Integer, Character> map = new ConcurrentHashMap<>();\n\n        Thread wthread = new Thread(() -> {\n            System.out.println("写操作线程开始执行");\n            for (int i = 0; i < 26; i++) {\n                map.put(i, (char) (\'a\' + i));\n            }\n        });\n        Thread rthread = new Thread(() -> {\n            System.out.println("读操作线程开始执行");\n            for (Integer key : map.keySet()) {\n                System.out.println(key + " - " + map.get(key));\n            }\n        });\n        wthread.start();\n        rthread.start();\n        Thread.sleep(1000);\n    }\n}\n\n\n# ConcurrentHashMap 的原理\n\n> ConcurrentHashMap 一直在演进，尤其在 Java 1.7 和 Java 1.8，其数据结构和并发机制有很大的差异。\n\n * Java 1.7\n   * 数据结构：数组＋单链表\n   * 并发机制：采用分段锁机制细化锁粒度，降低阻塞，从而提高并发性。\n * Java 1.8\n   * 数据结构：数组＋单链表＋红黑树\n   * 并发机制：取消分段锁，之后基于 CAS + synchronized 实现。\n\n# Java 1.7 的实现\n\n分段锁，是将内部进行分段（Segment），里面是 HashEntry 数组，和 HashMap 类似，哈希相同的条目也是以链表形式存放。 HashEntry 内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制，以改进利用 Unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的。\n\n\n\n在进行并发写操作时，ConcurrentHashMap 会获取可重入锁（ReentrantLock），以保证数据一致性。所以，在并发修改期间，相应 Segment 是被锁定的。\n\npublic class ConcurrentHashMap<K, V> extends AbstractMap<K, V>\n        implements ConcurrentMap<K, V>, Serializable {\n\n    // 将整个hashmap分成几个小的map，每个segment都是一个锁；与hashtable相比，这么设计的目的是对于put, remove等操作，可以减少并发冲突，对\n    // 不属于同一个片段的节点可以并发操作，大大提高了性能\n    final Segment<K,V>[] segments;\n\n    // 本质上Segment类就是一个小的hashmap，里面table数组存储了各个节点的数据，继承了ReentrantLock, 可以作为互拆锁使用\n    static final class Segment<K,V> extends ReentrantLock implements Serializable {\n        transient volatile HashEntry<K,V>[] table;\n        transient int count;\n    }\n\n    // 基本节点，存储Key， Value值\n    static final class HashEntry<K,V> {\n        final int hash;\n        final K key;\n        volatile V value;\n        volatile HashEntry<K,V> next;\n    }\n}\n\n\n# Java 1.8 的实现\n\n * 数据结构改进：与 HashMap 一样，将原先 数组＋单链表 的数据结构，变更为 数组＋单链表＋红黑树 的结构。当出现哈希冲突时，数据会存入数组指定桶的单链表，当链表长度达到 8，则将其转换为红黑树结构，这样其查询的时间复杂度可以降低到 $$O(logN)$$，以改进性能。\n * 并发机制改进：\n   * 取消 segments 字段，直接采用 transient volatile HashEntry<K,V>[] table 保存数据，采用 table 数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。\n   * 使用 CAS + sychronized 操作，在特定场景进行无锁并发操作。使用 Unsafe、LongAdder 之类底层手段，进行极端情况的优化。现代 JDK 中，synchronized 已经被不断优化，可以不再过分担心性能差异，另外，相比于 ReentrantLock，它可以减少内存消耗，这是个非常大的优势。\n\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        // 如果table为空，初始化；否则，根据hash值计算得到数组索引i，如果tab[i]为空，直接新建节点Node即可。注：tab[i]实质为链表或者红黑树的首节点。\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            if (casTabAt(tab, i, null,\n                         new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        // 如果tab[i]不为空并且hash值为MOVED，说明该链表正在进行transfer操作，返回扩容完成后的table。\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            // 针对首个节点进行加锁操作，而不是segment，进一步减少线程冲突\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) {\n                        binCount = 1;\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            // 如果在链表中找到值为key的节点e，直接设置e.val = value即可。\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            // 如果没有找到值为key的节点，直接新建Node并加入链表即可。\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    // 如果首节点为TreeBin类型，说明为红黑树结构，执行putTreeVal操作。\n                    else if (f instanceof TreeBin) {\n                        Node<K,V> p;\n                        binCount = 2;\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                // 如果节点数>＝8，那么转换链表结构为红黑树结构。\n                if (binCount >= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    // 计数增加1，有可能触发transfer操作(扩容)。\n    addCount(1L, binCount);\n    return null;\n}\n\n\n# ConcurrentHashMap 的实战\n\n> 示例摘自：《Java 业务开发常见错误 100 例》\n\n# ConcurrentHashMap 错误示例\n\n    //线程个数\n    private static int THREAD_COUNT = 10;\n    //总元素数量\n    private static int ITEM_COUNT = 1000;\n\n    public static void main(String[] args) throws InterruptedException {\n        ConcurrentHashMap<String, Long> concurrentHashMap = getData(ITEM_COUNT - 100);\n        //初始900个元素\n        System.out.println("init size:" + concurrentHashMap.size());\n        ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);\n        //使用线程池并发处理逻辑\n        forkJoinPool.execute(() -> IntStream.rangeClosed(1, 10).parallel().forEach(i -> {\n            //查询还需要补充多少个元素\n            int gap = ITEM_COUNT - concurrentHashMap.size();\n            System.out.println("gap size:" + gap);\n            //补充元素\n            concurrentHashMap.putAll(getData(gap));\n        }));\n        //等待所有任务完成\n        forkJoinPool.shutdown();\n        forkJoinPool.awaitTermination(1, TimeUnit.HOURS);\n        //最后元素个数会是1000吗？\n        System.out.println("finish size:" + concurrentHashMap.size());\n    }\n\n    private static ConcurrentHashMap<String, Long> getData(int count) {\n        return LongStream.rangeClosed(1, count)\n            .boxed()\n            .collect(\n                Collectors.toConcurrentMap(\n                    i -> UUID.randomUUID().toString(),\n                    i -> i,\n                    (o1, o2) -> o1,\n                    ConcurrentHashMap::new));\n    }\n\n\n初始大小 900 符合预期，还需要填充 100 个元素。\n\n预期结果为 1000 个元素，实际大于 1000 个元素。\n\n【分析】\n\nConcurrentHashMap 对外提供的方法或能力的限制：\n\n * 使用了 ConcurrentHashMap，不代表对它的多个操作之间的状态是一致的，是没有其他线程在操作它的，如果需要确保需要手动加锁。\n * 诸如 size、isEmpty 和 containsValue 等聚合方法，在并发情况下可能会反映 ConcurrentHashMap 的中间状态。因此在并发情况下，这些方法的返回值只能用作参考，而不能用于流程控制。显然，利用 size 方法计算差异值，是一个流程控制。\n * 诸如 putAll 这样的聚合方法也不能确保原子性，在 putAll 的过程中去获取数据可能会获取到部分数据。\n\n# ConcurrentHashMap 错误示例修正 1.0 版\n\n通过 synchronized 加锁，当然可以保证数据一致性，但是牺牲了 ConcurrentHashMap 的性能，没哟真正发挥出 ConcurrentHashMap 的特性。\n\n\n    //线程个数\n    private static int THREAD_COUNT = 10;\n    //总元素数量\n    private static int ITEM_COUNT = 1000;\n\n    public static void main(String[] args) throws InterruptedException {\n        ConcurrentHashMap<String, Long> concurrentHashMap = getData(ITEM_COUNT - 100);\n        //初始900个元素\n        System.out.println("init size:" + concurrentHashMap.size());\n        ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);\n        //使用线程池并发处理逻辑\n        forkJoinPool.execute(() -> IntStream.rangeClosed(1, 10).parallel().forEach(i -> {\n            //查询还需要补充多少个元素\n            synchronized (concurrentHashMap) {\n                int gap = ITEM_COUNT - concurrentHashMap.size();\n                System.out.println("gap size:" + gap);\n                //补充元素\n                concurrentHashMap.putAll(getData(gap));\n            }\n        }));\n        //等待所有任务完成\n        forkJoinPool.shutdown();\n        forkJoinPool.awaitTermination(1, TimeUnit.HOURS);\n        //最后元素个数会是1000吗？\n        System.out.println("finish size:" + concurrentHashMap.size());\n    }\n\n    private static ConcurrentHashMap<String, Long> getData(int count) {\n        return LongStream.rangeClosed(1, count)\n            .boxed()\n            .collect(\n                Collectors.toConcurrentMap(\n                    i -> UUID.randomUUID().toString(),\n                    i -> i,\n                    (o1, o2) -> o1,\n                    ConcurrentHashMap::new));\n    }\n\n\n# ConcurrentHashMap 错误示例修正 2.0 版\n\n\n    //循环次数\n    private static int LOOP_COUNT = 10000000;\n    //线程个数\n    private static int THREAD_COUNT = 10;\n    //总元素数量\n    private static int ITEM_COUNT = 1000;\n\n    public static void main(String[] args) throws InterruptedException {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start("normaluse");\n        Map<String, Long> normaluse = normaluse();\n        stopWatch.stop();\n        Assert.isTrue(normaluse.size() == ITEM_COUNT, "normaluse size error");\n        Assert.isTrue(normaluse.values().stream()\n                .mapToLong(aLong -> aLong).reduce(0, Long::sum) == LOOP_COUNT\n            , "normaluse count error");\n        stopWatch.start("gooduse");\n        Map<String, Long> gooduse = gooduse();\n        stopWatch.stop();\n        Assert.isTrue(gooduse.size() == ITEM_COUNT, "gooduse size error");\n        Assert.isTrue(gooduse.values().stream()\n                .mapToLong(l -> l)\n                .reduce(0, Long::sum) == LOOP_COUNT\n            , "gooduse count error");\n        System.out.println(stopWatch.prettyPrint());\n    }\n\n    private static Map<String, Long> normaluse() throws InterruptedException {\n        ConcurrentHashMap<String, Long> freqs = new ConcurrentHashMap<>(ITEM_COUNT);\n        ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);\n        forkJoinPool.execute(() -> IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -> {\n                String key = "item" + ThreadLocalRandom.current().nextInt(ITEM_COUNT);\n                synchronized (freqs) {\n                    if (freqs.containsKey(key)) {\n                        freqs.put(key, freqs.get(key) + 1);\n                    } else {\n                        freqs.put(key, 1L);\n                    }\n                }\n            }\n        ));\n        forkJoinPool.shutdown();\n        forkJoinPool.awaitTermination(1, TimeUnit.HOURS);\n        return freqs;\n    }\n\n    private static Map<String, Long> gooduse() throws InterruptedException {\n        ConcurrentHashMap<String, LongAdder> freqs = new ConcurrentHashMap<>(ITEM_COUNT);\n        ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);\n        forkJoinPool.execute(() -> IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -> {\n                String key = "item" + ThreadLocalRandom.current().nextInt(ITEM_COUNT);\n                freqs.computeIfAbsent(key, k -> new LongAdder()).increment();\n            }\n        ));\n        forkJoinPool.shutdown();\n        forkJoinPool.awaitTermination(1, TimeUnit.HOURS);\n        return freqs.entrySet().stream()\n            .collect(Collectors.toMap(\n                e -> e.getKey(),\n                e -> e.getValue().longValue())\n            );\n    }\n\n\n\n# List\n\n\n# CopyOnWriteArrayList\n\nCopyOnWriteArrayList 是线程安全的 ArrayList。CopyOnWrite 字面意思为写的时候会将共享变量新复制一份出来。复制的好处在于读操作是无锁的（也就是无阻塞）。\n\nCopyOnWriteArrayList 仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。如果读写比例均衡或者有大量写操作的话，使用 CopyOnWriteArrayList 的性能会非常糟糕。\n\n# CopyOnWriteArrayList 原理\n\nCopyOnWriteArrayList 内部维护了一个数组，成员变量 array 就指向这个内部数组，所有的读操作都是基于 array 进行的，如下图所示，迭代器 Iterator 遍历的就是 array 数组。\n\n\n\n * lock - 执行写时复制操作，需要使用可重入锁加锁\n * array - 对象数组，用于存放元素\n\n    /** The lock protecting all mutators */\n    final transient ReentrantLock lock = new ReentrantLock();\n\n    /** The array, accessed only via getArray/setArray. */\n    private transient volatile Object[] array;\n\n\n\n\n（1）读操作\n\n在 CopyOnWriteAarrayList 中，读操作不同步，因为它们在内部数组的快照上工作，所以多个迭代器可以同时遍历而不会相互阻塞（图 1,2,4）。\n\nCopyOnWriteArrayList 的读操作是不用加锁的，性能很高。\n\npublic E get(int index) {\n    return get(getArray(), index);\n}\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\n\n\n（2）写操作\n\n所有的写操作都是同步的。他们在备份数组（图 3）的副本上工作。写操作完成后，后备阵列将被替换为复制的阵列，并释放锁定。支持数组变得易变，所以替换数组的调用是原子（图 5）。\n\n写操作后创建的迭代器将能够看到修改的结构（图 6,7）。\n\n写时复制集合返回的迭代器不会抛出 ConcurrentModificationException，因为它们在数组的快照上工作，并且无论后续的修改（2,4）如何，都会像迭代器创建时那样完全返回元素。\n\n添加操作 - 添加的逻辑很简单，先将原容器 copy 一份，然后在新副本上执行写操作，之后再切换引用。当然此过程是要加锁的。\n\npublic boolean add(E e) {\n    //ReentrantLock加锁，保证线程安全\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        Object[] elements = getArray();\n        int len = elements.length;\n        //拷贝原容器，长度为原容器长度加一\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        //在新副本上执行添加操作\n        newElements[len] = e;\n        //将原容器引用指向新副本\n        setArray(newElements);\n        return true;\n    } finally {\n        //解锁\n        lock.unlock();\n    }\n}\n\n\n删除操作 - 删除操作同理，将除要删除元素之外的其他元素拷贝到新副本中，然后切换引用，将原容器引用指向新副本。同属写操作，需要加锁。\n\npublic E remove(int index) {\n    //加锁\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        Object[] elements = getArray();\n        int len = elements.length;\n        E oldValue = get(elements, index);\n        int numMoved = len - index - 1;\n        if (numMoved == 0)\n            //如果要删除的是列表末端数据，拷贝前len-1个数据到新副本上，再切换引用\n            setArray(Arrays.copyOf(elements, len - 1));\n        else {\n            //否则，将除要删除元素之外的其他元素拷贝到新副本中，并切换引用\n            Object[] newElements = new Object[len - 1];\n            System.arraycopy(elements, 0, newElements, 0, index);\n            System.arraycopy(elements, index + 1, newElements, index,\n                              numMoved);\n            setArray(newElements);\n        }\n        return oldValue;\n    } finally {\n        //解锁\n        lock.unlock();\n    }\n}\n\n\n# CopyOnWriteArrayList 示例\n\npublic class CopyOnWriteArrayListDemo {\n\n    static class ReadTask implements Runnable {\n\n        List<String> list;\n\n        ReadTask(List<String> list) {\n            this.list = list;\n        }\n\n        public void run() {\n            for (String str : list) {\n                System.out.println(str);\n            }\n        }\n    }\n\n    static class WriteTask implements Runnable {\n\n        List<String> list;\n        int index;\n\n        WriteTask(List<String> list, int index) {\n            this.list = list;\n            this.index = index;\n        }\n\n        public void run() {\n            list.remove(index);\n            list.add(index, "write_" + index);\n        }\n    }\n\n    public void run() {\n        final int NUM = 10;\n        // ArrayList 在并发迭代访问时会抛出 ConcurrentModificationException 异常\n        // List<String> list = new ArrayList<>();\n        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\n        for (int i = 0; i < NUM; i++) {\n            list.add("main_" + i);\n        }\n        ExecutorService executorService = Executors.newFixedThreadPool(NUM);\n        for (int i = 0; i < NUM; i++) {\n            executorService.execute(new ReadTask(list));\n            executorService.execute(new WriteTask(list, i));\n        }\n        executorService.shutdown();\n    }\n\n    public static void main(String[] args) {\n        new CopyOnWriteArrayListDemo().run();\n    }\n}\n\n\n# CopyOnWriteArrayList 实战\n\n@Slf4j\npublic class WrongCopyOnWriteList {\n\n    public static void main(String[] args) {\n        testRead();\n        testWrite();\n    }\n\n    public static Map testWrite() {\n        List<Integer> copyOnWriteArrayList = new CopyOnWriteArrayList<>();\n        List<Integer> synchronizedList = Collections.synchronizedList(new ArrayList<>());\n        StopWatch stopWatch = new StopWatch();\n        int loopCount = 100000;\n        stopWatch.start("Write:copyOnWriteArrayList");\n        IntStream.rangeClosed(1, loopCount)\n            .parallel()\n            .forEach(__ -> copyOnWriteArrayList.add(ThreadLocalRandom.current().nextInt(loopCount)));\n        stopWatch.stop();\n        stopWatch.start("Write:synchronizedList");\n        IntStream.rangeClosed(1, loopCount)\n            .parallel()\n            .forEach(__ -> synchronizedList.add(ThreadLocalRandom.current().nextInt(loopCount)));\n        stopWatch.stop();\n        log.info(stopWatch.prettyPrint());\n        Map result = new HashMap();\n        result.put("copyOnWriteArrayList", copyOnWriteArrayList.size());\n        result.put("synchronizedList", synchronizedList.size());\n        return result;\n    }\n\n    private static void addAll(List<Integer> list) {\n        list.addAll(IntStream.rangeClosed(1, 1000000).boxed().collect(Collectors.toList()));\n    }\n\n    public static Map testRead() {\n        List<Integer> copyOnWriteArrayList = new CopyOnWriteArrayList<>();\n        List<Integer> synchronizedList = Collections.synchronizedList(new ArrayList<>());\n        addAll(copyOnWriteArrayList);\n        addAll(synchronizedList);\n        StopWatch stopWatch = new StopWatch();\n        int loopCount = 1000000;\n        int count = copyOnWriteArrayList.size();\n        stopWatch.start("Read:copyOnWriteArrayList");\n        IntStream.rangeClosed(1, loopCount)\n            .parallel()\n            .forEach(__ -> copyOnWriteArrayList.get(ThreadLocalRandom.current().nextInt(count)));\n        stopWatch.stop();\n        stopWatch.start("Read:synchronizedList");\n        IntStream.range(0, loopCount)\n            .parallel()\n            .forEach(__ -> synchronizedList.get(ThreadLocalRandom.current().nextInt(count)));\n        stopWatch.stop();\n        log.info(stopWatch.prettyPrint());\n        Map result = new HashMap();\n        result.put("copyOnWriteArrayList", copyOnWriteArrayList.size());\n        result.put("synchronizedList", synchronizedList.size());\n        return result;\n    }\n\n}\n\n\n读性能差不多是写性能的一百倍。\n\n\n# Set\n\nSet 接口的两个实现是 CopyOnWriteArraySet 和 ConcurrentSkipListSet，使用场景可以参考前面讲述的 CopyOnWriteArrayList 和 ConcurrentSkipListMap，它们的原理都是一样的。\n\n\n# Queue\n\nJava 并发包里面 Queue 这类并发容器是最复杂的，你可以从以下两个维度来分类。一个维度是阻塞与非阻塞，所谓阻塞指的是：当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。另一个维度是单端与双端，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。Java 并发包里阻塞队列都用 Blocking 关键字标识，单端队列使用 Queue 标识，双端队列使用 Deque 标识。\n\n\n# BlockingQueue\n\nBlockingQueue 顾名思义，是一个阻塞队列。BlockingQueue 基本都是基于锁实现。在 BlockingQueue 中，当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。\n\nBlockingQueue 接口定义如下：\n\npublic interface BlockingQueue<E> extends Queue<E> {}\n\n\n核心 API：\n\n// 获取并移除队列头结点，如果必要，其会等待直到队列出现元素\nE take() throws InterruptedException;\n// 插入元素，如果队列已满，则等待直到队列出现空闲空间\nvoid put(E e) throws InterruptedException;\n\n\nBlockingQueue 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用：\n\n * 抛出异常；\n * 返回特殊值（null 或 true/false，取决于具体的操作）；\n * 阻塞等待此操作，直到这个操作成功；\n * 阻塞等待此操作，直到成功或者超时指定时间。\n\n总结如下：\n\n          THROWS EXCEPTION   SPECIAL VALUE   BLOCKS           TIMES OUT\nInsert    add(e)             offer(e)        put(e)           offer(e, time, unit)\nRemove    remove()           poll()          take()           poll(time, unit)\nExamine   element()          peek()          not applicable   not applicable\n\nBlockingQueue 的各个实现类都遵循了这些规则。\n\nBlockingQueue 不接受 null 值元素。\n\nJDK 提供了以下阻塞队列：\n\n * ArrayBlockingQueue - 一个由数组结构组成的有界阻塞队列。\n * LinkedBlockingQueue - 一个由链表结构组成的有界阻塞队列。\n * PriorityBlockingQueue - 一个支持优先级排序的无界阻塞队列。\n * SynchronousQueue - 一个不存储元素的阻塞队列。\n * DelayQueue - 一个使用优先级队列实现的无界阻塞队列。\n * LinkedTransferQueue - 一个由链表结构组成的无界阻塞队列。\n\nBlockingQueue 基本都是基于锁实现。\n\n\n# PriorityBlockingQueue 类\n\nPriorityBlockingQueue 类定义如下：\n\npublic class PriorityBlockingQueue<E> extends AbstractQueue<E>\n    implements BlockingQueue<E>, java.io.Serializable {}\n\n\n# PriorityBlockingQueue 要点\n\n * PriorityBlockingQueue 可以视为 PriorityQueue 的线程安全版本。\n * PriorityBlockingQueue 实现了 BlockingQueue，也是一个阻塞队列。\n * PriorityBlockingQueue 实现了 Serializable，支持序列化。\n * PriorityBlockingQueue 不接受 null 值元素。\n * PriorityBlockingQueue 的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。\n\n# PriorityBlockingQueue 原理\n\nPriorityBlockingQueue 有两个重要成员：\n\nprivate transient Object[] queue;\nprivate final ReentrantLock lock;\n\n\n * queue 是一个 Object 数组，用于保存 PriorityBlockingQueue 的元素。\n * 而可重入锁 lock 则用于在执行插入、删除操作时，保证这个方法在当前线程释放锁之前，其他线程不能访问。\n\nPriorityBlockingQueue 的容量虽然有初始化大小，但是不限制大小，如果当前容量已满，插入新元素时会自动扩容。\n\n\n# ArrayBlockingQueue 类\n\nArrayBlockingQueue 是由数组结构组成的有界阻塞队列。\n\n# ArrayBlockingQueue 要点\n\nArrayBlockingQueue 类定义如下：\n\npublic class ArrayBlockingQueue<E> extends AbstractQueue<E>\n        implements BlockingQueue<E>, java.io.Serializable {\n    // 数组的大小就决定了队列的边界，所以初始化时必须指定容量\n    public ArrayBlockingQueue(int capacity) { //... }\n    public ArrayBlockingQueue(int capacity, boolean fair) { //... }\n    public ArrayBlockingQueue(int capacity, boolean fair, Collection<? extends E> c) { //... }\n}\n\n\n说明：\n\n * ArrayBlockingQueue 实现了 BlockingQueue，也是一个阻塞队列。\n * ArrayBlockingQueue 实现了 Serializable，支持序列化。\n * ArrayBlockingQueue 是基于数组实现的有界阻塞队列。所以初始化时必须指定容量。\n\n# ArrayBlockingQueue 原理\n\nArrayBlockingQueue 的重要成员如下：\n\n// 用于存放元素的数组\nfinal Object[] items;\n// 下一次读取操作的位置\nint takeIndex;\n// 下一次写入操作的位置\nint putIndex;\n// 队列中的元素数量\nint count;\n\n// 以下几个就是控制并发用的同步器\nfinal ReentrantLock lock;\nprivate final Condition notEmpty;\nprivate final Condition notFull;\n\n\nArrayBlockingQueue 内部以 final 的数组保存数据，数组的大小就决定了队列的边界。\n\nArrayBlockingQueue 实现并发同步的原理就是，读操作和写操作都需要获取到 AQS 独占锁才能进行操作。\n\n * 如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。\n * 如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除，然后唤醒写线程队列的第一个等待线程。\n\n对于 ArrayBlockingQueue，我们可以在构造的时候指定以下三个参数：\n\n * 队列容量，其限制了队列中最多允许的元素个数；\n * 指定独占锁是公平锁还是非公平锁。非公平锁的吞吐量比较高，公平锁可以保证每次都是等待最久的线程获取到锁；\n * 可以指定用一个集合来初始化，将此集合中的元素在构造方法期间就先添加到队列中。\n\n\n# LinkedBlockingQueue 类\n\nLinkedBlockingQueue 是由链表结构组成的有界阻塞队列。容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为 Integer.MAX_VALUE，成为了无界队列。\n\n# LinkedBlockingQueue 要点\n\nLinkedBlockingQueue 类定义如下：\n\npublic class LinkedBlockingQueue<E> extends AbstractQueue<E>\n        implements BlockingQueue<E>, java.io.Serializable {}\n\n\n * LinkedBlockingQueue 实现了 BlockingQueue，也是一个阻塞队列。\n * LinkedBlockingQueue 实现了 Serializable，支持序列化。\n * LinkedBlockingQueue 是基于单链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用。\n * LinkedBlockingQueue 中元素按照插入顺序保存（FIFO）。\n\n# LinkedBlockingQueue 原理\n\nLinkedBlockingQueue 中的重要数据结构：\n\n// 队列容量\nprivate final int capacity;\n// 队列中的元素数量\nprivate final AtomicInteger count = new AtomicInteger(0);\n// 队头\nprivate transient Node<E> head;\n// 队尾\nprivate transient Node<E> last;\n\n// take, poll, peek 等读操作的方法需要获取到这个锁\nprivate final ReentrantLock takeLock = new ReentrantLock();\n// 如果读操作的时候队列是空的，那么等待 notEmpty 条件\nprivate final Condition notEmpty = takeLock.newCondition();\n// put, offer 等写操作的方法需要获取到这个锁\nprivate final ReentrantLock putLock = new ReentrantLock();\n// 如果写操作的时候队列是满的，那么等待 notFull 条件\nprivate final Condition notFull = putLock.newCondition();\n\n\n这里用了两对 Lock 和 Condition，简单介绍如下：\n\n * takeLock 和 notEmpty 搭配：如果要获取（take）一个元素，需要获取 takeLock 锁，但是获取了锁还不够，如果队列此时为空，还需要队列不为空（notEmpty）这个条件（Condition）。\n * putLock 需要和 notFull 搭配：如果要插入（put）一个元素，需要获取 putLock 锁，但是获取了锁还不够，如果队列此时已满，还需要队列不是满的（notFull）这个条件（Condition）。\n\n\n# SynchronousQueue 类\n\nSynchronousQueue 是不存储元素的阻塞队列。每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。那么这个队列的容量是多少呢？是 1 吗？其实不是的，其内部容量是 0。\n\nSynchronousQueue 定义如下：\n\npublic class SynchronousQueue<E> extends AbstractQueue<E>\n    implements BlockingQueue<E>, java.io.Serializable {}\n\n\nSynchronousQueue 这个类，在线程池的实现类 ScheduledThreadPoolExecutor 中得到了应用。\n\nSynchronousQueue 的队列其实是虚的，即队列容量为 0。数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费。\n\nSynchronousQueue 中不能使用 peek 方法（在这里这个方法直接返回 null），peek 方法的语义是只读取不移除，显然，这个方法的语义是不符合 SynchronousQueue 的特征的。\n\nSynchronousQueue 也不能被迭代，因为根本就没有元素可以拿来迭代的。\n\n虽然 SynchronousQueue 间接地实现了 Collection 接口，但是如果你将其当做 Collection 来用的话，那么集合是空的。\n\n当然，SynchronousQueue 也不允许传递 null 值的（并发包中的容器类好像都不支持插入 null 值，因为 null 值往往用作其他用途，比如用于方法的返回值代表操作失败）。\n\n\n# ConcurrentLinkedDeque 类\n\nDeque 的侧重点是支持对队列头尾都进行插入和删除，所以提供了特定的方法，如:\n\n * 尾部插入时需要的 addLast(e)、offerLast(e)。\n * 尾部删除所需要的 removeLast()、pollLast()。\n\n\n# Queue 的并发应用\n\nQueue 被广泛使用在生产者 - 消费者场景。而在并发场景，利用 BlockingQueue 的阻塞机制，可以减少很多并发协调工作。\n\n这么多并发 Queue 的实现，如何选择呢？\n\n * 考虑应用场景中对队列边界的要求。ArrayBlockingQueue 是有明确的容量限制的，而 LinkedBlockingQueue 则取决于我们是否在创建时指定，SynchronousQueue 则干脆不能缓存任何元素。\n * 从空间利用角度，数组结构的 ArrayBlockingQueue 要比 LinkedBlockingQueue 紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。\n * 通用场景中，LinkedBlockingQueue 的吞吐量一般优于 ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。\n * ArrayBlockingQueue 实现比较简单，性能更好预测，属于表现稳定的“选手”。\n * 可能令人意外的是，很多时候 SynchronousQueue 的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。\n\n\n# 参考资料\n\n * 《Java 并发编程实战》\n * 《Java 并发编程的艺术》\n * https://blog.csdn.net/u010425776/article/details/54890215\n * https://blog.csdn.net/wangxiaotongfan/article/details/52074160\n * https://my.oschina.net/hosee/blog/675884\n * https://www.jianshu.com/p/c0642afe03e0\n * https://www.jianshu.com/p/f6730d5784ad\n * http://www.javarticles.com/2012/06/copyonwritearraylist.html\n * https://www.cnblogs.com/xrq730/p/5020760.html\n * https://www.cnblogs.com/leesf456/p/5547853.html\n * http://www.cnblogs.com/chengxiao/p/6881974.html\n * http://www.cnblogs.com/dolphin0520/p/3933404.html\n * HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！',normalizedContent:'# java 并发和容器\n\n\n# 同步容器\n\n\n# 同步容器简介\n\n在 java 中，同步容器主要包括 2 类：\n\n * vector、stack、hashtable\n   * vector - vector 实现了 list 接口。vector 实际上就是一个数组，和 arraylist 类似。但是 vector 中的方法都是 synchronized 方法，即进行了同步措施。\n   * stack - stack 也是一个同步容器，它的方法也用 synchronized 进行了同步，它实际上是继承于 vector 类。\n   * hashtable- hashtable 实现了 map 接口，它和 hashmap 很相似，但是 hashtable 进行了同步处理，而 hashmap 没有。\n * collections 类中提供的静态工厂方法创建的类（由 collections.synchronizedxxx 等方法）\n\n\n# 同步容器的问题\n\n同步容器的同步原理就是在其 get、set、size 等主要方法上用 synchronized 修饰。 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。\n\n> 想详细了解 synchronized 用法和原理可以参考：java 并发核心机制\n\n# 性能问题\n\nsynchronized 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 synchronized 的容器性能要差很多。\n\n> 注：尤其是在 java 1.6 没有对 synchronized 进行优化前，阻塞开销很高。\n\n# 安全问题\n\n同步容器真的绝对安全吗？\n\n其实也未必。在做复合操作（非原子操作）时，仍然需要加锁来保护。常见复合操作如下：\n\n * 迭代：反复访问元素，直到遍历完全部元素；\n * 跳转：根据指定顺序寻找当前元素的下一个（下 n 个）元素；\n * 条件运算：例如若没有则添加等；\n\n❌ 不安全的示例\n\npublic class vectordemo {\n\n    static vector<integer> vector = new vector<>();\n\n    public static void main(string[] args) {\n        while (true) {\n            vector.clear();\n\n            for (int i = 0; i < 10; i++) {\n                vector.add(i);\n            }\n\n            thread thread1 = new thread() {\n                @override\n                public void run() {\n                    for (int i = 0; i < vector.size(); i++) {\n                        vector.remove(i);\n                    }\n                }\n            };\n\n            thread thread2 = new thread() {\n                @override\n                public void run() {\n                    for (int i = 0; i < vector.size(); i++) {\n                        vector.get(i);\n                    }\n                }\n            };\n\n            thread1.start();\n            thread2.start();\n\n            while (thread.activecount() > 10) {\n                system.out.println("同时存在 10 个以上线程，退出");\n                return;\n            }\n        }\n    }\n\n}\n\n\n以上程序执行时可能会出现数组越界错误。\n\nvector 是线程安全的，那为什么还会报这个错？\n\n这是因为，对于 vector，虽然能保证每一个时刻只能有一个线程访问它，但是不排除这种可能：\n\n当某个线程在某个时刻执行这句时：\n\nfor(int i=0;i<vector.size();i++)\n    vector.get(i);\n\n\n假若此时 vector 的 size 方法返回的是 10，i 的值为 9\n\n然后另外一个线程执行了这句：\n\nfor(int i=0;i<vector.size();i++)\n    vector.remove(i);\n\n\n将下标为 9 的元素删除了。\n\n那么通过 get 方法访问下标为 9 的元素肯定就会出问题了。\n\n✔ 安全示例\n\n因此为了保证线程安全，必须在方法调用端做额外的同步措施，如下面所示：\n\npublic class vectordemo2 {\n\n    static vector<integer> vector = new vector<integer>();\n\n    public static void main(string[] args) {\n        while (true) {\n            for (int i = 0; i < 10; i++) {\n                vector.add(i);\n            }\n\n            thread thread1 = new thread() {\n                @override\n                public void run() {\n                    synchronized (vectordemo2.class) {   //进行额外的同步\n                        for (int i = 0; i < vector.size(); i++) {\n                            vector.remove(i);\n                        }\n                    }\n                }\n            };\n\n            thread thread2 = new thread() {\n                @override\n                public void run() {\n                    synchronized (vectordemo2.class) {\n                        for (int i = 0; i < vector.size(); i++) {\n                            vector.get(i);\n                        }\n                    }\n                }\n            };\n\n            thread1.start();\n            thread2.start();\n\n            while (thread.activecount() > 10) {\n                system.out.println("同时存在 10 个以上线程，退出");\n                return;\n            }\n        }\n    }\n\n}\n\n\nconcurrentmodificationexception 异常\n\n在对 vector 等容器并发地进行迭代修改时，会报 concurrentmodificationexception 异常，关于这个异常将会在后续文章中讲述。\n\n但是在并发容器中不会出现这个问题。\n\n\n# 并发容器简介\n\n同步容器将所有对容器状态的访问都串行化，以保证线程安全性，这种策略会严重降低并发性。\n\njava 1.5 后提供了多种并发容器，使用并发容器来替代同步容器，可以极大地提高伸缩性并降低风险。\n\nj.u.c 包中提供了几个非常有用的并发容器作为线程安全的容器：\n\n并发容器                    对应的普通容器     描述\nconcurrenthashmap       hashmap     java 1.8 之前采用分段锁机制细化锁粒度，降低阻塞，从而提高并发性；java 1.8 之后基于 cas 实现。\nconcurrentskiplistmap   sortedmap   基于跳表实现的\ncopyonwritearraylist    arraylist   \ncopyonwritearrayset     set         基于 copyonwritearraylist 实现。\nconcurrentskiplistset   sortedset   基于 concurrentskiplistmap 实现。\nconcurrentlinkedqueue   queue       线程安全的无界队列。底层采用单链表。支持 fifo。\nconcurrentlinkeddeque   deque       线程安全的无界双端队列。底层采用双向链表。支持 fifo 和 filo。\narrayblockingqueue      queue       数组实现的阻塞队列。\nlinkedblockingqueue     queue       链表实现的阻塞队列。\nlinkedblockingdeque     deque       双向链表实现的双端阻塞队列。\n\nj.u.c 包中提供的并发容器命名一般分为三类：\n\n * concurrent\n   * 这类型的锁竞争相对于 copyonwrite 要高一些，但写操作代价要小一些。\n   * 此外，concurrent 往往提供了较低的遍历一致性，即：当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。代价就是，在获取容器大小 size() ，容器是否为空等方法，不一定完全精确，但这是为了获取并发吞吐量的设计取舍，可以理解。与之相比，如果是使用同步容器，就会出现 fail-fast 问题，即：检测到容器在遍历过程中发生了修改，则抛出 concurrentmodificationexception，不再继续遍历。\n * copyonwrite - 一个线程写，多个线程读。读操作时不加锁，写操作时通过在副本上加锁保证并发安全，空间开销较大。\n * blocking - 内部实现一般是基于锁，提供阻塞队列的能力。\n\n❌ 错误示例，产生 concurrentmodificationexception 异常：\n\npublic void removekeys(map<string, object> map, final string... keys) {\n    map.keyset().removeif(key -> arrayutil.contains(keys, key));\n}\n\n\n❌ 错误示例，产生 concurrentmodificationexception 异常：\n\npublic static <k, v> map<k, v> removekeys(map<string, object> map, final string... keys) {\n\tfor (k key : keys) {\n\t\tmap.remove(key);\n\t}\n\treturn map;\n}\n\n\n\n# 并发场景下的 map\n\n如果对数据有强一致要求，则需使用 hashtable；在大部分场景通常都是弱一致性的情况下，使用 concurrenthashmap 即可；如果数据量在千万级别，且存在大量增删改操作，则可以考虑使用 concurrentskiplistmap。\n\n\n# 并发场景下的 list\n\n读多写少用 copyonwritearraylist。\n\n写多读少用 concurrentlinkedqueue ，但由于是无界的，要有容量限制，避免无限膨胀，导致内存溢出。\n\n\n# map\n\nmap 接口的两个实现是 concurrenthashmap 和 concurrentskiplistmap，它们从应用的角度来看，主要区别在于concurrenthashmap 的 key 是无序的，而 concurrentskiplistmap 的 key 是有序的。所以如果你需要保证 key 的顺序，就只能使用 concurrentskiplistmap。\n\n使用 concurrenthashmap 和 concurrentskiplistmap 需要注意的地方是，它们的 key 和 value 都不能为空，否则会抛出nullpointerexception这个运行时异常。\n\n\n# concurrenthashmap\n\nconcurrenthashmap 是线程安全的 hashmap ，用于替代 hashtable。\n\n# concurrenthashmap 的特性\n\nconcurrenthashmap 实现了 concurrentmap 接口，而 concurrentmap 接口扩展了 map 接口。\n\npublic class concurrenthashmap<k,v> extends abstractmap<k,v>\n    implements concurrentmap<k,v>, serializable {\n    // ...\n}\n\n\nconcurrenthashmap 的实现包含了 hashmap 所有的基本特性，如：数据结构、读写策略等。\n\nconcurrenthashmap 没有实现对 map 加锁以提供独占访问。因此无法通过在客户端加锁的方式来创建新的原子操作。但是，一些常见的复合操作，如：“若没有则添加”、“若相等则移除”、“若相等则替换”，都已经实现为原子操作，并且是围绕 concurrentmap 的扩展接口而实现。\n\npublic interface concurrentmap<k, v> extends map<k, v> {\n\n    // 仅当 k 没有相应的映射值才插入\n    v putifabsent(k key, v value);\n\n    // 仅当 k 被映射到 v 时才移除\n    boolean remove(object key, object value);\n\n    // 仅当 k 被映射到 oldvalue 时才替换为 newvalue\n    boolean replace(k key, v oldvalue, v newvalue);\n\n    // 仅当 k 被映射到某个值时才替换为 newvalue\n    v replace(k key, v value);\n}\n\n\n不同于 hashtable，concurrenthashmap 提供的迭代器不会抛出 concurrentmodificationexception，因此不需要在迭代过程中对容器加锁。\n\n> 🔔 注意：一些需要对整个 map 进行计算的方法，如 size 和 isempty ，由于返回的结果在计算时可能已经过期，所以并非实时的精确值。这是一种策略上的权衡，在并发环境下，这类方法由于总在不断变化，所以获取其实时精确值的意义不大。concurrenthashmap 弱化这类方法，以换取更重要操作（如：get、put、containeskey、remove 等）的性能。\n\n# concurrenthashmap 的用法\n\n示例：不会出现 concurrentmodificationexception\n\nconcurrenthashmap 的基本操作与 hashmap 的用法基本一样。不同于 hashmap、hashtable，concurrenthashmap 提供的迭代器不会抛出 concurrentmodificationexception，因此不需要在迭代过程中对容器加锁。\n\npublic class concurrenthashmapdemo {\n\n    public static void main(string[] args) throws interruptedexception {\n\n        // hashmap 在并发迭代访问时会抛出 concurrentmodificationexception 异常\n        // map<integer, character> map = new hashmap<>();\n        map<integer, character> map = new concurrenthashmap<>();\n\n        thread wthread = new thread(() -> {\n            system.out.println("写操作线程开始执行");\n            for (int i = 0; i < 26; i++) {\n                map.put(i, (char) (\'a\' + i));\n            }\n        });\n        thread rthread = new thread(() -> {\n            system.out.println("读操作线程开始执行");\n            for (integer key : map.keyset()) {\n                system.out.println(key + " - " + map.get(key));\n            }\n        });\n        wthread.start();\n        rthread.start();\n        thread.sleep(1000);\n    }\n}\n\n\n# concurrenthashmap 的原理\n\n> concurrenthashmap 一直在演进，尤其在 java 1.7 和 java 1.8，其数据结构和并发机制有很大的差异。\n\n * java 1.7\n   * 数据结构：数组＋单链表\n   * 并发机制：采用分段锁机制细化锁粒度，降低阻塞，从而提高并发性。\n * java 1.8\n   * 数据结构：数组＋单链表＋红黑树\n   * 并发机制：取消分段锁，之后基于 cas + synchronized 实现。\n\n# java 1.7 的实现\n\n分段锁，是将内部进行分段（segment），里面是 hashentry 数组，和 hashmap 类似，哈希相同的条目也是以链表形式存放。 hashentry 内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制，以改进利用 unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 unsafe 中的很多操作都是 jvm intrinsic 优化过的。\n\n\n\n在进行并发写操作时，concurrenthashmap 会获取可重入锁（reentrantlock），以保证数据一致性。所以，在并发修改期间，相应 segment 是被锁定的。\n\npublic class concurrenthashmap<k, v> extends abstractmap<k, v>\n        implements concurrentmap<k, v>, serializable {\n\n    // 将整个hashmap分成几个小的map，每个segment都是一个锁；与hashtable相比，这么设计的目的是对于put, remove等操作，可以减少并发冲突，对\n    // 不属于同一个片段的节点可以并发操作，大大提高了性能\n    final segment<k,v>[] segments;\n\n    // 本质上segment类就是一个小的hashmap，里面table数组存储了各个节点的数据，继承了reentrantlock, 可以作为互拆锁使用\n    static final class segment<k,v> extends reentrantlock implements serializable {\n        transient volatile hashentry<k,v>[] table;\n        transient int count;\n    }\n\n    // 基本节点，存储key， value值\n    static final class hashentry<k,v> {\n        final int hash;\n        final k key;\n        volatile v value;\n        volatile hashentry<k,v> next;\n    }\n}\n\n\n# java 1.8 的实现\n\n * 数据结构改进：与 hashmap 一样，将原先 数组＋单链表 的数据结构，变更为 数组＋单链表＋红黑树 的结构。当出现哈希冲突时，数据会存入数组指定桶的单链表，当链表长度达到 8，则将其转换为红黑树结构，这样其查询的时间复杂度可以降低到 $$o(logn)$$，以改进性能。\n * 并发机制改进：\n   * 取消 segments 字段，直接采用 transient volatile hashentry<k,v>[] table 保存数据，采用 table 数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。\n   * 使用 cas + sychronized 操作，在特定场景进行无锁并发操作。使用 unsafe、longadder 之类底层手段，进行极端情况的优化。现代 jdk 中，synchronized 已经被不断优化，可以不再过分担心性能差异，另外，相比于 reentrantlock，它可以减少内存消耗，这是个非常大的优势。\n\nfinal v putval(k key, v value, boolean onlyifabsent) {\n    if (key == null || value == null) throw new nullpointerexception();\n    int hash = spread(key.hashcode());\n    int bincount = 0;\n    for (node<k,v>[] tab = table;;) {\n        node<k,v> f; int n, i, fh;\n        // 如果table为空，初始化；否则，根据hash值计算得到数组索引i，如果tab[i]为空，直接新建节点node即可。注：tab[i]实质为链表或者红黑树的首节点。\n        if (tab == null || (n = tab.length) == 0)\n            tab = inittable();\n        else if ((f = tabat(tab, i = (n - 1) & hash)) == null) {\n            if (castabat(tab, i, null,\n                         new node<k,v>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        // 如果tab[i]不为空并且hash值为moved，说明该链表正在进行transfer操作，返回扩容完成后的table。\n        else if ((fh = f.hash) == moved)\n            tab = helptransfer(tab, f);\n        else {\n            v oldval = null;\n            // 针对首个节点进行加锁操作，而不是segment，进一步减少线程冲突\n            synchronized (f) {\n                if (tabat(tab, i) == f) {\n                    if (fh >= 0) {\n                        bincount = 1;\n                        for (node<k,v> e = f;; ++bincount) {\n                            k ek;\n                            // 如果在链表中找到值为key的节点e，直接设置e.val = value即可。\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldval = e.val;\n                                if (!onlyifabsent)\n                                    e.val = value;\n                                break;\n                            }\n                            // 如果没有找到值为key的节点，直接新建node并加入链表即可。\n                            node<k,v> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new node<k,v>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    // 如果首节点为treebin类型，说明为红黑树结构，执行puttreeval操作。\n                    else if (f instanceof treebin) {\n                        node<k,v> p;\n                        bincount = 2;\n                        if ((p = ((treebin<k,v>)f).puttreeval(hash, key,\n                                                       value)) != null) {\n                            oldval = p.val;\n                            if (!onlyifabsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            if (bincount != 0) {\n                // 如果节点数>＝8，那么转换链表结构为红黑树结构。\n                if (bincount >= treeify_threshold)\n                    treeifybin(tab, i);\n                if (oldval != null)\n                    return oldval;\n                break;\n            }\n        }\n    }\n    // 计数增加1，有可能触发transfer操作(扩容)。\n    addcount(1l, bincount);\n    return null;\n}\n\n\n# concurrenthashmap 的实战\n\n> 示例摘自：《java 业务开发常见错误 100 例》\n\n# concurrenthashmap 错误示例\n\n    //线程个数\n    private static int thread_count = 10;\n    //总元素数量\n    private static int item_count = 1000;\n\n    public static void main(string[] args) throws interruptedexception {\n        concurrenthashmap<string, long> concurrenthashmap = getdata(item_count - 100);\n        //初始900个元素\n        system.out.println("init size:" + concurrenthashmap.size());\n        forkjoinpool forkjoinpool = new forkjoinpool(thread_count);\n        //使用线程池并发处理逻辑\n        forkjoinpool.execute(() -> intstream.rangeclosed(1, 10).parallel().foreach(i -> {\n            //查询还需要补充多少个元素\n            int gap = item_count - concurrenthashmap.size();\n            system.out.println("gap size:" + gap);\n            //补充元素\n            concurrenthashmap.putall(getdata(gap));\n        }));\n        //等待所有任务完成\n        forkjoinpool.shutdown();\n        forkjoinpool.awaittermination(1, timeunit.hours);\n        //最后元素个数会是1000吗？\n        system.out.println("finish size:" + concurrenthashmap.size());\n    }\n\n    private static concurrenthashmap<string, long> getdata(int count) {\n        return longstream.rangeclosed(1, count)\n            .boxed()\n            .collect(\n                collectors.toconcurrentmap(\n                    i -> uuid.randomuuid().tostring(),\n                    i -> i,\n                    (o1, o2) -> o1,\n                    concurrenthashmap::new));\n    }\n\n\n初始大小 900 符合预期，还需要填充 100 个元素。\n\n预期结果为 1000 个元素，实际大于 1000 个元素。\n\n【分析】\n\nconcurrenthashmap 对外提供的方法或能力的限制：\n\n * 使用了 concurrenthashmap，不代表对它的多个操作之间的状态是一致的，是没有其他线程在操作它的，如果需要确保需要手动加锁。\n * 诸如 size、isempty 和 containsvalue 等聚合方法，在并发情况下可能会反映 concurrenthashmap 的中间状态。因此在并发情况下，这些方法的返回值只能用作参考，而不能用于流程控制。显然，利用 size 方法计算差异值，是一个流程控制。\n * 诸如 putall 这样的聚合方法也不能确保原子性，在 putall 的过程中去获取数据可能会获取到部分数据。\n\n# concurrenthashmap 错误示例修正 1.0 版\n\n通过 synchronized 加锁，当然可以保证数据一致性，但是牺牲了 concurrenthashmap 的性能，没哟真正发挥出 concurrenthashmap 的特性。\n\n\n    //线程个数\n    private static int thread_count = 10;\n    //总元素数量\n    private static int item_count = 1000;\n\n    public static void main(string[] args) throws interruptedexception {\n        concurrenthashmap<string, long> concurrenthashmap = getdata(item_count - 100);\n        //初始900个元素\n        system.out.println("init size:" + concurrenthashmap.size());\n        forkjoinpool forkjoinpool = new forkjoinpool(thread_count);\n        //使用线程池并发处理逻辑\n        forkjoinpool.execute(() -> intstream.rangeclosed(1, 10).parallel().foreach(i -> {\n            //查询还需要补充多少个元素\n            synchronized (concurrenthashmap) {\n                int gap = item_count - concurrenthashmap.size();\n                system.out.println("gap size:" + gap);\n                //补充元素\n                concurrenthashmap.putall(getdata(gap));\n            }\n        }));\n        //等待所有任务完成\n        forkjoinpool.shutdown();\n        forkjoinpool.awaittermination(1, timeunit.hours);\n        //最后元素个数会是1000吗？\n        system.out.println("finish size:" + concurrenthashmap.size());\n    }\n\n    private static concurrenthashmap<string, long> getdata(int count) {\n        return longstream.rangeclosed(1, count)\n            .boxed()\n            .collect(\n                collectors.toconcurrentmap(\n                    i -> uuid.randomuuid().tostring(),\n                    i -> i,\n                    (o1, o2) -> o1,\n                    concurrenthashmap::new));\n    }\n\n\n# concurrenthashmap 错误示例修正 2.0 版\n\n\n    //循环次数\n    private static int loop_count = 10000000;\n    //线程个数\n    private static int thread_count = 10;\n    //总元素数量\n    private static int item_count = 1000;\n\n    public static void main(string[] args) throws interruptedexception {\n        stopwatch stopwatch = new stopwatch();\n        stopwatch.start("normaluse");\n        map<string, long> normaluse = normaluse();\n        stopwatch.stop();\n        assert.istrue(normaluse.size() == item_count, "normaluse size error");\n        assert.istrue(normaluse.values().stream()\n                .maptolong(along -> along).reduce(0, long::sum) == loop_count\n            , "normaluse count error");\n        stopwatch.start("gooduse");\n        map<string, long> gooduse = gooduse();\n        stopwatch.stop();\n        assert.istrue(gooduse.size() == item_count, "gooduse size error");\n        assert.istrue(gooduse.values().stream()\n                .maptolong(l -> l)\n                .reduce(0, long::sum) == loop_count\n            , "gooduse count error");\n        system.out.println(stopwatch.prettyprint());\n    }\n\n    private static map<string, long> normaluse() throws interruptedexception {\n        concurrenthashmap<string, long> freqs = new concurrenthashmap<>(item_count);\n        forkjoinpool forkjoinpool = new forkjoinpool(thread_count);\n        forkjoinpool.execute(() -> intstream.rangeclosed(1, loop_count).parallel().foreach(i -> {\n                string key = "item" + threadlocalrandom.current().nextint(item_count);\n                synchronized (freqs) {\n                    if (freqs.containskey(key)) {\n                        freqs.put(key, freqs.get(key) + 1);\n                    } else {\n                        freqs.put(key, 1l);\n                    }\n                }\n            }\n        ));\n        forkjoinpool.shutdown();\n        forkjoinpool.awaittermination(1, timeunit.hours);\n        return freqs;\n    }\n\n    private static map<string, long> gooduse() throws interruptedexception {\n        concurrenthashmap<string, longadder> freqs = new concurrenthashmap<>(item_count);\n        forkjoinpool forkjoinpool = new forkjoinpool(thread_count);\n        forkjoinpool.execute(() -> intstream.rangeclosed(1, loop_count).parallel().foreach(i -> {\n                string key = "item" + threadlocalrandom.current().nextint(item_count);\n                freqs.computeifabsent(key, k -> new longadder()).increment();\n            }\n        ));\n        forkjoinpool.shutdown();\n        forkjoinpool.awaittermination(1, timeunit.hours);\n        return freqs.entryset().stream()\n            .collect(collectors.tomap(\n                e -> e.getkey(),\n                e -> e.getvalue().longvalue())\n            );\n    }\n\n\n\n# list\n\n\n# copyonwritearraylist\n\ncopyonwritearraylist 是线程安全的 arraylist。copyonwrite 字面意思为写的时候会将共享变量新复制一份出来。复制的好处在于读操作是无锁的（也就是无阻塞）。\n\ncopyonwritearraylist 仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。如果读写比例均衡或者有大量写操作的话，使用 copyonwritearraylist 的性能会非常糟糕。\n\n# copyonwritearraylist 原理\n\ncopyonwritearraylist 内部维护了一个数组，成员变量 array 就指向这个内部数组，所有的读操作都是基于 array 进行的，如下图所示，迭代器 iterator 遍历的就是 array 数组。\n\n\n\n * lock - 执行写时复制操作，需要使用可重入锁加锁\n * array - 对象数组，用于存放元素\n\n    /** the lock protecting all mutators */\n    final transient reentrantlock lock = new reentrantlock();\n\n    /** the array, accessed only via getarray/setarray. */\n    private transient volatile object[] array;\n\n\n\n\n（1）读操作\n\n在 copyonwriteaarraylist 中，读操作不同步，因为它们在内部数组的快照上工作，所以多个迭代器可以同时遍历而不会相互阻塞（图 1,2,4）。\n\ncopyonwritearraylist 的读操作是不用加锁的，性能很高。\n\npublic e get(int index) {\n    return get(getarray(), index);\n}\nprivate e get(object[] a, int index) {\n    return (e) a[index];\n}\n\n\n（2）写操作\n\n所有的写操作都是同步的。他们在备份数组（图 3）的副本上工作。写操作完成后，后备阵列将被替换为复制的阵列，并释放锁定。支持数组变得易变，所以替换数组的调用是原子（图 5）。\n\n写操作后创建的迭代器将能够看到修改的结构（图 6,7）。\n\n写时复制集合返回的迭代器不会抛出 concurrentmodificationexception，因为它们在数组的快照上工作，并且无论后续的修改（2,4）如何，都会像迭代器创建时那样完全返回元素。\n\n添加操作 - 添加的逻辑很简单，先将原容器 copy 一份，然后在新副本上执行写操作，之后再切换引用。当然此过程是要加锁的。\n\npublic boolean add(e e) {\n    //reentrantlock加锁，保证线程安全\n    final reentrantlock lock = this.lock;\n    lock.lock();\n    try {\n        object[] elements = getarray();\n        int len = elements.length;\n        //拷贝原容器，长度为原容器长度加一\n        object[] newelements = arrays.copyof(elements, len + 1);\n        //在新副本上执行添加操作\n        newelements[len] = e;\n        //将原容器引用指向新副本\n        setarray(newelements);\n        return true;\n    } finally {\n        //解锁\n        lock.unlock();\n    }\n}\n\n\n删除操作 - 删除操作同理，将除要删除元素之外的其他元素拷贝到新副本中，然后切换引用，将原容器引用指向新副本。同属写操作，需要加锁。\n\npublic e remove(int index) {\n    //加锁\n    final reentrantlock lock = this.lock;\n    lock.lock();\n    try {\n        object[] elements = getarray();\n        int len = elements.length;\n        e oldvalue = get(elements, index);\n        int nummoved = len - index - 1;\n        if (nummoved == 0)\n            //如果要删除的是列表末端数据，拷贝前len-1个数据到新副本上，再切换引用\n            setarray(arrays.copyof(elements, len - 1));\n        else {\n            //否则，将除要删除元素之外的其他元素拷贝到新副本中，并切换引用\n            object[] newelements = new object[len - 1];\n            system.arraycopy(elements, 0, newelements, 0, index);\n            system.arraycopy(elements, index + 1, newelements, index,\n                              nummoved);\n            setarray(newelements);\n        }\n        return oldvalue;\n    } finally {\n        //解锁\n        lock.unlock();\n    }\n}\n\n\n# copyonwritearraylist 示例\n\npublic class copyonwritearraylistdemo {\n\n    static class readtask implements runnable {\n\n        list<string> list;\n\n        readtask(list<string> list) {\n            this.list = list;\n        }\n\n        public void run() {\n            for (string str : list) {\n                system.out.println(str);\n            }\n        }\n    }\n\n    static class writetask implements runnable {\n\n        list<string> list;\n        int index;\n\n        writetask(list<string> list, int index) {\n            this.list = list;\n            this.index = index;\n        }\n\n        public void run() {\n            list.remove(index);\n            list.add(index, "write_" + index);\n        }\n    }\n\n    public void run() {\n        final int num = 10;\n        // arraylist 在并发迭代访问时会抛出 concurrentmodificationexception 异常\n        // list<string> list = new arraylist<>();\n        copyonwritearraylist<string> list = new copyonwritearraylist<>();\n        for (int i = 0; i < num; i++) {\n            list.add("main_" + i);\n        }\n        executorservice executorservice = executors.newfixedthreadpool(num);\n        for (int i = 0; i < num; i++) {\n            executorservice.execute(new readtask(list));\n            executorservice.execute(new writetask(list, i));\n        }\n        executorservice.shutdown();\n    }\n\n    public static void main(string[] args) {\n        new copyonwritearraylistdemo().run();\n    }\n}\n\n\n# copyonwritearraylist 实战\n\n@slf4j\npublic class wrongcopyonwritelist {\n\n    public static void main(string[] args) {\n        testread();\n        testwrite();\n    }\n\n    public static map testwrite() {\n        list<integer> copyonwritearraylist = new copyonwritearraylist<>();\n        list<integer> synchronizedlist = collections.synchronizedlist(new arraylist<>());\n        stopwatch stopwatch = new stopwatch();\n        int loopcount = 100000;\n        stopwatch.start("write:copyonwritearraylist");\n        intstream.rangeclosed(1, loopcount)\n            .parallel()\n            .foreach(__ -> copyonwritearraylist.add(threadlocalrandom.current().nextint(loopcount)));\n        stopwatch.stop();\n        stopwatch.start("write:synchronizedlist");\n        intstream.rangeclosed(1, loopcount)\n            .parallel()\n            .foreach(__ -> synchronizedlist.add(threadlocalrandom.current().nextint(loopcount)));\n        stopwatch.stop();\n        log.info(stopwatch.prettyprint());\n        map result = new hashmap();\n        result.put("copyonwritearraylist", copyonwritearraylist.size());\n        result.put("synchronizedlist", synchronizedlist.size());\n        return result;\n    }\n\n    private static void addall(list<integer> list) {\n        list.addall(intstream.rangeclosed(1, 1000000).boxed().collect(collectors.tolist()));\n    }\n\n    public static map testread() {\n        list<integer> copyonwritearraylist = new copyonwritearraylist<>();\n        list<integer> synchronizedlist = collections.synchronizedlist(new arraylist<>());\n        addall(copyonwritearraylist);\n        addall(synchronizedlist);\n        stopwatch stopwatch = new stopwatch();\n        int loopcount = 1000000;\n        int count = copyonwritearraylist.size();\n        stopwatch.start("read:copyonwritearraylist");\n        intstream.rangeclosed(1, loopcount)\n            .parallel()\n            .foreach(__ -> copyonwritearraylist.get(threadlocalrandom.current().nextint(count)));\n        stopwatch.stop();\n        stopwatch.start("read:synchronizedlist");\n        intstream.range(0, loopcount)\n            .parallel()\n            .foreach(__ -> synchronizedlist.get(threadlocalrandom.current().nextint(count)));\n        stopwatch.stop();\n        log.info(stopwatch.prettyprint());\n        map result = new hashmap();\n        result.put("copyonwritearraylist", copyonwritearraylist.size());\n        result.put("synchronizedlist", synchronizedlist.size());\n        return result;\n    }\n\n}\n\n\n读性能差不多是写性能的一百倍。\n\n\n# set\n\nset 接口的两个实现是 copyonwritearrayset 和 concurrentskiplistset，使用场景可以参考前面讲述的 copyonwritearraylist 和 concurrentskiplistmap，它们的原理都是一样的。\n\n\n# queue\n\njava 并发包里面 queue 这类并发容器是最复杂的，你可以从以下两个维度来分类。一个维度是阻塞与非阻塞，所谓阻塞指的是：当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。另一个维度是单端与双端，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。java 并发包里阻塞队列都用 blocking 关键字标识，单端队列使用 queue 标识，双端队列使用 deque 标识。\n\n\n# blockingqueue\n\nblockingqueue 顾名思义，是一个阻塞队列。blockingqueue 基本都是基于锁实现。在 blockingqueue 中，当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。\n\nblockingqueue 接口定义如下：\n\npublic interface blockingqueue<e> extends queue<e> {}\n\n\n核心 api：\n\n// 获取并移除队列头结点，如果必要，其会等待直到队列出现元素\ne take() throws interruptedexception;\n// 插入元素，如果队列已满，则等待直到队列出现空闲空间\nvoid put(e e) throws interruptedexception;\n\n\nblockingqueue 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用：\n\n * 抛出异常；\n * 返回特殊值（null 或 true/false，取决于具体的操作）；\n * 阻塞等待此操作，直到这个操作成功；\n * 阻塞等待此操作，直到成功或者超时指定时间。\n\n总结如下：\n\n          throws exception   special value   blocks           times out\ninsert    add(e)             offer(e)        put(e)           offer(e, time, unit)\nremove    remove()           poll()          take()           poll(time, unit)\nexamine   element()          peek()          not applicable   not applicable\n\nblockingqueue 的各个实现类都遵循了这些规则。\n\nblockingqueue 不接受 null 值元素。\n\njdk 提供了以下阻塞队列：\n\n * arrayblockingqueue - 一个由数组结构组成的有界阻塞队列。\n * linkedblockingqueue - 一个由链表结构组成的有界阻塞队列。\n * priorityblockingqueue - 一个支持优先级排序的无界阻塞队列。\n * synchronousqueue - 一个不存储元素的阻塞队列。\n * delayqueue - 一个使用优先级队列实现的无界阻塞队列。\n * linkedtransferqueue - 一个由链表结构组成的无界阻塞队列。\n\nblockingqueue 基本都是基于锁实现。\n\n\n# priorityblockingqueue 类\n\npriorityblockingqueue 类定义如下：\n\npublic class priorityblockingqueue<e> extends abstractqueue<e>\n    implements blockingqueue<e>, java.io.serializable {}\n\n\n# priorityblockingqueue 要点\n\n * priorityblockingqueue 可以视为 priorityqueue 的线程安全版本。\n * priorityblockingqueue 实现了 blockingqueue，也是一个阻塞队列。\n * priorityblockingqueue 实现了 serializable，支持序列化。\n * priorityblockingqueue 不接受 null 值元素。\n * priorityblockingqueue 的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。\n\n# priorityblockingqueue 原理\n\npriorityblockingqueue 有两个重要成员：\n\nprivate transient object[] queue;\nprivate final reentrantlock lock;\n\n\n * queue 是一个 object 数组，用于保存 priorityblockingqueue 的元素。\n * 而可重入锁 lock 则用于在执行插入、删除操作时，保证这个方法在当前线程释放锁之前，其他线程不能访问。\n\npriorityblockingqueue 的容量虽然有初始化大小，但是不限制大小，如果当前容量已满，插入新元素时会自动扩容。\n\n\n# arrayblockingqueue 类\n\narrayblockingqueue 是由数组结构组成的有界阻塞队列。\n\n# arrayblockingqueue 要点\n\narrayblockingqueue 类定义如下：\n\npublic class arrayblockingqueue<e> extends abstractqueue<e>\n        implements blockingqueue<e>, java.io.serializable {\n    // 数组的大小就决定了队列的边界，所以初始化时必须指定容量\n    public arrayblockingqueue(int capacity) { //... }\n    public arrayblockingqueue(int capacity, boolean fair) { //... }\n    public arrayblockingqueue(int capacity, boolean fair, collection<? extends e> c) { //... }\n}\n\n\n说明：\n\n * arrayblockingqueue 实现了 blockingqueue，也是一个阻塞队列。\n * arrayblockingqueue 实现了 serializable，支持序列化。\n * arrayblockingqueue 是基于数组实现的有界阻塞队列。所以初始化时必须指定容量。\n\n# arrayblockingqueue 原理\n\narrayblockingqueue 的重要成员如下：\n\n// 用于存放元素的数组\nfinal object[] items;\n// 下一次读取操作的位置\nint takeindex;\n// 下一次写入操作的位置\nint putindex;\n// 队列中的元素数量\nint count;\n\n// 以下几个就是控制并发用的同步器\nfinal reentrantlock lock;\nprivate final condition notempty;\nprivate final condition notfull;\n\n\narrayblockingqueue 内部以 final 的数组保存数据，数组的大小就决定了队列的边界。\n\narrayblockingqueue 实现并发同步的原理就是，读操作和写操作都需要获取到 aqs 独占锁才能进行操作。\n\n * 如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。\n * 如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除，然后唤醒写线程队列的第一个等待线程。\n\n对于 arrayblockingqueue，我们可以在构造的时候指定以下三个参数：\n\n * 队列容量，其限制了队列中最多允许的元素个数；\n * 指定独占锁是公平锁还是非公平锁。非公平锁的吞吐量比较高，公平锁可以保证每次都是等待最久的线程获取到锁；\n * 可以指定用一个集合来初始化，将此集合中的元素在构造方法期间就先添加到队列中。\n\n\n# linkedblockingqueue 类\n\nlinkedblockingqueue 是由链表结构组成的有界阻塞队列。容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为 integer.max_value，成为了无界队列。\n\n# linkedblockingqueue 要点\n\nlinkedblockingqueue 类定义如下：\n\npublic class linkedblockingqueue<e> extends abstractqueue<e>\n        implements blockingqueue<e>, java.io.serializable {}\n\n\n * linkedblockingqueue 实现了 blockingqueue，也是一个阻塞队列。\n * linkedblockingqueue 实现了 serializable，支持序列化。\n * linkedblockingqueue 是基于单链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用。\n * linkedblockingqueue 中元素按照插入顺序保存（fifo）。\n\n# linkedblockingqueue 原理\n\nlinkedblockingqueue 中的重要数据结构：\n\n// 队列容量\nprivate final int capacity;\n// 队列中的元素数量\nprivate final atomicinteger count = new atomicinteger(0);\n// 队头\nprivate transient node<e> head;\n// 队尾\nprivate transient node<e> last;\n\n// take, poll, peek 等读操作的方法需要获取到这个锁\nprivate final reentrantlock takelock = new reentrantlock();\n// 如果读操作的时候队列是空的，那么等待 notempty 条件\nprivate final condition notempty = takelock.newcondition();\n// put, offer 等写操作的方法需要获取到这个锁\nprivate final reentrantlock putlock = new reentrantlock();\n// 如果写操作的时候队列是满的，那么等待 notfull 条件\nprivate final condition notfull = putlock.newcondition();\n\n\n这里用了两对 lock 和 condition，简单介绍如下：\n\n * takelock 和 notempty 搭配：如果要获取（take）一个元素，需要获取 takelock 锁，但是获取了锁还不够，如果队列此时为空，还需要队列不为空（notempty）这个条件（condition）。\n * putlock 需要和 notfull 搭配：如果要插入（put）一个元素，需要获取 putlock 锁，但是获取了锁还不够，如果队列此时已满，还需要队列不是满的（notfull）这个条件（condition）。\n\n\n# synchronousqueue 类\n\nsynchronousqueue 是不存储元素的阻塞队列。每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。那么这个队列的容量是多少呢？是 1 吗？其实不是的，其内部容量是 0。\n\nsynchronousqueue 定义如下：\n\npublic class synchronousqueue<e> extends abstractqueue<e>\n    implements blockingqueue<e>, java.io.serializable {}\n\n\nsynchronousqueue 这个类，在线程池的实现类 scheduledthreadpoolexecutor 中得到了应用。\n\nsynchronousqueue 的队列其实是虚的，即队列容量为 0。数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费。\n\nsynchronousqueue 中不能使用 peek 方法（在这里这个方法直接返回 null），peek 方法的语义是只读取不移除，显然，这个方法的语义是不符合 synchronousqueue 的特征的。\n\nsynchronousqueue 也不能被迭代，因为根本就没有元素可以拿来迭代的。\n\n虽然 synchronousqueue 间接地实现了 collection 接口，但是如果你将其当做 collection 来用的话，那么集合是空的。\n\n当然，synchronousqueue 也不允许传递 null 值的（并发包中的容器类好像都不支持插入 null 值，因为 null 值往往用作其他用途，比如用于方法的返回值代表操作失败）。\n\n\n# concurrentlinkeddeque 类\n\ndeque 的侧重点是支持对队列头尾都进行插入和删除，所以提供了特定的方法，如:\n\n * 尾部插入时需要的 addlast(e)、offerlast(e)。\n * 尾部删除所需要的 removelast()、polllast()。\n\n\n# queue 的并发应用\n\nqueue 被广泛使用在生产者 - 消费者场景。而在并发场景，利用 blockingqueue 的阻塞机制，可以减少很多并发协调工作。\n\n这么多并发 queue 的实现，如何选择呢？\n\n * 考虑应用场景中对队列边界的要求。arrayblockingqueue 是有明确的容量限制的，而 linkedblockingqueue 则取决于我们是否在创建时指定，synchronousqueue 则干脆不能缓存任何元素。\n * 从空间利用角度，数组结构的 arrayblockingqueue 要比 linkedblockingqueue 紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。\n * 通用场景中，linkedblockingqueue 的吞吐量一般优于 arrayblockingqueue，因为它实现了更加细粒度的锁操作。\n * arrayblockingqueue 实现比较简单，性能更好预测，属于表现稳定的“选手”。\n * 可能令人意外的是，很多时候 synchronousqueue 的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。\n\n\n# 参考资料\n\n * 《java 并发编程实战》\n * 《java 并发编程的艺术》\n * https://blog.csdn.net/u010425776/article/details/54890215\n * https://blog.csdn.net/wangxiaotongfan/article/details/52074160\n * https://my.oschina.net/hosee/blog/675884\n * https://www.jianshu.com/p/c0642afe03e0\n * https://www.jianshu.com/p/f6730d5784ad\n * http://www.javarticles.com/2012/06/copyonwritearraylist.html\n * https://www.cnblogs.com/xrq730/p/5020760.html\n * https://www.cnblogs.com/leesf456/p/5547853.html\n * http://www.cnblogs.com/chengxiao/p/6881974.html\n * http://www.cnblogs.com/dolphin0520/p/3933404.html\n * hashmap? concurrenthashmap? 相信看完这篇没人能难住你！',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java线程池",frontmatter:{title:"Java线程池",categories:["编程","Java","JavaSE","并发"],tags:["Java","JavaSE","并发","线程池"],abbrlink:"2b9621c6",date:"2019-12-24T23:52:25.000Z",permalink:"/pages/241a67/"},regularPath:"/05.%E5%B9%B6%E5%8F%91/07.Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html",relativePath:"05.并发/07.Java线程池.md",key:"v-2b9ad123",path:"/pages/241a67/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:15},{level:3,title:"什么是线程池",slug:"什么是线程池",normalizedTitle:"什么是线程池",charIndex:22},{level:3,title:"为什么要用线程池",slug:"为什么要用线程池",normalizedTitle:"为什么要用线程池",charIndex:80},{level:2,title:"Executor 框架",slug:"executor-框架",normalizedTitle:"executor 框架",charIndex:399},{level:3,title:"核心 API 概述",slug:"核心-api-概述",normalizedTitle:"核心 api 概述",charIndex:492},{level:3,title:"Executor",slug:"executor",normalizedTitle:"executor",charIndex:399},{level:3,title:"ExecutorService",slug:"executorservice",normalizedTitle:"executorservice",charIndex:554},{level:3,title:"ScheduledExecutorService",slug:"scheduledexecutorservice",normalizedTitle:"scheduledexecutorservice",charIndex:631},{level:2,title:"ThreadPoolExecutor",slug:"threadpoolexecutor",normalizedTitle:"threadpoolexecutor",charIndex:753},{level:3,title:"重要字段",slug:"重要字段",normalizedTitle:"重要字段",charIndex:3616},{level:3,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:5105},{level:3,title:"execute 方法",slug:"execute-方法",normalizedTitle:"execute 方法",charIndex:1008},{level:3,title:"其他重要方法",slug:"其他重要方法",normalizedTitle:"其他重要方法",charIndex:7996},{level:3,title:"使用示例",slug:"使用示例",normalizedTitle:"使用示例",charIndex:8985},{level:2,title:"Executors",slug:"executors",normalizedTitle:"executors",charIndex:905},{level:3,title:"newSingleThreadExecutor",slug:"newsinglethreadexecutor",normalizedTitle:"newsinglethreadexecutor",charIndex:10119},{level:3,title:"newFixedThreadPool",slug:"newfixedthreadpool",normalizedTitle:"newfixedthreadpool",charIndex:6870},{level:3,title:"newCachedThreadPool",slug:"newcachedthreadpool",normalizedTitle:"newcachedthreadpool",charIndex:7052},{level:3,title:"newScheduleThreadPool",slug:"newschedulethreadpool",normalizedTitle:"newschedulethreadpool",charIndex:12235},{level:3,title:"newWorkStealingPool",slug:"newworkstealingpool",normalizedTitle:"newworkstealingpool",charIndex:13411},{level:2,title:"线程池最佳实践",slug:"线程池最佳实践",normalizedTitle:"线程池最佳实践",charIndex:13506},{level:3,title:"计算线程数量",slug:"计算线程数量",normalizedTitle:"计算线程数量",charIndex:13518},{level:3,title:"建议使用有界阻塞队列",slug:"建议使用有界阻塞队列",normalizedTitle:"建议使用有界阻塞队列",charIndex:13890},{level:3,title:"重要任务应该自定义拒绝策略",slug:"重要任务应该自定义拒绝策略",normalizedTitle:"重要任务应该自定义拒绝策略",charIndex:15528},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:15735}],headersStr:"简介 什么是线程池 为什么要用线程池 Executor 框架 核心 API 概述 Executor ExecutorService ScheduledExecutorService ThreadPoolExecutor 重要字段 构造方法 execute 方法 其他重要方法 使用示例 Executors newSingleThreadExecutor newFixedThreadPool newCachedThreadPool newScheduleThreadPool newWorkStealingPool 线程池最佳实践 计算线程数量 建议使用有界阻塞队列 重要任务应该自定义拒绝策略 参考资料",content:'# Java 线程池\n\n\n# 简介\n\n\n# 什么是线程池\n\n线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。\n\n\n# 为什么要用线程池\n\n如果并发请求数量很多，但每个线程执行的时间很短，就会出现频繁的创建和销毁线程。如此一来，会大大降低系统的效率，可能频繁创建和销毁线程的时间、资源开销要大于实际工作的所需。\n\n正是由于这个问题，所以有必要引入线程池。使用 线程池的好处 有以下几点：\n\n * 降低资源消耗 - 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n * 提高响应速度 - 当任务到达时，任务可以不需要等到线程创建就能立即执行。\n * 提高线程的可管理性 - 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。\n\n\n# Executor 框架\n\n> Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。\n\n\n# 核心 API 概述\n\nExecutor 框架核心 API 如下：\n\n * Executor - 运行任务的简单接口。\n * ExecutorService - 扩展了 Executor 接口。扩展能力：\n   * 支持有返回值的线程；\n   * 支持管理线程的生命周期。\n * ScheduledExecutorService - 扩展了 ExecutorService 接口。扩展能力：支持定期执行任务。\n * AbstractExecutorService - ExecutorService 接口的默认实现。\n * ThreadPoolExecutor - Executor 框架最核心的类，它继承了 AbstractExecutorService 类。\n * ScheduledThreadPoolExecutor - ScheduledExecutorService 接口的实现，一个可定时调度任务的线程池。\n * Executors - 可以通过调用 Executors 的静态工厂方法来创建线程池并返回一个 ExecutorService 对象。\n\n\n\n\n# Executor\n\nExecutor 接口中只定义了一个 execute 方法，用于接收一个 Runnable 对象。\n\npublic interface Executor {\n    void execute(Runnable command);\n}\n\n\n\n# ExecutorService\n\nExecutorService 接口继承了 Executor 接口，它还提供了 invokeAll、invokeAny、shutdown、submit 等方法。\n\npublic interface ExecutorService extends Executor {\n\n    void shutdown();\n\n    List<Runnable> shutdownNow();\n\n    boolean isShutdown();\n\n    boolean isTerminated();\n\n    boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    <T> Future<T> submit(Callable<T> task);\n\n    <T> Future<T> submit(Runnable task, T result);\n\n    Future<?> submit(Runnable task);\n\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException;\n\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,\n                                  long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException, ExecutionException;\n\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks,\n                    long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n\n\n从其支持的方法定义，不难看出：相比于 Executor 接口，ExecutorService 接口主要的扩展是：\n\n * 支持有返回值的线程 - sumbit、invokeAll、invokeAny 方法中都支持传入Callable 对象。\n * 支持管理线程生命周期 - shutdown、shutdownNow、isShutdown 等方法。\n\n\n# ScheduledExecutorService\n\nScheduledExecutorService 接口扩展了 ExecutorService 接口。\n\n它除了支持前面两个接口的所有能力以外，还支持定时调度线程。\n\npublic interface ScheduledExecutorService extends ExecutorService {\n\n    public ScheduledFuture<?> schedule(Runnable command,\n                                       long delay, TimeUnit unit);\n\n    public <V> ScheduledFuture<V> schedule(Callable<V> callable,\n                                           long delay, TimeUnit unit);\n\n    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n                                                  long initialDelay,\n                                                  long period,\n                                                  TimeUnit unit);\n\n    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n                                                     long initialDelay,\n                                                     long delay,\n                                                     TimeUnit unit);\n\n}\n\n\n其扩展的接口提供以下能力：\n\n * schedule 方法可以在指定的延时后执行一个 Runnable 或者 Callable 任务。\n * scheduleAtFixedRate 方法和 scheduleWithFixedDelay 方法可以按照指定时间间隔，定期执行任务。\n\n\n# ThreadPoolExecutor\n\njava.uitl.concurrent.ThreadPoolExecutor 类是 Executor 框架中最核心的类。所以，本文将着重讲述一下这个类。\n\n\n# 重要字段\n\nThreadPoolExecutor 有以下重要字段：\n\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n\n参数说明：\n\n * ctl - 用于控制线程池的运行状态和线程池中的有效线程数量。它包含两部分的信息：\n   * 线程池的运行状态 (runState)\n   * 线程池内有效线程的数量 (workerCount)\n   * 可以看到，ctl 使用了 Integer 类型来保存，高 3 位保存 runState，低 29 位保存 workerCount。COUNT_BITS 就是 29，CAPACITY 就是 1 左移 29 位减 1（29 个 1），这个常量表示 workerCount 的上限值，大约是 5 亿。\n * 运行状态 - 线程池一共有五种运行状态：\n   * RUNNING - 运行状态。接受新任务，并且也能处理阻塞队列中的任务。\n   * SHUTDOWN - 关闭状态。不接受新任务，但可以处理阻塞队列中的任务。\n     * 在线程池处于 RUNNING 状态时，调用 shutdown 方法会使线程池进入到该状态。\n     * finalize 方法在执行过程中也会调用 shutdown 方法进入该状态。\n   * STOP - 停止状态。不接受新任务，也不处理队列中的任务。会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow 方法会使线程池进入到该状态。\n   * TIDYING - 整理状态。如果所有的任务都已终止了，workerCount (有效线程数) 为 0，线程池进入该状态后会调用 terminated 方法进入 TERMINATED 状态。\n   * TERMINATED - 已终止状态。在 terminated 方法执行完后进入该状态。默认 terminated 方法中什么也没有做。进入 TERMINATED 的条件如下：\n     * 线程池不是 RUNNING 状态；\n     * 线程池状态不是 TIDYING 状态或 TERMINATED 状态；\n     * 如果线程池状态是 SHUTDOWN 并且 workerQueue 为空；\n     * workerCount 为 0；\n     * 设置 TIDYING 状态成功。\n\n\n\n\n# 构造方法\n\nThreadPoolExecutor 有四个构造方法，前三个都是基于第四个实现。第四个构造方法定义如下：\n\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n\n\n参数说明：\n\n * corePoolSize - 核心线程数量。当有新任务通过 execute 方法提交时 ，线程池会执行以下判断：\n   * 如果运行的线程数少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的。\n   * 如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当 workQueue 满时才创建新的线程去处理任务；\n   * 如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建的线程池的大小是固定的。这时如果有新任务提交，若 workQueue 未满，则将请求放入 workQueue 中，等待有空闲的线程去从 workQueue 中取任务并处理；\n   * 如果运行的线程数量大于等于 maximumPoolSize，这时如果 workQueue 已经满了，则使用 handler 所指定的策略来处理任务；\n   * 所以，任务提交时，判断的顺序为 corePoolSize => workQueue => maximumPoolSize。\n * maximumPoolSize - 最大线程数量。\n   * 如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。\n   * 值得注意的是：如果使用了无界的任务队列这个参数就没什么效果。\n * keepAliveTime：线程保持活动的时间。\n   * 当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime。\n   * 所以，如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。\n * unit - keepAliveTime 的时间单位。有 7 种取值。可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。\n * workQueue - 等待执行的任务队列。用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。\n   * ArrayBlockingQueue - 有界阻塞队列。\n     * 此队列是基于数组的先进先出队列（FIFO）。\n     * 此队列创建时必须指定大小。\n   * LinkedBlockingQueue - 无界阻塞队列。\n     * 此队列是基于链表的先进先出队列（FIFO）。\n     * 如果创建时没有指定此队列大小，则默认为 Integer.MAX_VALUE。\n     * 吞吐量通常要高于 ArrayBlockingQueue。\n     * 使用 LinkedBlockingQueue 意味着： maximumPoolSize 将不起作用，线程池能创建的最大线程数为 corePoolSize，因为任务等待队列是无界队列。\n     * Executors.newFixedThreadPool 使用了这个队列。\n   * SynchronousQueue - 不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。\n     * 每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。\n     * 吞吐量通常要高于 LinkedBlockingQueue。\n     * Executors.newCachedThreadPool 使用了这个队列。\n   * PriorityBlockingQueue - 具有优先级的无界阻塞队列。\n * threadFactory - 线程工厂。可以通过线程工厂给每个创建出来的线程设置更有意义的名字。\n * handler - 饱和策略。它是 RejectedExecutionHandler 类型的变量。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。线程池支持以下策略：\n   * AbortPolicy - 丢弃任务并抛出异常。这也是默认策略。\n   * DiscardPolicy - 丢弃任务，但不抛出异常。\n   * DiscardOldestPolicy - 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。\n   * CallerRunsPolicy - 直接调用 run 方法并且阻塞执行。\n   * 如果以上策略都不能满足需要，也可以通过实现 RejectedExecutionHandler 接口来定制处理策略。如记录日志或持久化不能处理的任务。\n\n\n# execute 方法\n\n默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。\n\n提交任务可以使用 execute 方法，它是 ThreadPoolExecutor 的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。\n\nexecute 方法工作流程如下：\n\n 1. 如果 workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务；\n 2. 如果 workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；\n 3. 如果 workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；\n 4. 如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。\n\n\n\n\n# 其他重要方法\n\n在 ThreadPoolExecutor 类中还有一些重要的方法：\n\n * submit - 类似于 execute，但是针对的是有返回值的线程。submit 方法是在 ExecutorService 中声明的方法，在 AbstractExecutorService 就已经有了具体的实现。ThreadPoolExecutor 直接复用 AbstractExecutorService 的 submit 方法。\n * shutdown - 不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。\n   * 将线程池切换到 SHUTDOWN 状态；\n   * 并调用 interruptIdleWorkers 方法请求中断所有空闲的 worker；\n   * 最后调用 tryTerminate 尝试结束线程池。\n * shutdownNow - 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。与 shutdown 方法类似，不同的地方在于：\n   * 设置状态为 STOP；\n   * 中断所有工作线程，无论是否是空闲的；\n   * 取出阻塞队列中没有被执行的任务并返回。\n * isShutdown - 调用了 shutdown 或 shutdownNow 方法后，isShutdown 方法就会返回 true。\n * isTerminaed - 当所有的任务都已关闭后，才表示线程池关闭成功，这时调用 isTerminaed 方法会返回 true。\n * setCorePoolSize - 设置核心线程数大小。\n * setMaximumPoolSize - 设置最大线程数大小。\n * getTaskCount - 线程池已经执行的和未执行的任务总数；\n * getCompletedTaskCount - 线程池已完成的任务数量，该值小于等于 taskCount；\n * getLargestPoolSize - 线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了 maximumPoolSize；\n * getPoolSize - 线程池当前的线程数量；\n * getActiveCount - 当前线程池中正在执行任务的线程数量。\n\n\n# 使用示例\n\npublic class ThreadPoolExecutorDemo {\n\n    public static void main(String[] args) {\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 500, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            Executors.defaultThreadFactory(),\n            new ThreadPoolExecutor.AbortPolicy());\n\n        for (int i = 0; i < 100; i++) {\n            threadPoolExecutor.execute(new MyThread());\n            String info = String.format("线程池中线程数目：%s，队列中等待执行的任务数目：%s，已执行玩别的任务数目：%s",\n                threadPoolExecutor.getPoolSize(),\n                threadPoolExecutor.getQueue().size(),\n                threadPoolExecutor.getCompletedTaskCount());\n            System.out.println(info);\n        }\n        threadPoolExecutor.shutdown();\n    }\n\n    static class MyThread implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getName() + " 执行");\n        }\n\n    }\n\n}\n\n\n\n# Executors\n\nJDK 的 Executors 类中提供了几种具有代表性的线程池，这些线程池 都是基于 ThreadPoolExecutor 的定制化实现。\n\n在实际使用线程池的场景中，我们往往不是直接使用 ThreadPoolExecutor ，而是使用 JDK 中提供的具有代表性的线程池实例。\n\n\n# newSingleThreadExecutor\n\n创建一个单线程的线程池。\n\n只会创建唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它 。\n\n单工作线程最大的特点是：可保证顺序地执行各个任务。\n\n示例：\n\npublic class SingleThreadExecutorDemo {\n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        for (int i = 0; i < 100; i++) {\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(Thread.currentThread().getName() + " 执行");\n                }\n            });\n        }\n        executorService.shutdown();\n    }\n\n}\n\n\n\n# newFixedThreadPool\n\n创建一个固定大小的线程池。\n\n每次提交一个任务就会新创建一个工作线程，如果工作线程数量达到线程池最大线程数，则将提交的任务存入到阻塞队列中。\n\nFixedThreadPool 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。\n\n示例：\n\npublic class FixedThreadPoolDemo {\n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        for (int i = 0; i < 100; i++) {\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(Thread.currentThread().getName() + " 执行");\n                }\n            });\n        }\n        executorService.shutdown();\n    }\n\n}\n\n\n\n# newCachedThreadPool\n\n创建一个可缓存的线程池。\n\n * 如果线程池大小超过处理任务所需要的线程数，就会回收部分空闲的线程；\n * 如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。\n * 此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。 因此，使用 CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。\n\n示例：\n\npublic class CachedThreadPoolDemo {\n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        for (int i = 0; i < 100; i++) {\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(Thread.currentThread().getName() + " 执行");\n                }\n            });\n        }\n        executorService.shutdown();\n    }\n\n}\n\n\n\n# newScheduleThreadPool\n\n创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\npublic class ScheduledThreadPoolDemo {\n\n    public static void main(String[] args) {\n        schedule();\n        scheduleAtFixedRate();\n    }\n\n    private static void schedule() {\n        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(5);\n        for (int i = 0; i < 100; i++) {\n            executorService.schedule(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(Thread.currentThread().getName() + " 执行");\n                }\n            }, 1, TimeUnit.SECONDS);\n        }\n        executorService.shutdown();\n    }\n\n    private static void scheduleAtFixedRate() {\n        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(5);\n        for (int i = 0; i < 100; i++) {\n            executorService.scheduleAtFixedRate(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(Thread.currentThread().getName() + " 执行");\n                }\n            }, 1, 1, TimeUnit.SECONDS);\n        }\n        executorService.shutdown();\n    }\n\n}\n\n\n\n# newWorkStealingPool\n\nJava 8 才引入。\n\n其内部会构建 ForkJoinPool，利用 Work-Stealing 算法，并行地处理任务，不保证处理顺序。\n\n\n# 线程池最佳实践\n\n\n# 计算线程数量\n\n一般多线程执行的任务类型可以分为 CPU 密集型和 I/O 密集型，根据不同的任务类型，我们计算线程数的方法也不一样。\n\n**CPU 密集型任务：**这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。\n\n**I/O 密集型任务：**这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。\n\n\n# 建议使用有界阻塞队列\n\n不建议使用 Executors 的最重要的原因是：Executors 提供的很多方法默认使用的都是无界的 LinkedBlockingQueue，高负载情境下，无界队列很容易导致 OOM，而 OOM 会导致所有请求都无法处理，这是致命问题。所以强烈建议使用有界队列。\n\n《阿里巴巴 Java 开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动 new ThreadPoolExecutor 来创建线程池。制订这条规则是因为容易导致生产事故，最典型的就是 newFixedThreadPool 和 newCachedThreadPool，可能因为资源耗尽导致 OOM 问题。\n\n【示例】newFixedThreadPool OOM\n\nThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(1);\nprintStats(threadPool);\nfor (int i = 0; i < 100000000; i++) {\n\tthreadPool.execute(() -> {\n\t\tString payload = IntStream.rangeClosed(1, 1000000)\n\t\t\t.mapToObj(__ -> "a")\n\t\t\t.collect(Collectors.joining("")) + UUID.randomUUID().toString();\n\t\ttry {\n\t\t\tTimeUnit.HOURS.sleep(1);\n\t\t} catch (InterruptedException e) {\n\t\t}\n\t\tlog.info(payload);\n\t});\n}\n\nthreadPool.shutdown();\nthreadPool.awaitTermination(1, TimeUnit.HOURS);\n\n\nnewFixedThreadPool 使用的工作队列是 LinkedBlockingQueue ，而默认构造方法的 LinkedBlockingQueue 是一个 Integer.MAX_VALUE 长度的队列，可以认为是无界的。如果任务较多并且执行较慢的话，队列可能会快速积压，撑爆内存导致 OOM。\n\n【示例】newCachedThreadPool OOM\n\nThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();\nprintStats(threadPool);\nfor (int i = 0; i < 100000000; i++) {\n\tthreadPool.execute(() -> {\n\t\tString payload = UUID.randomUUID().toString();\n\t\ttry {\n\t\t\tTimeUnit.HOURS.sleep(1);\n\t\t} catch (InterruptedException e) {\n\t\t}\n\t\tlog.info(payload);\n\t});\n}\nthreadPool.shutdown();\nthreadPool.awaitTermination(1, TimeUnit.HOURS);\n\n\nnewCachedThreadPool 的最大线程数是 Integer.MAX_VALUE，可以认为是没有上限的，而其工作队列 SynchronousQueue 是一个没有存储空间的阻塞队列。这意味着，只要有请求到来，就必须找到一条工作线程来处理，如果当前没有空闲的线程就再创建一条新的。\n\n如果大量的任务进来后会创建大量的线程。我们知道线程是需要分配一定的内存空间作为线程栈的，比如 1MB，因此无限制创建线程必然会导致 OOM。\n\n\n# 重要任务应该自定义拒绝策略\n\n使用有界队列，当任务过多时，线程池会触发执行拒绝策略，线程池默认的拒绝策略会 throw RejectedExecutionException 这是个运行时异常，对于运行时异常编译器并不强制 catch 它，所以开发人员很容易忽略。因此默认拒绝策略要慎重使用。如果线程池处理的任务非常重要，建议自定义自己的拒绝策略；并且在实际工作中，自定义的拒绝策略往往和降级策略配合使用。\n\n\n# 参考资料\n\n * 《Java 并发编程实战》\n * 《Java 并发编程的艺术》\n * 深入理解 Java 线程池：ThreadPoolExecutor\n * java 并发编程--Executor 框架',normalizedContent:'# java 线程池\n\n\n# 简介\n\n\n# 什么是线程池\n\n线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。\n\n\n# 为什么要用线程池\n\n如果并发请求数量很多，但每个线程执行的时间很短，就会出现频繁的创建和销毁线程。如此一来，会大大降低系统的效率，可能频繁创建和销毁线程的时间、资源开销要大于实际工作的所需。\n\n正是由于这个问题，所以有必要引入线程池。使用 线程池的好处 有以下几点：\n\n * 降低资源消耗 - 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n * 提高响应速度 - 当任务到达时，任务可以不需要等到线程创建就能立即执行。\n * 提高线程的可管理性 - 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。\n\n\n# executor 框架\n\n> executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。\n\n\n# 核心 api 概述\n\nexecutor 框架核心 api 如下：\n\n * executor - 运行任务的简单接口。\n * executorservice - 扩展了 executor 接口。扩展能力：\n   * 支持有返回值的线程；\n   * 支持管理线程的生命周期。\n * scheduledexecutorservice - 扩展了 executorservice 接口。扩展能力：支持定期执行任务。\n * abstractexecutorservice - executorservice 接口的默认实现。\n * threadpoolexecutor - executor 框架最核心的类，它继承了 abstractexecutorservice 类。\n * scheduledthreadpoolexecutor - scheduledexecutorservice 接口的实现，一个可定时调度任务的线程池。\n * executors - 可以通过调用 executors 的静态工厂方法来创建线程池并返回一个 executorservice 对象。\n\n\n\n\n# executor\n\nexecutor 接口中只定义了一个 execute 方法，用于接收一个 runnable 对象。\n\npublic interface executor {\n    void execute(runnable command);\n}\n\n\n\n# executorservice\n\nexecutorservice 接口继承了 executor 接口，它还提供了 invokeall、invokeany、shutdown、submit 等方法。\n\npublic interface executorservice extends executor {\n\n    void shutdown();\n\n    list<runnable> shutdownnow();\n\n    boolean isshutdown();\n\n    boolean isterminated();\n\n    boolean awaittermination(long timeout, timeunit unit)\n        throws interruptedexception;\n\n    <t> future<t> submit(callable<t> task);\n\n    <t> future<t> submit(runnable task, t result);\n\n    future<?> submit(runnable task);\n\n    <t> list<future<t>> invokeall(collection<? extends callable<t>> tasks)\n        throws interruptedexception;\n\n    <t> list<future<t>> invokeall(collection<? extends callable<t>> tasks,\n                                  long timeout, timeunit unit)\n        throws interruptedexception;\n\n    <t> t invokeany(collection<? extends callable<t>> tasks)\n        throws interruptedexception, executionexception;\n\n    <t> t invokeany(collection<? extends callable<t>> tasks,\n                    long timeout, timeunit unit)\n        throws interruptedexception, executionexception, timeoutexception;\n}\n\n\n从其支持的方法定义，不难看出：相比于 executor 接口，executorservice 接口主要的扩展是：\n\n * 支持有返回值的线程 - sumbit、invokeall、invokeany 方法中都支持传入callable 对象。\n * 支持管理线程生命周期 - shutdown、shutdownnow、isshutdown 等方法。\n\n\n# scheduledexecutorservice\n\nscheduledexecutorservice 接口扩展了 executorservice 接口。\n\n它除了支持前面两个接口的所有能力以外，还支持定时调度线程。\n\npublic interface scheduledexecutorservice extends executorservice {\n\n    public scheduledfuture<?> schedule(runnable command,\n                                       long delay, timeunit unit);\n\n    public <v> scheduledfuture<v> schedule(callable<v> callable,\n                                           long delay, timeunit unit);\n\n    public scheduledfuture<?> scheduleatfixedrate(runnable command,\n                                                  long initialdelay,\n                                                  long period,\n                                                  timeunit unit);\n\n    public scheduledfuture<?> schedulewithfixeddelay(runnable command,\n                                                     long initialdelay,\n                                                     long delay,\n                                                     timeunit unit);\n\n}\n\n\n其扩展的接口提供以下能力：\n\n * schedule 方法可以在指定的延时后执行一个 runnable 或者 callable 任务。\n * scheduleatfixedrate 方法和 schedulewithfixeddelay 方法可以按照指定时间间隔，定期执行任务。\n\n\n# threadpoolexecutor\n\njava.uitl.concurrent.threadpoolexecutor 类是 executor 框架中最核心的类。所以，本文将着重讲述一下这个类。\n\n\n# 重要字段\n\nthreadpoolexecutor 有以下重要字段：\n\nprivate final atomicinteger ctl = new atomicinteger(ctlof(running, 0));\nprivate static final int count_bits = integer.size - 3;\nprivate static final int capacity   = (1 << count_bits) - 1;\n// runstate is stored in the high-order bits\nprivate static final int running    = -1 << count_bits;\nprivate static final int shutdown   =  0 << count_bits;\nprivate static final int stop       =  1 << count_bits;\nprivate static final int tidying    =  2 << count_bits;\nprivate static final int terminated =  3 << count_bits;\n\n\n参数说明：\n\n * ctl - 用于控制线程池的运行状态和线程池中的有效线程数量。它包含两部分的信息：\n   * 线程池的运行状态 (runstate)\n   * 线程池内有效线程的数量 (workercount)\n   * 可以看到，ctl 使用了 integer 类型来保存，高 3 位保存 runstate，低 29 位保存 workercount。count_bits 就是 29，capacity 就是 1 左移 29 位减 1（29 个 1），这个常量表示 workercount 的上限值，大约是 5 亿。\n * 运行状态 - 线程池一共有五种运行状态：\n   * running - 运行状态。接受新任务，并且也能处理阻塞队列中的任务。\n   * shutdown - 关闭状态。不接受新任务，但可以处理阻塞队列中的任务。\n     * 在线程池处于 running 状态时，调用 shutdown 方法会使线程池进入到该状态。\n     * finalize 方法在执行过程中也会调用 shutdown 方法进入该状态。\n   * stop - 停止状态。不接受新任务，也不处理队列中的任务。会中断正在处理任务的线程。在线程池处于 running 或 shutdown 状态时，调用 shutdownnow 方法会使线程池进入到该状态。\n   * tidying - 整理状态。如果所有的任务都已终止了，workercount (有效线程数) 为 0，线程池进入该状态后会调用 terminated 方法进入 terminated 状态。\n   * terminated - 已终止状态。在 terminated 方法执行完后进入该状态。默认 terminated 方法中什么也没有做。进入 terminated 的条件如下：\n     * 线程池不是 running 状态；\n     * 线程池状态不是 tidying 状态或 terminated 状态；\n     * 如果线程池状态是 shutdown 并且 workerqueue 为空；\n     * workercount 为 0；\n     * 设置 tidying 状态成功。\n\n\n\n\n# 构造方法\n\nthreadpoolexecutor 有四个构造方法，前三个都是基于第四个实现。第四个构造方法定义如下：\n\npublic threadpoolexecutor(int corepoolsize,\n                              int maximumpoolsize,\n                              long keepalivetime,\n                              timeunit unit,\n                              blockingqueue<runnable> workqueue,\n                              threadfactory threadfactory,\n                              rejectedexecutionhandler handler) {\n\n\n参数说明：\n\n * corepoolsize - 核心线程数量。当有新任务通过 execute 方法提交时 ，线程池会执行以下判断：\n   * 如果运行的线程数少于 corepoolsize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的。\n   * 如果线程池中的线程数量大于等于 corepoolsize 且小于 maximumpoolsize，则只有当 workqueue 满时才创建新的线程去处理任务；\n   * 如果设置的 corepoolsize 和 maximumpoolsize 相同，则创建的线程池的大小是固定的。这时如果有新任务提交，若 workqueue 未满，则将请求放入 workqueue 中，等待有空闲的线程去从 workqueue 中取任务并处理；\n   * 如果运行的线程数量大于等于 maximumpoolsize，这时如果 workqueue 已经满了，则使用 handler 所指定的策略来处理任务；\n   * 所以，任务提交时，判断的顺序为 corepoolsize => workqueue => maximumpoolsize。\n * maximumpoolsize - 最大线程数量。\n   * 如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。\n   * 值得注意的是：如果使用了无界的任务队列这个参数就没什么效果。\n * keepalivetime：线程保持活动的时间。\n   * 当线程池中的线程数量大于 corepoolsize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepalivetime。\n   * 所以，如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。\n * unit - keepalivetime 的时间单位。有 7 种取值。可选的单位有天（days），小时（hours），分钟（minutes），毫秒(milliseconds)，微秒(microseconds, 千分之一毫秒)和毫微秒(nanoseconds, 千分之一微秒)。\n * workqueue - 等待执行的任务队列。用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。\n   * arrayblockingqueue - 有界阻塞队列。\n     * 此队列是基于数组的先进先出队列（fifo）。\n     * 此队列创建时必须指定大小。\n   * linkedblockingqueue - 无界阻塞队列。\n     * 此队列是基于链表的先进先出队列（fifo）。\n     * 如果创建时没有指定此队列大小，则默认为 integer.max_value。\n     * 吞吐量通常要高于 arrayblockingqueue。\n     * 使用 linkedblockingqueue 意味着： maximumpoolsize 将不起作用，线程池能创建的最大线程数为 corepoolsize，因为任务等待队列是无界队列。\n     * executors.newfixedthreadpool 使用了这个队列。\n   * synchronousqueue - 不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。\n     * 每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。\n     * 吞吐量通常要高于 linkedblockingqueue。\n     * executors.newcachedthreadpool 使用了这个队列。\n   * priorityblockingqueue - 具有优先级的无界阻塞队列。\n * threadfactory - 线程工厂。可以通过线程工厂给每个创建出来的线程设置更有意义的名字。\n * handler - 饱和策略。它是 rejectedexecutionhandler 类型的变量。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。线程池支持以下策略：\n   * abortpolicy - 丢弃任务并抛出异常。这也是默认策略。\n   * discardpolicy - 丢弃任务，但不抛出异常。\n   * discardoldestpolicy - 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。\n   * callerrunspolicy - 直接调用 run 方法并且阻塞执行。\n   * 如果以上策略都不能满足需要，也可以通过实现 rejectedexecutionhandler 接口来定制处理策略。如记录日志或持久化不能处理的任务。\n\n\n# execute 方法\n\n默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。\n\n提交任务可以使用 execute 方法，它是 threadpoolexecutor 的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。\n\nexecute 方法工作流程如下：\n\n 1. 如果 workercount < corepoolsize，则创建并启动一个线程来执行新提交的任务；\n 2. 如果 workercount >= corepoolsize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；\n 3. 如果 workercount >= corepoolsize && workercount < maximumpoolsize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；\n 4. 如果workercount >= maximumpoolsize，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。\n\n\n\n\n# 其他重要方法\n\n在 threadpoolexecutor 类中还有一些重要的方法：\n\n * submit - 类似于 execute，但是针对的是有返回值的线程。submit 方法是在 executorservice 中声明的方法，在 abstractexecutorservice 就已经有了具体的实现。threadpoolexecutor 直接复用 abstractexecutorservice 的 submit 方法。\n * shutdown - 不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。\n   * 将线程池切换到 shutdown 状态；\n   * 并调用 interruptidleworkers 方法请求中断所有空闲的 worker；\n   * 最后调用 tryterminate 尝试结束线程池。\n * shutdownnow - 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。与 shutdown 方法类似，不同的地方在于：\n   * 设置状态为 stop；\n   * 中断所有工作线程，无论是否是空闲的；\n   * 取出阻塞队列中没有被执行的任务并返回。\n * isshutdown - 调用了 shutdown 或 shutdownnow 方法后，isshutdown 方法就会返回 true。\n * isterminaed - 当所有的任务都已关闭后，才表示线程池关闭成功，这时调用 isterminaed 方法会返回 true。\n * setcorepoolsize - 设置核心线程数大小。\n * setmaximumpoolsize - 设置最大线程数大小。\n * gettaskcount - 线程池已经执行的和未执行的任务总数；\n * getcompletedtaskcount - 线程池已完成的任务数量，该值小于等于 taskcount；\n * getlargestpoolsize - 线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了 maximumpoolsize；\n * getpoolsize - 线程池当前的线程数量；\n * getactivecount - 当前线程池中正在执行任务的线程数量。\n\n\n# 使用示例\n\npublic class threadpoolexecutordemo {\n\n    public static void main(string[] args) {\n        threadpoolexecutor threadpoolexecutor = new threadpoolexecutor(5, 10, 500, timeunit.milliseconds,\n            new linkedblockingqueue<runnable>(),\n            executors.defaultthreadfactory(),\n            new threadpoolexecutor.abortpolicy());\n\n        for (int i = 0; i < 100; i++) {\n            threadpoolexecutor.execute(new mythread());\n            string info = string.format("线程池中线程数目：%s，队列中等待执行的任务数目：%s，已执行玩别的任务数目：%s",\n                threadpoolexecutor.getpoolsize(),\n                threadpoolexecutor.getqueue().size(),\n                threadpoolexecutor.getcompletedtaskcount());\n            system.out.println(info);\n        }\n        threadpoolexecutor.shutdown();\n    }\n\n    static class mythread implements runnable {\n\n        @override\n        public void run() {\n            system.out.println(thread.currentthread().getname() + " 执行");\n        }\n\n    }\n\n}\n\n\n\n# executors\n\njdk 的 executors 类中提供了几种具有代表性的线程池，这些线程池 都是基于 threadpoolexecutor 的定制化实现。\n\n在实际使用线程池的场景中，我们往往不是直接使用 threadpoolexecutor ，而是使用 jdk 中提供的具有代表性的线程池实例。\n\n\n# newsinglethreadexecutor\n\n创建一个单线程的线程池。\n\n只会创建唯一的工作线程来执行任务，保证所有任务按照指定顺序(fifo, lifo, 优先级)执行。 如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它 。\n\n单工作线程最大的特点是：可保证顺序地执行各个任务。\n\n示例：\n\npublic class singlethreadexecutordemo {\n\n    public static void main(string[] args) {\n        executorservice executorservice = executors.newsinglethreadexecutor();\n        for (int i = 0; i < 100; i++) {\n            executorservice.execute(new runnable() {\n                @override\n                public void run() {\n                    system.out.println(thread.currentthread().getname() + " 执行");\n                }\n            });\n        }\n        executorservice.shutdown();\n    }\n\n}\n\n\n\n# newfixedthreadpool\n\n创建一个固定大小的线程池。\n\n每次提交一个任务就会新创建一个工作线程，如果工作线程数量达到线程池最大线程数，则将提交的任务存入到阻塞队列中。\n\nfixedthreadpool 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。\n\n示例：\n\npublic class fixedthreadpooldemo {\n\n    public static void main(string[] args) {\n        executorservice executorservice = executors.newfixedthreadpool(3);\n        for (int i = 0; i < 100; i++) {\n            executorservice.execute(new runnable() {\n                @override\n                public void run() {\n                    system.out.println(thread.currentthread().getname() + " 执行");\n                }\n            });\n        }\n        executorservice.shutdown();\n    }\n\n}\n\n\n\n# newcachedthreadpool\n\n创建一个可缓存的线程池。\n\n * 如果线程池大小超过处理任务所需要的线程数，就会回收部分空闲的线程；\n * 如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。\n * 此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 jvm）能够创建的最大线程大小。 因此，使用 cachedthreadpool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。\n\n示例：\n\npublic class cachedthreadpooldemo {\n\n    public static void main(string[] args) {\n        executorservice executorservice = executors.newcachedthreadpool();\n        for (int i = 0; i < 100; i++) {\n            executorservice.execute(new runnable() {\n                @override\n                public void run() {\n                    system.out.println(thread.currentthread().getname() + " 执行");\n                }\n            });\n        }\n        executorservice.shutdown();\n    }\n\n}\n\n\n\n# newschedulethreadpool\n\n创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\npublic class scheduledthreadpooldemo {\n\n    public static void main(string[] args) {\n        schedule();\n        scheduleatfixedrate();\n    }\n\n    private static void schedule() {\n        scheduledexecutorservice executorservice = executors.newscheduledthreadpool(5);\n        for (int i = 0; i < 100; i++) {\n            executorservice.schedule(new runnable() {\n                @override\n                public void run() {\n                    system.out.println(thread.currentthread().getname() + " 执行");\n                }\n            }, 1, timeunit.seconds);\n        }\n        executorservice.shutdown();\n    }\n\n    private static void scheduleatfixedrate() {\n        scheduledexecutorservice executorservice = executors.newscheduledthreadpool(5);\n        for (int i = 0; i < 100; i++) {\n            executorservice.scheduleatfixedrate(new runnable() {\n                @override\n                public void run() {\n                    system.out.println(thread.currentthread().getname() + " 执行");\n                }\n            }, 1, 1, timeunit.seconds);\n        }\n        executorservice.shutdown();\n    }\n\n}\n\n\n\n# newworkstealingpool\n\njava 8 才引入。\n\n其内部会构建 forkjoinpool，利用 work-stealing 算法，并行地处理任务，不保证处理顺序。\n\n\n# 线程池最佳实践\n\n\n# 计算线程数量\n\n一般多线程执行的任务类型可以分为 cpu 密集型和 i/o 密集型，根据不同的任务类型，我们计算线程数的方法也不一样。\n\n**cpu 密集型任务：**这种任务消耗的主要是 cpu 资源，可以将线程数设置为 n（cpu 核心数）+1，比 cpu 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，cpu 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 cpu 的空闲时间。\n\n**i/o 密集型任务：**这种任务应用起来，系统会用大部分的时间来处理 i/o 交互，而线程在处理 i/o 的时间段内不会占用 cpu 来处理，这时就可以将 cpu 交出给其它线程使用。因此在 i/o 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2n。\n\n\n# 建议使用有界阻塞队列\n\n不建议使用 executors 的最重要的原因是：executors 提供的很多方法默认使用的都是无界的 linkedblockingqueue，高负载情境下，无界队列很容易导致 oom，而 oom 会导致所有请求都无法处理，这是致命问题。所以强烈建议使用有界队列。\n\n《阿里巴巴 java 开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动 new threadpoolexecutor 来创建线程池。制订这条规则是因为容易导致生产事故，最典型的就是 newfixedthreadpool 和 newcachedthreadpool，可能因为资源耗尽导致 oom 问题。\n\n【示例】newfixedthreadpool oom\n\nthreadpoolexecutor threadpool = (threadpoolexecutor) executors.newfixedthreadpool(1);\nprintstats(threadpool);\nfor (int i = 0; i < 100000000; i++) {\n\tthreadpool.execute(() -> {\n\t\tstring payload = intstream.rangeclosed(1, 1000000)\n\t\t\t.maptoobj(__ -> "a")\n\t\t\t.collect(collectors.joining("")) + uuid.randomuuid().tostring();\n\t\ttry {\n\t\t\ttimeunit.hours.sleep(1);\n\t\t} catch (interruptedexception e) {\n\t\t}\n\t\tlog.info(payload);\n\t});\n}\n\nthreadpool.shutdown();\nthreadpool.awaittermination(1, timeunit.hours);\n\n\nnewfixedthreadpool 使用的工作队列是 linkedblockingqueue ，而默认构造方法的 linkedblockingqueue 是一个 integer.max_value 长度的队列，可以认为是无界的。如果任务较多并且执行较慢的话，队列可能会快速积压，撑爆内存导致 oom。\n\n【示例】newcachedthreadpool oom\n\nthreadpoolexecutor threadpool = (threadpoolexecutor) executors.newcachedthreadpool();\nprintstats(threadpool);\nfor (int i = 0; i < 100000000; i++) {\n\tthreadpool.execute(() -> {\n\t\tstring payload = uuid.randomuuid().tostring();\n\t\ttry {\n\t\t\ttimeunit.hours.sleep(1);\n\t\t} catch (interruptedexception e) {\n\t\t}\n\t\tlog.info(payload);\n\t});\n}\nthreadpool.shutdown();\nthreadpool.awaittermination(1, timeunit.hours);\n\n\nnewcachedthreadpool 的最大线程数是 integer.max_value，可以认为是没有上限的，而其工作队列 synchronousqueue 是一个没有存储空间的阻塞队列。这意味着，只要有请求到来，就必须找到一条工作线程来处理，如果当前没有空闲的线程就再创建一条新的。\n\n如果大量的任务进来后会创建大量的线程。我们知道线程是需要分配一定的内存空间作为线程栈的，比如 1mb，因此无限制创建线程必然会导致 oom。\n\n\n# 重要任务应该自定义拒绝策略\n\n使用有界队列，当任务过多时，线程池会触发执行拒绝策略，线程池默认的拒绝策略会 throw rejectedexecutionexception 这是个运行时异常，对于运行时异常编译器并不强制 catch 它，所以开发人员很容易忽略。因此默认拒绝策略要慎重使用。如果线程池处理的任务非常重要，建议自定义自己的拒绝策略；并且在实际工作中，自定义的拒绝策略往往和降级策略配合使用。\n\n\n# 参考资料\n\n * 《java 并发编程实战》\n * 《java 并发编程的艺术》\n * 深入理解 java 线程池：threadpoolexecutor\n * java 并发编程--executor 框架',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java并发工具类",frontmatter:{title:"Java并发工具类",categories:["编程","Java","JavaSE","并发"],tags:["Java","JavaSE","并发"],abbrlink:"19b32c42",date:"2019-12-24T23:52:25.000Z",permalink:"/pages/2f46ce/"},regularPath:"/05.%E5%B9%B6%E5%8F%91/08.Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB.html",relativePath:"05.并发/08.Java并发工具类.md",key:"v-4514b826",path:"/pages/2f46ce/",headers:[{level:2,title:"CountDownLatch",slug:"countdownlatch",normalizedTitle:"countdownlatch",charIndex:75},{level:2,title:"CyclicBarrier",slug:"cyclicbarrier",normalizedTitle:"cyclicbarrier",charIndex:1891},{level:2,title:"Semaphore",slug:"semaphore",normalizedTitle:"semaphore",charIndex:4270},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6049},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6317}],headersStr:"CountDownLatch CyclicBarrier Semaphore 总结 参考资料",content:'# Java 并发工具类\n\n> JDK 的 java.util.concurrent 包（即 J.U.C）中提供了几个非常有用的并发工具类。\n\n\n# CountDownLatch\n\n> 字面意思为 递减计数锁。用于控制一个线程等待多个线程。\n> \n> CountDownLatch 维护一个计数器 count，表示需要等待的事件数量。countDown 方法递减计数器，表示有一个事件已经发生。调用 await 方法的线程会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。\n\n\n\nCountDownLatch 是基于 AQS(AbstractQueuedSynchronizer) 实现的。\n\nCountDownLatch 唯一的构造方法：\n\n// 初始化计数器\npublic CountDownLatch(int count) {};\n\n\n说明：\n\n * count 为统计值。\n\nCountDownLatch 的重要方法：\n\npublic void await() throws InterruptedException { };\npublic boolean await(long timeout, TimeUnit unit) throws InterruptedException { };\npublic void countDown() { };\n\n\n说明：\n\n * await() - 调用 await() 方法的线程会被挂起，它会等待直到 count 值为 0 才继续执行。\n * await(long timeout, TimeUnit unit) - 和 await() 类似，只不过等待一定的时间后 count 值还没变为 0 的话就会继续执行\n * countDown() - 将统计值 count 减 1\n\n示例：\n\npublic class CountDownLatchDemo {\n\n    public static void main(String[] args) {\n        final CountDownLatch latch = new CountDownLatch(2);\n\n        new Thread(new MyThread(latch)).start();\n        new Thread(new MyThread(latch)).start();\n\n        try {\n            System.out.println("等待2个子线程执行完毕...");\n            latch.await();\n            System.out.println("2个子线程已经执行完毕");\n            System.out.println("继续执行主线程");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class MyThread implements Runnable {\n\n        private CountDownLatch latch;\n\n        public MyThread(CountDownLatch latch) {\n            this.latch = latch;\n        }\n\n        @Override\n        public void run() {\n            System.out.println("子线程" + Thread.currentThread().getName() + "正在执行");\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println("子线程" + Thread.currentThread().getName() + "执行完毕");\n            latch.countDown();\n        }\n\n    }\n\n}\n\n\n\n# CyclicBarrier\n\n> 字面意思是 循环栅栏。CyclicBarrier 可以让一组线程等待至某个状态（遵循字面意思，不妨称这个状态为栅栏）之后再全部同时执行。之所以叫循环栅栏是因为：当所有等待线程都被释放以后，CyclicBarrier 可以被重用。\n> \n> CyclicBarrier 维护一个计数器 count。每次执行 await 方法之后，count 加 1，直到计数器的值和设置的值相等，等待的所有线程才会继续执行。\n\nCyclicBarrier 是基于 ReentrantLock 和 Condition 实现的。\n\nCyclicBarrier 应用场景：CyclicBarrier 在并行迭代算法中非常有用。\n\n\n\nCyclicBarrier 提供了 2 个构造方法\n\npublic CyclicBarrier(int parties) {}\npublic CyclicBarrier(int parties, Runnable barrierAction) {}\n\n\n> 说明：\n> \n>  * parties - parties 数相当于一个阈值，当有 parties 数量的线程在等待时， CyclicBarrier 处于栅栏状态。\n>  * barrierAction - 当 CyclicBarrier 处于栅栏状态时执行的动作。\n\nCyclicBarrier 的重要方法：\n\npublic int await() throws InterruptedException, BrokenBarrierException {}\npublic int await(long timeout, TimeUnit unit)\n        throws InterruptedException,\n               BrokenBarrierException,\n               TimeoutException {}\n// 将屏障重置为初始状态\npublic void reset() {}\n\n\n> 说明：\n> \n>  * await() - 等待调用 await() 的线程数达到屏障数。如果当前线程是最后一个到达的线程，并且在构造函数中提供了非空屏障操作，则当前线程在允许其他线程继续之前运行该操作。如果在屏障动作期间发生异常，那么该异常将在当前线程中传播并且屏障被置于断开状态。\n>  * await(long timeout, TimeUnit unit) - 相比于 await() 方法，这个方法让这些线程等待至一定的时间，如果还有线程没有到达栅栏状态就直接让到达栅栏状态的线程执行后续任务。\n>  * reset() - 将屏障重置为初始状态。\n\n示例：\n\npublic class CyclicBarrierDemo {\n\n    final static int N = 4;\n\n    public static void main(String[] args) {\n        CyclicBarrier barrier = new CyclicBarrier(N,\n            new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println("当前线程" + Thread.currentThread().getName());\n                }\n            });\n\n        for (int i = 0; i < N; i++) {\n            MyThread myThread = new MyThread(barrier);\n            new Thread(myThread).start();\n        }\n    }\n\n    static class MyThread implements Runnable {\n\n        private CyclicBarrier cyclicBarrier;\n\n        MyThread(CyclicBarrier cyclicBarrier) {\n            this.cyclicBarrier = cyclicBarrier;\n        }\n\n        @Override\n        public void run() {\n            System.out.println("线程" + Thread.currentThread().getName() + "正在写入数据...");\n            try {\n                Thread.sleep(3000); // 以睡眠来模拟写入数据操作\n                System.out.println("线程" + Thread.currentThread().getName() + "写入数据完毕，等待其他线程写入完毕");\n                cyclicBarrier.await();\n            } catch (InterruptedException | BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n\n\n\n# Semaphore\n\n> 字面意思为 信号量。Semaphore 用来控制某段代码块的并发数。\n> \n> Semaphore 管理着一组虚拟的许可（permit），permit 的初始数量可通过构造方法来指定。每次执行 acquire 方法可以获取一个 permit，如果没有就等待；而 release 方法可以释放一个 permit。\n\nSemaphore 应用场景：\n\n * Semaphore 可以用于实现资源池，如数据库连接池。\n * Semaphore 可以用于将任何一种容器变成有界阻塞容器。\n\n\n\nSemaphore 提供了 2 个构造方法：\n\n// 参数 permits 表示许可数目，即同时可以允许多少线程进行访问\npublic Semaphore(int permits) {}\n// 参数 fair 表示是否是公平的，即等待时间越久的越先获取许可\npublic Semaphore(int permits, boolean fair) {}\n\n\n> 说明：\n> \n>  * permits - 初始化固定数量的 permit，并且默认为非公平模式。\n>  * fair - 设置是否为公平模式。所谓公平，是指等待久的优先获取 permit。\n\nSemaphore的重要方法：\n\n// 获取 1 个许可\npublic void acquire() throws InterruptedException {}\n//获取 permits 个许可\npublic void acquire(int permits) throws InterruptedException {}\n// 释放 1 个许可\npublic void release() {}\n//释放 permits 个许可\npublic void release(int permits) {}\n\n\n说明：\n\n * acquire() - 获取 1 个 permit。\n * acquire(int permits) - 获取 permits 数量的 permit。\n * release() - 释放 1 个 permit。\n * release(int permits) - 释放 permits 数量的 permit。\n\n示例：\n\npublic class SemaphoreDemo {\n\n    private static final int THREAD_COUNT = 30;\n\n    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);\n\n    private static Semaphore semaphore = new Semaphore(10);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threadPool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        semaphore.acquire();\n                        System.out.println("save data");\n                        semaphore.release();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        }\n\n        threadPool.shutdown();\n    }\n\n}\n\n\n\n# 总结\n\n * CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不同：\n   * CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；\n   * CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；\n   * 另外，CountDownLatch 是不可以重用的，而 CyclicBarrier 是可以重用的。\n * Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。\n\n\n# 参考资料\n\n * 《Java 并发编程实战》\n * 《Java 并发编程的艺术》\n * Java 并发编程：CountDownLatch、CyclicBarrier 和 Semaphore',normalizedContent:'# java 并发工具类\n\n> jdk 的 java.util.concurrent 包（即 j.u.c）中提供了几个非常有用的并发工具类。\n\n\n# countdownlatch\n\n> 字面意思为 递减计数锁。用于控制一个线程等待多个线程。\n> \n> countdownlatch 维护一个计数器 count，表示需要等待的事件数量。countdown 方法递减计数器，表示有一个事件已经发生。调用 await 方法的线程会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。\n\n\n\ncountdownlatch 是基于 aqs(abstractqueuedsynchronizer) 实现的。\n\ncountdownlatch 唯一的构造方法：\n\n// 初始化计数器\npublic countdownlatch(int count) {};\n\n\n说明：\n\n * count 为统计值。\n\ncountdownlatch 的重要方法：\n\npublic void await() throws interruptedexception { };\npublic boolean await(long timeout, timeunit unit) throws interruptedexception { };\npublic void countdown() { };\n\n\n说明：\n\n * await() - 调用 await() 方法的线程会被挂起，它会等待直到 count 值为 0 才继续执行。\n * await(long timeout, timeunit unit) - 和 await() 类似，只不过等待一定的时间后 count 值还没变为 0 的话就会继续执行\n * countdown() - 将统计值 count 减 1\n\n示例：\n\npublic class countdownlatchdemo {\n\n    public static void main(string[] args) {\n        final countdownlatch latch = new countdownlatch(2);\n\n        new thread(new mythread(latch)).start();\n        new thread(new mythread(latch)).start();\n\n        try {\n            system.out.println("等待2个子线程执行完毕...");\n            latch.await();\n            system.out.println("2个子线程已经执行完毕");\n            system.out.println("继续执行主线程");\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n\n    static class mythread implements runnable {\n\n        private countdownlatch latch;\n\n        public mythread(countdownlatch latch) {\n            this.latch = latch;\n        }\n\n        @override\n        public void run() {\n            system.out.println("子线程" + thread.currentthread().getname() + "正在执行");\n            try {\n                thread.sleep(1000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            system.out.println("子线程" + thread.currentthread().getname() + "执行完毕");\n            latch.countdown();\n        }\n\n    }\n\n}\n\n\n\n# cyclicbarrier\n\n> 字面意思是 循环栅栏。cyclicbarrier 可以让一组线程等待至某个状态（遵循字面意思，不妨称这个状态为栅栏）之后再全部同时执行。之所以叫循环栅栏是因为：当所有等待线程都被释放以后，cyclicbarrier 可以被重用。\n> \n> cyclicbarrier 维护一个计数器 count。每次执行 await 方法之后，count 加 1，直到计数器的值和设置的值相等，等待的所有线程才会继续执行。\n\ncyclicbarrier 是基于 reentrantlock 和 condition 实现的。\n\ncyclicbarrier 应用场景：cyclicbarrier 在并行迭代算法中非常有用。\n\n\n\ncyclicbarrier 提供了 2 个构造方法\n\npublic cyclicbarrier(int parties) {}\npublic cyclicbarrier(int parties, runnable barrieraction) {}\n\n\n> 说明：\n> \n>  * parties - parties 数相当于一个阈值，当有 parties 数量的线程在等待时， cyclicbarrier 处于栅栏状态。\n>  * barrieraction - 当 cyclicbarrier 处于栅栏状态时执行的动作。\n\ncyclicbarrier 的重要方法：\n\npublic int await() throws interruptedexception, brokenbarrierexception {}\npublic int await(long timeout, timeunit unit)\n        throws interruptedexception,\n               brokenbarrierexception,\n               timeoutexception {}\n// 将屏障重置为初始状态\npublic void reset() {}\n\n\n> 说明：\n> \n>  * await() - 等待调用 await() 的线程数达到屏障数。如果当前线程是最后一个到达的线程，并且在构造函数中提供了非空屏障操作，则当前线程在允许其他线程继续之前运行该操作。如果在屏障动作期间发生异常，那么该异常将在当前线程中传播并且屏障被置于断开状态。\n>  * await(long timeout, timeunit unit) - 相比于 await() 方法，这个方法让这些线程等待至一定的时间，如果还有线程没有到达栅栏状态就直接让到达栅栏状态的线程执行后续任务。\n>  * reset() - 将屏障重置为初始状态。\n\n示例：\n\npublic class cyclicbarrierdemo {\n\n    final static int n = 4;\n\n    public static void main(string[] args) {\n        cyclicbarrier barrier = new cyclicbarrier(n,\n            new runnable() {\n                @override\n                public void run() {\n                    system.out.println("当前线程" + thread.currentthread().getname());\n                }\n            });\n\n        for (int i = 0; i < n; i++) {\n            mythread mythread = new mythread(barrier);\n            new thread(mythread).start();\n        }\n    }\n\n    static class mythread implements runnable {\n\n        private cyclicbarrier cyclicbarrier;\n\n        mythread(cyclicbarrier cyclicbarrier) {\n            this.cyclicbarrier = cyclicbarrier;\n        }\n\n        @override\n        public void run() {\n            system.out.println("线程" + thread.currentthread().getname() + "正在写入数据...");\n            try {\n                thread.sleep(3000); // 以睡眠来模拟写入数据操作\n                system.out.println("线程" + thread.currentthread().getname() + "写入数据完毕，等待其他线程写入完毕");\n                cyclicbarrier.await();\n            } catch (interruptedexception | brokenbarrierexception e) {\n                e.printstacktrace();\n            }\n        }\n\n    }\n\n}\n\n\n\n# semaphore\n\n> 字面意思为 信号量。semaphore 用来控制某段代码块的并发数。\n> \n> semaphore 管理着一组虚拟的许可（permit），permit 的初始数量可通过构造方法来指定。每次执行 acquire 方法可以获取一个 permit，如果没有就等待；而 release 方法可以释放一个 permit。\n\nsemaphore 应用场景：\n\n * semaphore 可以用于实现资源池，如数据库连接池。\n * semaphore 可以用于将任何一种容器变成有界阻塞容器。\n\n\n\nsemaphore 提供了 2 个构造方法：\n\n// 参数 permits 表示许可数目，即同时可以允许多少线程进行访问\npublic semaphore(int permits) {}\n// 参数 fair 表示是否是公平的，即等待时间越久的越先获取许可\npublic semaphore(int permits, boolean fair) {}\n\n\n> 说明：\n> \n>  * permits - 初始化固定数量的 permit，并且默认为非公平模式。\n>  * fair - 设置是否为公平模式。所谓公平，是指等待久的优先获取 permit。\n\nsemaphore的重要方法：\n\n// 获取 1 个许可\npublic void acquire() throws interruptedexception {}\n//获取 permits 个许可\npublic void acquire(int permits) throws interruptedexception {}\n// 释放 1 个许可\npublic void release() {}\n//释放 permits 个许可\npublic void release(int permits) {}\n\n\n说明：\n\n * acquire() - 获取 1 个 permit。\n * acquire(int permits) - 获取 permits 数量的 permit。\n * release() - 释放 1 个 permit。\n * release(int permits) - 释放 permits 数量的 permit。\n\n示例：\n\npublic class semaphoredemo {\n\n    private static final int thread_count = 30;\n\n    private static executorservice threadpool = executors.newfixedthreadpool(thread_count);\n\n    private static semaphore semaphore = new semaphore(10);\n\n    public static void main(string[] args) {\n        for (int i = 0; i < thread_count; i++) {\n            threadpool.execute(new runnable() {\n                @override\n                public void run() {\n                    try {\n                        semaphore.acquire();\n                        system.out.println("save data");\n                        semaphore.release();\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                }\n            });\n        }\n\n        threadpool.shutdown();\n    }\n\n}\n\n\n\n# 总结\n\n * countdownlatch 和 cyclicbarrier 都能够实现线程之间的等待，只不过它们侧重点不同：\n   * countdownlatch 一般用于某个线程 a 等待若干个其他线程执行完任务之后，它才执行；\n   * cyclicbarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；\n   * 另外，countdownlatch 是不可以重用的，而 cyclicbarrier 是可以重用的。\n * semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。\n\n\n# 参考资料\n\n * 《java 并发编程实战》\n * 《java 并发编程的艺术》\n * java 并发编程：countdownlatch、cyclicbarrier 和 semaphore',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java内存模型",frontmatter:{title:"Java内存模型",categories:["编程","Java","JavaSE","并发"],tags:["Java","JavaSE","并发"],abbrlink:"91e798bc",date:"2020-12-25T18:43:11.000Z",permalink:"/pages/80f538/"},regularPath:"/05.%E5%B9%B6%E5%8F%91/09.Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html",relativePath:"05.并发/09.Java内存模型.md",key:"v-44bda162",path:"/pages/80f538/",headers:[{level:2,title:"物理内存模型",slug:"物理内存模型",normalizedTitle:"物理内存模型",charIndex:218},{level:3,title:"硬件处理效率",slug:"硬件处理效率",normalizedTitle:"硬件处理效率",charIndex:287},{level:3,title:"缓存一致性",slug:"缓存一致性",normalizedTitle:"缓存一致性",charIndex:568},{level:3,title:"代码乱序执行优化",slug:"代码乱序执行优化",normalizedTitle:"代码乱序执行优化",charIndex:759},{level:2,title:"Java 内存模型",slug:"java-内存模型-2",normalizedTitle:"java 内存模型",charIndex:2},{level:3,title:"主内存和工作内存",slug:"主内存和工作内存",normalizedTitle:"主内存和工作内存",charIndex:1535},{level:3,title:"JMM 内存操作的问题",slug:"jmm-内存操作的问题",normalizedTitle:"jmm 内存操作的问题",charIndex:2079},{level:3,title:"内存间交互操作",slug:"内存间交互操作",normalizedTitle:"内存间交互操作",charIndex:2596},{level:3,title:"并发安全特性",slug:"并发安全特性",normalizedTitle:"并发安全特性",charIndex:4067},{level:4,title:"原子性",slug:"原子性",normalizedTitle:"原子性",charIndex:1318},{level:4,title:"可见性",slug:"可见性",normalizedTitle:"可见性",charIndex:133},{level:4,title:"有序性",slug:"有序性",normalizedTitle:"有序性",charIndex:137},{level:2,title:"Happens-Before",slug:"happens-before",normalizedTitle:"happens-before",charIndex:51},{level:2,title:"内存屏障",slug:"内存屏障",normalizedTitle:"内存屏障",charIndex:66},{level:2,title:"volatile",slug:"volatile",normalizedTitle:"volatile",charIndex:23},{level:4,title:"volatile 变量的特性",slug:"volatile-变量的特性",normalizedTitle:"volatile 变量的特性",charIndex:6782},{level:5,title:"保证变量对所有线程的可见性",slug:"保证变量对所有线程的可见性",normalizedTitle:"保证变量对所有线程的可见性",charIndex:6821},{level:5,title:"语义 2 禁止进行指令重排序",slug:"语义-2-禁止进行指令重排序",normalizedTitle:"语义 2 禁止进行指令重排序",charIndex:7574},{level:4,title:"volatile 的原理",slug:"volatile-的原理",normalizedTitle:"volatile 的原理",charIndex:8322},{level:4,title:"volatile 的使用场景",slug:"volatile-的使用场景",normalizedTitle:"volatile 的使用场景",charIndex:8868},{level:2,title:"synchronized",slug:"synchronized",normalizedTitle:"synchronized",charIndex:32},{level:3,title:"long 和 double 变量的特殊规则",slug:"long-和-double-变量的特殊规则",normalizedTitle:"long 和 double 变量的特殊规则",charIndex:8989},{level:3,title:"final 型量的特殊规则",slug:"final-型量的特殊规则",normalizedTitle:"final 型量的特殊规则",charIndex:9416},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:9592}],headersStr:"物理内存模型 硬件处理效率 缓存一致性 代码乱序执行优化 Java 内存模型 主内存和工作内存 JMM 内存操作的问题 内存间交互操作 并发安全特性 原子性 可见性 有序性 Happens-Before 内存屏障 volatile volatile 变量的特性 保证变量对所有线程的可见性 语义 2 禁止进行指令重排序 volatile 的原理 volatile 的使用场景 synchronized long 和 double 变量的特殊规则 final 型量的特殊规则 参考资料",content:'# Java 内存模型\n\n> 关键词：JMM、volatile、synchronized、final、Happens-Before、内存屏障\n> \n> 摘要：Java 内存模型（Java Memory Model），简称 JMM。Java 内存模型的目标是为了解决由可见性和有序性导致的并发安全问题。Java 内存模型通过 屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。\n\n\n# 物理内存模型\n\n物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。\n\n\n# 硬件处理效率\n\n物理内存的第一个问题是：硬件处理效率。\n\n * 绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少需要与内存交互，如读取运算数据、存储运算结果，这个 I/O 操作是很难消除的（无法仅靠寄存器完成所有运算任务）。\n * 由于计算机的存储设备与处理器的运算速度有几个数量级的差距 ，这种速度上的矛盾，会降低硬件的处理效率。所以，现代计算机都不得不 加入高速缓存（Cache） 来作为内存和处理器之间的缓冲。将需要用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步会内存中，这样处理器就无需等待缓慢的内存读写了。\n\n\n# 缓存一致性\n\n高速缓存解决了 硬件效率问题，但是引入了一个新的问题：缓存一致性（Cache Coherence）。\n\n在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。\n\n为了解决缓存一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。\n\n\n\n\n# 代码乱序执行优化\n\n除了高速缓存以外，为了使得处理器内部的运算单元尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化。处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。\n\n\n\n乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化。\n\n * 单核环境下，处理器保证做出的优化不会导致执行结果远离预期目标，但在多核环境下却并非如此。\n * 多核环境下， 如果存在一个核的计算任务依赖另一个核的计算任务的中间结果，而且对相关数据读写没做任何防护措施，那么其顺序性并不能靠代码的先后顺序来保证。\n\n\n\n\n# Java 内存模型\n\n内存模型 这个概念。我们可以理解为：在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理计算机可以有不一样的内存模型，JVM 也有自己的内存模型。\n\nJVM 中试图定义一种 Java 内存模型（Java Memory Model, JMM）来屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序 在各种平台下都能达到一致的内存访问效果。\n\n在 Java 并发简介 中已经介绍了，并发安全需要满足可见性、有序性、原子性。其中，导致可见性的原因是缓存，导致有序性的原因是编译优化。那解决可见性、有序性最直接的办法就是禁用缓存和编译优化 。但这么做，性能就堪忧了。\n\n合理的方案应该是按需禁用缓存以及编译优化。那么，如何做到呢？，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及 Happens-Before 规则。\n\n\n# 主内存和工作内存\n\nJMM 的主要目标是 定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数值对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，JMM 并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，也没有限制即使编译器进行调整代码执行顺序这类优化措施。\n\nJMM 规定了所有的变量都存储在主内存（Main Memory）中。\n\n每条线程还有自己的工作内存（Working Memory），工作内存中保留了该线程使用到的变量的主内存的副本。工作内存是 JMM 的一个抽象概念，并不真实存在，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。\n\n\n\n线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。\n\n\n\n> 说明：\n> \n> 这里说的主内存、工作内存与 Java 内存区域中的堆、栈、方法区等不是同一个层次的内存划分。\n\n\n# JMM 内存操作的问题\n\n类似于物理内存模型面临的问题，JMM 存在以下两个问题：\n\n * 工作内存数据一致性 - 各个线程操作数据时会保存使用到的主内存中的共享变量副本，当多个线程的运算任务都涉及同一个共享变量时，将导致各自的的共享变量副本不一致。如果真的发生这种情况，数据同步回主内存以谁的副本数据为准？ Java 内存模型主要通过一系列的数据同步协议、规则来保证数据的一致性。\n * 指令重排序优化 - Java 中重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译期重排序和运行期重排序，分别对应编译时和运行时环境。 同样的，指令重排序不是随意重排序，它需要满足以下两个条件：\n   * 在单线程环境下不能改变程序运行的结果。即时编译器（和处理器）需要保证程序能够遵守 as-if-serial 属性。通俗地说，就是在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。\n   * 存在数据依赖关系的不允许重排序。\n   * 多线程环境下，如果线程处理逻辑之间存在依赖关系，有可能因为指令重排序导致运行结果与预期不同。\n\n\n# 内存间交互操作\n\nJMM 定义了 8 个操作来完成主内存和工作内存之间的交互操作。JVM 实现时必须保证下面介绍的每种操作都是 原子的（对于 double 和 long 型的变量来说，load、store、read、和 write 操作在某些平台上允许有例外 ）。\n\n * lock (锁定) - 作用于主内存的变量，它把一个变量标识为一条线程独占的状态。\n * unlock (解锁) - 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\n * read (读取) - 作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。\n * write (写入) - 作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。\n * load (载入) - 作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。\n * use (使用) - 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时就会执行这个操作。\n * assign (赋值) - 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\n * store (存储) - 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后 write 操作使用。\n\n如果要把一个变量从主内存中复制到工作内存，就需要按序执行 read 和 load 操作；如果把变量从工作内存中同步回主内存中，就需要按序执行 store 和 write 操作。但 Java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。\n\nJMM 还规定了上述 8 种基本操作，需要满足以下规则：\n\n * read 和 load 必须成对出现；store 和 write 必须成对出现。即不允许一个变量从主内存读取了但工作内存不接受，或从工作内存发起回写了但主内存不接受的情况出现。\n * 不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须把变化同步到主内存中。\n * 不允许一个线程无原因的（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。\n * 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign ）的变量。换句话说，就是对一个变量实施 use 和 store 操作之前，必须先执行过了 load 或 assign 操作。\n * 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。所以 lock 和 unlock 必须成对出现。\n * 如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。\n * 如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。\n * 对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）\n\n\n\n\n# 并发安全特性\n\n上文介绍了 Java 内存交互的 8 种基本操作，它们遵循 Java 内存三大特性：原子性、可见性、有序性。\n\n而这三大特性，归根结底，是为了实现多线程的 数据一致性，使得程序在多线程并发，指令重排序优化的环境中能如预期运行。\n\n# 原子性\n\n原子性即一个操作或者多个操作，要么全部执行（执行的过程不会被任何因素打断），要么就都不执行。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。\n\n在 Java 中，为了保证原子性，提供了两个高级的字节码指令 monitorenter 和 monitorexit。这两个字节码，在 Java 中对应的关键字就是 synchronized。\n\n因此，在 Java 中可以使用 synchronized 来保证方法和代码块内的操作是原子性的。\n\n# 可见性\n\n可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\nJMM 是通过 "变量修改后将新值同步回主内存， 变量读取前从主内存刷新变量值" 这种依赖主内存作为传递媒介的方式来实现的。\n\nJava 实现多线程可见性的方式有：\n\n * volatile\n * synchronized\n * final\n\n# 有序性\n\n有序性规则表现在以下两种场景: 线程内和线程间\n\n * 线程内 - 从某个线程的角度看方法的执行，指令会按照一种叫“串行”（as-if-serial）的方式执行，此种方式已经应用于顺序编程语言。\n * 线程间 - 这个线程“观察”到其他线程并发地执行非同步的代码时，由于指令重排序优化，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块（synchronized 关键字修饰）以及 volatile 字段的操作仍维持相对有序。\n\n在 Java 中，可以使用 synchronized 和 volatile 来保证多线程之间操作的有序性。实现方式有所区别：\n\n * volatile 关键字会禁止指令重排序。\n * synchronized 关键字通过互斥保证同一时刻只允许一条线程操作。\n\n\n# Happens-Before\n\nJMM 为程序中所有的操作定义了一个偏序关系，称之为 先行发生原则（Happens-Before）。\n\nHappens-Before 是指 前面一个操作的结果对后续操作是可见的。\n\nHappens-Before 非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作间是否可能存在冲突的所有问题。\n\n * 程序次序规则 - 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。\n * 锁定规则 - 一个 unLock 操作先行发生于后面对同一个锁的 lock 操作。\n * volatile 变量规则 - 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。\n * 线程启动规则 - Thread 对象的 start() 方法先行发生于此线程的每个一个动作。\n * 线程终止规则 - 线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行。\n * 线程中断规则 - 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测到是否有中断发生。\n * 对象终结规则 - 一个对象的初始化完成先行发生于它的 finalize() 方法的开始。\n * 传递性 - 如果操作 A 先行发生于 操作 B，而操作 B 又 先行发生于 操作 C，则可以得出操作 A 先行发生于 操作 C。\n\n\n# 内存屏障\n\nJava 中如何保证底层操作的有序性和可见性？可以通过内存屏障（memory barrier）。\n\n内存屏障是被插入两个 CPU 指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障有序性的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障可见性。\n\n举个例子：\n\nStore1;\nStore2;\nLoad1;\nStoreLoad;  //内存屏障\nStore3;\nLoad2;\nLoad3;\n复制代码\n\n\n对于上面的一组 CPU 指令（Store 表示写入指令，Load 表示读取指令），StoreLoad 屏障之前的 Store 指令无法与 StoreLoad 屏障之后的 Load 指令进行交换位置，即重排序。但是 StoreLoad 屏障之前和之后的指令是可以互换位置的，即 Store1 可以和 Store2 互换，Load2 可以和 Load3 互换。\n\n常见有 4 种屏障\n\n * LoadLoad 屏障 - 对于这样的语句 Load1; LoadLoad; Load2，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。\n * StoreStore 屏障 - 对于这样的语句 Store1; StoreStore; Store2，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。\n * LoadStore 屏障 - 对于这样的语句 Load1; LoadStore; Store2，在 Store2 及后续写入操作被执行前，保证 Load1 要读取的数据被读取完毕。\n * StoreLoad 屏障 - 对于这样的语句 Store1; StoreLoad; Load2，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。\n\nJava 中对内存屏障的使用在一般的代码中不太容易见到，常见的有 volatile 和 synchronized 关键字修饰的代码块(后面再展开介绍)，还可以通过 Unsafe 这个类来使用内存屏障。\n\n\n# volatile\n\nvolatile 是 JVM 提供的 最轻量级的同步机制。\n\nvolatile 的中文意思是不稳定的，易变的，用 volatile 修饰变量是为了保证变量在多线程中的可见性。\n\n# volatile 变量的特性\n\nvolatile 变量具有两种特性：\n\n * 保证变量对所有线程的可见性。\n * 禁止进行指令重排序\n\n# 保证变量对所有线程的可见性\n\n这里的可见性是指当一条线程修改了 volatile 变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。\n\n线程写 volatile 变量的过程：\n\n 1. 改变线程工作内存中 volatile 变量副本的值\n 2. 将改变后的副本的值从工作内存刷新到主内存\n\n线程读 volatile 变量的过程：\n\n 1. 从主内存中读取 volatile 变量的最新值到线程的工作内存中\n 2. 从工作内存中读取 volatile 变量的副本\n\n> 注意：保证可见性不等同于 volatile 变量保证并发操作的安全性\n> \n> 在不符合以下两点的场景中，仍然要通过枷锁来保证原子性：\n> \n>  * 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n>  * 变量不需要与其他状态变量共同参与不变约束。\n\n但是如果多个线程同时把更新后的变量值同时刷新回主内存，可能导致得到的值不是预期结果：\n\n举个例子： 定义 volatile int count = 0，2 个线程同时执行 count++ 操作，每个线程都执行 500 次，最终结果小于 1000，原因是每个线程执行 count++ 需要以下 3 个步骤：\n\n 1. 线程从主内存读取最新的 count 的值\n 2. 执行引擎把 count 值加 1，并赋值给线程工作内存\n 3. 线程工作内存把 count 值保存到主内存 有可能某一时刻 2 个线程在步骤 1 读取到的值都是 100，执行完步骤 2 得到的值都是 101，最后刷新了 2 次 101 保存到主内存。\n\n# 语义 2 禁止进行指令重排序\n\n具体一点解释，禁止重排序的规则如下：\n\n * 当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n * 在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。\n\n普通的变量仅仅会保证该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证赋值操作的顺序与程序代码中的执行顺序一致。\n\n举个例子：\n\nvolatile boolean initialized = false;\n\n// 下面代码线程A中执行\n// 读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用\ndoSomethingReadConfg();\ninitialized = true;\n\n// 下面代码线程B中执行\n// 等待initialized 为true，代表线程A已经把配置信息初始化完成\nwhile (!initialized) {\n     sleep();\n}\n// 使用线程A初始化好的配置信息\ndoSomethingWithConfig();\n复制代码\n\n\n上面代码中如果定义 initialized 变量时没有使用 volatile 修饰，就有可能会由于指令重排序的优化，导致线程 A 中最后一句代码 "initialized = true" 在 “doSomethingReadConfg()” 之前被执行，这样会导致线程 B 中使用配置信息的代码就可能出现错误，而 volatile 关键字就禁止重排序的语义可以避免此类情况发生。\n\n# volatile 的原理\n\n具体实现方式是在编译期生成字节码时，会在指令序列中增加内存屏障来保证，下面是基于保守策略的 JMM 内存屏障插入策略：\n\n * 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。 该屏障除了保证了屏障之前的写操作和该屏障之后的写操作不能重排序，还会保证了 volatile 写操作之前，任何的读写操作都会先于 volatile 被提交。\n * 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。 该屏障除了使 volatile 写操作不会与之后的读操作重排序外，还会刷新处理器缓存，使 volatile 变量的写更新对其他线程可见。\n * 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。 该屏障除了使 volatile 读操作不会与之前的写操作发生重排序外，还会刷新处理器缓存，使 volatile 变量读取的为最新值。\n * 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。 该屏障除了禁止了 volatile 读操作与其之后的任何写操作进行重排序，还会刷新处理器缓存，使其他线程 volatile 变量的写更新对 volatile 读操作的线程可见。\n\n# volatile 的使用场景\n\n总结起来，就是“一次写入，到处读取”，某一线程负责更新变量，其他线程只读取变量(不更新变量)，并根据变量的新值执行相应逻辑。例如状态标志位更新，观察者模型变量值发布。\n\n\n# synchronized\n\n\n# long 和 double 变量的特殊规则\n\nJMM 要求 lock、unlock、read、load、assign、use、store、write 这 8 种操作都具有原子性，但是对于 64 位的数据类型（long 和 double），在模型中特别定义相对宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作分为 2 次 32 位的操作来进行，即允许虚拟机可选择不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。由于这种非原子性，有可能导致其他线程读到同步未完成的“32 位的半个变量”的值。\n\n不过实际开发中，Java 内存模型强烈建议虚拟机把 64 位数据的读写实现为具有原子性，目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的 long 和 double 变量专门声明为 volatile。\n\n\n# final 型量的特殊规则\n\n我们知道，final 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。 final 关键字的可见性是指：被 final 修饰的字段在声明时或者构造器中，一旦初始化完成，那么在其他线程无须同步就能正确看见 final 字段的值。这是因为一旦初始化完成，final 变量的值立刻回写到主内存。\n\n\n# 参考资料\n\n * 《Java 并发编程实战》\n * 《Java 并发编程的艺术》\n * 《深入理解 Java 虚拟机》\n * 理解 Java 内存模型\n * 《Java 并发编程实战》',normalizedContent:'# java 内存模型\n\n> 关键词：jmm、volatile、synchronized、final、happens-before、内存屏障\n> \n> 摘要：java 内存模型（java memory model），简称 jmm。java 内存模型的目标是为了解决由可见性和有序性导致的并发安全问题。java 内存模型通过 屏蔽各种硬件和操作系统的内存访问差异，以实现让 java 程序在各种平台下都能达到一致的内存访问效果。\n\n\n# 物理内存模型\n\n物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。\n\n\n# 硬件处理效率\n\n物理内存的第一个问题是：硬件处理效率。\n\n * 绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少需要与内存交互，如读取运算数据、存储运算结果，这个 i/o 操作是很难消除的（无法仅靠寄存器完成所有运算任务）。\n * 由于计算机的存储设备与处理器的运算速度有几个数量级的差距 ，这种速度上的矛盾，会降低硬件的处理效率。所以，现代计算机都不得不 加入高速缓存（cache） 来作为内存和处理器之间的缓冲。将需要用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步会内存中，这样处理器就无需等待缓慢的内存读写了。\n\n\n# 缓存一致性\n\n高速缓存解决了 硬件效率问题，但是引入了一个新的问题：缓存一致性（cache coherence）。\n\n在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。\n\n为了解决缓存一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。\n\n\n\n\n# 代码乱序执行优化\n\n除了高速缓存以外，为了使得处理器内部的运算单元尽量被充分利用，处理器可能会对输入代码进行乱序执行（out-of-order execution）优化。处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。\n\n\n\n乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化。\n\n * 单核环境下，处理器保证做出的优化不会导致执行结果远离预期目标，但在多核环境下却并非如此。\n * 多核环境下， 如果存在一个核的计算任务依赖另一个核的计算任务的中间结果，而且对相关数据读写没做任何防护措施，那么其顺序性并不能靠代码的先后顺序来保证。\n\n\n\n\n# java 内存模型\n\n内存模型 这个概念。我们可以理解为：在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理计算机可以有不一样的内存模型，jvm 也有自己的内存模型。\n\njvm 中试图定义一种 java 内存模型（java memory model, jmm）来屏蔽各种硬件和操作系统的内存访问差异，以实现让 java 程序 在各种平台下都能达到一致的内存访问效果。\n\n在 java 并发简介 中已经介绍了，并发安全需要满足可见性、有序性、原子性。其中，导致可见性的原因是缓存，导致有序性的原因是编译优化。那解决可见性、有序性最直接的办法就是禁用缓存和编译优化 。但这么做，性能就堪忧了。\n\n合理的方案应该是按需禁用缓存以及编译优化。那么，如何做到呢？，java 内存模型规范了 jvm 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及 happens-before 规则。\n\n\n# 主内存和工作内存\n\njmm 的主要目标是 定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（variables）与 java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数值对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，jmm 并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，也没有限制即使编译器进行调整代码执行顺序这类优化措施。\n\njmm 规定了所有的变量都存储在主内存（main memory）中。\n\n每条线程还有自己的工作内存（working memory），工作内存中保留了该线程使用到的变量的主内存的副本。工作内存是 jmm 的一个抽象概念，并不真实存在，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。\n\n\n\n线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。\n\n\n\n> 说明：\n> \n> 这里说的主内存、工作内存与 java 内存区域中的堆、栈、方法区等不是同一个层次的内存划分。\n\n\n# jmm 内存操作的问题\n\n类似于物理内存模型面临的问题，jmm 存在以下两个问题：\n\n * 工作内存数据一致性 - 各个线程操作数据时会保存使用到的主内存中的共享变量副本，当多个线程的运算任务都涉及同一个共享变量时，将导致各自的的共享变量副本不一致。如果真的发生这种情况，数据同步回主内存以谁的副本数据为准？ java 内存模型主要通过一系列的数据同步协议、规则来保证数据的一致性。\n * 指令重排序优化 - java 中重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译期重排序和运行期重排序，分别对应编译时和运行时环境。 同样的，指令重排序不是随意重排序，它需要满足以下两个条件：\n   * 在单线程环境下不能改变程序运行的结果。即时编译器（和处理器）需要保证程序能够遵守 as-if-serial 属性。通俗地说，就是在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。\n   * 存在数据依赖关系的不允许重排序。\n   * 多线程环境下，如果线程处理逻辑之间存在依赖关系，有可能因为指令重排序导致运行结果与预期不同。\n\n\n# 内存间交互操作\n\njmm 定义了 8 个操作来完成主内存和工作内存之间的交互操作。jvm 实现时必须保证下面介绍的每种操作都是 原子的（对于 double 和 long 型的变量来说，load、store、read、和 write 操作在某些平台上允许有例外 ）。\n\n * lock (锁定) - 作用于主内存的变量，它把一个变量标识为一条线程独占的状态。\n * unlock (解锁) - 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\n * read (读取) - 作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。\n * write (写入) - 作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。\n * load (载入) - 作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。\n * use (使用) - 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时就会执行这个操作。\n * assign (赋值) - 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\n * store (存储) - 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后 write 操作使用。\n\n如果要把一个变量从主内存中复制到工作内存，就需要按序执行 read 和 load 操作；如果把变量从工作内存中同步回主内存中，就需要按序执行 store 和 write 操作。但 java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。\n\njmm 还规定了上述 8 种基本操作，需要满足以下规则：\n\n * read 和 load 必须成对出现；store 和 write 必须成对出现。即不允许一个变量从主内存读取了但工作内存不接受，或从工作内存发起回写了但主内存不接受的情况出现。\n * 不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须把变化同步到主内存中。\n * 不允许一个线程无原因的（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。\n * 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign ）的变量。换句话说，就是对一个变量实施 use 和 store 操作之前，必须先执行过了 load 或 assign 操作。\n * 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。所以 lock 和 unlock 必须成对出现。\n * 如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。\n * 如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。\n * 对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）\n\n\n\n\n# 并发安全特性\n\n上文介绍了 java 内存交互的 8 种基本操作，它们遵循 java 内存三大特性：原子性、可见性、有序性。\n\n而这三大特性，归根结底，是为了实现多线程的 数据一致性，使得程序在多线程并发，指令重排序优化的环境中能如预期运行。\n\n# 原子性\n\n原子性即一个操作或者多个操作，要么全部执行（执行的过程不会被任何因素打断），要么就都不执行。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。\n\n在 java 中，为了保证原子性，提供了两个高级的字节码指令 monitorenter 和 monitorexit。这两个字节码，在 java 中对应的关键字就是 synchronized。\n\n因此，在 java 中可以使用 synchronized 来保证方法和代码块内的操作是原子性的。\n\n# 可见性\n\n可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\njmm 是通过 "变量修改后将新值同步回主内存， 变量读取前从主内存刷新变量值" 这种依赖主内存作为传递媒介的方式来实现的。\n\njava 实现多线程可见性的方式有：\n\n * volatile\n * synchronized\n * final\n\n# 有序性\n\n有序性规则表现在以下两种场景: 线程内和线程间\n\n * 线程内 - 从某个线程的角度看方法的执行，指令会按照一种叫“串行”（as-if-serial）的方式执行，此种方式已经应用于顺序编程语言。\n * 线程间 - 这个线程“观察”到其他线程并发地执行非同步的代码时，由于指令重排序优化，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块（synchronized 关键字修饰）以及 volatile 字段的操作仍维持相对有序。\n\n在 java 中，可以使用 synchronized 和 volatile 来保证多线程之间操作的有序性。实现方式有所区别：\n\n * volatile 关键字会禁止指令重排序。\n * synchronized 关键字通过互斥保证同一时刻只允许一条线程操作。\n\n\n# happens-before\n\njmm 为程序中所有的操作定义了一个偏序关系，称之为 先行发生原则（happens-before）。\n\nhappens-before 是指 前面一个操作的结果对后续操作是可见的。\n\nhappens-before 非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作间是否可能存在冲突的所有问题。\n\n * 程序次序规则 - 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。\n * 锁定规则 - 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。\n * volatile 变量规则 - 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。\n * 线程启动规则 - thread 对象的 start() 方法先行发生于此线程的每个一个动作。\n * 线程终止规则 - 线程中所有的操作都先行发生于线程的终止检测，我们可以通过 thread.join() 方法结束、thread.isalive() 的返回值手段检测到线程已经终止执行。\n * 线程中断规则 - 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 thread.interrupted() 方法检测到是否有中断发生。\n * 对象终结规则 - 一个对象的初始化完成先行发生于它的 finalize() 方法的开始。\n * 传递性 - 如果操作 a 先行发生于 操作 b，而操作 b 又 先行发生于 操作 c，则可以得出操作 a 先行发生于 操作 c。\n\n\n# 内存屏障\n\njava 中如何保证底层操作的有序性和可见性？可以通过内存屏障（memory barrier）。\n\n内存屏障是被插入两个 cpu 指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障有序性的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障可见性。\n\n举个例子：\n\nstore1;\nstore2;\nload1;\nstoreload;  //内存屏障\nstore3;\nload2;\nload3;\n复制代码\n\n\n对于上面的一组 cpu 指令（store 表示写入指令，load 表示读取指令），storeload 屏障之前的 store 指令无法与 storeload 屏障之后的 load 指令进行交换位置，即重排序。但是 storeload 屏障之前和之后的指令是可以互换位置的，即 store1 可以和 store2 互换，load2 可以和 load3 互换。\n\n常见有 4 种屏障\n\n * loadload 屏障 - 对于这样的语句 load1; loadload; load2，在 load2 及后续读取操作要读取的数据被访问前，保证 load1 要读取的数据被读取完毕。\n * storestore 屏障 - 对于这样的语句 store1; storestore; store2，在 store2 及后续写入操作执行前，保证 store1 的写入操作对其它处理器可见。\n * loadstore 屏障 - 对于这样的语句 load1; loadstore; store2，在 store2 及后续写入操作被执行前，保证 load1 要读取的数据被读取完毕。\n * storeload 屏障 - 对于这样的语句 store1; storeload; load2，在 load2 及后续所有读取操作执行前，保证 store1 的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。\n\njava 中对内存屏障的使用在一般的代码中不太容易见到，常见的有 volatile 和 synchronized 关键字修饰的代码块(后面再展开介绍)，还可以通过 unsafe 这个类来使用内存屏障。\n\n\n# volatile\n\nvolatile 是 jvm 提供的 最轻量级的同步机制。\n\nvolatile 的中文意思是不稳定的，易变的，用 volatile 修饰变量是为了保证变量在多线程中的可见性。\n\n# volatile 变量的特性\n\nvolatile 变量具有两种特性：\n\n * 保证变量对所有线程的可见性。\n * 禁止进行指令重排序\n\n# 保证变量对所有线程的可见性\n\n这里的可见性是指当一条线程修改了 volatile 变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。\n\n线程写 volatile 变量的过程：\n\n 1. 改变线程工作内存中 volatile 变量副本的值\n 2. 将改变后的副本的值从工作内存刷新到主内存\n\n线程读 volatile 变量的过程：\n\n 1. 从主内存中读取 volatile 变量的最新值到线程的工作内存中\n 2. 从工作内存中读取 volatile 变量的副本\n\n> 注意：保证可见性不等同于 volatile 变量保证并发操作的安全性\n> \n> 在不符合以下两点的场景中，仍然要通过枷锁来保证原子性：\n> \n>  * 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n>  * 变量不需要与其他状态变量共同参与不变约束。\n\n但是如果多个线程同时把更新后的变量值同时刷新回主内存，可能导致得到的值不是预期结果：\n\n举个例子： 定义 volatile int count = 0，2 个线程同时执行 count++ 操作，每个线程都执行 500 次，最终结果小于 1000，原因是每个线程执行 count++ 需要以下 3 个步骤：\n\n 1. 线程从主内存读取最新的 count 的值\n 2. 执行引擎把 count 值加 1，并赋值给线程工作内存\n 3. 线程工作内存把 count 值保存到主内存 有可能某一时刻 2 个线程在步骤 1 读取到的值都是 100，执行完步骤 2 得到的值都是 101，最后刷新了 2 次 101 保存到主内存。\n\n# 语义 2 禁止进行指令重排序\n\n具体一点解释，禁止重排序的规则如下：\n\n * 当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n * 在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。\n\n普通的变量仅仅会保证该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证赋值操作的顺序与程序代码中的执行顺序一致。\n\n举个例子：\n\nvolatile boolean initialized = false;\n\n// 下面代码线程a中执行\n// 读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用\ndosomethingreadconfg();\ninitialized = true;\n\n// 下面代码线程b中执行\n// 等待initialized 为true，代表线程a已经把配置信息初始化完成\nwhile (!initialized) {\n     sleep();\n}\n// 使用线程a初始化好的配置信息\ndosomethingwithconfig();\n复制代码\n\n\n上面代码中如果定义 initialized 变量时没有使用 volatile 修饰，就有可能会由于指令重排序的优化，导致线程 a 中最后一句代码 "initialized = true" 在 “dosomethingreadconfg()” 之前被执行，这样会导致线程 b 中使用配置信息的代码就可能出现错误，而 volatile 关键字就禁止重排序的语义可以避免此类情况发生。\n\n# volatile 的原理\n\n具体实现方式是在编译期生成字节码时，会在指令序列中增加内存屏障来保证，下面是基于保守策略的 jmm 内存屏障插入策略：\n\n * 在每个 volatile 写操作的前面插入一个 storestore 屏障。 该屏障除了保证了屏障之前的写操作和该屏障之后的写操作不能重排序，还会保证了 volatile 写操作之前，任何的读写操作都会先于 volatile 被提交。\n * 在每个 volatile 写操作的后面插入一个 storeload 屏障。 该屏障除了使 volatile 写操作不会与之后的读操作重排序外，还会刷新处理器缓存，使 volatile 变量的写更新对其他线程可见。\n * 在每个 volatile 读操作的后面插入一个 loadload 屏障。 该屏障除了使 volatile 读操作不会与之前的写操作发生重排序外，还会刷新处理器缓存，使 volatile 变量读取的为最新值。\n * 在每个 volatile 读操作的后面插入一个 loadstore 屏障。 该屏障除了禁止了 volatile 读操作与其之后的任何写操作进行重排序，还会刷新处理器缓存，使其他线程 volatile 变量的写更新对 volatile 读操作的线程可见。\n\n# volatile 的使用场景\n\n总结起来，就是“一次写入，到处读取”，某一线程负责更新变量，其他线程只读取变量(不更新变量)，并根据变量的新值执行相应逻辑。例如状态标志位更新，观察者模型变量值发布。\n\n\n# synchronized\n\n\n# long 和 double 变量的特殊规则\n\njmm 要求 lock、unlock、read、load、assign、use、store、write 这 8 种操作都具有原子性，但是对于 64 位的数据类型（long 和 double），在模型中特别定义相对宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作分为 2 次 32 位的操作来进行，即允许虚拟机可选择不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。由于这种非原子性，有可能导致其他线程读到同步未完成的“32 位的半个变量”的值。\n\n不过实际开发中，java 内存模型强烈建议虚拟机把 64 位数据的读写实现为具有原子性，目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的 long 和 double 变量专门声明为 volatile。\n\n\n# final 型量的特殊规则\n\n我们知道，final 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。 final 关键字的可见性是指：被 final 修饰的字段在声明时或者构造器中，一旦初始化完成，那么在其他线程无须同步就能正确看见 final 字段的值。这是因为一旦初始化完成，final 变量的值立刻回写到主内存。\n\n\n# 参考资料\n\n * 《java 并发编程实战》\n * 《java 并发编程的艺术》\n * 《深入理解 java 虚拟机》\n * 理解 java 内存模型\n * 《java 并发编程实战》',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"ForkJoin框架",frontmatter:{title:"ForkJoin框架",categories:["编程","Java","JavaSE","并发"],tags:["Java","JavaSE","并发"],abbrlink:"c16f2ba9",date:"2020-07-14T15:27:46.000Z",permalink:"/pages/e96ed2/"},regularPath:"/05.%E5%B9%B6%E5%8F%91/10.ForkJoin%E6%A1%86%E6%9E%B6.html",relativePath:"05.并发/10.ForkJoin框架.md",key:"v-39d421ee",path:"/pages/e96ed2/",headers:[{level:2,title:"CompletableFuture",slug:"completablefuture",normalizedTitle:"completablefuture",charIndex:93},{level:3,title:"runAsync 和 supplyAsync 方法",slug:"runasync-和-supplyasync-方法",normalizedTitle:"runasync 和 supplyasync 方法",charIndex:179},{level:2,title:"CompletionStage",slug:"completionstage",normalizedTitle:"completionstage",charIndex:707},{level:3,title:"串行关系",slug:"串行关系",normalizedTitle:"串行关系",charIndex:760},{level:3,title:"描述 AND 汇聚关系",slug:"描述-and-汇聚关系",normalizedTitle:"描述 and 汇聚关系",charIndex:1397},{level:3,title:"描述 OR 汇聚关系",slug:"描述-or-汇聚关系",normalizedTitle:"描述 or 汇聚关系",charIndex:1855},{level:3,title:"异常处理",slug:"异常处理",normalizedTitle:"异常处理",charIndex:2764},{level:2,title:"Fork/Join",slug:"fork-join",normalizedTitle:"fork/join",charIndex:3866},{level:3,title:"ForkJoinPool 工作原理",slug:"forkjoinpool-工作原理",normalizedTitle:"forkjoinpool 工作原理",charIndex:4451},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5241}],headersStr:"CompletableFuture runAsync 和 supplyAsync 方法 CompletionStage 串行关系 描述 AND 汇聚关系 描述 OR 汇聚关系 异常处理 Fork/Join ForkJoinPool 工作原理 参考资料",content:"# Java Fork Join 框架\n\n对于简单的并行任务，你可以通过“线程池 +Future”的方案来解决；如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 CompletableFuture 来解决；而批量的并行任务，则可以通过 CompletionService 来解决。\n\n\n# CompletableFuture\n\n\n# runAsync 和 supplyAsync 方法\n\nCompletableFuture 提供了四个静态方法来创建一个异步操作。\n\npublic static CompletableFuture<Void> runAsync(Runnable runnable)\npublic static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)\n\n\n没有指定 Executor 的方法会使用 ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。\n\n * runAsync 方法不支持返回值。\n * supplyAsync 可以支持返回值。\n\n\n# CompletionStage\n\nCompletionStage 接口可以清晰地描述任务之间的时序关系，如串行关系、并行关系、汇聚关系等。\n\n\n# 串行关系\n\nCompletionStage 接口里面描述串行关系，主要是 thenApply、thenAccept、thenRun 和 thenCompose 这四个系列的接口。\n\nthenApply 系列函数里参数 fn 的类型是接口 Function<T, R>，这个接口里与 CompletionStage 相关的方法是 R apply(T t)，这个方法既能接收参数也支持返回值，所以 thenApply 系列方法返回的是CompletionStage。\n\n而 thenAccept 系列方法里参数 consumer 的类型是接口 Consumer<T>，这个接口里与 CompletionStage 相关的方法是 void accept(T t)，这个方法虽然支持参数，但却不支持回值，所以 thenAccept 系列方法返回的是CompletionStage<Void>。\n\nthenRun 系列方法里 action 的参数是 Runnable，所以 action 既不能接收参数也不支持返回值，所以 thenRun 系列方法返回的也是CompletionStage<Void>。\n\n这些方法里面 Async 代表的是异步执行 fn、consumer 或者 action。其中，需要你注意的是 thenCompose 系列方法，这个系列的方法会新创建出一个子流程，最终结果和 thenApply 系列是相同的。\n\n\n# 描述 AND 汇聚关系\n\nCompletionStage 接口里面描述 AND 汇聚关系，主要是 thenCombine、thenAcceptBoth 和 runAfterBoth 系列的接口，这些接口的区别也是源自 fn、consumer、action 这三个核心参数不同。\n\nCompletionStage<R> thenCombine(other, fn);\nCompletionStage<R> thenCombineAsync(other, fn);\nCompletionStage<Void> thenAcceptBoth(other, consumer);\nCompletionStage<Void> thenAcceptBothAsync(other, consumer);\nCompletionStage<Void> runAfterBoth(other, action);\nCompletionStage<Void> runAfterBothAsync(other, action);\n\n\n\n# 描述 OR 汇聚关系\n\nCompletionStage 接口里面描述 OR 汇聚关系，主要是 applyToEither、acceptEither 和 runAfterEither 系列的接口，这些接口的区别也是源自 fn、consumer、action 这三个核心参数不同。\n\nCompletionStage applyToEither(other, fn);\nCompletionStage applyToEitherAsync(other, fn);\nCompletionStage acceptEither(other, consumer);\nCompletionStage acceptEitherAsync(other, consumer);\nCompletionStage runAfterEither(other, action);\nCompletionStage runAfterEitherAsync(other, action);\n\n\n下面的示例代码展示了如何使用 applyToEither() 方法来描述一个 OR 汇聚关系。\n\nCompletableFuture<String> f1 =\n  CompletableFuture.supplyAsync(()->{\n    int t = getRandom(5, 10);\n    sleep(t, TimeUnit.SECONDS);\n    return String.valueOf(t);\n});\n\nCompletableFuture<String> f2 =\n  CompletableFuture.supplyAsync(()->{\n    int t = getRandom(5, 10);\n    sleep(t, TimeUnit.SECONDS);\n    return String.valueOf(t);\n});\n\nCompletableFuture<String> f3 =\n  f1.applyToEither(f2,s -> s);\n\nSystem.out.println(f3.join());\n\n\n\n# 异常处理\n\n虽然上面我们提到的 fn、consumer、action 它们的核心方法都不允许抛出可检查异常，但是却无法限制它们抛出运行时异常，例如下面的代码，执行 7/0 就会出现除零错误这个运行时异常。非异步编程里面，我们可以使用 try{}catch{} 来捕获并处理异常，那在异步编程里面，异常该如何处理呢？\n\nCompletableFuture<Integer>\n  f0 = CompletableFuture.\n    .supplyAsync(()->(7/0))\n    .thenApply(r->r*10);\nSystem.out.println(f0.join());\n\n\nCompletionStage 接口给我们提供的方案非常简单，比 try{}catch{}还要简单，下面是相关的方法，使用这些方法进行异常处理和串行操作是一样的，都支持链式编程方式。\n\nCompletionStage exceptionally(fn);\nCompletionStage<R> whenComplete(consumer);\nCompletionStage<R> whenCompleteAsync(consumer);\nCompletionStage<R> handle(fn);\nCompletionStage<R> handleAsync(fn);\n\n\n下面的示例代码展示了如何使用 exceptionally() 方法来处理异常，exceptionally() 的使用非常类似于 try{}catch{}中的 catch{}，但是由于支持链式编程方式，所以相对更简单。既然有 try{}catch{}，那就一定还有 try{}finally{}，whenComplete() 和 handle() 系列方法就类似于 try{}finally{}中的 finally{}，无论是否发生异常都会执行 whenComplete() 中的回调函数 consumer 和 handle() 中的回调函数 fn。whenComplete() 和 handle() 的区别在于 whenComplete() 不支持返回结果，而 handle() 是支持返回结果的。\n\nCompletableFuture<Integer>\n  f0 = CompletableFuture\n    .supplyAsync(()->7/0))\n    .thenApply(r->r*10)\n    .exceptionally(e->0);\nSystem.out.println(f0.join());\n\n\n\n# Fork/Join\n\nFork/Join 是一个并行计算的框架，主要就是用来支持分治任务模型的，这个计算框架里的Fork 对应的是分治任务模型里的任务分解，Join 对应的是结果合并。Fork/Join 计算框架主要包含两部分，一部分是分治任务的线程池 ForkJoinPool，另一部分是分治任务 ForkJoinTask。这两部分的关系类似于 ThreadPoolExecutor 和 Runnable 的关系，都可以理解为提交任务到线程池，只不过分治任务有自己独特类型 ForkJoinTask。\n\nForkJoinTask 是一个抽象类，它的方法有很多，最核心的是 fork() 方法和 join() 方法，其中 fork() 方法会异步地执行一个子任务，而 join() 方法则会阻塞当前线程来等待子任务的执行结果。ForkJoinTask 有两个子类——RecursiveAction 和 RecursiveTask，通过名字你就应该能知道，它们都是用递归的方式来处理分治任务的。这两个子类都定义了抽象方法 compute()，不过区别是 RecursiveAction 定义的 compute() 没有返回值，而 RecursiveTask 定义的 compute() 方法是有返回值的。这两个子类也是抽象类，在使用的时候，需要你定义子类去扩展。\n\n\n# ForkJoinPool 工作原理\n\nFork/Join 并行计算的核心组件是 ForkJoinPool，所以下面我们就来简单介绍一下 ForkJoinPool 的工作原理。\n\n通过专栏前面文章的学习，你应该已经知道 ThreadPoolExecutor 本质上是一个生产者 - 消费者模式的实现，内部有一个任务队列，这个任务队列是生产者和消费者通信的媒介；ThreadPoolExecutor 可以有多个工作线程，但是这些工作线程都共享一个任务队列。\n\nForkJoinPool 本质上也是一个生产者 - 消费者的实现，但是更加智能，你可以参考下面的 ForkJoinPool 工作原理图来理解其原理。ThreadPoolExecutor 内部只有一个任务队列，而 ForkJoinPool 内部有多个任务队列，当我们通过 ForkJoinPool 的 invoke() 或者 submit() 方法提交任务时，ForkJoinPool 根据一定的路由规则把任务提交到一个任务队列中，如果任务在执行过程中会创建出子任务，那么子任务会提交到工作线程对应的任务队列中。\n\n如果工作线程对应的任务队列空了，是不是就没活儿干了呢？不是的，ForkJoinPool 支持一种叫做“任务窃取”的机制，如果工作线程空闲了，那它可以“窃取”其他工作任务队列里的任务，例如下图中，线程 T2 对应的任务队列已经空了，它可以“窃取”线程 T1 对应的任务队列的任务。如此一来，所有的工作线程都不会闲下来了。\n\nForkJoinPool 中的任务队列采用的是双端队列，工作线程正常获取任务和“窃取任务”分别是从任务队列不同的端消费，这样能避免很多不必要的数据竞争。我们这里介绍的仅仅是简化后的原理，ForkJoinPool 的实现远比我们这里介绍的复杂，如果你感兴趣，建议去看它的源码。\n\n\n\n\n# 参考资料\n\n * 《Java 并发编程实战》\n * 《Java 并发编程的艺术》\n * 《Java 并发编程实战》\n * CompletableFuture 使用详解",normalizedContent:"# java fork join 框架\n\n对于简单的并行任务，你可以通过“线程池 +future”的方案来解决；如果任务之间有聚合关系，无论是 and 聚合还是 or 聚合，都可以通过 completablefuture 来解决；而批量的并行任务，则可以通过 completionservice 来解决。\n\n\n# completablefuture\n\n\n# runasync 和 supplyasync 方法\n\ncompletablefuture 提供了四个静态方法来创建一个异步操作。\n\npublic static completablefuture<void> runasync(runnable runnable)\npublic static completablefuture<void> runasync(runnable runnable, executor executor)\npublic static <u> completablefuture<u> supplyasync(supplier<u> supplier)\npublic static <u> completablefuture<u> supplyasync(supplier<u> supplier, executor executor)\n\n\n没有指定 executor 的方法会使用 forkjoinpool.commonpool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。\n\n * runasync 方法不支持返回值。\n * supplyasync 可以支持返回值。\n\n\n# completionstage\n\ncompletionstage 接口可以清晰地描述任务之间的时序关系，如串行关系、并行关系、汇聚关系等。\n\n\n# 串行关系\n\ncompletionstage 接口里面描述串行关系，主要是 thenapply、thenaccept、thenrun 和 thencompose 这四个系列的接口。\n\nthenapply 系列函数里参数 fn 的类型是接口 function<t, r>，这个接口里与 completionstage 相关的方法是 r apply(t t)，这个方法既能接收参数也支持返回值，所以 thenapply 系列方法返回的是completionstage。\n\n而 thenaccept 系列方法里参数 consumer 的类型是接口 consumer<t>，这个接口里与 completionstage 相关的方法是 void accept(t t)，这个方法虽然支持参数，但却不支持回值，所以 thenaccept 系列方法返回的是completionstage<void>。\n\nthenrun 系列方法里 action 的参数是 runnable，所以 action 既不能接收参数也不支持返回值，所以 thenrun 系列方法返回的也是completionstage<void>。\n\n这些方法里面 async 代表的是异步执行 fn、consumer 或者 action。其中，需要你注意的是 thencompose 系列方法，这个系列的方法会新创建出一个子流程，最终结果和 thenapply 系列是相同的。\n\n\n# 描述 and 汇聚关系\n\ncompletionstage 接口里面描述 and 汇聚关系，主要是 thencombine、thenacceptboth 和 runafterboth 系列的接口，这些接口的区别也是源自 fn、consumer、action 这三个核心参数不同。\n\ncompletionstage<r> thencombine(other, fn);\ncompletionstage<r> thencombineasync(other, fn);\ncompletionstage<void> thenacceptboth(other, consumer);\ncompletionstage<void> thenacceptbothasync(other, consumer);\ncompletionstage<void> runafterboth(other, action);\ncompletionstage<void> runafterbothasync(other, action);\n\n\n\n# 描述 or 汇聚关系\n\ncompletionstage 接口里面描述 or 汇聚关系，主要是 applytoeither、accepteither 和 runaftereither 系列的接口，这些接口的区别也是源自 fn、consumer、action 这三个核心参数不同。\n\ncompletionstage applytoeither(other, fn);\ncompletionstage applytoeitherasync(other, fn);\ncompletionstage accepteither(other, consumer);\ncompletionstage accepteitherasync(other, consumer);\ncompletionstage runaftereither(other, action);\ncompletionstage runaftereitherasync(other, action);\n\n\n下面的示例代码展示了如何使用 applytoeither() 方法来描述一个 or 汇聚关系。\n\ncompletablefuture<string> f1 =\n  completablefuture.supplyasync(()->{\n    int t = getrandom(5, 10);\n    sleep(t, timeunit.seconds);\n    return string.valueof(t);\n});\n\ncompletablefuture<string> f2 =\n  completablefuture.supplyasync(()->{\n    int t = getrandom(5, 10);\n    sleep(t, timeunit.seconds);\n    return string.valueof(t);\n});\n\ncompletablefuture<string> f3 =\n  f1.applytoeither(f2,s -> s);\n\nsystem.out.println(f3.join());\n\n\n\n# 异常处理\n\n虽然上面我们提到的 fn、consumer、action 它们的核心方法都不允许抛出可检查异常，但是却无法限制它们抛出运行时异常，例如下面的代码，执行 7/0 就会出现除零错误这个运行时异常。非异步编程里面，我们可以使用 try{}catch{} 来捕获并处理异常，那在异步编程里面，异常该如何处理呢？\n\ncompletablefuture<integer>\n  f0 = completablefuture.\n    .supplyasync(()->(7/0))\n    .thenapply(r->r*10);\nsystem.out.println(f0.join());\n\n\ncompletionstage 接口给我们提供的方案非常简单，比 try{}catch{}还要简单，下面是相关的方法，使用这些方法进行异常处理和串行操作是一样的，都支持链式编程方式。\n\ncompletionstage exceptionally(fn);\ncompletionstage<r> whencomplete(consumer);\ncompletionstage<r> whencompleteasync(consumer);\ncompletionstage<r> handle(fn);\ncompletionstage<r> handleasync(fn);\n\n\n下面的示例代码展示了如何使用 exceptionally() 方法来处理异常，exceptionally() 的使用非常类似于 try{}catch{}中的 catch{}，但是由于支持链式编程方式，所以相对更简单。既然有 try{}catch{}，那就一定还有 try{}finally{}，whencomplete() 和 handle() 系列方法就类似于 try{}finally{}中的 finally{}，无论是否发生异常都会执行 whencomplete() 中的回调函数 consumer 和 handle() 中的回调函数 fn。whencomplete() 和 handle() 的区别在于 whencomplete() 不支持返回结果，而 handle() 是支持返回结果的。\n\ncompletablefuture<integer>\n  f0 = completablefuture\n    .supplyasync(()->7/0))\n    .thenapply(r->r*10)\n    .exceptionally(e->0);\nsystem.out.println(f0.join());\n\n\n\n# fork/join\n\nfork/join 是一个并行计算的框架，主要就是用来支持分治任务模型的，这个计算框架里的fork 对应的是分治任务模型里的任务分解，join 对应的是结果合并。fork/join 计算框架主要包含两部分，一部分是分治任务的线程池 forkjoinpool，另一部分是分治任务 forkjointask。这两部分的关系类似于 threadpoolexecutor 和 runnable 的关系，都可以理解为提交任务到线程池，只不过分治任务有自己独特类型 forkjointask。\n\nforkjointask 是一个抽象类，它的方法有很多，最核心的是 fork() 方法和 join() 方法，其中 fork() 方法会异步地执行一个子任务，而 join() 方法则会阻塞当前线程来等待子任务的执行结果。forkjointask 有两个子类——recursiveaction 和 recursivetask，通过名字你就应该能知道，它们都是用递归的方式来处理分治任务的。这两个子类都定义了抽象方法 compute()，不过区别是 recursiveaction 定义的 compute() 没有返回值，而 recursivetask 定义的 compute() 方法是有返回值的。这两个子类也是抽象类，在使用的时候，需要你定义子类去扩展。\n\n\n# forkjoinpool 工作原理\n\nfork/join 并行计算的核心组件是 forkjoinpool，所以下面我们就来简单介绍一下 forkjoinpool 的工作原理。\n\n通过专栏前面文章的学习，你应该已经知道 threadpoolexecutor 本质上是一个生产者 - 消费者模式的实现，内部有一个任务队列，这个任务队列是生产者和消费者通信的媒介；threadpoolexecutor 可以有多个工作线程，但是这些工作线程都共享一个任务队列。\n\nforkjoinpool 本质上也是一个生产者 - 消费者的实现，但是更加智能，你可以参考下面的 forkjoinpool 工作原理图来理解其原理。threadpoolexecutor 内部只有一个任务队列，而 forkjoinpool 内部有多个任务队列，当我们通过 forkjoinpool 的 invoke() 或者 submit() 方法提交任务时，forkjoinpool 根据一定的路由规则把任务提交到一个任务队列中，如果任务在执行过程中会创建出子任务，那么子任务会提交到工作线程对应的任务队列中。\n\n如果工作线程对应的任务队列空了，是不是就没活儿干了呢？不是的，forkjoinpool 支持一种叫做“任务窃取”的机制，如果工作线程空闲了，那它可以“窃取”其他工作任务队列里的任务，例如下图中，线程 t2 对应的任务队列已经空了，它可以“窃取”线程 t1 对应的任务队列的任务。如此一来，所有的工作线程都不会闲下来了。\n\nforkjoinpool 中的任务队列采用的是双端队列，工作线程正常获取任务和“窃取任务”分别是从任务队列不同的端消费，这样能避免很多不必要的数据竞争。我们这里介绍的仅仅是简化后的原理，forkjoinpool 的实现远比我们这里介绍的复杂，如果你感兴趣，建议去看它的源码。\n\n\n\n\n# 参考资料\n\n * 《java 并发编程实战》\n * 《java 并发编程的艺术》\n * 《java 并发编程实战》\n * completablefuture 使用详解",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Synchronized",frontmatter:{title:"Synchronized",categories:["编程","Java","JavaSE","并发"],tags:["Java","JavaSE","并发"],abbrlink:"f5dbca44",date:"2020-12-25T18:43:11.000Z",permalink:"/pages/560949/"},regularPath:"/05.%E5%B9%B6%E5%8F%91/11.Synchronized.html",relativePath:"05.并发/11.Synchronized.md",key:"v-43f2d4d3",path:"/pages/560949/",headers:[{level:2,title:"synchronized 的简介",slug:"synchronized-的简介",normalizedTitle:"synchronized 的简介",charIndex:19},{level:2,title:"synchronized 的应用",slug:"synchronized-的应用",normalizedTitle:"synchronized 的应用",charIndex:421},{level:3,title:"同步实例方法",slug:"同步实例方法",normalizedTitle:"同步实例方法",charIndex:467},{level:3,title:"同步静态方法",slug:"同步静态方法",normalizedTitle:"同步静态方法",charIndex:497},{level:3,title:"同步代码块",slug:"同步代码块",normalizedTitle:"同步代码块",charIndex:534},{level:2,title:"synchronized 的原理",slug:"synchronized-的原理",normalizedTitle:"synchronized 的原理",charIndex:5655},{level:3,title:"同步代码块",slug:"同步代码块-2",normalizedTitle:"同步代码块",charIndex:534},{level:3,title:"同步方法",slug:"同步方法",normalizedTitle:"同步方法",charIndex:480},{level:3,title:"Monitor",slug:"monitor",normalizedTitle:"monitor",charIndex:5727},{level:2,title:"synchronized 的优化",slug:"synchronized-的优化",normalizedTitle:"synchronized 的优化",charIndex:7389},{level:3,title:"Java 对象头",slug:"java-对象头",normalizedTitle:"java 对象头",charIndex:7480},{level:3,title:"偏向锁",slug:"偏向锁",normalizedTitle:"偏向锁",charIndex:7705},{level:3,title:"轻量级锁",slug:"轻量级锁",normalizedTitle:"轻量级锁",charIndex:7754},{level:3,title:"锁消除 / 锁粗化",slug:"锁消除-锁粗化",normalizedTitle:"锁消除 / 锁粗化",charIndex:8633},{level:4,title:"锁消除",slug:"锁消除",normalizedTitle:"锁消除",charIndex:8633},{level:4,title:"锁粗化",slug:"锁粗化",normalizedTitle:"锁粗化",charIndex:8639},{level:3,title:"自旋锁",slug:"自旋锁",normalizedTitle:"自旋锁",charIndex:9774},{level:2,title:"synchronized 的误区",slug:"synchronized-的误区",normalizedTitle:"synchronized 的误区",charIndex:10036},{level:3,title:"synchronized 使用范围不当导致的错误",slug:"synchronized-使用范围不当导致的错误",normalizedTitle:"synchronized 使用范围不当导致的错误",charIndex:10087},{level:3,title:"synchronized 保护对象不对导致的错误",slug:"synchronized-保护对象不对导致的错误",normalizedTitle:"synchronized 保护对象不对导致的错误",charIndex:11671},{level:3,title:"锁粒度导致的问题",slug:"锁粒度导致的问题",normalizedTitle:"锁粒度导致的问题",charIndex:12882},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:14224}],headersStr:"synchronized 的简介 synchronized 的应用 同步实例方法 同步静态方法 同步代码块 synchronized 的原理 同步代码块 同步方法 Monitor synchronized 的优化 Java 对象头 偏向锁 轻量级锁 锁消除 / 锁粗化 锁消除 锁粗化 自旋锁 synchronized 的误区 synchronized 使用范围不当导致的错误 synchronized 保护对象不对导致的错误 锁粒度导致的问题 参考资料",content:'# Synchronized\n\n\n# synchronized 的简介\n\nsynchronized 是 Java 中的关键字，是 利用锁的机制来实现互斥同步的。\n\nsynchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。\n\n如果不需要 Lock 、ReadWriteLock 所提供的高级同步特性，应该优先考虑使用 synchronized ，理由如下：\n\n * Java 1.6 以后，synchronized 做了大量的优化，其性能已经与 Lock 、ReadWriteLock 基本上持平。从趋势来看，Java 未来仍将继续优化 synchronized ，而不是 ReentrantLock 。\n * ReentrantLock 是 Oracle JDK 的 API，在其他版本的 JDK 中不一定支持；而 synchronized 是 JVM 的内置特性，所有 JDK 版本都提供支持。\n\n\n# synchronized 的应用\n\nsynchronized 有 3 种应用方式：\n\n * 同步实例方法 - 对于普通同步方法，锁是当前实例对象\n * 同步静态方法 - 对于静态同步方法，锁是当前类的 Class 对象\n * 同步代码块 - 对于同步方法块，锁是 synchonized 括号里配置的对象\n\n> 说明：\n> \n> 类似 Vector、Hashtable 这类同步类，就是使用 synchonized 修饰其重要方法，来保证其线程安全。\n> \n> 事实上，这类同步容器也非绝对的线程安全，当执行迭代器遍历，根据条件删除元素这种场景下，就可能出现线程不安全的情况。此外，Java 1.6 针对 synchonized 进行优化前，由于阻塞，其性能不高。\n> \n> 综上，这类同步容器，在现代 Java 程序中，已经渐渐不用了。\n\n\n# 同步实例方法\n\n❌ 错误示例 - 未同步的示例\n\npublic class NoSynchronizedDemo implements Runnable {\n\n    public static final int MAX = 100000;\n\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        NoSynchronizedDemo instance = new NoSynchronizedDemo();\n        Thread t1 = new Thread(instance);\n        Thread t2 = new Thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(count);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < MAX; i++) {\n            increase();\n        }\n    }\n\n    public void increase() {\n        count++;\n    }\n\n}\n// 输出结果: 小于 200000 的随机数字\n\n\nJava 实例方法同步是同步在拥有该方法的对象上。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。\n\npublic class SynchronizedDemo implements Runnable {\n\n    private static final int MAX = 100000;\n\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        SynchronizedDemo instance = new SynchronizedDemo();\n        Thread t1 = new Thread(instance);\n        Thread t2 = new Thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(count);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < MAX; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰普通方法\n     */\n    public synchronized void increase() {\n        count++;\n    }\n\n}\n\n\n【示例】错误示例\n\nclass Account {\n  private int balance;\n  // 转账\n  synchronized void transfer(\n      Account target, int amt){\n    if (this.balance > amt) {\n      this.balance -= amt;\n      target.balance += amt;\n    }\n  }\n}\n\n\n在这段代码中，临界区内有两个资源，分别是转出账户的余额 this.balance 和转入账户的余额 target.balance，并且用的是一把锁 this，符合我们前面提到的，多个资源可以用一把锁来保护，这看上去完全正确呀。真的是这样吗？可惜，这个方案仅仅是看似正确，为什么呢？\n\n问题就出在 this 这把锁上，this 这把锁可以保护自己的余额 this.balance，却保护不了别人的余额 target.balance，就像你不能用自家的锁来保护别人家的资产，也不能用自己的票来保护别人的座位一样。\n\n\n\n应该保证使用的锁能覆盖所有受保护资源。\n\n【示例】正确姿势\n\nclass Account {\n  private Object lock；\n  private int balance;\n  private Account();\n  // 创建 Account 时传入同一个 lock 对象\n  public Account(Object lock) {\n    this.lock = lock;\n  }\n  // 转账\n  void transfer(Account target, int amt){\n    // 此处检查所有对象共享的锁\n    synchronized(lock) {\n      if (this.balance > amt) {\n        this.balance -= amt;\n        target.balance += amt;\n      }\n    }\n  }\n}\n\n\n这个办法确实能解决问题，但是有点小瑕疵，它要求在创建 Account 对象的时候必须传入同一个对象，如果创建 Account 对象时，传入的 lock 不是同一个对象，那可就惨了，会出现锁自家门来保护他家资产的荒唐事。在真实的项目场景中，创建 Account 对象的代码很可能分散在多个工程中，传入共享的 lock 真的很难。\n\n上面的方案缺乏实践的可行性，我们需要更好的方案。还真有，就是用 Account.class 作为共享的锁。Account.class 是所有 Account 对象共享的，而且这个对象是 Java 虚拟机在加载 Account 类的时候创建的，所以我们不用担心它的唯一性。使用 Account.class 作为共享的锁，我们就无需在创建 Account 对象时传入了，代码更简单。\n\n【示例】正确姿势\n\nclass Account {\n  private int balance;\n  // 转账\n  void transfer(Account target, int amt){\n    synchronized(Account.class) {\n      if (this.balance > amt) {\n        this.balance -= amt;\n        target.balance += amt;\n      }\n    }\n  }\n}\n\n\n\n# 同步静态方法\n\n静态方法的同步是指同步在该方法所在的类对象上。因为在 JVM 中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。\n\n对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。\n\npublic class SynchronizedDemo2 implements Runnable {\n\n    private static final int MAX = 100000;\n\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        SynchronizedDemo2 instance = new SynchronizedDemo2();\n        Thread t1 = new Thread(instance);\n        Thread t2 = new Thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(count);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < MAX; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰静态方法\n     */\n    public synchronized static void increase() {\n        count++;\n    }\n\n}\n\n\n\n# 同步代码块\n\n有时你不需要同步整个方法，而是同步方法中的一部分。Java 可以对方法的一部分进行同步。\n\n注意 Java 同步块构造器用括号将对象括起来。在上例中，使用了 this，即为调用 add 方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。\n\n一次只有一个线程能够在同步于同一个监视器对象的 Java 方法内执行。\n\npublic class SynchronizedDemo3 implements Runnable {\n\n    private static final int MAX = 100000;\n\n    private static int count = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        SynchronizedDemo3 instance = new SynchronizedDemo3();\n        Thread t1 = new Thread(instance);\n        Thread t2 = new Thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(count);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < MAX; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰代码块\n     */\n    public static void increase() {\n        synchronized (SynchronizedDemo3.class) {\n            count++;\n        }\n    }\n\n}\n\n\n\n# synchronized 的原理\n\nsynchronized 代码块是由一对 monitorenter 和 monitorexit 指令实现的，Monitor 对象是同步的基本实现单元。在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。\n\n如果 synchronized 明确制定了对象参数，那就是这个对象的引用；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是静态方法，去对对应的对象实例或 Class 对象来作为锁对象。\n\nsynchronized 同步块对同一线程来说是可重入的，不会出现锁死问题。\n\nsynchronized 同步块是互斥的，即已进入的线程执行完成前，会阻塞其他试图进入的线程。\n\n【示例】\n\npublic void foo(Object lock) {\n    synchronized (lock) {\n      lock.hashCode();\n    }\n  }\n  // 上面的 Java 代码将编译为下面的字节码\n  public void foo(java.lang.Object);\n    Code:\n       0: aload_1\n       1: dup\n       2: astore_2\n       3: monitorenter\n       4: aload_1\n       5: invokevirtual java/lang/Object.hashCode:()I\n       8: pop\n       9: aload_2\n      10: monitorexit\n      11: goto          19\n      14: astore_3\n      15: aload_2\n      16: monitorexit\n      17: aload_3\n      18: athrow\n      19: return\n    Exception table:\n       from    to  target type\n           4    11    14   any\n          14    17    14   any\n\n\n\n\n# 同步代码块\n\nsynchronized 在修饰同步代码块时，是由 monitorenter 和 monitorexit 指令来实现同步的。进入 monitorenter 指令后，线程将持有 Monitor 对象，退出 monitorenter 指令后，线程将释放该 Monitor 对象。\n\n\n# 同步方法\n\nsynchronized 修饰同步方法时，会设置一个 ACC_SYNCHRONIZED 标志。当方法调用时，调用指令将会检查该方法是否被设置 ACC_SYNCHRONIZED 访问标志。如果设置了该标志，执行线程将先持有 Monitor 对象，然后再执行方法。在该方法运行期间，其它线程将无法获取到该 Mointor 对象，当方法执行完成后，再释放该 Monitor 对象。\n\n\n# Monitor\n\n每个对象实例都会有一个 Monitor，Monitor 可以和对象一起创建、销毁。Monitor 是由 ObjectMonitor 实现，而 ObjectMonitor 是由 C++ 的 ObjectMonitor.hpp 文件实现。\n\n当多个线程同时访问一段同步代码时，多个线程会先被存放在 EntryList 集合中，处于 block 状态的线程，都会被加入到该列表。接下来当线程获取到对象的 Monitor 时，Monitor 是依靠底层操作系统的 Mutex Lock 来实现互斥的，线程申请 Mutex 成功，则持有该 Mutex，其它线程将无法获取到该 Mutex。\n\n如果线程调用 wait() 方法，就会释放当前持有的 Mutex，并且该线程会进入 WaitSet 集合中，等待下一次被唤醒。如果当前线程顺利执行完方法，也将释放 Mutex。\n\n\n# synchronized 的优化\n\n> Java 1.6 以后，synchronized 做了大量的优化，其性能已经与 Lock 、ReadWriteLock 基本上持平。\n\n\n# Java 对象头\n\n在 JDK1.6 JVM 中，对象实例在堆内存中被分为了三个部分：对象头、实例数据和对齐填充。其中 Java 对象头由 Mark Word、指向类的指针以及数组长度三部分组成。\n\nMark Word 记录了对象和锁有关的信息。Mark Word 在 64 位 JVM 中的长度是 64bit，我们可以一起看下 64 位 JVM 的存储结构是怎么样的。如下图所示：\n\n\n\n锁升级功能主要依赖于 Mark Word 中的锁标志位和释放偏向锁标志位，synchronized 同步锁就是从偏向锁开始的，随着竞争越来越激烈，偏向锁升级到轻量级锁，最终升级到重量级锁。\n\nJava 1.6 引入了偏向锁和轻量级锁，从而让 synchronized 拥有了四个状态：\n\n * 无锁状态（unlocked）\n * 偏向锁状态（biasble）\n * 轻量级锁状态（lightweight locked）\n * 重量级锁状态（inflated）\n\n当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现。\n\n当没有竞争出现时，默认会使用偏向锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。\n\n如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏向锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。\n\n\n# 偏向锁\n\n偏向锁的思想是偏向于第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。\n\n\n\n\n# 轻量级锁\n\n轻量级锁是相对于传统的重量级锁而言，它 使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。\n\n当尝试获取一个锁对象时，如果锁对象标记为 0|01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。\n\n\n\n\n# 锁消除 / 锁粗化\n\n除了锁升级优化，Java 还使用了编译器对锁进行优化。\n\n# 锁消除\n\n锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。\n\nJIT 编译器在动态编译同步块的时候，借助了一种被称为逃逸分析的技术，来判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其它线程。\n\n确认是的话，那么 JIT 编译器在编译这个同步块的时候不会生成 synchronized 所表示的锁的申请与释放的机器码，即消除了锁的使用。在 Java7 之后的版本就不需要手动配置了，该操作可以自动实现。\n\n对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：\n\npublic static String concatString(String s1, String s2, String s3) {\n    return s1 + s2 + s3;\n}\n\n\nString 是一个不可变的类，编译器会对 String 的拼接自动优化。在 Java 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：\n\npublic static String concatString(String s1, String s2, String s3) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    sb.append(s3);\n    return sb.toString();\n}\n\n\n每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。\n\n# 锁粗化\n\n锁粗化同理，就是在 JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。\n\n如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。\n\n上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。\n\n\n# 自旋锁\n\n互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。\n\n自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。\n\n在 Java 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。\n\n\n# synchronized 的误区\n\n> 示例摘自：《Java 业务开发常见错误 100 例》\n\n\n# synchronized 使用范围不当导致的错误\n\npublic class Interesting {\n\n    volatile int a = 1;\n    volatile int b = 1;\n\n    public static void main(String[] args) {\n        Interesting interesting = new Interesting();\n        new Thread(() -> interesting.add()).start();\n        new Thread(() -> interesting.compare()).start();\n    }\n\n    public synchronized void add() {\n        log.info("add start");\n        for (int i = 0; i < 10000; i++) {\n            a++;\n            b++;\n        }\n        log.info("add done");\n    }\n\n    public void compare() {\n        log.info("compare start");\n        for (int i = 0; i < 10000; i++) {\n            //a始终等于b吗？\n            if (a < b) {\n                log.info("a:{},b:{},{}", a, b, a > b);\n                //最后的a>b应该始终是false吗？\n            }\n        }\n        log.info("compare done");\n    }\n\n}\n\n\n【输出】\n\n16:05:25.541 [Thread-0] INFO io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - add start\n16:05:25.544 [Thread-0] INFO io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - add done\n16:05:25.544 [Thread-1] INFO io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - compare start\n16:05:25.544 [Thread-1] INFO io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - compare done\n\n\n之所以出现这种错乱，是因为两个线程是交错执行 add 和 compare 方法中的业务逻辑，而且这些业务逻辑不是原子性的：a++ 和 b++ 操作中可以穿插在 compare 方法的比较代码中；更需要注意的是，a<b 这种比较操作在字节码层面是加载 a、加载 b 和比较三步，代码虽然是一行但也不是原子性的。\n\n所以，正确的做法应该是，为 add 和 compare 都加上方法锁，确保 add 方法执行时，compare 无法读取 a 和 b：\n\npublic synchronized void add()\npublic synchronized void compare()\n\n\n所以，使用锁解决问题之前一定要理清楚，我们要保护的是什么逻辑，多线程执行的情况又是怎样的。\n\n\n# synchronized 保护对象不对导致的错误\n\n加锁前要清楚锁和被保护的对象是不是一个层面的。\n\n静态字段属于类，类级别的锁才能保护；而非静态字段属于类实例，实例级别的锁就可以保护。\n\npublic class synchronized错误使用示例2 {\n\n    public static void main(String[] args) {\n        synchronized错误使用示例2 demo = new synchronized错误使用示例2();\n        System.out.println(demo.wrong(1000000));\n        System.out.println(demo.right(1000000));\n    }\n\n    public int wrong(int count) {\n        Data.reset();\n        IntStream.rangeClosed(1, count).parallel().forEach(i -> new Data().wrong());\n        return Data.getCounter();\n    }\n\n    public int right(int count) {\n        Data.reset();\n        IntStream.rangeClosed(1, count).parallel().forEach(i -> new Data().right());\n        return Data.getCounter();\n    }\n\n    private static class Data {\n\n        @Getter\n        private static int counter = 0;\n        private static Object locker = new Object();\n\n        public static int reset() {\n            counter = 0;\n            return counter;\n        }\n\n        public synchronized void wrong() {\n            counter++;\n        }\n\n        public void right() {\n            synchronized (locker) {\n                counter++;\n            }\n        }\n\n    }\n\n}\n\n\nwrong 方法中试图对一个静态对象加对象级别的 synchronized 锁，并不能保证线程安全。\n\n\n# 锁粒度导致的问题\n\n要尽可能的缩小加锁的范围，这可以提高并发吞吐。\n\n如果精细化考虑了锁应用范围后，性能还无法满足需求的话，我们就要考虑另一个维度的粒度问题了，即：区分读写场景以及资源的访问冲突，考虑使用悲观方式的锁还是乐观方式的锁。\n\npublic class synchronized锁粒度不当 {\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.wrong();\n        demo.right();\n    }\n\n    private static class Demo {\n\n        private List<Integer> data = new ArrayList<>();\n\n        private void slow() {\n            try {\n                TimeUnit.MILLISECONDS.sleep(10);\n            } catch (InterruptedException e) {\n            }\n        }\n\n        public int wrong() {\n            long begin = System.currentTimeMillis();\n            IntStream.rangeClosed(1, 1000).parallel().forEach(i -> {\n                synchronized (this) {\n                    slow();\n                    data.add(i);\n                }\n            });\n            log.info("took:{}", System.currentTimeMillis() - begin);\n            return data.size();\n        }\n\n        public int right() {\n            long begin = System.currentTimeMillis();\n            IntStream.rangeClosed(1, 1000).parallel().forEach(i -> {\n                slow();\n                synchronized (data) {\n                    data.add(i);\n                }\n            });\n            log.info("took:{}", System.currentTimeMillis() - begin);\n            return data.size();\n        }\n\n    }\n\n}\n\n\n\n# 参考资料\n\n * 《Java 并发编程实战》\n * 《Java 并发编程的艺术》\n * 《深入理解 Java 虚拟机》\n * 《Java 业务开发常见错误 100 例》\n * Java 并发编程：volatile 关键字解析\n * Java 并发编程：synchronized\n * 深入理解 Java 并发之 synchronized 实现原理\n * Java CAS 完全解读\n * Java 中 CAS 详解\n * ThreadLocal 终极篇\n * synchronized 实现原理及锁优化\n * Non-blocking Algorithms',normalizedContent:'# synchronized\n\n\n# synchronized 的简介\n\nsynchronized 是 java 中的关键字，是 利用锁的机制来实现互斥同步的。\n\nsynchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。\n\n如果不需要 lock 、readwritelock 所提供的高级同步特性，应该优先考虑使用 synchronized ，理由如下：\n\n * java 1.6 以后，synchronized 做了大量的优化，其性能已经与 lock 、readwritelock 基本上持平。从趋势来看，java 未来仍将继续优化 synchronized ，而不是 reentrantlock 。\n * reentrantlock 是 oracle jdk 的 api，在其他版本的 jdk 中不一定支持；而 synchronized 是 jvm 的内置特性，所有 jdk 版本都提供支持。\n\n\n# synchronized 的应用\n\nsynchronized 有 3 种应用方式：\n\n * 同步实例方法 - 对于普通同步方法，锁是当前实例对象\n * 同步静态方法 - 对于静态同步方法，锁是当前类的 class 对象\n * 同步代码块 - 对于同步方法块，锁是 synchonized 括号里配置的对象\n\n> 说明：\n> \n> 类似 vector、hashtable 这类同步类，就是使用 synchonized 修饰其重要方法，来保证其线程安全。\n> \n> 事实上，这类同步容器也非绝对的线程安全，当执行迭代器遍历，根据条件删除元素这种场景下，就可能出现线程不安全的情况。此外，java 1.6 针对 synchonized 进行优化前，由于阻塞，其性能不高。\n> \n> 综上，这类同步容器，在现代 java 程序中，已经渐渐不用了。\n\n\n# 同步实例方法\n\n❌ 错误示例 - 未同步的示例\n\npublic class nosynchronizeddemo implements runnable {\n\n    public static final int max = 100000;\n\n    private static int count = 0;\n\n    public static void main(string[] args) throws interruptedexception {\n        nosynchronizeddemo instance = new nosynchronizeddemo();\n        thread t1 = new thread(instance);\n        thread t2 = new thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        system.out.println(count);\n    }\n\n    @override\n    public void run() {\n        for (int i = 0; i < max; i++) {\n            increase();\n        }\n    }\n\n    public void increase() {\n        count++;\n    }\n\n}\n// 输出结果: 小于 200000 的随机数字\n\n\njava 实例方法同步是同步在拥有该方法的对象上。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。\n\npublic class synchronizeddemo implements runnable {\n\n    private static final int max = 100000;\n\n    private static int count = 0;\n\n    public static void main(string[] args) throws interruptedexception {\n        synchronizeddemo instance = new synchronizeddemo();\n        thread t1 = new thread(instance);\n        thread t2 = new thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        system.out.println(count);\n    }\n\n    @override\n    public void run() {\n        for (int i = 0; i < max; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰普通方法\n     */\n    public synchronized void increase() {\n        count++;\n    }\n\n}\n\n\n【示例】错误示例\n\nclass account {\n  private int balance;\n  // 转账\n  synchronized void transfer(\n      account target, int amt){\n    if (this.balance > amt) {\n      this.balance -= amt;\n      target.balance += amt;\n    }\n  }\n}\n\n\n在这段代码中，临界区内有两个资源，分别是转出账户的余额 this.balance 和转入账户的余额 target.balance，并且用的是一把锁 this，符合我们前面提到的，多个资源可以用一把锁来保护，这看上去完全正确呀。真的是这样吗？可惜，这个方案仅仅是看似正确，为什么呢？\n\n问题就出在 this 这把锁上，this 这把锁可以保护自己的余额 this.balance，却保护不了别人的余额 target.balance，就像你不能用自家的锁来保护别人家的资产，也不能用自己的票来保护别人的座位一样。\n\n\n\n应该保证使用的锁能覆盖所有受保护资源。\n\n【示例】正确姿势\n\nclass account {\n  private object lock；\n  private int balance;\n  private account();\n  // 创建 account 时传入同一个 lock 对象\n  public account(object lock) {\n    this.lock = lock;\n  }\n  // 转账\n  void transfer(account target, int amt){\n    // 此处检查所有对象共享的锁\n    synchronized(lock) {\n      if (this.balance > amt) {\n        this.balance -= amt;\n        target.balance += amt;\n      }\n    }\n  }\n}\n\n\n这个办法确实能解决问题，但是有点小瑕疵，它要求在创建 account 对象的时候必须传入同一个对象，如果创建 account 对象时，传入的 lock 不是同一个对象，那可就惨了，会出现锁自家门来保护他家资产的荒唐事。在真实的项目场景中，创建 account 对象的代码很可能分散在多个工程中，传入共享的 lock 真的很难。\n\n上面的方案缺乏实践的可行性，我们需要更好的方案。还真有，就是用 account.class 作为共享的锁。account.class 是所有 account 对象共享的，而且这个对象是 java 虚拟机在加载 account 类的时候创建的，所以我们不用担心它的唯一性。使用 account.class 作为共享的锁，我们就无需在创建 account 对象时传入了，代码更简单。\n\n【示例】正确姿势\n\nclass account {\n  private int balance;\n  // 转账\n  void transfer(account target, int amt){\n    synchronized(account.class) {\n      if (this.balance > amt) {\n        this.balance -= amt;\n        target.balance += amt;\n      }\n    }\n  }\n}\n\n\n\n# 同步静态方法\n\n静态方法的同步是指同步在该方法所在的类对象上。因为在 jvm 中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。\n\n对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。\n\npublic class synchronizeddemo2 implements runnable {\n\n    private static final int max = 100000;\n\n    private static int count = 0;\n\n    public static void main(string[] args) throws interruptedexception {\n        synchronizeddemo2 instance = new synchronizeddemo2();\n        thread t1 = new thread(instance);\n        thread t2 = new thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        system.out.println(count);\n    }\n\n    @override\n    public void run() {\n        for (int i = 0; i < max; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰静态方法\n     */\n    public synchronized static void increase() {\n        count++;\n    }\n\n}\n\n\n\n# 同步代码块\n\n有时你不需要同步整个方法，而是同步方法中的一部分。java 可以对方法的一部分进行同步。\n\n注意 java 同步块构造器用括号将对象括起来。在上例中，使用了 this，即为调用 add 方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。\n\n一次只有一个线程能够在同步于同一个监视器对象的 java 方法内执行。\n\npublic class synchronizeddemo3 implements runnable {\n\n    private static final int max = 100000;\n\n    private static int count = 0;\n\n    public static void main(string[] args) throws interruptedexception {\n        synchronizeddemo3 instance = new synchronizeddemo3();\n        thread t1 = new thread(instance);\n        thread t2 = new thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        system.out.println(count);\n    }\n\n    @override\n    public void run() {\n        for (int i = 0; i < max; i++) {\n            increase();\n        }\n    }\n\n    /**\n     * synchronized 修饰代码块\n     */\n    public static void increase() {\n        synchronized (synchronizeddemo3.class) {\n            count++;\n        }\n    }\n\n}\n\n\n\n# synchronized 的原理\n\nsynchronized 代码块是由一对 monitorenter 和 monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。\n\n如果 synchronized 明确制定了对象参数，那就是这个对象的引用；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是静态方法，去对对应的对象实例或 class 对象来作为锁对象。\n\nsynchronized 同步块对同一线程来说是可重入的，不会出现锁死问题。\n\nsynchronized 同步块是互斥的，即已进入的线程执行完成前，会阻塞其他试图进入的线程。\n\n【示例】\n\npublic void foo(object lock) {\n    synchronized (lock) {\n      lock.hashcode();\n    }\n  }\n  // 上面的 java 代码将编译为下面的字节码\n  public void foo(java.lang.object);\n    code:\n       0: aload_1\n       1: dup\n       2: astore_2\n       3: monitorenter\n       4: aload_1\n       5: invokevirtual java/lang/object.hashcode:()i\n       8: pop\n       9: aload_2\n      10: monitorexit\n      11: goto          19\n      14: astore_3\n      15: aload_2\n      16: monitorexit\n      17: aload_3\n      18: athrow\n      19: return\n    exception table:\n       from    to  target type\n           4    11    14   any\n          14    17    14   any\n\n\n\n\n# 同步代码块\n\nsynchronized 在修饰同步代码块时，是由 monitorenter 和 monitorexit 指令来实现同步的。进入 monitorenter 指令后，线程将持有 monitor 对象，退出 monitorenter 指令后，线程将释放该 monitor 对象。\n\n\n# 同步方法\n\nsynchronized 修饰同步方法时，会设置一个 acc_synchronized 标志。当方法调用时，调用指令将会检查该方法是否被设置 acc_synchronized 访问标志。如果设置了该标志，执行线程将先持有 monitor 对象，然后再执行方法。在该方法运行期间，其它线程将无法获取到该 mointor 对象，当方法执行完成后，再释放该 monitor 对象。\n\n\n# monitor\n\n每个对象实例都会有一个 monitor，monitor 可以和对象一起创建、销毁。monitor 是由 objectmonitor 实现，而 objectmonitor 是由 c++ 的 objectmonitor.hpp 文件实现。\n\n当多个线程同时访问一段同步代码时，多个线程会先被存放在 entrylist 集合中，处于 block 状态的线程，都会被加入到该列表。接下来当线程获取到对象的 monitor 时，monitor 是依靠底层操作系统的 mutex lock 来实现互斥的，线程申请 mutex 成功，则持有该 mutex，其它线程将无法获取到该 mutex。\n\n如果线程调用 wait() 方法，就会释放当前持有的 mutex，并且该线程会进入 waitset 集合中，等待下一次被唤醒。如果当前线程顺利执行完方法，也将释放 mutex。\n\n\n# synchronized 的优化\n\n> java 1.6 以后，synchronized 做了大量的优化，其性能已经与 lock 、readwritelock 基本上持平。\n\n\n# java 对象头\n\n在 jdk1.6 jvm 中，对象实例在堆内存中被分为了三个部分：对象头、实例数据和对齐填充。其中 java 对象头由 mark word、指向类的指针以及数组长度三部分组成。\n\nmark word 记录了对象和锁有关的信息。mark word 在 64 位 jvm 中的长度是 64bit，我们可以一起看下 64 位 jvm 的存储结构是怎么样的。如下图所示：\n\n\n\n锁升级功能主要依赖于 mark word 中的锁标志位和释放偏向锁标志位，synchronized 同步锁就是从偏向锁开始的，随着竞争越来越激烈，偏向锁升级到轻量级锁，最终升级到重量级锁。\n\njava 1.6 引入了偏向锁和轻量级锁，从而让 synchronized 拥有了四个状态：\n\n * 无锁状态（unlocked）\n * 偏向锁状态（biasble）\n * 轻量级锁状态（lightweight locked）\n * 重量级锁状态（inflated）\n\n当 jvm 检测到不同的竞争状况时，会自动切换到适合的锁实现。\n\n当没有竞争出现时，默认会使用偏向锁。jvm 会利用 cas 操作（compare and swap），在对象头上的 mark word 部分设置线程 id，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。\n\n如果有另外的线程试图锁定某个已经被偏斜过的对象，jvm 就需要撤销（revoke）偏向锁，并切换到轻量级锁实现。轻量级锁依赖 cas 操作 mark word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。\n\n\n# 偏向锁\n\n偏向锁的思想是偏向于第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 cas 操作也不再需要。\n\n\n\n\n# 轻量级锁\n\n轻量级锁是相对于传统的重量级锁而言，它 使用 cas 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 cas 操作进行同步，如果 cas 失败了再改用互斥量进行同步。\n\n当尝试获取一个锁对象时，如果锁对象标记为 0|01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 lock record，然后使用 cas 操作将对象的 mark word 更新为 lock record 指针。如果 cas 操作成功了，那么线程就获取了该对象上的锁，并且对象的 mark word 的锁标记变为 00，表示该对象处于轻量级锁状态。\n\n\n\n\n# 锁消除 / 锁粗化\n\n除了锁升级优化，java 还使用了编译器对锁进行优化。\n\n# 锁消除\n\n锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。\n\njit 编译器在动态编译同步块的时候，借助了一种被称为逃逸分析的技术，来判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其它线程。\n\n确认是的话，那么 jit 编译器在编译这个同步块的时候不会生成 synchronized 所表示的锁的申请与释放的机器码，即消除了锁的使用。在 java7 之后的版本就不需要手动配置了，该操作可以自动实现。\n\n对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：\n\npublic static string concatstring(string s1, string s2, string s3) {\n    return s1 + s2 + s3;\n}\n\n\nstring 是一个不可变的类，编译器会对 string 的拼接自动优化。在 java 1.5 之前，会转化为 stringbuffer 对象的连续 append() 操作：\n\npublic static string concatstring(string s1, string s2, string s3) {\n    stringbuffer sb = new stringbuffer();\n    sb.append(s1);\n    sb.append(s2);\n    sb.append(s3);\n    return sb.tostring();\n}\n\n\n每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatstring() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatstring() 方法之外，其他线程无法访问到它，因此可以进行消除。\n\n# 锁粗化\n\n锁粗化同理，就是在 jit 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 jit 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。\n\n如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。\n\n上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。\n\n\n# 自旋锁\n\n互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。\n\n自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 cpu 时间，它只适用于共享数据的锁定状态很短的场景。\n\n在 java 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。\n\n\n# synchronized 的误区\n\n> 示例摘自：《java 业务开发常见错误 100 例》\n\n\n# synchronized 使用范围不当导致的错误\n\npublic class interesting {\n\n    volatile int a = 1;\n    volatile int b = 1;\n\n    public static void main(string[] args) {\n        interesting interesting = new interesting();\n        new thread(() -> interesting.add()).start();\n        new thread(() -> interesting.compare()).start();\n    }\n\n    public synchronized void add() {\n        log.info("add start");\n        for (int i = 0; i < 10000; i++) {\n            a++;\n            b++;\n        }\n        log.info("add done");\n    }\n\n    public void compare() {\n        log.info("compare start");\n        for (int i = 0; i < 10000; i++) {\n            //a始终等于b吗？\n            if (a < b) {\n                log.info("a:{},b:{},{}", a, b, a > b);\n                //最后的a>b应该始终是false吗？\n            }\n        }\n        log.info("compare done");\n    }\n\n}\n\n\n【输出】\n\n16:05:25.541 [thread-0] info io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - add start\n16:05:25.544 [thread-0] info io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - add done\n16:05:25.544 [thread-1] info io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - compare start\n16:05:25.544 [thread-1] info io.github.dunwu.javacore.concurrent.sync.synchronized使用范围不当 - compare done\n\n\n之所以出现这种错乱，是因为两个线程是交错执行 add 和 compare 方法中的业务逻辑，而且这些业务逻辑不是原子性的：a++ 和 b++ 操作中可以穿插在 compare 方法的比较代码中；更需要注意的是，a<b 这种比较操作在字节码层面是加载 a、加载 b 和比较三步，代码虽然是一行但也不是原子性的。\n\n所以，正确的做法应该是，为 add 和 compare 都加上方法锁，确保 add 方法执行时，compare 无法读取 a 和 b：\n\npublic synchronized void add()\npublic synchronized void compare()\n\n\n所以，使用锁解决问题之前一定要理清楚，我们要保护的是什么逻辑，多线程执行的情况又是怎样的。\n\n\n# synchronized 保护对象不对导致的错误\n\n加锁前要清楚锁和被保护的对象是不是一个层面的。\n\n静态字段属于类，类级别的锁才能保护；而非静态字段属于类实例，实例级别的锁就可以保护。\n\npublic class synchronized错误使用示例2 {\n\n    public static void main(string[] args) {\n        synchronized错误使用示例2 demo = new synchronized错误使用示例2();\n        system.out.println(demo.wrong(1000000));\n        system.out.println(demo.right(1000000));\n    }\n\n    public int wrong(int count) {\n        data.reset();\n        intstream.rangeclosed(1, count).parallel().foreach(i -> new data().wrong());\n        return data.getcounter();\n    }\n\n    public int right(int count) {\n        data.reset();\n        intstream.rangeclosed(1, count).parallel().foreach(i -> new data().right());\n        return data.getcounter();\n    }\n\n    private static class data {\n\n        @getter\n        private static int counter = 0;\n        private static object locker = new object();\n\n        public static int reset() {\n            counter = 0;\n            return counter;\n        }\n\n        public synchronized void wrong() {\n            counter++;\n        }\n\n        public void right() {\n            synchronized (locker) {\n                counter++;\n            }\n        }\n\n    }\n\n}\n\n\nwrong 方法中试图对一个静态对象加对象级别的 synchronized 锁，并不能保证线程安全。\n\n\n# 锁粒度导致的问题\n\n要尽可能的缩小加锁的范围，这可以提高并发吞吐。\n\n如果精细化考虑了锁应用范围后，性能还无法满足需求的话，我们就要考虑另一个维度的粒度问题了，即：区分读写场景以及资源的访问冲突，考虑使用悲观方式的锁还是乐观方式的锁。\n\npublic class synchronized锁粒度不当 {\n\n    public static void main(string[] args) {\n        demo demo = new demo();\n        demo.wrong();\n        demo.right();\n    }\n\n    private static class demo {\n\n        private list<integer> data = new arraylist<>();\n\n        private void slow() {\n            try {\n                timeunit.milliseconds.sleep(10);\n            } catch (interruptedexception e) {\n            }\n        }\n\n        public int wrong() {\n            long begin = system.currenttimemillis();\n            intstream.rangeclosed(1, 1000).parallel().foreach(i -> {\n                synchronized (this) {\n                    slow();\n                    data.add(i);\n                }\n            });\n            log.info("took:{}", system.currenttimemillis() - begin);\n            return data.size();\n        }\n\n        public int right() {\n            long begin = system.currenttimemillis();\n            intstream.rangeclosed(1, 1000).parallel().foreach(i -> {\n                slow();\n                synchronized (data) {\n                    data.add(i);\n                }\n            });\n            log.info("took:{}", system.currenttimemillis() - begin);\n            return data.size();\n        }\n\n    }\n\n}\n\n\n\n# 参考资料\n\n * 《java 并发编程实战》\n * 《java 并发编程的艺术》\n * 《深入理解 java 虚拟机》\n * 《java 业务开发常见错误 100 例》\n * java 并发编程：volatile 关键字解析\n * java 并发编程：synchronized\n * 深入理解 java 并发之 synchronized 实现原理\n * java cas 完全解读\n * java 中 cas 详解\n * threadlocal 终极篇\n * synchronized 实现原理及锁优化\n * non-blocking algorithms',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 并发",frontmatter:{title:"Java 并发",categories:["编程","Java","JavaSE","并发"],tags:["Java","JavaSE","并发"],abbrlink:"c67d7820",date:"2020-06-04T13:51:01.000Z",hidden:!0,permalink:"/pages/a5fb25/"},regularPath:"/05.%E5%B9%B6%E5%8F%91/",relativePath:"05.并发/README.md",key:"v-63688c1a",path:"/pages/a5fb25/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:236},{level:3,title:"Java 并发简介",slug:"java-并发简介",normalizedTitle:"java 并发简介",charIndex:246},{level:3,title:"Java 线程基础",slug:"java-线程基础",normalizedTitle:"java 线程基础",charIndex:298},{level:3,title:"Java 并发核心机制",slug:"java-并发核心机制",normalizedTitle:"java 并发核心机制",charIndex:404},{level:3,title:"Java 并发锁",slug:"java-并发锁",normalizedTitle:"java 并发锁",charIndex:465},{level:3,title:"Java 原子类",slug:"java-原子类",normalizedTitle:"java 原子类",charIndex:536},{level:3,title:"Java 并发容器",slug:"java-并发容器",normalizedTitle:"java 并发容器",charIndex:567},{level:3,title:"Java 线程池",slug:"java-线程池",normalizedTitle:"java 线程池",charIndex:627},{level:3,title:"Java 并发工具类",slug:"java-并发工具类",normalizedTitle:"java 并发工具类",charIndex:701},{level:3,title:"Java 内存模型",slug:"java-内存模型",normalizedTitle:"java 内存模型",charIndex:762},{level:3,title:"ForkJoin 框架",slug:"forkjoin-框架",normalizedTitle:"forkjoin 框架",charIndex:835},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:851},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:1014}],headersStr:"📖 内容 Java 并发简介 Java 线程基础 Java 并发核心机制 Java 并发锁 Java 原子类 Java 并发容器 Java 线程池 Java 并发工具类 Java 内存模型 ForkJoin 框架 📚 资料 🚪 传送",content:"# Java 并发\n\n> Java 并发总结、整理 Java 并发编程相关知识点。\n> \n> 并发编程并非 Java 语言所独有，而是一种成熟的编程范式，Java 只是用自己的方式实现了并发工作模型。学习 Java 并发编程，应该先熟悉并发的基本概念，然后进一步了解并发的特性以及其特性所面临的问题。掌握了这些，当学习 Java 并发工具时，才会明白它们各自是为了解决什么问题，为什么要这样设计。通过这样由点到面的学习方式，更容易融会贯通，将并发知识形成体系化。\n\n\n# 📖 内容\n\n\n# Java 并发简介\n\n> 关键词：进程、线程、安全性、活跃性、性能、死锁、饥饿、上下文切换\n\n\n\n\n# Java 线程基础\n\n> 关键词：Thread、Runnable、Callable、Future、wait、notify、notifyAll、join、sleep、yeild、线程状态、线程通信\n\n\n\n\n\n\n# Java 并发核心机制\n\n> 关键词：synchronized、volatile、CAS、ThreadLocal\n\n\n# Java 并发锁\n\n> 关键词：AQS、ReentrantLock、ReentrantReadWriteLock、Condition\n\n\n# Java 原子类\n\n> 关键词：CAS、Atomic\n\n\n# Java 并发容器\n\n> 关键词：ConcurrentHashMap、CopyOnWriteArrayList\n\n\n# Java 线程池\n\n> 关键词：Executor、ExecutorService、ThreadPoolExecutor、Executors\n\n\n# Java 并发工具类\n\n> 关键词：CountDownLatch、CyclicBarrier、Semaphore\n\n\n# Java 内存模型\n\n> 关键词：JMM、volatile、synchronized、final、Happens-Before、内存屏障\n\n\n# ForkJoin 框架\n\n\n# 📚 资料\n\n * 《Java 并发编程实战》\n * 《Java 并发编程的艺术》\n * 《深入理解 Java 虚拟机》\n * 《Effective Java》\n * 《Java 核心技术面试精讲》\n * 《Java 性能调优实战》\n * 《Java 业务开发常见错误 100 例》\n * 《Java 并发编程实战》\n\n\n# 🚪 传送\n\n◾ 🏠 JAVACORE 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"# java 并发\n\n> java 并发总结、整理 java 并发编程相关知识点。\n> \n> 并发编程并非 java 语言所独有，而是一种成熟的编程范式，java 只是用自己的方式实现了并发工作模型。学习 java 并发编程，应该先熟悉并发的基本概念，然后进一步了解并发的特性以及其特性所面临的问题。掌握了这些，当学习 java 并发工具时，才会明白它们各自是为了解决什么问题，为什么要这样设计。通过这样由点到面的学习方式，更容易融会贯通，将并发知识形成体系化。\n\n\n# 📖 内容\n\n\n# java 并发简介\n\n> 关键词：进程、线程、安全性、活跃性、性能、死锁、饥饿、上下文切换\n\n\n\n\n# java 线程基础\n\n> 关键词：thread、runnable、callable、future、wait、notify、notifyall、join、sleep、yeild、线程状态、线程通信\n\n\n\n\n\n\n# java 并发核心机制\n\n> 关键词：synchronized、volatile、cas、threadlocal\n\n\n# java 并发锁\n\n> 关键词：aqs、reentrantlock、reentrantreadwritelock、condition\n\n\n# java 原子类\n\n> 关键词：cas、atomic\n\n\n# java 并发容器\n\n> 关键词：concurrenthashmap、copyonwritearraylist\n\n\n# java 线程池\n\n> 关键词：executor、executorservice、threadpoolexecutor、executors\n\n\n# java 并发工具类\n\n> 关键词：countdownlatch、cyclicbarrier、semaphore\n\n\n# java 内存模型\n\n> 关键词：jmm、volatile、synchronized、final、happens-before、内存屏障\n\n\n# forkjoin 框架\n\n\n# 📚 资料\n\n * 《java 并发编程实战》\n * 《java 并发编程的艺术》\n * 《深入理解 java 虚拟机》\n * 《effective java》\n * 《java 核心技术面试精讲》\n * 《java 性能调优实战》\n * 《java 业务开发常见错误 100 例》\n * 《java 并发编程实战》\n\n\n# 🚪 传送\n\n◾ 🏠 javacore 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"JVM 体系结构",frontmatter:{title:"JVM 体系结构",categories:["编程","Java","JavaSE","JVM"],tags:["Java","JavaSE","JVM"],abbrlink:"65bff513",date:"2021-05-24T15:41:47.000Z",permalink:"/pages/e0de21/"},regularPath:"/06.JVM/01.JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html",relativePath:"06.JVM/01.JVM体系结构.md",key:"v-28d2db4f",path:"/pages/e0de21/",headers:[{level:2,title:"JVM 简介",slug:"jvm-简介",normalizedTitle:"jvm 简介",charIndex:65},{level:3,title:"计算机体系结构",slug:"计算机体系结构",normalizedTitle:"计算机体系结构",charIndex:76},{level:3,title:"JVM 体系结构简介",slug:"jvm-体系结构简介",normalizedTitle:"jvm 体系结构简介",charIndex:152},{level:2,title:"Hotspot 架构",slug:"hotspot-架构",normalizedTitle:"hotspot 架构",charIndex:287},{level:3,title:"Hotspot 关键组件",slug:"hotspot-关键组件",normalizedTitle:"hotspot 关键组件",charIndex:551},{level:3,title:"性能指标",slug:"性能指标",normalizedTitle:"性能指标",charIndex:706},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1019}],headersStr:"JVM 简介 计算机体系结构 JVM 体系结构简介 Hotspot 架构 Hotspot 关键组件 性能指标 参考资料",content:"# JVM 体系结构\n\n> JVM 能跨平台工作，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件、硬件之间的差异。\n\n\n# JVM 简介\n\n\n# 计算机体系结构\n\n真实的计算机体系结构的核心部分包含：\n\n * 指令集\n * 计算单元（CPU）\n * 寻址方式\n * 寄存器\n * 存储单元\n\n\n# JVM 体系结构简介\n\nJVM 体系结构与计算机体系结构相似，它的核心部分包含：\n\n * JVM 指令集\n * 类加载器\n * 执行引擎 - 相当于 JVM 的 CPU\n * 内存区 - JVM 的存储\n * 本地方法调用 - 调用 C/C++ 实现的本地方法\n\n\n# Hotspot 架构\n\nHotspot 是最流行的 JVM。\n\nJava 虚拟机的主要组件，包括类加载器、运行时数据区和执行引擎。\n\nHotspot 虚拟机拥有一个架构，它支持强大特性和能力的基础平台，支持实现高性能和强大的可伸缩性的能力。举个例子，Hotspot 虚拟机 JIT 编译器生成动态的优化，换句话说，它们在 Java 应用执行期做出优化，为底层系统架构生成高性能的本地机器指令。另外，经过它的运行时环境和多线程垃圾回收成熟的进化和连续的设计， Hotspot 虚拟机在高可用计算系统上产出了高伸缩性。\n\n\n\n\n# Hotspot 关键组件\n\nJava 虚拟机有三个组件关注着什么时候进行性能优化，堆空间是对象所存储的地方，这个区域被启动时选择的垃圾回收器管理，大部分调优选项与调整堆大小和根据你的情况选择最适当的垃圾收集器相关。即时编译器对性能也有很大的影响，但是使用新版本的 Java 虚拟机时很少需要调整。\n\n\n\n\n# 性能指标\n\nJava 虚拟机的性能指标主要有两点：\n\n * 停顿时间 - 响应延迟是指一个应用回应一个请求的速度有多快。对关注响应能力的应用来说，长暂停时间是不可接受的，重点是在短的时间周期内能做出响应。\n   * 桌面 UI 响应事件的速度\n   * 网站返回网页的速度\n   * 数据查询返回的速度\n * 吞吐量 - 吞吐量关注在特定的时间周期内一个应用的工作量的最大值。对关注吞吐量的应用来说长暂停时间是可以接受的。由于高吞吐量的应用关注的基准在更长周期时间上，所以快速响应时间不在考虑之内。\n   * 给定时间内完成事务的数量\n   * 一小时内批处理程序完成的工作数量\n   * 一小时内数据查询完成的数量\n\n\n# 参考资料\n\n * 《深入理解 Java 虚拟机》",normalizedContent:"# jvm 体系结构\n\n> jvm 能跨平台工作，主要是由于 jvm 屏蔽了与各个计算机平台相关的软件、硬件之间的差异。\n\n\n# jvm 简介\n\n\n# 计算机体系结构\n\n真实的计算机体系结构的核心部分包含：\n\n * 指令集\n * 计算单元（cpu）\n * 寻址方式\n * 寄存器\n * 存储单元\n\n\n# jvm 体系结构简介\n\njvm 体系结构与计算机体系结构相似，它的核心部分包含：\n\n * jvm 指令集\n * 类加载器\n * 执行引擎 - 相当于 jvm 的 cpu\n * 内存区 - jvm 的存储\n * 本地方法调用 - 调用 c/c++ 实现的本地方法\n\n\n# hotspot 架构\n\nhotspot 是最流行的 jvm。\n\njava 虚拟机的主要组件，包括类加载器、运行时数据区和执行引擎。\n\nhotspot 虚拟机拥有一个架构，它支持强大特性和能力的基础平台，支持实现高性能和强大的可伸缩性的能力。举个例子，hotspot 虚拟机 jit 编译器生成动态的优化，换句话说，它们在 java 应用执行期做出优化，为底层系统架构生成高性能的本地机器指令。另外，经过它的运行时环境和多线程垃圾回收成熟的进化和连续的设计， hotspot 虚拟机在高可用计算系统上产出了高伸缩性。\n\n\n\n\n# hotspot 关键组件\n\njava 虚拟机有三个组件关注着什么时候进行性能优化，堆空间是对象所存储的地方，这个区域被启动时选择的垃圾回收器管理，大部分调优选项与调整堆大小和根据你的情况选择最适当的垃圾收集器相关。即时编译器对性能也有很大的影响，但是使用新版本的 java 虚拟机时很少需要调整。\n\n\n\n\n# 性能指标\n\njava 虚拟机的性能指标主要有两点：\n\n * 停顿时间 - 响应延迟是指一个应用回应一个请求的速度有多快。对关注响应能力的应用来说，长暂停时间是不可接受的，重点是在短的时间周期内能做出响应。\n   * 桌面 ui 响应事件的速度\n   * 网站返回网页的速度\n   * 数据查询返回的速度\n * 吞吐量 - 吞吐量关注在特定的时间周期内一个应用的工作量的最大值。对关注吞吐量的应用来说长暂停时间是可以接受的。由于高吞吐量的应用关注的基准在更长周期时间上，所以快速响应时间不在考虑之内。\n   * 给定时间内完成事务的数量\n   * 一小时内批处理程序完成的工作数量\n   * 一小时内数据查询完成的数量\n\n\n# 参考资料\n\n * 《深入理解 java 虚拟机》",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 内存管理",frontmatter:{title:"Java 内存管理",categories:["编程","Java","JavaSE","JVM"],tags:["Java","JavaSE","JVM"],abbrlink:"8d9025b6",date:"2020-06-28T16:19:00.000Z",permalink:"/pages/692f5d/"},regularPath:"/06.JVM/02.JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.html",relativePath:"06.JVM/02.JVM内存区域.md",key:"v-740dc458",path:"/pages/692f5d/",headers:[{level:2,title:"内存简介",slug:"内存简介",normalizedTitle:"内存简介",charIndex:16},{level:3,title:"物理内存和虚拟内存",slug:"物理内存和虚拟内存",normalizedTitle:"物理内存和虚拟内存",charIndex:25},{level:3,title:"内核空间和用户空间",slug:"内核空间和用户空间",normalizedTitle:"内核空间和用户空间",charIndex:119},{level:3,title:"使用内存的 Java 组件",slug:"使用内存的-java-组件",normalizedTitle:"使用内存的 java 组件",charIndex:202},{level:2,title:"运行时数据区域",slug:"运行时数据区域",normalizedTitle:"运行时数据区域",charIndex:315},{level:3,title:"程序计数器",slug:"程序计数器",normalizedTitle:"程序计数器",charIndex:444},{level:3,title:"Java 虚拟机栈",slug:"java-虚拟机栈",normalizedTitle:"java 虚拟机栈",charIndex:884},{level:3,title:"本地方法栈",slug:"本地方法栈",normalizedTitle:"本地方法栈",charIndex:1688},{level:3,title:"Java 堆",slug:"java-堆",normalizedTitle:"java 堆",charIndex:271},{level:3,title:"方法区",slug:"方法区",normalizedTitle:"方法区",charIndex:1226},{level:3,title:"运行时常量池",slug:"运行时常量池",normalizedTitle:"运行时常量池",charIndex:1219},{level:3,title:"直接内存",slug:"直接内存",normalizedTitle:"直接内存",charIndex:3182},{level:3,title:"Java 内存区域对比",slug:"java-内存区域对比",normalizedTitle:"java 内存区域对比",charIndex:3529},{level:2,title:"JVM 运行原理",slug:"jvm-运行原理",normalizedTitle:"jvm 运行原理",charIndex:3871},{level:2,title:"OutOfMemoryError",slug:"outofmemoryerror",normalizedTitle:"outofmemoryerror",charIndex:856},{level:3,title:"什么是 OutOfMemoryError",slug:"什么是-outofmemoryerror",normalizedTitle:"什么是 outofmemoryerror",charIndex:5637},{level:3,title:"堆空间溢出",slug:"堆空间溢出",normalizedTitle:"堆空间溢出",charIndex:5829},{level:4,title:"Java heap space 分析步骤",slug:"java-heap-space-分析步骤",normalizedTitle:"java heap space 分析步骤",charIndex:6144},{level:4,title:"内存泄漏",slug:"内存泄漏",normalizedTitle:"内存泄漏",charIndex:6030},{level:4,title:"内存溢出",slug:"内存溢出",normalizedTitle:"内存溢出",charIndex:6052},{level:3,title:"GC 开销超过限制",slug:"gc-开销超过限制",normalizedTitle:"gc 开销超过限制",charIndex:8225},{level:3,title:"永久代空间不足",slug:"永久代空间不足",normalizedTitle:"永久代空间不足",charIndex:8980},{level:4,title:"初始化时永久代空间不足",slug:"初始化时永久代空间不足",normalizedTitle:"初始化时永久代空间不足",charIndex:9337},{level:4,title:"重部署时永久代空间不足",slug:"重部署时永久代空间不足",normalizedTitle:"重部署时永久代空间不足",charIndex:10125},{level:4,title:"PermGen space 解决方案",slug:"permgen-space-解决方案",normalizedTitle:"permgen space 解决方案",charIndex:10755},{level:3,title:"元数据区空间不足",slug:"元数据区空间不足",normalizedTitle:"元数据区空间不足",charIndex:12227},{level:3,title:"无法新建本地线程",slug:"无法新建本地线程",normalizedTitle:"无法新建本地线程",charIndex:13565},{level:3,title:"直接内存溢出",slug:"直接内存溢出",normalizedTitle:"直接内存溢出",charIndex:15208},{level:2,title:"StackOverflowError",slug:"stackoverflowerror",normalizedTitle:"stackoverflowerror",charIndex:1516},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:16494}],headersStr:"内存简介 物理内存和虚拟内存 内核空间和用户空间 使用内存的 Java 组件 运行时数据区域 程序计数器 Java 虚拟机栈 本地方法栈 Java 堆 方法区 运行时常量池 直接内存 Java 内存区域对比 JVM 运行原理 OutOfMemoryError 什么是 OutOfMemoryError 堆空间溢出 Java heap space 分析步骤 内存泄漏 内存溢出 GC 开销超过限制 永久代空间不足 初始化时永久代空间不足 重部署时永久代空间不足 PermGen space 解决方案 元数据区空间不足 无法新建本地线程 直接内存溢出 StackOverflowError 参考资料",content:'# Java 内存管理\n\n\n# 内存简介\n\n\n# 物理内存和虚拟内存\n\n所谓物理内存就是通常所说的 RAM（随机存储器）。\n\n虚拟内存使得多个进程在同时运行时可以共享物理内存，这里的共享只是空间上共享，在逻辑上彼此仍然是隔离的。\n\n\n# 内核空间和用户空间\n\n一个计算通常有固定大小的内存空间，但是程序并不能使用全部的空间。因为这些空间被划分为内核空间和用户空间，而程序只能使用用户空间的内存。\n\n\n# 使用内存的 Java 组件\n\nJava 启动后，作为一个进程运行在操作系统中。\n\n有哪些 Java 组件需要占用内存呢？\n\n * 堆内存：Java 堆、类和类加载器\n * 栈内存：线程\n * 本地内存：NIO、JNI\n\n\n# 运行时数据区域\n\nJVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。如下图所示：\n\n\n\n\n# 程序计数器\n\n程序计数器（Program Counter Register） 是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。\n\n当执行的线程数量超过 CPU 数量时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令，从而在线程切换后能恢复到正确的执行位置。各条线程间的计数器互不影响，独立存储，我们称这类内存区域为 “线程私有” 的内存。\n\n * 如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；\n * 如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。\n\n> 🔔 注意：此内存区域是唯一一个在 JVM 中没有规定任何 OutOfMemoryError 情况的区域。\n\n\n# Java 虚拟机栈\n\nJava 虚拟机栈（Java Virtual Machine Stacks） 也是线程私有的，它的生命周期与线程相同。\n\n每个 Java 方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储 局部变量表、操作数栈、常量池引用 等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\n\n\n\n * 局部变量表 - 32 位变量槽，存放了编译期可知的各种基本数据类型、对象引用、ReturnAddress 类型。\n * 操作数栈 - 基于栈的执行引擎，虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。\n * 动态链接 - 每个栈帧都包含一个指向运行时常量池（方法区的一部分）中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。Class 文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另一部分将在每一次的运行期间转化为直接应用，这部分称为动态链接。\n * 方法出口 - 返回方法被调用的位置，恢复上层方法的局部变量和操作数栈，如果无返回值，则把它压入调用者的操作数栈。\n\n> 🔔 注意：\n> \n> 该区域可能抛出以下异常：\n> \n>  * 如果线程请求的栈深度超过最大值，就会抛出 StackOverflowError 异常；\n>  * 如果虚拟机栈进行动态扩展时，无法申请到足够内存，就会抛出 OutOfMemoryError 异常。\n> \n> 💡 提示：\n> \n> 可以通过 -Xss 这个虚拟机参数来指定一个程序的 Java 虚拟机栈内存大小：\n> \n> java -Xss=512M HackTheJava\n\n\n# 本地方法栈\n\n本地方法栈（Native Method Stack） 与虚拟机栈的作用相似。\n\n二者的区别在于：虚拟机栈为 Java 方法服务；本地方法栈为 Native 方法服务。本地方法并不是用 Java 实现的，而是由 C 语言实现的。\n\n\n\n> 🔔 注意：本地方法栈也会抛出 StackOverflowError 异常和 OutOfMemoryError 异常。\n\n\n# Java 堆\n\nJava 堆（Java Heap） 的作用就是存放对象实例，几乎所有的对象实例都是在这里分配内存。\n\nJava 堆是垃圾收集的主要区域（因此也被叫做"GC 堆"）。现代的垃圾收集器基本都是采用分代收集算法，该算法的思想是针对不同的对象采取不同的垃圾回收算法。\n\n因此虚拟机把 Java 堆分成以下三块：\n\n * 新生代（Young Generation）\n   * Eden - Eden 和 Survivor 的比例为 8:1\n   * From Survivor\n   * To Survivor\n * 老年代（Old Generation）\n * 永久代（Permanent Generation）\n\n当一个对象被创建时，它首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。\n\n\n\n> 🔔 注意：Java 堆不需要连续内存，并且可以动态扩展其内存，扩展失败会抛出 OutOfMemoryError 异常。\n> \n> 💡 提示：可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的 Java 堆内存大小，第一个参数设置初始值，第二个参数设置最大值。\n> \n> java -Xms=1M -Xmx=2M HackTheJava\n\n\n# 方法区\n\n方法区（Method Area）也被称为永久代。方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。\n\n> 🔔 注意：和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。\n> \n> 💡 提示：\n> \n>  * JDK 1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收。可通过参数 -XX:PermSize 和 -XX:MaxPermSize 设置。\n>  * JDK 1.8 之后，取消了永久代，用 **metaspace（元数据）**区替代。可通过参数 -XX:MaxMetaspaceSize 设置。\n\n\n# 运行时常量池\n\n运行时常量池（Runtime Constant Pool） 是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容会在类加载后被放入这个区域。\n\n * 字面量 - 文本字符串、声明为 final 的常量值等。\n * 符号引用 - 类和接口的完全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符。\n\n除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。这部分常量也会被放入运行时常量池。\n\n> 🔔 注意：当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。\n\n\n# 直接内存\n\n直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 JVM 规范中定义的内存区域。\n\n在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。\n\n> 🔔 注意：直接内存这部分也被频繁的使用，且也可能导致 OutOfMemoryError 异常。\n> \n> 💡 提示：直接内存容量可通过 -XX:MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆最大值（-Xmx 指定）一样。\n\n\n# Java 内存区域对比\n\n内存区域        内存作用范围    异常\n程序计数器       线程私有      无\nJava 虚拟机栈   线程私有      StackOverflowError 和 OutOfMemoryError\n本地方法栈       线程私有      StackOverflowError 和 OutOfMemoryError\nJava 堆      线程共享      OutOfMemoryError\n方法区         线程共享      OutOfMemoryError\n运行时常量池      线程共享      OutOfMemoryError\n直接内存        非运行时数据区   OutOfMemoryError\n\n\n# JVM 运行原理\n\npublic class JVMCase {\n\n\t// 常量\n\tpublic final static String MAN_SEX_TYPE = "man";\n\n\t// 静态变量\n\tpublic static String WOMAN_SEX_TYPE = "woman";\n\n\tpublic static void main(String[] args) {\n\n\t\tStudent stu = new Student();\n\t\tstu.setName("nick");\n\t\tstu.setSexType(MAN_SEX_TYPE);\n\t\tstu.setAge(20);\n\n\t\tJVMCase jvmcase = new JVMCase();\n\n\t\t// 调用静态方法\n\t\tprint(stu);\n\t\t// 调用非静态方法\n\t\tjvmcase.sayHello(stu);\n\t}\n\n\n\t// 常规静态方法\n\tpublic static void print(Student stu) {\n\t\tSystem.out.println("name: " + stu.getName() + "; sex:" + stu.getSexType() + "; age:" + stu.getAge());\n\t}\n\n\n\t// 非静态方法\n\tpublic void sayHello(Student stu) {\n\t\tSystem.out.println(stu.getName() + "say: hello");\n\t}\n}\n\nclass Student{\n\tString name;\n\tString sexType;\n\tint age;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getSexType() {\n\t\treturn sexType;\n\t}\n\tpublic void setSexType(String sexType) {\n\t\tthis.sexType = sexType;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n}\n\n\n运行以上代码时，JVM 处理过程如下：\n\n（1）JVM 向操作系统申请内存，JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给 JVM，接下来 JVM 就进行内部分配。\n\n（2）JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。\n\n（3）class 文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值（这部分我在第 21 讲还会详细介绍）。\n\n\n\n（4）完成上一个步骤后，将会进行最后一个初始化阶段。在这个阶段中，JVM 首先会执行构造器 <clinit> 方法，编译器会在 .java 文件被编译成 .class 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 <clinit>() 方法。\n\n\n\n（5）执行方法。启动 main 线程，执行 main 方法，开始执行第一行代码。此时堆内存中会创建一个 student 对象，对象引用 student 就存放在栈中。\n\n\n\n（6）此时再次创建一个 JVMCase 对象，调用 sayHello 非静态方法，sayHello 方法属于对象 JVMCase，此时 sayHello 方法入栈，并通过栈中的 student 引用调用堆中的 Student 对象；之后，调用静态方法 print，print 静态方法属于 JVMCase 类，是从静态方法中获取，之后放入到栈中，也是通过 student 引用调用堆中的 student 对象。\n\n\n\n\n# OutOfMemoryError\n\n\n# 什么是 OutOfMemoryError\n\nOutOfMemoryError 简称为 OOM。Java 中对 OOM 的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。通俗的解释是：JVM 内存不足了。\n\n在 JVM 规范中，除了程序计数器区域外，其他运行时区域都可能发生 OutOfMemoryError 异常（简称 OOM）。\n\n下面逐一介绍 OOM 发生场景。\n\n\n# 堆空间溢出\n\njava.lang.OutOfMemoryError: Java heap space 这个错误意味着：堆空间溢出。\n\n更细致的说法是：Java 堆内存已经达到 -Xmx 设置的最大值。Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾收集器回收这些对象，那么当堆空间到达最大容量限制后就会产生 OOM。\n\n堆空间溢出有可能是**内存泄漏（Memory Leak）** 或 内存溢出（Memory Overflow） 。需要使用 jstack 和 jmap 生成 threaddump 和 heapdump，然后用内存分析工具（如：MAT）进行分析。\n\n# Java heap space 分析步骤\n\n 1. 使用 jmap 或 -XX:+HeapDumpOnOutOfMemoryError 获取堆快照。\n 2. 使用内存分析工具（visualvm、mat、jProfile 等）对堆快照文件进行分析。\n 3. 根据分析图，重点是确认内存中的对象是否是必要的，分清究竟是是内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。\n\n# 内存泄漏\n\n内存泄漏是指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。\n\n内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏随着被执行的次数不断增加，最终会导致内存溢出。\n\n内存泄漏常见场景：\n\n * 静态容器\n   * 声明为静态（static）的 HashMap、Vector 等集合\n   * 通俗来讲 A 中有 B，当前只把 B 设置为空，A 没有设置为空，回收时 B 无法回收。因为被 A 引用。\n * 监听器\n   * 监听器被注册后释放对象时没有删除监听器\n * 物理连接\n   * 各种连接池建立了连接，必须通过 close() 关闭链接\n * 内部类和外部模块等的引用\n   * 发现它的方式同内存溢出，可再加个实时观察\n   * jstat -gcutil 7362 2500 70\n\n重点关注：\n\n * FGC — 从应用程序启动到采样时发生 Full GC 的次数。\n * FGCT — 从应用程序启动到采样时 Full GC 所用的时间（单位秒）。\n * FGC 次数越多，FGCT 所需时间越多，越有可能存在内存泄漏。\n\n如果是内存泄漏，可以进一步查看泄漏对象到 GC Roots 的对象引用链。这样就能找到泄漏对象是怎样与 GC Roots 关联并导致 GC 无法回收它们的。掌握了这些原因，就可以较准确的定位出引起内存泄漏的代码。\n\n导致内存泄漏的常见原因是使用容器，且不断向容器中添加元素，但没有清理，导致容器内存不断膨胀。\n\n【示例】\n\n/**\n * 内存泄漏示例\n * 错误现象：java.lang.OutOfMemoryError: Java heap space\n * VM Args：-verbose:gc -Xms10M -Xmx10M -XX:+HeapDumpOnOutOfMemoryError\n */\npublic class HeapOutOfMemoryDemo {\n\n    public static void main(String[] args) {\n        List<OomObject> list = new ArrayList<>();\n        while (true) {\n            list.add(new OomObject());\n        }\n    }\n\n    static class OomObject {}\n\n}\n\n\n# 内存溢出\n\n如果不存在内存泄漏，即内存中的对象确实都必须存活着，则应当检查虚拟机的堆参数（-Xmx 和 -Xms），与机器物理内存进行对比，看看是否可以调大。并从代码上检查是否存在某些对象生命周期过长、持有时间过长的情况，尝试减少程序运行期的内存消耗。\n\n【示例】\n\n/**\n * 堆溢出示例\n * <p>\n * 错误现象：java.lang.OutOfMemoryError: Java heap space\n * <p>\n * VM Args：-verbose:gc -Xms10M -Xmx10M\n *\n * @author <a href="mailto:forbreak@163.com">Zhang Peng</a>\n * @since 2019-06-25\n */\npublic class HeapOutOfMemoryDemo {\n\n    public static void main(String[] args) {\n        Double[] array = new Double[999999999];\n        System.out.println("array length = [" + array.length + "]");\n    }\n\n}\n\n\n执行 java -verbose:gc -Xms10M -Xmx10M -XX:+HeapDumpOnOutOfMemoryError io.github.dunwu.javacore.jvm.memory.HeapMemoryLeakMemoryErrorDemo\n\n上面的例子是一个极端的例子，试图创建一个维度很大的数组，堆内存无法分配这么大的内存，从而报错：Java heap space。\n\n但如果在现实中，代码并没有问题，仅仅是因为堆内存不足，可以通过 -Xms 和 -Xmx 适当调整堆内存大小。\n\n\n# GC 开销超过限制\n\njava.lang.OutOfMemoryError: GC overhead limit exceeded 这个错误，官方给出的定义是：超过 98% 的时间用来做 GC 并且回收了不到 2% 的堆内存时会抛出此异常。这意味着，发生在 GC 占用大量时间为释放很小空间的时候发生的，是一种保护机制。导致异常的原因：一般是因为堆太小，没有足够的内存。\n\n【示例】\n\n/**\n * GC overhead limit exceeded 示例\n * 错误现象：java.lang.OutOfMemoryError: GC overhead limit exceeded\n * 发生在GC占用大量时间为释放很小空间的时候发生的，是一种保护机制。导致异常的原因：一般是因为堆太小，没有足够的内存。\n * 官方对此的定义：超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常。\n * VM Args: -Xms10M -Xmx10M\n */\npublic class GcOverheadLimitExceededDemo {\n\n    public static void main(String[] args) {\n        List<Double> list = new ArrayList<>();\n        double d = 0.0;\n        while (true) {\n            list.add(d++);\n        }\n    }\n\n}\n\n\n【处理】\n\n与 Java heap space 错误处理方法类似，先判断是否存在内存泄漏。如果有，则修正代码；如果没有，则通过 -Xms 和 -Xmx 适当调整堆内存大小。\n\n\n# 永久代空间不足\n\n【错误】\n\njava.lang.OutOfMemoryError: PermGen space\n\n\n【原因】\n\nPerm （永久代）空间主要用于存放 Class 和 Meta 信息，包括类的名称和字段，带有方法字节码的方法，常量池信息，与类关联的对象数组和类型数组以及即时编译器优化。GC 在主程序运行期间不会对永久代空间进行清理，默认是 64M 大小。\n\n根据上面的定义，可以得出 PermGen 大小要求取决于加载的类的数量以及此类声明的大小。因此，可以说造成该错误的主要原因是永久代中装入了太多的类或太大的类。\n\n在 JDK8 之前的版本中，可以通过 -XX:PermSize 和 -XX:MaxPermSize 设置永久代空间大小，从而限制方法区大小，并间接限制其中常量池的容量。\n\n# 初始化时永久代空间不足\n\n【示例】\n\n/**\n * 永久代内存空间不足示例\n * <p>\n * 错误现象：\n * <ul>\n * <li>java.lang.OutOfMemoryError: PermGen space (JDK8 以前版本)</li>\n * <li>java.lang.OutOfMemoryError: Metaspace (JDK8 及以后版本)</li>\n * </ul>\n * VM Args:\n * <ul>\n * <li>-Xmx100M -XX:MaxPermSize=16M (JDK8 以前版本)</li>\n * <li>-Xmx100M -XX:MaxMetaspaceSize=16M (JDK8 及以后版本)</li>\n * </ul>\n */\npublic class PermOutOfMemoryErrorDemo {\n\n    public static void main(String[] args) throws Exception {\n        for (int i = 0; i < 100_000_000; i++) {\n            generate("eu.plumbr.demo.Generated" + i);\n        }\n    }\n\n    public static Class generate(String name) throws Exception {\n        ClassPool pool = ClassPool.getDefault();\n        return pool.makeClass(name).toClass();\n    }\n\n}\n\n\n在此示例中，源代码遍历循环并在运行时生成类。javassist 库正在处理类生成的复杂性。\n\n# 重部署时永久代空间不足\n\n对于更复杂，更实际的示例，让我们逐步介绍一下在应用程序重新部署期间发生的 Permgen 空间错误。重新部署应用程序时，你希望垃圾回收会摆脱引用所有先前加载的类的加载器，并被加载新类的类加载器取代。\n\n不幸的是，许多第三方库以及对线程，JDBC 驱动程序或文件系统句柄等资源的不良处理使得无法卸载以前使用的类加载器。反过来，这意味着在每次重新部署期间，所有先前版本的类仍将驻留在 PermGen 中，从而在每次重新部署期间生成数十兆的垃圾。\n\n让我们想象一个使用 JDBC 驱动程序连接到关系数据库的示例应用程序。启动应用程序时，初始化代码将加载 JDBC 驱动程序以连接到数据库。对应于规范，JDBC 驱动程序向 java.sql.DriverManager 进行注册。该注册包括将对驱动程序实例的引用存储在 DriverManager 的静态字段中。\n\n现在，当从应用程序服务器取消部署应用程序时，java.sql.DriverManager 仍将保留该引用。我们最终获得了对驱动程序类的实时引用，而驱动程序类又保留了用于加载应用程序的 java.lang.Classloader 实例的引用。反过来，这意味着垃圾回收算法无法回收空间。\n\n而且该 java.lang.ClassLoader 实例仍引用应用程序的所有类，通常在 PermGen 中占据数十兆字节。这意味着只需少量重新部署即可填充通常大小的 PermGen。\n\n# PermGen space 解决方案\n\n（1）解决初始化时的 OutOfMemoryError\n\n在应用程序启动期间触发由于 PermGen 耗尽导致的 OutOfMemoryError 时，解决方案很简单。该应用程序仅需要更多空间才能将所有类加载到 PermGen 区域，因此我们只需要增加其大小即可。为此，更改你的应用程序启动配置并添加（或增加，如果存在）-XX:MaxPermSize 参数，类似于以下示例：\n\njava -XX:MaxPermSize=512m com.yourcompany.YourClass\n\n\n上面的配置将告诉 JVM，PermGen 可以增长到 512MB。\n\n清理应用程序中 WEB-INF/lib 下的 jar，用不上的 jar 删除掉，多个应用公共的 jar 移动到 Tomcat 的 lib 目录，减少重复加载。\n\n🔔 注意：-XX:PermSize 一般设为 64M\n\n（2）解决重新部署时的 OutOfMemoryError\n\n重新部署应用程序后立即发生 OutOfMemoryError 时，应用程序会遭受类加载器泄漏的困扰。在这种情况下，解决问题的最简单，继续进行堆转储分析–使用类似于以下命令的重新部署后进行堆转储：\n\njmap -dump:format=b,file=dump.hprof <process-id>\n\n\n然后使用你最喜欢的堆转储分析器打开转储（Eclipse MAT 是一个很好的工具）。在分析器中可以查找重复的类，尤其是那些正在加载应用程序类的类。从那里，你需要进行所有类加载器的查找，以找到当前活动的类加载器。\n\n对于非活动类加载器，你需要通过从非活动类加载器收集到 GC 根的最短路径来确定阻止它们被垃圾收集的引用。有了此信息，你将找到根本原因。如果根本原因是在第三方库中，则可以进入 Google/StackOverflow 查看是否是已知问题以获取补丁/解决方法。\n\n（3）解决运行时 OutOfMemoryError\n\n第一步是检查是否允许 GC 从 PermGen 卸载类。在这方面，标准的 JVM 相当保守-类是天生的。因此，一旦加载，即使没有代码在使用它们，类也会保留在内存中。当应用程序动态创建许多类并且长时间不需要生成的类时，这可能会成为问题。在这种情况下，允许 JVM 卸载类定义可能会有所帮助。这可以通过在启动脚本中仅添加一个配置参数来实现：\n\n-XX:+CMSClassUnloadingEnabled\n\n\n默认情况下，此选项设置为 false，因此要启用此功能，你需要在 Java 选项中显式设置。如果启用 CMSClassUnloadingEnabled，GC 也会扫描 PermGen 并删除不再使用的类。请记住，只有同时使用 UseConcMarkSweepGC 时此选项才起作用。\n\n-XX:+UseConcMarkSweepGC\n\n\n在确保可以卸载类并且问题仍然存在之后，你应该继续进行堆转储分析–使用类似于以下命令的方法进行堆转储：\n\njmap -dump:file=dump.hprof,format=b <process-id>\n\n\n然后，使用你最喜欢的堆转储分析器（例如 Eclipse MAT）打开转储，然后根据已加载的类数查找最昂贵的类加载器。从此类加载器中，你可以继续提取已加载的类，并按实例对此类进行排序，以使可疑对象排在首位。\n\n然后，对于每个可疑者，就需要你手动将根本原因追溯到生成此类的应用程序代码。\n\n\n# 元数据区空间不足\n\n【错误】\n\nException in thread "main" java.lang.OutOfMemoryError: Metaspace\n\n\n【原因】\n\nJava8 以后，JVM 内存空间发生了很大的变化。取消了永久代，转而变为元数据区。\n\n元数据区的内存不足，即方法区和运行时常量池的空间不足。\n\n方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。\n\n一个类要被垃圾收集器回收，判定条件是比较苛刻的。在经常动态生成大量 Class 的应用中，需要特别注意类的回收状况。这类常见除了 CGLib 字节码增强和动态语言以外，常见的还有：大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。\n\n【示例】方法区出现 OutOfMemoryError\n\npublic class MethodAreaOutOfMemoryDemo {\n\n    public static void main(String[] args) {\n        while (true) {\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(Bean.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() {\n                @Override\n                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n                    return proxy.invokeSuper(obj, args);\n                }\n            });\n            enhancer.create();\n        }\n    }\n\n    static class Bean {}\n\n}\n\n\n【解决】\n\n当由于元空间而面临 OutOfMemoryError 时，第一个解决方案应该是显而易见的。如果应用程序耗尽了内存中的 Metaspace 区域，则应增加 Metaspace 的大小。更改应用程序启动配置并增加以下内容：\n\n-XX:MaxMetaspaceSize=512m\n\n\n上面的配置示例告诉 JVM，允许 Metaspace 增长到 512 MB。\n\n另一种解决方案甚至更简单。你可以通过删除此参数来完全解除对 Metaspace 大小的限制，JVM 默认对 Metaspace 的大小没有限制。但是请注意以下事实：这样做可能会导致大量交换或达到本机物理内存而分配失败。\n\n\n# 无法新建本地线程\n\njava.lang.OutOfMemoryError: Unable to create new native thread 这个错误意味着：Java 应用程序已达到其可以启动线程数的限制。\n\n【原因】\n\n当发起一个线程的创建时，虚拟机会在 JVM 内存创建一个 Thread 对象同时创建一个操作系统线程，而这个系统线程的内存用的不是 JVM 内存，而是系统中剩下的内存。\n\n那么，究竟能创建多少线程呢？这里有一个公式：\n\n线程数 = (MaxProcessMemory - JVMMemory - ReservedOsMemory) / (ThreadStackSize)\n\n\n【参数】\n\n * MaxProcessMemory - 一个进程的最大内存\n * JVMMemory - JVM 内存\n * ReservedOsMemory - 保留的操作系统内存\n * ThreadStackSize - 线程栈的大小\n\n给 JVM 分配的内存越多，那么能用来创建系统线程的内存就会越少，越容易发生 unable to create new native thread。所以，JVM 内存不是分配的越大越好。\n\n但是，通常导致 java.lang.OutOfMemoryError 的情况：无法创建新的本机线程需要经历以下阶段：\n\n 1. JVM 内部运行的应用程序请求新的 Java 线程\n 2. JVM 本机代码代理为操作系统创建新本机线程的请求\n 3. 操作系统尝试创建一个新的本机线程，该线程需要将内存分配给该线程\n 4. 操作系统将拒绝本机内存分配，原因是 32 位 Java 进程大小已耗尽其内存地址空间（例如，已达到（2-4）GB 进程大小限制）或操作系统的虚拟内存已完全耗尽\n 5. 引发 java.lang.OutOfMemoryError: Unable to create new native thread 错误。\n\n【示例】\n\npublic class UnableCreateNativeThreadErrorDemo {\n\n    public static void main(String[] args) {\n        while (true) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        TimeUnit.MINUTES.sleep(5);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n        }\n    }\n}\n\n\n【处理】\n\n可以通过增加操作系统级别的限制来绕过无法创建新的本机线程问题。例如，如果限制了 JVM 可在用户空间中产生的进程数，则应检查出并可能增加该限制：\n\n[root@dev ~]# ulimit -a\ncore file size          (blocks, -c) 0\n--- cut for brevity ---\nmax user processes              (-u) 1800\n\n\n通常，OutOfMemoryError 对新的本机线程的限制表示编程错误。当应用程序产生数千个线程时，很可能出了一些问题—很少有应用程序可以从如此大量的线程中受益。\n\n解决问题的一种方法是开始进行线程转储以了解情况。\n\n\n# 直接内存溢出\n\n由直接内存导致的内存溢出，一个明显的特征是在 Head Dump 文件中不会看见明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，就可以考虑检查一下是不是这方面的原因。\n\n【示例】直接内存 OutOfMemoryError\n\n/**\n * 本机直接内存溢出示例\n * 错误现象：java.lang.OutOfMemoryError\n * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M\n */\npublic class DirectOutOfMemoryDemo {\n\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) throws IllegalAccessException {\n        Field unsafeField = Unsafe.class.getDeclaredFields()[0];\n        unsafeField.setAccessible(true);\n        Unsafe unsafe = (Unsafe) unsafeField.get(null);\n        while (true) {\n            unsafe.allocateMemory(_1MB);\n        }\n    }\n\n}\n\n\n\n# StackOverflowError\n\n对于 HotSpot 虚拟机来说，栈容量只由 -Xss 参数来决定如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。\n\n从实战来说，栈溢出的常见原因：\n\n * 递归函数调用层数太深\n * 大量循环或死循环\n\n【示例】递归函数调用层数太深导致 StackOverflowError\n\npublic class StackOverflowDemo {\n\n    private int stackLength = 1;\n\n    public void recursion() {\n        stackLength++;\n        recursion();\n    }\n\n    public static void main(String[] args) {\n        StackOverflowDemo obj = new StackOverflowDemo();\n        try {\n            obj.recursion();\n        } catch (Throwable e) {\n            System.out.println("栈深度：" + obj.stackLength);\n            e.printStackTrace();\n        }\n    }\n\n}\n\n\n\n# 参考资料\n\n * 《深入理解 Java 虚拟机》\n * 《Java 性能调优实战》\n * 从表到里学习 JVM 实现\n * 作为测试你应该知道的 JAVA OOM 及定位分析\n * 异常、堆内存溢出、OOM 的几种情况\n * 介绍 JVM 中 OOM 的 8 种类型',normalizedContent:'# java 内存管理\n\n\n# 内存简介\n\n\n# 物理内存和虚拟内存\n\n所谓物理内存就是通常所说的 ram（随机存储器）。\n\n虚拟内存使得多个进程在同时运行时可以共享物理内存，这里的共享只是空间上共享，在逻辑上彼此仍然是隔离的。\n\n\n# 内核空间和用户空间\n\n一个计算通常有固定大小的内存空间，但是程序并不能使用全部的空间。因为这些空间被划分为内核空间和用户空间，而程序只能使用用户空间的内存。\n\n\n# 使用内存的 java 组件\n\njava 启动后，作为一个进程运行在操作系统中。\n\n有哪些 java 组件需要占用内存呢？\n\n * 堆内存：java 堆、类和类加载器\n * 栈内存：线程\n * 本地内存：nio、jni\n\n\n# 运行时数据区域\n\njvm 在执行 java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。如下图所示：\n\n\n\n\n# 程序计数器\n\n程序计数器（program counter register） 是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。\n\n当执行的线程数量超过 cpu 数量时，线程之间会根据时间片轮询争夺 cpu 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 cpu 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令，从而在线程切换后能恢复到正确的执行位置。各条线程间的计数器互不影响，独立存储，我们称这类内存区域为 “线程私有” 的内存。\n\n * 如果线程正在执行的是一个 java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；\n * 如果正在执行的是 native 方法，这个计数器值则为空（undefined）。\n\n> 🔔 注意：此内存区域是唯一一个在 jvm 中没有规定任何 outofmemoryerror 情况的区域。\n\n\n# java 虚拟机栈\n\njava 虚拟机栈（java virtual machine stacks） 也是线程私有的，它的生命周期与线程相同。\n\n每个 java 方法在执行的同时都会创建一个栈帧（stack frame）用于存储 局部变量表、操作数栈、常量池引用 等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 java 虚拟机栈中入栈和出栈的过程。\n\n\n\n * 局部变量表 - 32 位变量槽，存放了编译期可知的各种基本数据类型、对象引用、returnaddress 类型。\n * 操作数栈 - 基于栈的执行引擎，虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。\n * 动态链接 - 每个栈帧都包含一个指向运行时常量池（方法区的一部分）中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。class 文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另一部分将在每一次的运行期间转化为直接应用，这部分称为动态链接。\n * 方法出口 - 返回方法被调用的位置，恢复上层方法的局部变量和操作数栈，如果无返回值，则把它压入调用者的操作数栈。\n\n> 🔔 注意：\n> \n> 该区域可能抛出以下异常：\n> \n>  * 如果线程请求的栈深度超过最大值，就会抛出 stackoverflowerror 异常；\n>  * 如果虚拟机栈进行动态扩展时，无法申请到足够内存，就会抛出 outofmemoryerror 异常。\n> \n> 💡 提示：\n> \n> 可以通过 -xss 这个虚拟机参数来指定一个程序的 java 虚拟机栈内存大小：\n> \n> java -xss=512m hackthejava\n\n\n# 本地方法栈\n\n本地方法栈（native method stack） 与虚拟机栈的作用相似。\n\n二者的区别在于：虚拟机栈为 java 方法服务；本地方法栈为 native 方法服务。本地方法并不是用 java 实现的，而是由 c 语言实现的。\n\n\n\n> 🔔 注意：本地方法栈也会抛出 stackoverflowerror 异常和 outofmemoryerror 异常。\n\n\n# java 堆\n\njava 堆（java heap） 的作用就是存放对象实例，几乎所有的对象实例都是在这里分配内存。\n\njava 堆是垃圾收集的主要区域（因此也被叫做"gc 堆"）。现代的垃圾收集器基本都是采用分代收集算法，该算法的思想是针对不同的对象采取不同的垃圾回收算法。\n\n因此虚拟机把 java 堆分成以下三块：\n\n * 新生代（young generation）\n   * eden - eden 和 survivor 的比例为 8:1\n   * from survivor\n   * to survivor\n * 老年代（old generation）\n * 永久代（permanent generation）\n\n当一个对象被创建时，它首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。\n\n\n\n> 🔔 注意：java 堆不需要连续内存，并且可以动态扩展其内存，扩展失败会抛出 outofmemoryerror 异常。\n> \n> 💡 提示：可以通过 -xms 和 -xmx 两个虚拟机参数来指定一个程序的 java 堆内存大小，第一个参数设置初始值，第二个参数设置最大值。\n> \n> java -xms=1m -xmx=2m hackthejava\n\n\n# 方法区\n\n方法区（method area）也被称为永久代。方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。\n\n> 🔔 注意：和 java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 outofmemoryerror 异常。\n> \n> 💡 提示：\n> \n>  * jdk 1.7 之前，hotspot 虚拟机把它当成永久代来进行垃圾回收。可通过参数 -xx:permsize 和 -xx:maxpermsize 设置。\n>  * jdk 1.8 之后，取消了永久代，用 **metaspace（元数据）**区替代。可通过参数 -xx:maxmetaspacesize 设置。\n\n\n# 运行时常量池\n\n运行时常量池（runtime constant pool） 是方法区的一部分，class 文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是常量池（constant pool table），用于存放编译器生成的各种字面量和符号引用，这部分内容会在类加载后被放入这个区域。\n\n * 字面量 - 文本字符串、声明为 final 的常量值等。\n * 符号引用 - 类和接口的完全限定名（fully qualified name）、字段的名称和描述符（descriptor）、方法的名称和描述符。\n\n除了在编译期生成的常量，还允许动态生成，例如 string 类的 intern()。这部分常量也会被放入运行时常量池。\n\n> 🔔 注意：当常量池无法再申请到内存时会抛出 outofmemoryerror 异常。\n\n\n# 直接内存\n\n直接内存（direct memory）并不是虚拟机运行时数据区的一部分，也不是 jvm 规范中定义的内存区域。\n\n在 jdk 1.4 中新加入了 nio 类，它可以使用 native 函数库直接分配堆外内存，然后通过一个存储在 java 堆里的 directbytebuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 java 堆和 native 堆中来回复制数据。\n\n> 🔔 注意：直接内存这部分也被频繁的使用，且也可能导致 outofmemoryerror 异常。\n> \n> 💡 提示：直接内存容量可通过 -xx:maxdirectmemorysize 指定，如果不指定，则默认与 java 堆最大值（-xmx 指定）一样。\n\n\n# java 内存区域对比\n\n内存区域        内存作用范围    异常\n程序计数器       线程私有      无\njava 虚拟机栈   线程私有      stackoverflowerror 和 outofmemoryerror\n本地方法栈       线程私有      stackoverflowerror 和 outofmemoryerror\njava 堆      线程共享      outofmemoryerror\n方法区         线程共享      outofmemoryerror\n运行时常量池      线程共享      outofmemoryerror\n直接内存        非运行时数据区   outofmemoryerror\n\n\n# jvm 运行原理\n\npublic class jvmcase {\n\n\t// 常量\n\tpublic final static string man_sex_type = "man";\n\n\t// 静态变量\n\tpublic static string woman_sex_type = "woman";\n\n\tpublic static void main(string[] args) {\n\n\t\tstudent stu = new student();\n\t\tstu.setname("nick");\n\t\tstu.setsextype(man_sex_type);\n\t\tstu.setage(20);\n\n\t\tjvmcase jvmcase = new jvmcase();\n\n\t\t// 调用静态方法\n\t\tprint(stu);\n\t\t// 调用非静态方法\n\t\tjvmcase.sayhello(stu);\n\t}\n\n\n\t// 常规静态方法\n\tpublic static void print(student stu) {\n\t\tsystem.out.println("name: " + stu.getname() + "; sex:" + stu.getsextype() + "; age:" + stu.getage());\n\t}\n\n\n\t// 非静态方法\n\tpublic void sayhello(student stu) {\n\t\tsystem.out.println(stu.getname() + "say: hello");\n\t}\n}\n\nclass student{\n\tstring name;\n\tstring sextype;\n\tint age;\n\n\tpublic string getname() {\n\t\treturn name;\n\t}\n\tpublic void setname(string name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic string getsextype() {\n\t\treturn sextype;\n\t}\n\tpublic void setsextype(string sextype) {\n\t\tthis.sextype = sextype;\n\t}\n\tpublic int getage() {\n\t\treturn age;\n\t}\n\tpublic void setage(int age) {\n\t\tthis.age = age;\n\t}\n}\n\n\n运行以上代码时，jvm 处理过程如下：\n\n（1）jvm 向操作系统申请内存，jvm 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给 jvm，接下来 jvm 就进行内部分配。\n\n（2）jvm 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。\n\n（3）class 文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值（这部分我在第 21 讲还会详细介绍）。\n\n\n\n（4）完成上一个步骤后，将会进行最后一个初始化阶段。在这个阶段中，jvm 首先会执行构造器 <clinit> 方法，编译器会在 .java 文件被编译成 .class 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 <clinit>() 方法。\n\n\n\n（5）执行方法。启动 main 线程，执行 main 方法，开始执行第一行代码。此时堆内存中会创建一个 student 对象，对象引用 student 就存放在栈中。\n\n\n\n（6）此时再次创建一个 jvmcase 对象，调用 sayhello 非静态方法，sayhello 方法属于对象 jvmcase，此时 sayhello 方法入栈，并通过栈中的 student 引用调用堆中的 student 对象；之后，调用静态方法 print，print 静态方法属于 jvmcase 类，是从静态方法中获取，之后放入到栈中，也是通过 student 引用调用堆中的 student 对象。\n\n\n\n\n# outofmemoryerror\n\n\n# 什么是 outofmemoryerror\n\noutofmemoryerror 简称为 oom。java 中对 oom 的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。通俗的解释是：jvm 内存不足了。\n\n在 jvm 规范中，除了程序计数器区域外，其他运行时区域都可能发生 outofmemoryerror 异常（简称 oom）。\n\n下面逐一介绍 oom 发生场景。\n\n\n# 堆空间溢出\n\njava.lang.outofmemoryerror: java heap space 这个错误意味着：堆空间溢出。\n\n更细致的说法是：java 堆内存已经达到 -xmx 设置的最大值。java 堆用于存储对象实例，只要不断地创建对象，并且保证 gc roots 到对象之间有可达路径来避免垃圾收集器回收这些对象，那么当堆空间到达最大容量限制后就会产生 oom。\n\n堆空间溢出有可能是**内存泄漏（memory leak）** 或 内存溢出（memory overflow） 。需要使用 jstack 和 jmap 生成 threaddump 和 heapdump，然后用内存分析工具（如：mat）进行分析。\n\n# java heap space 分析步骤\n\n 1. 使用 jmap 或 -xx:+heapdumponoutofmemoryerror 获取堆快照。\n 2. 使用内存分析工具（visualvm、mat、jprofile 等）对堆快照文件进行分析。\n 3. 根据分析图，重点是确认内存中的对象是否是必要的，分清究竟是是内存泄漏（memory leak）还是内存溢出（memory overflow）。\n\n# 内存泄漏\n\n内存泄漏是指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。\n\n内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏随着被执行的次数不断增加，最终会导致内存溢出。\n\n内存泄漏常见场景：\n\n * 静态容器\n   * 声明为静态（static）的 hashmap、vector 等集合\n   * 通俗来讲 a 中有 b，当前只把 b 设置为空，a 没有设置为空，回收时 b 无法回收。因为被 a 引用。\n * 监听器\n   * 监听器被注册后释放对象时没有删除监听器\n * 物理连接\n   * 各种连接池建立了连接，必须通过 close() 关闭链接\n * 内部类和外部模块等的引用\n   * 发现它的方式同内存溢出，可再加个实时观察\n   * jstat -gcutil 7362 2500 70\n\n重点关注：\n\n * fgc — 从应用程序启动到采样时发生 full gc 的次数。\n * fgct — 从应用程序启动到采样时 full gc 所用的时间（单位秒）。\n * fgc 次数越多，fgct 所需时间越多，越有可能存在内存泄漏。\n\n如果是内存泄漏，可以进一步查看泄漏对象到 gc roots 的对象引用链。这样就能找到泄漏对象是怎样与 gc roots 关联并导致 gc 无法回收它们的。掌握了这些原因，就可以较准确的定位出引起内存泄漏的代码。\n\n导致内存泄漏的常见原因是使用容器，且不断向容器中添加元素，但没有清理，导致容器内存不断膨胀。\n\n【示例】\n\n/**\n * 内存泄漏示例\n * 错误现象：java.lang.outofmemoryerror: java heap space\n * vm args：-verbose:gc -xms10m -xmx10m -xx:+heapdumponoutofmemoryerror\n */\npublic class heapoutofmemorydemo {\n\n    public static void main(string[] args) {\n        list<oomobject> list = new arraylist<>();\n        while (true) {\n            list.add(new oomobject());\n        }\n    }\n\n    static class oomobject {}\n\n}\n\n\n# 内存溢出\n\n如果不存在内存泄漏，即内存中的对象确实都必须存活着，则应当检查虚拟机的堆参数（-xmx 和 -xms），与机器物理内存进行对比，看看是否可以调大。并从代码上检查是否存在某些对象生命周期过长、持有时间过长的情况，尝试减少程序运行期的内存消耗。\n\n【示例】\n\n/**\n * 堆溢出示例\n * <p>\n * 错误现象：java.lang.outofmemoryerror: java heap space\n * <p>\n * vm args：-verbose:gc -xms10m -xmx10m\n *\n * @author <a href="mailto:forbreak@163.com">zhang peng</a>\n * @since 2019-06-25\n */\npublic class heapoutofmemorydemo {\n\n    public static void main(string[] args) {\n        double[] array = new double[999999999];\n        system.out.println("array length = [" + array.length + "]");\n    }\n\n}\n\n\n执行 java -verbose:gc -xms10m -xmx10m -xx:+heapdumponoutofmemoryerror io.github.dunwu.javacore.jvm.memory.heapmemoryleakmemoryerrordemo\n\n上面的例子是一个极端的例子，试图创建一个维度很大的数组，堆内存无法分配这么大的内存，从而报错：java heap space。\n\n但如果在现实中，代码并没有问题，仅仅是因为堆内存不足，可以通过 -xms 和 -xmx 适当调整堆内存大小。\n\n\n# gc 开销超过限制\n\njava.lang.outofmemoryerror: gc overhead limit exceeded 这个错误，官方给出的定义是：超过 98% 的时间用来做 gc 并且回收了不到 2% 的堆内存时会抛出此异常。这意味着，发生在 gc 占用大量时间为释放很小空间的时候发生的，是一种保护机制。导致异常的原因：一般是因为堆太小，没有足够的内存。\n\n【示例】\n\n/**\n * gc overhead limit exceeded 示例\n * 错误现象：java.lang.outofmemoryerror: gc overhead limit exceeded\n * 发生在gc占用大量时间为释放很小空间的时候发生的，是一种保护机制。导致异常的原因：一般是因为堆太小，没有足够的内存。\n * 官方对此的定义：超过98%的时间用来做gc并且回收了不到2%的堆内存时会抛出此异常。\n * vm args: -xms10m -xmx10m\n */\npublic class gcoverheadlimitexceededdemo {\n\n    public static void main(string[] args) {\n        list<double> list = new arraylist<>();\n        double d = 0.0;\n        while (true) {\n            list.add(d++);\n        }\n    }\n\n}\n\n\n【处理】\n\n与 java heap space 错误处理方法类似，先判断是否存在内存泄漏。如果有，则修正代码；如果没有，则通过 -xms 和 -xmx 适当调整堆内存大小。\n\n\n# 永久代空间不足\n\n【错误】\n\njava.lang.outofmemoryerror: permgen space\n\n\n【原因】\n\nperm （永久代）空间主要用于存放 class 和 meta 信息，包括类的名称和字段，带有方法字节码的方法，常量池信息，与类关联的对象数组和类型数组以及即时编译器优化。gc 在主程序运行期间不会对永久代空间进行清理，默认是 64m 大小。\n\n根据上面的定义，可以得出 permgen 大小要求取决于加载的类的数量以及此类声明的大小。因此，可以说造成该错误的主要原因是永久代中装入了太多的类或太大的类。\n\n在 jdk8 之前的版本中，可以通过 -xx:permsize 和 -xx:maxpermsize 设置永久代空间大小，从而限制方法区大小，并间接限制其中常量池的容量。\n\n# 初始化时永久代空间不足\n\n【示例】\n\n/**\n * 永久代内存空间不足示例\n * <p>\n * 错误现象：\n * <ul>\n * <li>java.lang.outofmemoryerror: permgen space (jdk8 以前版本)</li>\n * <li>java.lang.outofmemoryerror: metaspace (jdk8 及以后版本)</li>\n * </ul>\n * vm args:\n * <ul>\n * <li>-xmx100m -xx:maxpermsize=16m (jdk8 以前版本)</li>\n * <li>-xmx100m -xx:maxmetaspacesize=16m (jdk8 及以后版本)</li>\n * </ul>\n */\npublic class permoutofmemoryerrordemo {\n\n    public static void main(string[] args) throws exception {\n        for (int i = 0; i < 100_000_000; i++) {\n            generate("eu.plumbr.demo.generated" + i);\n        }\n    }\n\n    public static class generate(string name) throws exception {\n        classpool pool = classpool.getdefault();\n        return pool.makeclass(name).toclass();\n    }\n\n}\n\n\n在此示例中，源代码遍历循环并在运行时生成类。javassist 库正在处理类生成的复杂性。\n\n# 重部署时永久代空间不足\n\n对于更复杂，更实际的示例，让我们逐步介绍一下在应用程序重新部署期间发生的 permgen 空间错误。重新部署应用程序时，你希望垃圾回收会摆脱引用所有先前加载的类的加载器，并被加载新类的类加载器取代。\n\n不幸的是，许多第三方库以及对线程，jdbc 驱动程序或文件系统句柄等资源的不良处理使得无法卸载以前使用的类加载器。反过来，这意味着在每次重新部署期间，所有先前版本的类仍将驻留在 permgen 中，从而在每次重新部署期间生成数十兆的垃圾。\n\n让我们想象一个使用 jdbc 驱动程序连接到关系数据库的示例应用程序。启动应用程序时，初始化代码将加载 jdbc 驱动程序以连接到数据库。对应于规范，jdbc 驱动程序向 java.sql.drivermanager 进行注册。该注册包括将对驱动程序实例的引用存储在 drivermanager 的静态字段中。\n\n现在，当从应用程序服务器取消部署应用程序时，java.sql.drivermanager 仍将保留该引用。我们最终获得了对驱动程序类的实时引用，而驱动程序类又保留了用于加载应用程序的 java.lang.classloader 实例的引用。反过来，这意味着垃圾回收算法无法回收空间。\n\n而且该 java.lang.classloader 实例仍引用应用程序的所有类，通常在 permgen 中占据数十兆字节。这意味着只需少量重新部署即可填充通常大小的 permgen。\n\n# permgen space 解决方案\n\n（1）解决初始化时的 outofmemoryerror\n\n在应用程序启动期间触发由于 permgen 耗尽导致的 outofmemoryerror 时，解决方案很简单。该应用程序仅需要更多空间才能将所有类加载到 permgen 区域，因此我们只需要增加其大小即可。为此，更改你的应用程序启动配置并添加（或增加，如果存在）-xx:maxpermsize 参数，类似于以下示例：\n\njava -xx:maxpermsize=512m com.yourcompany.yourclass\n\n\n上面的配置将告诉 jvm，permgen 可以增长到 512mb。\n\n清理应用程序中 web-inf/lib 下的 jar，用不上的 jar 删除掉，多个应用公共的 jar 移动到 tomcat 的 lib 目录，减少重复加载。\n\n🔔 注意：-xx:permsize 一般设为 64m\n\n（2）解决重新部署时的 outofmemoryerror\n\n重新部署应用程序后立即发生 outofmemoryerror 时，应用程序会遭受类加载器泄漏的困扰。在这种情况下，解决问题的最简单，继续进行堆转储分析–使用类似于以下命令的重新部署后进行堆转储：\n\njmap -dump:format=b,file=dump.hprof <process-id>\n\n\n然后使用你最喜欢的堆转储分析器打开转储（eclipse mat 是一个很好的工具）。在分析器中可以查找重复的类，尤其是那些正在加载应用程序类的类。从那里，你需要进行所有类加载器的查找，以找到当前活动的类加载器。\n\n对于非活动类加载器，你需要通过从非活动类加载器收集到 gc 根的最短路径来确定阻止它们被垃圾收集的引用。有了此信息，你将找到根本原因。如果根本原因是在第三方库中，则可以进入 google/stackoverflow 查看是否是已知问题以获取补丁/解决方法。\n\n（3）解决运行时 outofmemoryerror\n\n第一步是检查是否允许 gc 从 permgen 卸载类。在这方面，标准的 jvm 相当保守-类是天生的。因此，一旦加载，即使没有代码在使用它们，类也会保留在内存中。当应用程序动态创建许多类并且长时间不需要生成的类时，这可能会成为问题。在这种情况下，允许 jvm 卸载类定义可能会有所帮助。这可以通过在启动脚本中仅添加一个配置参数来实现：\n\n-xx:+cmsclassunloadingenabled\n\n\n默认情况下，此选项设置为 false，因此要启用此功能，你需要在 java 选项中显式设置。如果启用 cmsclassunloadingenabled，gc 也会扫描 permgen 并删除不再使用的类。请记住，只有同时使用 useconcmarksweepgc 时此选项才起作用。\n\n-xx:+useconcmarksweepgc\n\n\n在确保可以卸载类并且问题仍然存在之后，你应该继续进行堆转储分析–使用类似于以下命令的方法进行堆转储：\n\njmap -dump:file=dump.hprof,format=b <process-id>\n\n\n然后，使用你最喜欢的堆转储分析器（例如 eclipse mat）打开转储，然后根据已加载的类数查找最昂贵的类加载器。从此类加载器中，你可以继续提取已加载的类，并按实例对此类进行排序，以使可疑对象排在首位。\n\n然后，对于每个可疑者，就需要你手动将根本原因追溯到生成此类的应用程序代码。\n\n\n# 元数据区空间不足\n\n【错误】\n\nexception in thread "main" java.lang.outofmemoryerror: metaspace\n\n\n【原因】\n\njava8 以后，jvm 内存空间发生了很大的变化。取消了永久代，转而变为元数据区。\n\n元数据区的内存不足，即方法区和运行时常量池的空间不足。\n\n方法区用于存放 class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。\n\n一个类要被垃圾收集器回收，判定条件是比较苛刻的。在经常动态生成大量 class 的应用中，需要特别注意类的回收状况。这类常见除了 cglib 字节码增强和动态语言以外，常见的还有：大量 jsp 或动态产生 jsp 文件的应用（jsp 第一次运行时需要编译为 java 类）、基于 osgi 的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。\n\n【示例】方法区出现 outofmemoryerror\n\npublic class methodareaoutofmemorydemo {\n\n    public static void main(string[] args) {\n        while (true) {\n            enhancer enhancer = new enhancer();\n            enhancer.setsuperclass(bean.class);\n            enhancer.setusecache(false);\n            enhancer.setcallback(new methodinterceptor() {\n                @override\n                public object intercept(object obj, method method, object[] args, methodproxy proxy) throws throwable {\n                    return proxy.invokesuper(obj, args);\n                }\n            });\n            enhancer.create();\n        }\n    }\n\n    static class bean {}\n\n}\n\n\n【解决】\n\n当由于元空间而面临 outofmemoryerror 时，第一个解决方案应该是显而易见的。如果应用程序耗尽了内存中的 metaspace 区域，则应增加 metaspace 的大小。更改应用程序启动配置并增加以下内容：\n\n-xx:maxmetaspacesize=512m\n\n\n上面的配置示例告诉 jvm，允许 metaspace 增长到 512 mb。\n\n另一种解决方案甚至更简单。你可以通过删除此参数来完全解除对 metaspace 大小的限制，jvm 默认对 metaspace 的大小没有限制。但是请注意以下事实：这样做可能会导致大量交换或达到本机物理内存而分配失败。\n\n\n# 无法新建本地线程\n\njava.lang.outofmemoryerror: unable to create new native thread 这个错误意味着：java 应用程序已达到其可以启动线程数的限制。\n\n【原因】\n\n当发起一个线程的创建时，虚拟机会在 jvm 内存创建一个 thread 对象同时创建一个操作系统线程，而这个系统线程的内存用的不是 jvm 内存，而是系统中剩下的内存。\n\n那么，究竟能创建多少线程呢？这里有一个公式：\n\n线程数 = (maxprocessmemory - jvmmemory - reservedosmemory) / (threadstacksize)\n\n\n【参数】\n\n * maxprocessmemory - 一个进程的最大内存\n * jvmmemory - jvm 内存\n * reservedosmemory - 保留的操作系统内存\n * threadstacksize - 线程栈的大小\n\n给 jvm 分配的内存越多，那么能用来创建系统线程的内存就会越少，越容易发生 unable to create new native thread。所以，jvm 内存不是分配的越大越好。\n\n但是，通常导致 java.lang.outofmemoryerror 的情况：无法创建新的本机线程需要经历以下阶段：\n\n 1. jvm 内部运行的应用程序请求新的 java 线程\n 2. jvm 本机代码代理为操作系统创建新本机线程的请求\n 3. 操作系统尝试创建一个新的本机线程，该线程需要将内存分配给该线程\n 4. 操作系统将拒绝本机内存分配，原因是 32 位 java 进程大小已耗尽其内存地址空间（例如，已达到（2-4）gb 进程大小限制）或操作系统的虚拟内存已完全耗尽\n 5. 引发 java.lang.outofmemoryerror: unable to create new native thread 错误。\n\n【示例】\n\npublic class unablecreatenativethreaderrordemo {\n\n    public static void main(string[] args) {\n        while (true) {\n            new thread(new runnable() {\n                @override\n                public void run() {\n                    try {\n                        timeunit.minutes.sleep(5);\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                }\n            }).start();\n        }\n    }\n}\n\n\n【处理】\n\n可以通过增加操作系统级别的限制来绕过无法创建新的本机线程问题。例如，如果限制了 jvm 可在用户空间中产生的进程数，则应检查出并可能增加该限制：\n\n[root@dev ~]# ulimit -a\ncore file size          (blocks, -c) 0\n--- cut for brevity ---\nmax user processes              (-u) 1800\n\n\n通常，outofmemoryerror 对新的本机线程的限制表示编程错误。当应用程序产生数千个线程时，很可能出了一些问题—很少有应用程序可以从如此大量的线程中受益。\n\n解决问题的一种方法是开始进行线程转储以了解情况。\n\n\n# 直接内存溢出\n\n由直接内存导致的内存溢出，一个明显的特征是在 head dump 文件中不会看见明显的异常，如果发现 oom 之后 dump 文件很小，而程序中又直接或间接使用了 nio，就可以考虑检查一下是不是这方面的原因。\n\n【示例】直接内存 outofmemoryerror\n\n/**\n * 本机直接内存溢出示例\n * 错误现象：java.lang.outofmemoryerror\n * vm args：-xmx20m -xx:maxdirectmemorysize=10m\n */\npublic class directoutofmemorydemo {\n\n    private static final int _1mb = 1024 * 1024;\n\n    public static void main(string[] args) throws illegalaccessexception {\n        field unsafefield = unsafe.class.getdeclaredfields()[0];\n        unsafefield.setaccessible(true);\n        unsafe unsafe = (unsafe) unsafefield.get(null);\n        while (true) {\n            unsafe.allocatememory(_1mb);\n        }\n    }\n\n}\n\n\n\n# stackoverflowerror\n\n对于 hotspot 虚拟机来说，栈容量只由 -xss 参数来决定如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 stackoverflowerror 异常。\n\n从实战来说，栈溢出的常见原因：\n\n * 递归函数调用层数太深\n * 大量循环或死循环\n\n【示例】递归函数调用层数太深导致 stackoverflowerror\n\npublic class stackoverflowdemo {\n\n    private int stacklength = 1;\n\n    public void recursion() {\n        stacklength++;\n        recursion();\n    }\n\n    public static void main(string[] args) {\n        stackoverflowdemo obj = new stackoverflowdemo();\n        try {\n            obj.recursion();\n        } catch (throwable e) {\n            system.out.println("栈深度：" + obj.stacklength);\n            e.printstacktrace();\n        }\n    }\n\n}\n\n\n\n# 参考资料\n\n * 《深入理解 java 虚拟机》\n * 《java 性能调优实战》\n * 从表到里学习 jvm 实现\n * 作为测试你应该知道的 java oom 及定位分析\n * 异常、堆内存溢出、oom 的几种情况\n * 介绍 jvm 中 oom 的 8 种类型',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"JVM 垃圾收集",frontmatter:{title:"JVM 垃圾收集",categories:["编程","Java","JavaSE","JVM"],tags:["Java","JavaSE","JVM","GC"],abbrlink:"1d5640b1",date:"2020-06-07T09:21:16.000Z",permalink:"/pages/7fb1c8/"},regularPath:"/06.JVM/03.JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.html",relativePath:"06.JVM/03.JVM垃圾收集.md",key:"v-89b8bfb2",path:"/pages/7fb1c8/",headers:[{level:2,title:"对象活着吗",slug:"对象活着吗",normalizedTitle:"对象活着吗",charIndex:113},{level:3,title:"引用计数算法",slug:"引用计数算法",normalizedTitle:"引用计数算法",charIndex:123},{level:3,title:"可达性分析算法",slug:"可达性分析算法",normalizedTitle:"可达性分析算法",charIndex:598},{level:3,title:"引用类型",slug:"引用类型",normalizedTitle:"引用类型",charIndex:773},{level:4,title:"强引用",slug:"强引用",normalizedTitle:"强引用",charIndex:866},{level:4,title:"软引用",slug:"软引用",normalizedTitle:"软引用",charIndex:970},{level:4,title:"弱引用",slug:"弱引用",normalizedTitle:"弱引用",charIndex:1167},{level:4,title:"虚引用",slug:"虚引用",normalizedTitle:"虚引用",charIndex:2418},{level:3,title:"方法区的回收",slug:"方法区的回收",normalizedTitle:"方法区的回收",charIndex:2666},{level:3,title:"finalize()",slug:"finalize",normalizedTitle:"finalize()",charIndex:3039},{level:2,title:"垃圾收集算法",slug:"垃圾收集算法",normalizedTitle:"垃圾收集算法",charIndex:3237},{level:3,title:"垃圾收集性能",slug:"垃圾收集性能",normalizedTitle:"垃圾收集性能",charIndex:3248},{level:3,title:"标记 - 清除（Mark-Sweep）",slug:"标记-清除-mark-sweep",normalizedTitle:"标记 - 清除（mark-sweep）",charIndex:3413},{level:3,title:"标记 - 整理（Mark-Compact）",slug:"标记-整理-mark-compact",normalizedTitle:"标记 - 整理（mark-compact）",charIndex:3520},{level:3,title:"复制（Copying）",slug:"复制-copying",normalizedTitle:"复制（copying）",charIndex:3614},{level:3,title:"分代收集",slug:"分代收集",normalizedTitle:"分代收集",charIndex:4079},{level:4,title:"新生代",slug:"新生代",normalizedTitle:"新生代",charIndex:4208},{level:4,title:"老年代",slug:"老年代",normalizedTitle:"老年代",charIndex:4044},{level:4,title:"永久代",slug:"永久代",normalizedTitle:"永久代",charIndex:2683},{level:4,title:"JVM 参数",slug:"jvm-参数",normalizedTitle:"jvm 参数",charIndex:4884},{level:2,title:"垃圾收集器",slug:"垃圾收集器",normalizedTitle:"垃圾收集器",charIndex:901},{level:3,title:"串行收集器",slug:"串行收集器",normalizedTitle:"串行收集器",charIndex:5485},{level:4,title:"Serial 收集器",slug:"serial-收集器",normalizedTitle:"serial 收集器",charIndex:5580},{level:4,title:"Serial Old 收集器",slug:"serial-old-收集器",normalizedTitle:"serial old 收集器",charIndex:5767},{level:3,title:"并行收集器",slug:"并行收集器",normalizedTitle:"并行收集器",charIndex:6179},{level:4,title:"Parallel Scavenge 收集器",slug:"parallel-scavenge-收集器",normalizedTitle:"parallel scavenge 收集器",charIndex:6092},{level:4,title:"Parallel Old 收集器",slug:"parallel-old-收集器",normalizedTitle:"parallel old 收集器",charIndex:6339},{level:3,title:"并发标记清除收集器",slug:"并发标记清除收集器",normalizedTitle:"并发标记清除收集器",charIndex:7419},{level:4,title:"CMS 收集器",slug:"cms-收集器",normalizedTitle:"cms 收集器",charIndex:6125},{level:5,title:"CMS 回收机制",slug:"cms-回收机制",normalizedTitle:"cms 回收机制",charIndex:7768},{level:5,title:"CMS 回收年轻代详细步骤",slug:"cms-回收年轻代详细步骤",normalizedTitle:"cms 回收年轻代详细步骤",charIndex:8055},{level:5,title:"CMS 回收年老代详细步骤",slug:"cms-回收年老代详细步骤",normalizedTitle:"cms 回收年老代详细步骤",charIndex:8468},{level:5,title:"CMS 特点",slug:"cms-特点",normalizedTitle:"cms 特点",charIndex:8805},{level:4,title:"ParNew 收集器",slug:"parnew-收集器",normalizedTitle:"parnew 收集器",charIndex:7552},{level:3,title:"G1 收集器",slug:"g1-收集器",normalizedTitle:"g1 收集器",charIndex:9801},{level:4,title:"分代和分区",slug:"分代和分区",normalizedTitle:"分代和分区",charIndex:10047},{level:4,title:"G1 回收机制",slug:"g1-回收机制",normalizedTitle:"g1 回收机制",charIndex:10478},{level:4,title:"G1 回收年轻代详细步骤",slug:"g1-回收年轻代详细步骤",normalizedTitle:"g1 回收年轻代详细步骤",charIndex:11025},{level:4,title:"G1 回收年老代详细步骤",slug:"g1-回收年老代详细步骤",normalizedTitle:"g1 回收年老代详细步骤",charIndex:12029},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:11859},{level:2,title:"内存分配与回收策略",slug:"内存分配与回收策略",normalizedTitle:"内存分配与回收策略",charIndex:13094},{level:3,title:"Minor GC",slug:"minor-gc",normalizedTitle:"minor gc",charIndex:4325},{level:3,title:"Full GC",slug:"full-gc",normalizedTitle:"full gc",charIndex:9280},{level:4,title:"内存分配策略",slug:"内存分配策略",normalizedTitle:"内存分配策略",charIndex:13759},{level:4,title:"Full GC 的触发条件",slug:"full-gc-的触发条件",normalizedTitle:"full gc 的触发条件",charIndex:14598},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:15563}],headersStr:"对象活着吗 引用计数算法 可达性分析算法 引用类型 强引用 软引用 弱引用 虚引用 方法区的回收 finalize() 垃圾收集算法 垃圾收集性能 标记 - 清除（Mark-Sweep） 标记 - 整理（Mark-Compact） 复制（Copying） 分代收集 新生代 老年代 永久代 JVM 参数 垃圾收集器 串行收集器 Serial 收集器 Serial Old 收集器 并行收集器 Parallel Scavenge 收集器 Parallel Old 收集器 并发标记清除收集器 CMS 收集器 CMS 回收机制 CMS 回收年轻代详细步骤 CMS 回收年老代详细步骤 CMS 特点 ParNew 收集器 G1 收集器 分代和分区 G1 回收机制 G1 回收年轻代详细步骤 G1 回收年老代详细步骤 总结 内存分配与回收策略 Minor GC Full GC 内存分配策略 Full GC 的触发条件 参考资料",content:"# JVM 垃圾收集\n\n> 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 Java 堆和方法区进行。\n\n\n# 对象活着吗\n\n\n# 引用计数算法\n\n给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。\n\n两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。\n\npublic class ReferenceCountingGC {\n    public Object instance = null;\n\n    public static void main(String[] args) {\n        ReferenceCountingGC objectA = new ReferenceCountingGC();\n        ReferenceCountingGC objectB = new ReferenceCountingGC();\n        objectA.instance = objectB;\n        objectB.instance = objectA;\n    }\n}\n\n\n因为循环引用的存在，所以 Java 虚拟机不适用引用计数算法。\n\n\n# 可达性分析算法\n\n通过 GC Roots 作为起始点进行搜索，JVM 将能够到达到的对象视为存活，不可达的对象视为死亡。\n\n可达性分析算法\n\n可作为 GC Roots 的对象包括下面几种：\n\n * 虚拟机栈中引用的对象\n * 本地方法栈中引用的对象（Native 方法）\n * 方法区中，类静态属性引用的对象\n * 方法区中，常量引用的对象\n\n\n# 引用类型\n\n无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否可被回收都与引用有关。\n\nJava 具有四种强度不同的引用类型。\n\n# 强引用\n\n被强引用（Strong Reference）关联的对象不会被垃圾收集器回收。\n\n强引用：使用 new 一个新对象的方式来创建强引用。\n\nObject obj = new Object();\n\n\n# 软引用\n\n被软引用（Soft Reference）关联的对象，只有在内存不够的情况下才会被回收。\n\n软引用：使用 SoftReference 类来创建软引用。\n\nObject obj = new Object();\nSoftReference<Object> sf = new SoftReference<Object>(obj);\nobj = null; // 使对象只被软引用关联\n\n\n# 弱引用\n\n被弱引用（Weak Reference）关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。\n\n使用 WeakReference 类来实现弱引用。\n\nObject obj = new Object();\nWeakReference<Object> wf = new WeakReference<Object>(obj);\nobj = null;\n\n\nWeakHashMap 的 Entry 继承自 WeakReference，主要用来实现缓存。\n\nprivate static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V>\n\n\nTomcat 中的 ConcurrentCache 就使用了 WeakHashMap 来实现缓存功能。ConcurrentCache 采取的是分代缓存，经常使用的对象放入 eden 中，而不常用的对象放入 longterm。eden 使用 ConcurrentHashMap 实现，longterm 使用 WeakHashMap，保证了不常使用的对象容易被回收。\n\npublic final class ConcurrentCache<K, V> {\n\n    private final int size;\n\n    private final Map<K, V> eden;\n\n    private final Map<K, V> longterm;\n\n    public ConcurrentCache(int size) {\n        this.size = size;\n        this.eden = new ConcurrentHashMap<>(size);\n        this.longterm = new WeakHashMap<>(size);\n    }\n\n    public V get(K k) {\n        V v = this.eden.get(k);\n        if (v == null) {\n            v = this.longterm.get(k);\n            if (v != null)\n                this.eden.put(k, v);\n        }\n        return v;\n    }\n\n    public void put(K k, V v) {\n        if (this.eden.size() >= size) {\n            this.longterm.putAll(this.eden);\n            this.eden.clear();\n        }\n        this.eden.put(k, v);\n    }\n}\n\n\n# 虚引用\n\n又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。\n\n为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。\n\n使用 PhantomReference 来实现虚引用。\n\nObject obj = new Object();\nPhantomReference<Object> pf = new PhantomReference<Object>(obj);\nobj = null;\n\n\n\n# 方法区的回收\n\n因为方法区主要存放永久代对象，而永久代对象的回收率比年轻代差很多，因此在方法区上进行回收性价比不高。\n\n主要是对常量池的回收和对类的卸载。\n\n类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：\n\n * 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n * 加载该类的 ClassLoader 已经被回收。\n * 该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。\n\n可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。\n\n在大量使用反射、动态代理、CGLib 等字节码框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。\n\n\n# finalize()\n\nfinalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用 finalize()。\n\n当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。\n\n\n# 垃圾收集算法\n\n\n# 垃圾收集性能\n\n垃圾收集器的性能指标主要有两点：\n\n * 停顿时间 - 停顿时间是因为 GC 而导致程序不能工作的时间长度。\n * 吞吐量 - 吞吐量关注在特定的时间周期内一个应用的工作量的最大值。对关注吞吐量的应用来说长暂停时间是可以接受的。由于高吞吐量的应用关注的基准在更长周期时间上，所以快速响应时间不在考虑之内。\n\n\n# 标记 - 清除（Mark-Sweep）\n\n\n\n将需要回收的对象进行标记，然后清理掉被标记的对象。\n\n不足：\n\n * 标记和清除过程效率都不高；\n * 会产生大量不连续的内存碎片，导致无法给大对象分配内存。\n\n\n# 标记 - 整理（Mark-Compact）\n\n\n\n让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。\n\n\n# 复制（Copying）\n\n\n\n将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。\n\n主要不足是只使用了内存的一半。\n\n现在的商业虚拟机都采用这种收集算法来回收年轻代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1（可以通过参数 -XX:SurvivorRatio 来调整比例），保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。\n\n\n# 分代收集\n\n现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。\n\n一般将 Java 堆分为年轻代和老年代。\n\n * 年轻代使用：复制 算法\n * 老年代使用：标记 - 清理 或者 标记 - 整理 算法\n\n\n\n# 新生代\n\n新生代是大部分对象创建和销毁的区域，在通常的 Java 应用中，绝大部分对象生命周期都是很短暂的。其内部又分为 Eden 区域，作为对象初始分配的区域；两个 Survivor，有时候也叫 from、to 区域，被用来放置从 Minor GC 中保留下来的对象。\n\nJVM 会随意选取一个 Survivor 区域作为 to，然后会在 GC 过程中进行区域间拷贝，也就是将 Eden 中存活下来的对象和 from 区域的对象，拷贝到这个to区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。\n\nJava 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。\n\n# 老年代\n\n放置长生命周期的对象，通常都是从 Survivor 区域拷贝过来的对象。当然，也有特殊情况，如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。\n\n# 永久代\n\n这部分就是早期 Hotspot JVM 的方法区实现方式了，储存 Java 类元数据、常量池、Intern 字符串缓存。在 JDK 8 之后就不存在永久代这块儿了。\n\n# JVM 参数\n\n这里顺便提一下，JVM 允许对堆空间大小、各代空间大小进行设置，以调整 JVM GC。\n\n配置                  描述\n-Xss                虚拟机栈大小。\n-Xms                堆空间初始值。\n-Xmx                堆空间最大值。\n-Xmn                新生代空间大小。\n-XX:NewSize         新生代空间初始值。\n-XX:MaxNewSize      新生代空间最大值。\n-XX:NewRatio        新生代与年老代的比例。默认为 2，意味着老年代是新生代的 2 倍。\n-XX:SurvivorRatio   新生代中调整 eden 区与 survivor 区的比例，默认为 8。即 eden 区为 80% 的大小，两个\n                    survivor 分别为 10% 的大小。\n-XX:PermSize        永久代空间的初始值。\n-XX:MaxPermSize     永久代空间的最大值。\n\n\n# 垃圾收集器\n\n\n\n以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。\n\n注：G1 垃圾收集器既可以回收年轻代内存，也可以回收老年代内存。而其他垃圾收集器只能针对特定代的内存进行回收。\n\n\n# 串行收集器\n\n串行收集器（Serial）是最基本、发展历史最悠久的收集器。\n\n串行收集器是 client 模式下的默认收集器配置。因为在客户端模式下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的年轻代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。\n\n串行收集器采用单线程 stop-the-world 的方式进行收集。当内存不足时，串行 GC 设置停顿标识，待所有线程都进入安全点（Safepoint）时，应用线程暂停，串行 GC 开始工作，采用单线程方式回收空间并整理内存。\n\nSerial / Serial Old 收集器运行示意图\n\n单线程意味着复杂度更低、占用内存更少，垃圾回收效率高；但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核 CPU 的场合。\n\n# Serial 收集器\n\n> 开启选项：-XX:+UseSerialGC\n> \n> 打开此开关后，使用 Serial + Serial Old 收集器组合来进行内存回收。\n\n# Serial Old 收集器\n\nSerial Old 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途：\n\n * 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。\n * 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。\n\n\n# 并行收集器\n\n> 开启选项：-XX:+UseParallelGC\n> \n> 打开此开关后，使用 Parallel Scavenge + Serial Old 收集器组合来进行内存回收。\n> \n> 开启选项：-XX:+UseParallelOldGC\n> \n> 打开此开关后，使用 Parallel Scavenge + Parallel Old 收集器组合来进行内存回收。\n\n其他收集器都是以关注停顿时间为目标，而并行收集器是以关注吞吐量（Throughput）为目标的垃圾收集器。\n\n * 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；\n * 而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\n\n吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)\n\n\n并行收集器是 server 模式下的默认收集器。\n\n并行收集器与串行收集器工作模式相似，都是 stop-the-world 方式，只是暂停时并行地进行垃圾收集。并行收集器年轻代采用复制算法，老年代采用标记-整理，在回收的同时还会对内存进行压缩。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。\n\n在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 收集器 + Parallel Old 收集器。\n\nParallel / Parallel Old 收集器运行示意图\n\n# Parallel Scavenge 收集器\n\nParallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是：\n\n * -XX:MaxGCPauseMillis - 控制最大垃圾收集停顿时间，收集器将尽可能保证内存回收时间不超过设定值。\n * -XX:GCTimeRatio - 直接设置吞吐量大小的（值为大于 0 且小于 100 的整数）。\n\n缩短停顿时间是以牺牲吞吐量和年轻代空间来换取的：年轻代空间变小，垃圾回收变得频繁，导致吞吐量下降。\n\nParallel Scavenge 收集器还提供了一个参数 -XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定年轻代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。\n\n# Parallel Old 收集器\n\n是 Parallel Scavenge 收集器的老年代版本，使用多线程和 “标记-整理” 算法。\n\n\n# 并发标记清除收集器\n\n> 开启选项：-XX:+UseConcMarkSweepGC\n> \n> 打开此开关后，使用 CMS + ParNew + Serial Old 收集器组合来进行内存回收。\n\n并发标记清除收集器是以获取最短停顿时间为目标。\n\n开启后，年轻代使用 ParNew 收集器；老年代使用 CMS 收集器，如果 CMS 产生的碎片过多，导致无法存放浮动垃圾，JVM 会出现 Concurrent Mode Failure ，此时使用 Serial Old 收集器来替代 CMS 收集器清理碎片。\n\n# CMS 收集器\n\nCMS 收集器是一种以获取最短停顿时间为目标的收集器。\n\nCMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。\n\n# CMS 回收机制\n\nCMS 收集器运行步骤如下：\n\n 1. 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。\n 2. 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。\n 3. 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。\n 4. 并发清除：回收在标记阶段被鉴定为不可达的对象。不需要停顿。\n\n在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。\n\nCMS 收集器运行示意图\n\n# CMS 回收年轻代详细步骤\n\n（1）堆空间被分割为三块空间\n\n年轻代分割成一个 Eden 区和两个 Survivor 区。年老代一个连续的空间。就地完成对象收集。除非有 FullGC 否则不会压缩。\n\n（2）CMS 年轻代垃圾收集如何工作\n\n年轻代被标为浅绿色，年老代被标记为蓝色。如果你的应用已经运行了一段时间，CMS 的堆看起来应该是这个样子。对象分散在年老代区域里。\n\n\n\n使用 CMS，年老代对象就地释放。它们不会被来回移动。这个空间不会被压缩除非发生 FullGC。\n\n（3）年轻代收集\n\n从 Eden 和 Survivor 区复制活跃对象到另一个 Survivor 区。所有达到他们的年龄阈值的对象会晋升到年老代。\n\n（4）年轻代回收之后\n\n一次年轻代垃圾收集之后，Eden 区和其中一个 Survivor 区被清空。\n\n最近晋升的对象以深蓝色显示在上图中，绿色的对象是年轻代幸免的还没有晋升到老年代对象。\n\n# CMS 回收年老代详细步骤\n\n（1）CMS 的年老代收集\n\n发生两次 stop the world 事件：初始标记和重新标记。当年老代达到特定的占用比例时，CMS 开始执行。\n\n\n\n * 初始标记是一个短暂暂停的、可达对象被标记的阶段。\n * 并发标记寻找活跃对象在应用连续执行时。\n * 最后，在重新标记阶段，寻找在之前并发标记阶段中丢失的对象。\n\n（2）年老代收集-并发清除\n\n在之前阶段没有被标记的对象会被就地释放。不进行压缩操作。\n\n**注意：**未被标记的对象等于死亡对象\n\n（3）年老代收集-清除之后\n\n清除阶段之后，你可以看到大量内存被释放。你还可以注意到没有进行压缩操作。\n\n最后，CMS 收集器会再次进入重新设置阶段，等待下一次垃圾收集时机的到来。\n\n# CMS 特点\n\nCMS 收集器具有以下缺点：\n\n * 并发收集 - 并发指的是用户线程和 GC 线程同时运行。\n * 吞吐量低 - 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。\n * 无法处理浮动垃圾 - 可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。\n   * 可以使用 -XX:CMSInitiatingOccupancyFraction 来改变触发 CMS 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 收集器来替代 CMS 收集器。\n * 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。\n   * 可以使用 -XX:+UseCMSCompactAtFullCollection ，用于在 CMS 收集器要进行 Full GC 时开启内存碎片的合并整理，内存整理的过程是无法并发的，空间碎片问题没有了，但是停顿时间不得不变长了。\n   * 可以使用 -XX:CMSFullGCsBeforeCompaction ，用于设置执行多少次不压缩的 Full GC 后，来一次带压缩的（默认为 0，表示每次进入 Full GC 时都要进行碎片整理）。\n\n# ParNew 收集器\n\n> 开启选项：-XX:+UseParNewGC\n\nParNew 收集器其实是 Serial 收集器的多线程版本。\n\nParNew 收集器运行示意图\n\n是 Server 模式下的虚拟机首选年轻代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。\n\nParNew 收集器也是使用 -XX:+UseConcMarkSweepGC 后的默认年轻代收集器。\n\nParNew 收集器默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。\n\n\n# G1 收集器\n\n> 开启选项：-XX:+UseG1GC\n\n前面提到的垃圾收集器一般策略是关注吞吐量或停顿时间。而 G1 是一种兼顾吞吐量和停顿时间的 GC 收集器。G1 是 Oracle JDK9 以后的默认 GC 收集器。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。\n\nG1 最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至 CMS 的众多缺陷。\n\n# 分代和分区\n\n旧的垃圾收集器一般采取分代收集，Java 堆被分为年轻代、老年代和永久代。收集的范围都是整个年轻代或者整个老年代。\n\nG1 取消了永久代，并把年轻代和老年代划分成多个大小相等的独立区域（Region），年轻代和老年代不再物理隔离。G1 可以直接对年轻代和老年代一起回收。\n\n\n\n通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。\n\n每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。\n\n# G1 回收机制\n\nG1 收集器运行示意图\n\n如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：\n\n 1. 初始标记\n 2. 并发标记\n 3. 最终标记 - 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。\n 4. 筛选回收 - 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。\n\n具备如下特点：\n\n * 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。\n * 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。\n\n# G1 回收年轻代详细步骤\n\n（1）G1 初始堆空间\n\n堆空间是一个被分成许多固定大小区域的内存块。\n\nJava 虚拟机启动时选定区域大小。Java 虚拟机通常会指定 2000 个左右的大小相等、每个大小范围在 1 到 32M 的区域。\n\n（2）G1 堆空间分配\n\n实际上，这些区域被映射成 Eden、Survivor、年老代空间的逻辑表述形式。\n\n图片中的颜色表明了哪个区域被关联上什么角色。活跃对象从一个区域疏散（复制、移动）到另一个区域。区域被设计为并行的方式收集，可以暂停或者不暂停所有的其它用户线程。\n\n明显的区域可以被分配成 Eden、Survivor、Old 区域。另外，有第四种类型的区域叫做极大区域(Humongous regions)。这些区域被设计成保持标准区域大小的 50%或者更大的对象。它们被保存在一个连续的区域集合里。最后，最后一个类型的区域就是堆空间里没有使用的区域。\n\n**注意：**写作此文章时，收集极大对象时还没有被优化。因此，你应该避免创建这个大小的对象。\n\n（3）G1 的年轻代\n\n堆空间被分割成大约 2000 个区域。最小 1M，最大 32M，蓝色区域保持年老代对象，绿色区域保持年轻代对象。\n\n**注意：**区域没有必要像旧的收集器一样是保持连续的。\n\n（4）G1 的年轻代收集\n\n活跃对象会被疏散（复制、移动）到一个或多个 survivor 区域。如果达到晋升总阈值，对象会晋升到年老代区域。\n\n这是一个 stop the world 暂停。为下一次年轻代垃圾回收计算 Eden 和 Survivor 的大小。保留审计信息有助于计算大小。类似目标暂停时间的事情会被考虑在内。\n\n这个方法使重调区域大小变得很容易，按需把它们调大或调小。\n\n（5）G1 年轻代回收的尾声\n\n活跃对象被疏散到 Survivor 或者年老代区域。\n\n最近晋升的对象显示为深蓝色。Survivor 区域显示为绿色。\n\n关于 G1 的年轻代回收做以下总结：\n\n * 堆空间是一块单独的内存空间被分割成多个区域。\n * 年轻代内存是由一组非连续的区域组成。这使得需要重调大小变得容易。\n * 年轻代垃圾回收是 stop the world 事件，所有应用线程都会因此操作暂停。\n * 年轻代垃圾收集使用多线程并行回收。\n * 活跃对象被复制到新的 Survivor 区或者年老代区域。\n\n# G1 回收年老代详细步骤\n\n（1）初始标记阶段\n\n年轻代垃圾收集肩负着活跃对象初始标记的任务。在日志文件中被标为GC pause (young)(inital-mark)\n\n（2）并发标记阶段\n\n如果发现空区域(“X”标示的)，在重新标记阶段它们会被马上清除掉。当然，决定活性的审计信息也在此时被计算。\n\n（3）重新标记阶段\n\n空的区域被清除和回收掉。所有区域的活性在此时计算。\n\n（4）复制/清理阶段\n\nG1 选择活性最低的区域，这些区域能够以最快的速度回收。然后这些区域会在年轻代垃圾回收过程中被回收。在日志中被指示为*[GC pause (mixed)]*。所以年轻代和年老代在同一时间被回收。\n\n（5）复制/清理阶段之后\n\n被选择的区域已经被回收和压缩到图中显示的深蓝色区和深绿色区中。\n\n\n\n\n# 总结\n\n收集器                 串行/并行/并发   年轻代/老年代     收集算法           目标       适用场景\nSerial              串行         年轻代         复制             响应速度优先   单 CPU 环境下的 Client 模式\nSerial Old          串行         老年代         标记-整理          响应速度优先   单 CPU 环境下的 Client 模式、CMS 的后备预案\nParNew              串行 + 并行    年轻代         复制算法           响应速度优先   多 CPU 环境时在 Server 模式下与 CMS 配合\nParallel Scavenge   串行 + 并行    年轻代         复制算法           吞吐量优先    在后台运算而不需要太多交互的任务\nParallel Old        串行 + 并行    老年代         标记-整理          吞吐量优先    在后台运算而不需要太多交互的任务\nCMS                 并行 + 并发    老年代         标记-清除          响应速度优先   集中在互联网站或 B/S 系统服务端上的 Java 应用\nG1                  并行 + 并发    年轻代 + 老年代   标记-整理 + 复制算法   响应速度优先   面向服务端应用，将来替换 CMS\n\n\n# 内存分配与回收策略\n\n对象的内存分配，也就是在堆上分配。主要分配在年轻代的 Eden 区上，少数情况下也可能直接分配在老年代中。\n\n\n# Minor GC\n\n当 Eden 区空间不足时，触发 Minor GC。\n\nMinor GC 发生在年轻代上，因为年轻代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。\n\nMinor GC 工作流程：\n\n 1. Java 应用不断创建对象，通常都是分配在 Eden 区域，当其空间不足时（达到设定的阈值），触发 minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象（黄色方块）则被回收。\n\n 2. 经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件。这时候，另外一个 Survivor 区域则会成为 To 区域，Eden 区域的存活对象和 From 区域对象，都会被复制到 To 区域，并且存活的年龄计数会被加 1。\n\n 3. 类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过 -XX:MaxTenuringThreshold 参数指定。\n\n\n# Full GC\n\nFull GC 发生在老年代上，老年代对象和年轻代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。\n\n# 内存分配策略\n\n（一）对象优先在 Eden 分配\n\n大多数情况下，对象在年轻代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。\n\n（二）大对象直接进入老年代\n\n大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。\n\n经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。\n\n-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。\n\n（三）长期存活的对象进入老年代\n\n为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。\n\n-XX:MaxTenuringThreshold 用来定义年龄的阈值。\n\n（四）动态对象年龄判定\n\n虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。\n\n（五）空间分配担保\n\n在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于年轻代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。\n\n# Full GC 的触发条件\n\n对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：\n\n（1）调用 System.gc()\n\n此方法的调用是建议虚拟机进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 -XX:DisableExplicitGC 来禁止 RMI 调用 System.gc()。\n\n（2）老年代空间不足\n\n老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 java.lang.OutOfMemoryError: Java heap space。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在年轻代多存活一段时间以及不要创建过大的对象及数组。\n\n（3）方法区空间不足\n\nJVM 规范中运行时数据区域中的方法区，在 HotSpot 虚拟机中又被习惯称为永久代，永久代中存放的是类的描述信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出 java.lang.OutOfMemoryError: PermGen space 错误。为避免永久代占满造成 Full GC 现象，可采用的方法为增大 Perm Gen 空间或转为使用 CMS GC。\n\n（4）Minor GC 的平均晋升空间大小大于老年代可用空间\n\n如果发现统计数据说之前 Minor GC 的平均晋升大小比目前老年代剩余的空间大，则不会触发 Minor GC 而是转为触发 Full GC。\n\n（5）对象大小大于 To 区和老年代的可用内存\n\n由 Eden 区、From 区向 To 区复制时，对象大小大于 To 区可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。\n\n\n# 参考资料\n\n * 《深入理解 Java 虚拟机》\n * 从表到里学习 JVM 实现\n * 详解 JVM Garbage First(G1) 垃圾收集器\n * G1 垃圾收集器入门\n * Getting Started with the G1 Garbage Collector",normalizedContent:"# jvm 垃圾收集\n\n> 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 java 堆和方法区进行。\n\n\n# 对象活着吗\n\n\n# 引用计数算法\n\n给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。\n\n两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。\n\npublic class referencecountinggc {\n    public object instance = null;\n\n    public static void main(string[] args) {\n        referencecountinggc objecta = new referencecountinggc();\n        referencecountinggc objectb = new referencecountinggc();\n        objecta.instance = objectb;\n        objectb.instance = objecta;\n    }\n}\n\n\n因为循环引用的存在，所以 java 虚拟机不适用引用计数算法。\n\n\n# 可达性分析算法\n\n通过 gc roots 作为起始点进行搜索，jvm 将能够到达到的对象视为存活，不可达的对象视为死亡。\n\n可达性分析算法\n\n可作为 gc roots 的对象包括下面几种：\n\n * 虚拟机栈中引用的对象\n * 本地方法栈中引用的对象（native 方法）\n * 方法区中，类静态属性引用的对象\n * 方法区中，常量引用的对象\n\n\n# 引用类型\n\n无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否可被回收都与引用有关。\n\njava 具有四种强度不同的引用类型。\n\n# 强引用\n\n被强引用（strong reference）关联的对象不会被垃圾收集器回收。\n\n强引用：使用 new 一个新对象的方式来创建强引用。\n\nobject obj = new object();\n\n\n# 软引用\n\n被软引用（soft reference）关联的对象，只有在内存不够的情况下才会被回收。\n\n软引用：使用 softreference 类来创建软引用。\n\nobject obj = new object();\nsoftreference<object> sf = new softreference<object>(obj);\nobj = null; // 使对象只被软引用关联\n\n\n# 弱引用\n\n被弱引用（weak reference）关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。\n\n使用 weakreference 类来实现弱引用。\n\nobject obj = new object();\nweakreference<object> wf = new weakreference<object>(obj);\nobj = null;\n\n\nweakhashmap 的 entry 继承自 weakreference，主要用来实现缓存。\n\nprivate static class entry<k,v> extends weakreference<object> implements map.entry<k,v>\n\n\ntomcat 中的 concurrentcache 就使用了 weakhashmap 来实现缓存功能。concurrentcache 采取的是分代缓存，经常使用的对象放入 eden 中，而不常用的对象放入 longterm。eden 使用 concurrenthashmap 实现，longterm 使用 weakhashmap，保证了不常使用的对象容易被回收。\n\npublic final class concurrentcache<k, v> {\n\n    private final int size;\n\n    private final map<k, v> eden;\n\n    private final map<k, v> longterm;\n\n    public concurrentcache(int size) {\n        this.size = size;\n        this.eden = new concurrenthashmap<>(size);\n        this.longterm = new weakhashmap<>(size);\n    }\n\n    public v get(k k) {\n        v v = this.eden.get(k);\n        if (v == null) {\n            v = this.longterm.get(k);\n            if (v != null)\n                this.eden.put(k, v);\n        }\n        return v;\n    }\n\n    public void put(k k, v v) {\n        if (this.eden.size() >= size) {\n            this.longterm.putall(this.eden);\n            this.eden.clear();\n        }\n        this.eden.put(k, v);\n    }\n}\n\n\n# 虚引用\n\n又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。\n\n为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。\n\n使用 phantomreference 来实现虚引用。\n\nobject obj = new object();\nphantomreference<object> pf = new phantomreference<object>(obj);\nobj = null;\n\n\n\n# 方法区的回收\n\n因为方法区主要存放永久代对象，而永久代对象的回收率比年轻代差很多，因此在方法区上进行回收性价比不高。\n\n主要是对常量池的回收和对类的卸载。\n\n类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：\n\n * 该类所有的实例都已经被回收，也就是 java 堆中不存在该类的任何实例。\n * 加载该类的 classloader 已经被回收。\n * 该类对应的 java.lang.class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。\n\n可以通过 -xnoclassgc 参数来控制是否对类进行卸载。\n\n在大量使用反射、动态代理、cglib 等字节码框架、动态生成 jsp 以及 osgi 这类频繁自定义 classloader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。\n\n\n# finalize()\n\nfinalize() 类似 c++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用 finalize()。\n\n当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。\n\n\n# 垃圾收集算法\n\n\n# 垃圾收集性能\n\n垃圾收集器的性能指标主要有两点：\n\n * 停顿时间 - 停顿时间是因为 gc 而导致程序不能工作的时间长度。\n * 吞吐量 - 吞吐量关注在特定的时间周期内一个应用的工作量的最大值。对关注吞吐量的应用来说长暂停时间是可以接受的。由于高吞吐量的应用关注的基准在更长周期时间上，所以快速响应时间不在考虑之内。\n\n\n# 标记 - 清除（mark-sweep）\n\n\n\n将需要回收的对象进行标记，然后清理掉被标记的对象。\n\n不足：\n\n * 标记和清除过程效率都不高；\n * 会产生大量不连续的内存碎片，导致无法给大对象分配内存。\n\n\n# 标记 - 整理（mark-compact）\n\n\n\n让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。\n\n\n# 复制（copying）\n\n\n\n将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。\n\n主要不足是只使用了内存的一半。\n\n现在的商业虚拟机都采用这种收集算法来回收年轻代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 eden 空间和两块较小的 survior 空间，每次使用 eden 空间和其中一块 survivor。在回收时，将 eden 和 survivor 中还存活着的对象一次性复制到另一块 survivor 空间上，最后清理 eden 和使用过的那一块 survivor。hotspot 虚拟机的 eden 和 survivor 的大小比例默认为 8:1（可以通过参数 -xx:survivorratio 来调整比例），保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。\n\n\n# 分代收集\n\n现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。\n\n一般将 java 堆分为年轻代和老年代。\n\n * 年轻代使用：复制 算法\n * 老年代使用：标记 - 清理 或者 标记 - 整理 算法\n\n\n\n# 新生代\n\n新生代是大部分对象创建和销毁的区域，在通常的 java 应用中，绝大部分对象生命周期都是很短暂的。其内部又分为 eden 区域，作为对象初始分配的区域；两个 survivor，有时候也叫 from、to 区域，被用来放置从 minor gc 中保留下来的对象。\n\njvm 会随意选取一个 survivor 区域作为 to，然后会在 gc 过程中进行区域间拷贝，也就是将 eden 中存活下来的对象和 from 区域的对象，拷贝到这个to区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。\n\njava 虚拟机会记录 survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -xx:+maxtenuringthreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个 survivor 区已经被占用了 50%（对应虚拟机参数 -xx:targetsurvivorratio），那么较高复制次数的对象也会被晋升至老年代。\n\n# 老年代\n\n放置长生命周期的对象，通常都是从 survivor 区域拷贝过来的对象。当然，也有特殊情况，如果对象较大，jvm 会试图直接分配在 eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，jvm 就会直接分配到老年代。\n\n# 永久代\n\n这部分就是早期 hotspot jvm 的方法区实现方式了，储存 java 类元数据、常量池、intern 字符串缓存。在 jdk 8 之后就不存在永久代这块儿了。\n\n# jvm 参数\n\n这里顺便提一下，jvm 允许对堆空间大小、各代空间大小进行设置，以调整 jvm gc。\n\n配置                  描述\n-xss                虚拟机栈大小。\n-xms                堆空间初始值。\n-xmx                堆空间最大值。\n-xmn                新生代空间大小。\n-xx:newsize         新生代空间初始值。\n-xx:maxnewsize      新生代空间最大值。\n-xx:newratio        新生代与年老代的比例。默认为 2，意味着老年代是新生代的 2 倍。\n-xx:survivorratio   新生代中调整 eden 区与 survivor 区的比例，默认为 8。即 eden 区为 80% 的大小，两个\n                    survivor 分别为 10% 的大小。\n-xx:permsize        永久代空间的初始值。\n-xx:maxpermsize     永久代空间的最大值。\n\n\n# 垃圾收集器\n\n\n\n以上是 hotspot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。\n\n注：g1 垃圾收集器既可以回收年轻代内存，也可以回收老年代内存。而其他垃圾收集器只能针对特定代的内存进行回收。\n\n\n# 串行收集器\n\n串行收集器（serial）是最基本、发展历史最悠久的收集器。\n\n串行收集器是 client 模式下的默认收集器配置。因为在客户端模式下，分配给虚拟机管理的内存一般来说不会很大。serial 收集器收集几十兆甚至一两百兆的年轻代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。\n\n串行收集器采用单线程 stop-the-world 的方式进行收集。当内存不足时，串行 gc 设置停顿标识，待所有线程都进入安全点（safepoint）时，应用线程暂停，串行 gc 开始工作，采用单线程方式回收空间并整理内存。\n\nserial / serial old 收集器运行示意图\n\n单线程意味着复杂度更低、占用内存更少，垃圾回收效率高；但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核 cpu 的场合。\n\n# serial 收集器\n\n> 开启选项：-xx:+useserialgc\n> \n> 打开此开关后，使用 serial + serial old 收集器组合来进行内存回收。\n\n# serial old 收集器\n\nserial old 是 serial 收集器的老年代版本，也是给 client 模式下的虚拟机使用。如果用在 server 模式下，它有两大用途：\n\n * 在 jdk 1.5 以及之前版本（parallel old 诞生以前）中与 parallel scavenge 收集器搭配使用。\n * 作为 cms 收集器的后备预案，在并发收集发生 concurrent mode failure 时使用。\n\n\n# 并行收集器\n\n> 开启选项：-xx:+useparallelgc\n> \n> 打开此开关后，使用 parallel scavenge + serial old 收集器组合来进行内存回收。\n> \n> 开启选项：-xx:+useparalleloldgc\n> \n> 打开此开关后，使用 parallel scavenge + parallel old 收集器组合来进行内存回收。\n\n其他收集器都是以关注停顿时间为目标，而并行收集器是以关注吞吐量（throughput）为目标的垃圾收集器。\n\n * 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；\n * 而高吞吐量则可以高效率地利用 cpu 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\n\n吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)\n\n\n并行收集器是 server 模式下的默认收集器。\n\n并行收集器与串行收集器工作模式相似，都是 stop-the-world 方式，只是暂停时并行地进行垃圾收集。并行收集器年轻代采用复制算法，老年代采用标记-整理，在回收的同时还会对内存进行压缩。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。\n\n在注重吞吐量以及 cpu 资源敏感的场合，都可以优先考虑 parallel scavenge 收集器 + parallel old 收集器。\n\nparallel / parallel old 收集器运行示意图\n\n# parallel scavenge 收集器\n\nparallel scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是：\n\n * -xx:maxgcpausemillis - 控制最大垃圾收集停顿时间，收集器将尽可能保证内存回收时间不超过设定值。\n * -xx:gctimeratio - 直接设置吞吐量大小的（值为大于 0 且小于 100 的整数）。\n\n缩短停顿时间是以牺牲吞吐量和年轻代空间来换取的：年轻代空间变小，垃圾回收变得频繁，导致吞吐量下降。\n\nparallel scavenge 收集器还提供了一个参数 -xx:+useadaptivesizepolicy，这是一个开关参数，打开参数后，就不需要手工指定年轻代的大小（-xmn）、eden 和 survivor 区的比例（-xx:survivorratio）、晋升老年代对象年龄（-xx:pretenuresizethreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 gc 自适应的调节策略（gc ergonomics）。\n\n# parallel old 收集器\n\n是 parallel scavenge 收集器的老年代版本，使用多线程和 “标记-整理” 算法。\n\n\n# 并发标记清除收集器\n\n> 开启选项：-xx:+useconcmarksweepgc\n> \n> 打开此开关后，使用 cms + parnew + serial old 收集器组合来进行内存回收。\n\n并发标记清除收集器是以获取最短停顿时间为目标。\n\n开启后，年轻代使用 parnew 收集器；老年代使用 cms 收集器，如果 cms 产生的碎片过多，导致无法存放浮动垃圾，jvm 会出现 concurrent mode failure ，此时使用 serial old 收集器来替代 cms 收集器清理碎片。\n\n# cms 收集器\n\ncms 收集器是一种以获取最短停顿时间为目标的收集器。\n\ncms（concurrent mark sweep），mark sweep 指的是标记 - 清除算法。\n\n# cms 回收机制\n\ncms 收集器运行步骤如下：\n\n 1. 初始标记：仅仅只是标记一下 gc roots 能直接关联到的对象，速度很快，需要停顿。\n 2. 并发标记：进行 gc roots tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。\n 3. 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。\n 4. 并发清除：回收在标记阶段被鉴定为不可达的对象。不需要停顿。\n\n在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。\n\ncms 收集器运行示意图\n\n# cms 回收年轻代详细步骤\n\n（1）堆空间被分割为三块空间\n\n年轻代分割成一个 eden 区和两个 survivor 区。年老代一个连续的空间。就地完成对象收集。除非有 fullgc 否则不会压缩。\n\n（2）cms 年轻代垃圾收集如何工作\n\n年轻代被标为浅绿色，年老代被标记为蓝色。如果你的应用已经运行了一段时间，cms 的堆看起来应该是这个样子。对象分散在年老代区域里。\n\n\n\n使用 cms，年老代对象就地释放。它们不会被来回移动。这个空间不会被压缩除非发生 fullgc。\n\n（3）年轻代收集\n\n从 eden 和 survivor 区复制活跃对象到另一个 survivor 区。所有达到他们的年龄阈值的对象会晋升到年老代。\n\n（4）年轻代回收之后\n\n一次年轻代垃圾收集之后，eden 区和其中一个 survivor 区被清空。\n\n最近晋升的对象以深蓝色显示在上图中，绿色的对象是年轻代幸免的还没有晋升到老年代对象。\n\n# cms 回收年老代详细步骤\n\n（1）cms 的年老代收集\n\n发生两次 stop the world 事件：初始标记和重新标记。当年老代达到特定的占用比例时，cms 开始执行。\n\n\n\n * 初始标记是一个短暂暂停的、可达对象被标记的阶段。\n * 并发标记寻找活跃对象在应用连续执行时。\n * 最后，在重新标记阶段，寻找在之前并发标记阶段中丢失的对象。\n\n（2）年老代收集-并发清除\n\n在之前阶段没有被标记的对象会被就地释放。不进行压缩操作。\n\n**注意：**未被标记的对象等于死亡对象\n\n（3）年老代收集-清除之后\n\n清除阶段之后，你可以看到大量内存被释放。你还可以注意到没有进行压缩操作。\n\n最后，cms 收集器会再次进入重新设置阶段，等待下一次垃圾收集时机的到来。\n\n# cms 特点\n\ncms 收集器具有以下缺点：\n\n * 并发收集 - 并发指的是用户线程和 gc 线程同时运行。\n * 吞吐量低 - 低停顿时间是以牺牲吞吐量为代价的，导致 cpu 利用率不够高。\n * 无法处理浮动垃圾 - 可能出现 concurrent mode failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 gc 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 cms 收集不能像其它收集器那样等待老年代快满的时候再回收。\n   * 可以使用 -xx:cmsinitiatingoccupancyfraction 来改变触发 cms 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 concurrent mode failure，这时虚拟机将临时启用 serial old 收集器来替代 cms 收集器。\n * 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 full gc。\n   * 可以使用 -xx:+usecmscompactatfullcollection ，用于在 cms 收集器要进行 full gc 时开启内存碎片的合并整理，内存整理的过程是无法并发的，空间碎片问题没有了，但是停顿时间不得不变长了。\n   * 可以使用 -xx:cmsfullgcsbeforecompaction ，用于设置执行多少次不压缩的 full gc 后，来一次带压缩的（默认为 0，表示每次进入 full gc 时都要进行碎片整理）。\n\n# parnew 收集器\n\n> 开启选项：-xx:+useparnewgc\n\nparnew 收集器其实是 serial 收集器的多线程版本。\n\nparnew 收集器运行示意图\n\n是 server 模式下的虚拟机首选年轻代收集器，除了性能原因外，主要是因为除了 serial 收集器，只有它能与 cms 收集器配合工作。\n\nparnew 收集器也是使用 -xx:+useconcmarksweepgc 后的默认年轻代收集器。\n\nparnew 收集器默认开启的线程数量与 cpu 数量相同，可以使用 -xx:parallelgcthreads 参数来设置线程数。\n\n\n# g1 收集器\n\n> 开启选项：-xx:+useg1gc\n\n前面提到的垃圾收集器一般策略是关注吞吐量或停顿时间。而 g1 是一种兼顾吞吐量和停顿时间的 gc 收集器。g1 是 oracle jdk9 以后的默认 gc 收集器。g1 可以直观的设定停顿时间的目标，相比于 cms gc，g1 未必能做到 cms 在最好情况下的延时停顿，但是最差情况要好很多。\n\ng1 最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至 cms 的众多缺陷。\n\n# 分代和分区\n\n旧的垃圾收集器一般采取分代收集，java 堆被分为年轻代、老年代和永久代。收集的范围都是整个年轻代或者整个老年代。\n\ng1 取消了永久代，并把年轻代和老年代划分成多个大小相等的独立区域（region），年轻代和老年代不再物理隔离。g1 可以直接对年轻代和老年代一起回收。\n\n\n\n通过引入 region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 region。\n\n每个 region 都有一个 remembered set，用来记录该 region 对象的引用对象所在的 region。通过使用 remembered set，在做可达性分析的时候就可以避免全堆扫描。\n\n# g1 回收机制\n\ng1 收集器运行示意图\n\n如果不计算维护 remembered set 的操作，g1 收集器的运作大致可划分为以下几个步骤：\n\n 1. 初始标记\n 2. 并发标记\n 3. 最终标记 - 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 remembered set logs 里面，最终标记阶段需要把 remembered set logs 的数据合并到 remembered set 中。这阶段需要停顿线程，但是可并行执行。\n 4. 筛选回收 - 首先对各个 region 中的回收价值和成本进行排序，根据用户所期望的 gc 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。\n\n具备如下特点：\n\n * 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。\n * 可预测的停顿：能让使用者明确指定在一个长度为 m 毫秒的时间片段内，消耗在 gc 上的时间不得超过 n 毫秒。\n\n# g1 回收年轻代详细步骤\n\n（1）g1 初始堆空间\n\n堆空间是一个被分成许多固定大小区域的内存块。\n\njava 虚拟机启动时选定区域大小。java 虚拟机通常会指定 2000 个左右的大小相等、每个大小范围在 1 到 32m 的区域。\n\n（2）g1 堆空间分配\n\n实际上，这些区域被映射成 eden、survivor、年老代空间的逻辑表述形式。\n\n图片中的颜色表明了哪个区域被关联上什么角色。活跃对象从一个区域疏散（复制、移动）到另一个区域。区域被设计为并行的方式收集，可以暂停或者不暂停所有的其它用户线程。\n\n明显的区域可以被分配成 eden、survivor、old 区域。另外，有第四种类型的区域叫做极大区域(humongous regions)。这些区域被设计成保持标准区域大小的 50%或者更大的对象。它们被保存在一个连续的区域集合里。最后，最后一个类型的区域就是堆空间里没有使用的区域。\n\n**注意：**写作此文章时，收集极大对象时还没有被优化。因此，你应该避免创建这个大小的对象。\n\n（3）g1 的年轻代\n\n堆空间被分割成大约 2000 个区域。最小 1m，最大 32m，蓝色区域保持年老代对象，绿色区域保持年轻代对象。\n\n**注意：**区域没有必要像旧的收集器一样是保持连续的。\n\n（4）g1 的年轻代收集\n\n活跃对象会被疏散（复制、移动）到一个或多个 survivor 区域。如果达到晋升总阈值，对象会晋升到年老代区域。\n\n这是一个 stop the world 暂停。为下一次年轻代垃圾回收计算 eden 和 survivor 的大小。保留审计信息有助于计算大小。类似目标暂停时间的事情会被考虑在内。\n\n这个方法使重调区域大小变得很容易，按需把它们调大或调小。\n\n（5）g1 年轻代回收的尾声\n\n活跃对象被疏散到 survivor 或者年老代区域。\n\n最近晋升的对象显示为深蓝色。survivor 区域显示为绿色。\n\n关于 g1 的年轻代回收做以下总结：\n\n * 堆空间是一块单独的内存空间被分割成多个区域。\n * 年轻代内存是由一组非连续的区域组成。这使得需要重调大小变得容易。\n * 年轻代垃圾回收是 stop the world 事件，所有应用线程都会因此操作暂停。\n * 年轻代垃圾收集使用多线程并行回收。\n * 活跃对象被复制到新的 survivor 区或者年老代区域。\n\n# g1 回收年老代详细步骤\n\n（1）初始标记阶段\n\n年轻代垃圾收集肩负着活跃对象初始标记的任务。在日志文件中被标为gc pause (young)(inital-mark)\n\n（2）并发标记阶段\n\n如果发现空区域(“x”标示的)，在重新标记阶段它们会被马上清除掉。当然，决定活性的审计信息也在此时被计算。\n\n（3）重新标记阶段\n\n空的区域被清除和回收掉。所有区域的活性在此时计算。\n\n（4）复制/清理阶段\n\ng1 选择活性最低的区域，这些区域能够以最快的速度回收。然后这些区域会在年轻代垃圾回收过程中被回收。在日志中被指示为*[gc pause (mixed)]*。所以年轻代和年老代在同一时间被回收。\n\n（5）复制/清理阶段之后\n\n被选择的区域已经被回收和压缩到图中显示的深蓝色区和深绿色区中。\n\n\n\n\n# 总结\n\n收集器                 串行/并行/并发   年轻代/老年代     收集算法           目标       适用场景\nserial              串行         年轻代         复制             响应速度优先   单 cpu 环境下的 client 模式\nserial old          串行         老年代         标记-整理          响应速度优先   单 cpu 环境下的 client 模式、cms 的后备预案\nparnew              串行 + 并行    年轻代         复制算法           响应速度优先   多 cpu 环境时在 server 模式下与 cms 配合\nparallel scavenge   串行 + 并行    年轻代         复制算法           吞吐量优先    在后台运算而不需要太多交互的任务\nparallel old        串行 + 并行    老年代         标记-整理          吞吐量优先    在后台运算而不需要太多交互的任务\ncms                 并行 + 并发    老年代         标记-清除          响应速度优先   集中在互联网站或 b/s 系统服务端上的 java 应用\ng1                  并行 + 并发    年轻代 + 老年代   标记-整理 + 复制算法   响应速度优先   面向服务端应用，将来替换 cms\n\n\n# 内存分配与回收策略\n\n对象的内存分配，也就是在堆上分配。主要分配在年轻代的 eden 区上，少数情况下也可能直接分配在老年代中。\n\n\n# minor gc\n\n当 eden 区空间不足时，触发 minor gc。\n\nminor gc 发生在年轻代上，因为年轻代对象存活时间很短，因此 minor gc 会频繁执行，执行的速度一般也会比较快。\n\nminor gc 工作流程：\n\n 1. java 应用不断创建对象，通常都是分配在 eden 区域，当其空间不足时（达到设定的阈值），触发 minor gc。仍然被引用的对象（绿色方块）存活下来，被复制到 jvm 选择的 survivor 区域，而没有被引用的对象（黄色方块）则被回收。\n\n 2. 经过一次 minor gc，eden 就会空闲下来，直到再次达到 minor gc 触发条件。这时候，另外一个 survivor 区域则会成为 to 区域，eden 区域的存活对象和 from 区域对象，都会被复制到 to 区域，并且存活的年龄计数会被加 1。\n\n 3. 类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过 -xx:maxtenuringthreshold 参数指定。\n\n\n# full gc\n\nfull gc 发生在老年代上，老年代对象和年轻代的相反，其存活时间长，因此 full gc 很少执行，而且执行速度会比 minor gc 慢很多。\n\n# 内存分配策略\n\n（一）对象优先在 eden 分配\n\n大多数情况下，对象在年轻代 eden 区分配，当 eden 区空间不够时，发起 minor gc。\n\n（二）大对象直接进入老年代\n\n大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。\n\n经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。\n\n-xx:pretenuresizethreshold，大于此值的对象直接在老年代分配，避免在 eden 区和 survivor 区之间的大量内存复制。\n\n（三）长期存活的对象进入老年代\n\n为对象定义年龄计数器，对象在 eden 出生并经过 minor gc 依然存活，将移动到 survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。\n\n-xx:maxtenuringthreshold 用来定义年龄的阈值。\n\n（四）动态对象年龄判定\n\n虚拟机并不是永远地要求对象的年龄必须达到 maxtenuringthreshold 才能晋升老年代，如果在 survivor 区中相同年龄所有对象大小的总和大于 survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 maxtenuringthreshold 中要求的年龄。\n\n（五）空间分配担保\n\n在发生 minor gc 之前，虚拟机先检查老年代最大可用的连续空间是否大于年轻代所有对象总空间，如果条件成立的话，那么 minor gc 可以确认是安全的；如果不成立的话虚拟机会查看 handlepromotionfailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 minor gc，尽管这次 minor gc 是有风险的；如果小于，或者 handlepromotionfailure 设置不允许冒险，那这时也要改为进行一次 full gc。\n\n# full gc 的触发条件\n\n对于 minor gc，其触发条件非常简单，当 eden 区空间满时，就将触发一次 minor gc。而 full gc 则相对复杂，有以下条件：\n\n（1）调用 system.gc()\n\n此方法的调用是建议虚拟机进行 full gc，虽然只是建议而非一定，但很多情况下它会触发 full gc，从而增加 full gc 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 -xx:disableexplicitgc 来禁止 rmi 调用 system.gc()。\n\n（2）老年代空间不足\n\n老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 full gc 后空间仍然不足，则抛出 java.lang.outofmemoryerror: java heap space。为避免以上原因引起的 full gc，调优时应尽量做到让对象在 minor gc 阶段被回收、让对象在年轻代多存活一段时间以及不要创建过大的对象及数组。\n\n（3）方法区空间不足\n\njvm 规范中运行时数据区域中的方法区，在 hotspot 虚拟机中又被习惯称为永久代，永久代中存放的是类的描述信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 cms gc 的情况下也会执行 full gc。如果经过 full gc 仍然回收不了，那么 jvm 会抛出 java.lang.outofmemoryerror: permgen space 错误。为避免永久代占满造成 full gc 现象，可采用的方法为增大 perm gen 空间或转为使用 cms gc。\n\n（4）minor gc 的平均晋升空间大小大于老年代可用空间\n\n如果发现统计数据说之前 minor gc 的平均晋升大小比目前老年代剩余的空间大，则不会触发 minor gc 而是转为触发 full gc。\n\n（5）对象大小大于 to 区和老年代的可用内存\n\n由 eden 区、from 区向 to 区复制时，对象大小大于 to 区可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。\n\n\n# 参考资料\n\n * 《深入理解 java 虚拟机》\n * 从表到里学习 jvm 实现\n * 详解 jvm garbage first(g1) 垃圾收集器\n * g1 垃圾收集器入门\n * getting started with the g1 garbage collector",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"JVM 字节码",frontmatter:{title:"JVM 字节码",categories:["编程","Java","JavaSE","JVM"],tags:["Java","JavaSE","JVM","字节码"],abbrlink:"bce3e186",date:"2019-10-28T22:04:39.000Z",permalink:"/pages/f37148/"},regularPath:"/06.JVM/04.JVM%E5%AD%97%E8%8A%82%E7%A0%81.html",relativePath:"06.JVM/04.JVM字节码.md",key:"v-15000fa6",path:"/pages/f37148/",headers:[{level:2,title:"字节码",slug:"字节码",normalizedTitle:"字节码",charIndex:6},{level:3,title:"什么是字节码",slug:"什么是字节码",normalizedTitle:"什么是字节码",charIndex:214},{level:3,title:"字节码结构",slug:"字节码结构",normalizedTitle:"字节码结构",charIndex:659},{level:3,title:"字节码操作集合",slug:"字节码操作集合",normalizedTitle:"字节码操作集合",charIndex:3509},{level:3,title:"操作数栈和字节码",slug:"操作数栈和字节码",normalizedTitle:"操作数栈和字节码",charIndex:3778},{level:3,title:"字节码工具",slug:"字节码工具",normalizedTitle:"字节码工具",charIndex:4154},{level:2,title:"字节码增强",slug:"字节码增强",normalizedTitle:"字节码增强",charIndex:424},{level:3,title:"Asm",slug:"asm",normalizedTitle:"asm",charIndex:4331},{level:4,title:"核心 API",slug:"核心-api",normalizedTitle:"核心 api",charIndex:4507},{level:4,title:"树形 API",slug:"树形-api",normalizedTitle:"树形 api",charIndex:4515},{level:3,title:"Javassist",slug:"javassist",normalizedTitle:"javassist",charIndex:5102},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5580}],headersStr:"字节码 什么是字节码 字节码结构 字节码操作集合 操作数栈和字节码 字节码工具 字节码增强 Asm 核心 API 树形 API Javassist 参考资料",content:'# JVM 字节码\n\nJava 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。\n\n.class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项严格按照顺序紧凑地排列在 .class 文件中，中间没有添加任何分隔符。整个 .class 文件本质上就是一张表。\n\n\n# 字节码\n\n\n# 什么是字节码\n\n之所以被称之为字节码，是因为字节码文件由十六进制值组成，而 JVM 以两个十六进制值为一组，即以字节为单位进行读取。在 Java 中一般是用 javac 命令编译源代码为字节码文件，一个.java 文件从编译到运行的示例如下图所示。\n\n\n\n对于开发人员，了解字节码可以更准确、直观地理解 Java 语言中更深层次的东西，比如通过字节码，可以很直观地看到 Volatile 关键字如何在字节码上生效。另外，字节码增强技术在 Spring AOP、各种 ORM 框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益。除此之外，由于 JVM 规范的存在，只要最终可以生成符合规范的字节码就可以在 JVM 上运行，因此这就给了各种运行在 JVM 上的语言（如 Scala、Groovy、Kotlin）一种契机，可以扩展 Java 所没有的特性或者实现各种语法糖。理解字节码后再学习这些语言，可以“逆流而上”，从字节码视角看它的设计思路，学习起来也“易如反掌”。\n\n\n# 字节码结构\n\n.java 文件通过 javac 编译后将得到一个.class 文件，比如编写一个简单的 ByteCodeDemo 类，如下图 2 的左侧部分：\n\n\n\n编译后生成 ByteCodeDemo.class 文件，打开后是一堆十六进制数，按字节为单位进行分割后展示如图 2 右侧部分所示。上文提及过，JVM 对于字节码是有规范要求的，那么看似杂乱的十六进制符合什么结构呢？JVM 规范要求每一个字节码文件都要由十部分按照固定的顺序组成，整体结构如图 3 所示。接下来我们将一一介绍这十部分：\n\n\n\n（1）魔数（Magic Number）\n\n每个 .class 文件的头 4 个字节称为 魔数（magic number），它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 .class 文件。魔数的固定值为：0xCAFEBABE。\n\n> 有趣的是，魔数的固定值是 Java 之父 James Gosling 制定的，为 CafeBabe（咖啡宝贝），而 Java 的图标为一杯咖啡。\n\n（2）版本号（Version）\n\n版本号为魔数之后的 4 个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）。\n\n举例来说，如果版本号为：“00 00 00 34”。那么，次版本号转化为十进制为 0，主版本号转化为十进制为 52，在 Oracle 官网中查询序号 52 对应的主版本号为 1.8，所以编译该文件的 Java 版本号为 1.8.0。\n\n（3）常量池（Constant Pool）\n\n紧接着主版本号之后的字节为常量池入口。\n\n常量池主要存放两类常量：\n\n * 字面量 - 如文本字符串、声明为 final 的常量值。\n * 符号引用\n   * 类和接口的全限定名\n   * 字段的名称和描述符\n   * 方法的名称和描述符\n\n常量池整体上分为两部分：常量池计数器以及常量池数据区，如下图 4 所示。\n\n\n\n * 常量池计数器（constant_pool_count） - 由于常量的数量不固定，所以需要先放置两个字节来表示常量池容量计数值。图 2 中示例代码的字节码前 10 个字节如下图 5 所示，将十六进制的 24 转化为十进制值为 36，排除掉下标“0”，也就是说，这个类文件中共有 35 个常量。\n\n\n\n * 常量池数据区 - 数据区是由（constant_pool_count-1）个 cp_info 结构组成，一个 cp_info 结构对应一个常量。在字节码中共有 14 种类型的 cp_info（如下图 6 所示），每种类型的结构都是固定的。\n\n\n\n具体以 CONSTANT_utf8_info 为例，它的结构如下图 7 左侧所示。首先一个字节“tag”，它的值取自上图 6 中对应项的 Tag，由于它的类型是 utf8_info，所以值为“01”。接下来两个字节标识该字符串的长度 Length，然后 Length 个字节为这个字符串具体的值。从图 2 中的字节码摘取一个 cp_info 结构，如下图 7 右侧所示。将它翻译过来后，其含义为：该常量类型为 utf8 字符串，长度为一字节，数据为“a”。\n\n\n\n其他类型的 cp_info 结构在本文不再赘述，整体结构大同小异，都是先通过 Tag 来标识类型，然后后续 n 个字节来描述长度和（或）数据。先知其所以然，以后可以通过 javap -verbose ByteCodeDemo 命令，查看 JVM 反编译后的完整常量池，如下图 8 所示。可以看到反编译结果将每一个 cp_info 结构的类型和值都很明确地呈现了出来。\n\n\n\n（4）访问标志\n\n紧接着的 2 个字节代表访问标志，这个标志用于识别一些类或者接口的访问信息，描述该 Class 是类还是接口，以及是否被 public、abstract、final 等修饰符修饰。\n\nJVM 规范规定了如下图 9 的访问标志（Access_Flag）。需要注意的是，JVM 并没有穷举所有的访问标志，而是使用按位或操作来进行描述的，比如某个类的修饰符为 Public Final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 0x0001 | 0x0010=0x0011。\n\n（5）当前类名\n\n访问标志后的 2 个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。\n\n（6）父类名称\n\n当前类名后的 2 个字节，描述父类的全限定名，同上，保存的也是常量池中的索引值。\n\n（7）接口信息\n\n父类名称后为 2 字节的接口计数器，描述了该类或父类实现的接口数量。紧接着的 n 个字节是所有接口名称的字符串常量的索引值。\n\n（8）字段表\n\n字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量。字段表也分为两部分，第一部分为两个字节，描述字段个数；第二部分是每个字段的详细信息 fields_info。字段表结构如下图所示：\n\n\n\n以图 2 中字节码的字段表为例，如下图 11 所示。其中字段的访问标志查图 9，0002 对应为 Private。通过索引下标在图 8 中常量池分别得到字段名为“a”，描述符为“I”（代表 int）。综上，就可以唯一确定出一个类中声明的变量 private int a。\n\n\n\n（9）方法表\n\n字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数；第二部分为每个方法的详细信息。方法的详细信息较为复杂，包括方法的访问标志、方法名、方法的描述符以及方法的属性，如下图所示：\n\n\n\n方法的权限修饰符依然可以通过图 9 的值查询得到，方法名和方法的描述符都是常量池中的索引值，可以通过索引值在常量池中找到。而“方法的属性”这一部分较为复杂，直接借助 javap -verbose 将其反编译为人可以读懂的信息进行解读，如图 13 所示。可以看到属性中包括以下三个部分：\n\n * “Code 区”：源代码对应的 JVM 指令操作码，在进行字节码增强时重点操作的就是“Code 区”这一部分。\n * “LineNumberTable”：行号表，将 Code 区的操作码和源代码中的行号对应，Debug 时会起到作用（源代码走一行，需要走多少个 JVM 指令操作码）。\n * “LocalVariableTable”：本地变量表，包含 This 和局部变量，之所以可以在每一个方法内部都可以调用 This，是因为 JVM 将 This 作为每一个方法的第一个参数隐式进行传入。当然，这是针对非 Static 方法而言。\n\n\n\n（10）附加属性表\n\n字节码的最后一部分，该项存放了在该文件中类或接口所定义属性的基本信息。\n\n\n# 字节码操作集合\n\n在上图 13 中，Code 区的红色编号 0 ～ 17，就是.java 中的方法源代码编译后让 JVM 真正执行的操作码。为了帮助人们理解，反编译后看到的是十六进制操作码所对应的助记符，十六进制值操作码与助记符的对应关系，以及每一个操作码的用处可以查看 Oracle 官方文档进行了解，在需要用到时进行查阅即可。比如上图中第一个助记符为 iconst_2，对应到图 2 中的字节码为 0x05，用处是将 int 值 2 压入操作数栈中。以此类推，对 0~17 的助记符理解后，就是完整的 add()方法的实现。\n\n\n# 操作数栈和字节码\n\nJVM 的指令集是基于栈而不是寄存器，基于栈可以具备很好的跨平台性（因为寄存器指令集往往和硬件挂钩），但缺点在于，要完成同样的操作，基于栈的实现需要更多指令才能完成（因为栈只是一个 FILO 结构，需要频繁压栈出栈）。另外，由于栈是在内存实现的，而寄存器是在 CPU 的高速缓存区，相较而言，基于栈的速度要慢很多，这也是为了跨平台性而做出的牺牲。\n\n我们在上文所说的操作码或者操作集合，其实控制的就是这个 JVM 的操作数栈。为了更直观地感受操作码是如何控制操作数栈的，以及理解常量池、变量表的作用，将 add()方法的对操作数栈的操作制作为 GIF，如下图 14 所示，图中仅截取了常量池中被引用的部分，以指令 iconst_2 开始到 ireturn 结束，与图 13 中 Code 区 0~17 的指令一一对应：\n\n\n\n\n# 字节码工具\n\n如果每次查看反编译后的字节码都使用 javap 命令的话，好非常繁琐。这里推荐一个 Idea 插件：jclasslib。使用效果如图 15 所示，代码编译后在菜单栏"View"中选择"Show Bytecode With jclasslib"，可以很直观地看到当前字节码文件的类信息、常量池、方法区等信息。\n\n\n\n\n# 字节码增强\n\n\n# Asm\n\n对于需要手动操纵字节码的需求，可以使用 Asm，它可以直接生产 .class字节码文件，也可以在类被加载入 JVM 之前动态修改类行为（如下图 17 所示）。\n\nAsm 的应用场景有 AOP（Cglib 就是基于 Asm）、热部署、修改其他 jar 包中的类等。当然，涉及到如此底层的步骤，实现起来也比较麻烦。\n\n\n\nAsm 有两类 API：核心 API 和树形 API\n\n# 核心 API\n\nAsm Core API 可以类比解析 XML 文件中的 SAX 方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用 Core API。在 Core API 中有以下几个关键类：\n\n * ClassReader：用于读取已经编译好的.class 文件。\n * ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。\n * 各种 Visitor 类：如上所述，CoreAPI 根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的 Visitor，比如用于访问方法的 MethodVisitor、用于访问类变量的 FieldVisitor、用于访问注解的 AnnotationVisitor 等。为了实现 AOP，重点要使用的是 MethodVisitor。\n\n# 树形 API\n\nAsm Tree API 可以类比解析 XML 文件中的 DOM 方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。TreeApi 不同于 CoreAPI，TreeAPI 通过各种 Node 类来映射字节码的各个区域，类比 DOM 节点，就可以很好地理解这种编程方式。\n\n\n# Javassist\n\n利用 Javassist 实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。\n\n其中最重要的是 ClassPool、CtClass、CtMethod、CtField 这四个类：\n\n * CtClass（compile-time class） - 编译时类信息，它是一个 class 文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个 CtClass 对象，用来表示这个类文件。\n * ClassPool - 从开发视角来看，ClassPool 是一张保存 CtClass 信息的 HashTable，key 为类名，value 为类名对应的 CtClass 对象。当我们需要对某个类进行修改时，就是通过 pool.getCtClass("className")方法从 pool 中获取到相应的 CtClass。\n * CtMethod、CtField - 这两个比较好理解，对应的是类中的方法和属性。\n\n\n# 参考资料\n\n * 《深入理解 Java 虚拟机》\n * 一文让你明白 Java 字节码\n * Java 字节码增强探秘\n * Asm 4.0 官方文档\n * Javassist Github',normalizedContent:'# jvm 字节码\n\njava 之所以可以“一次编译，到处运行”，一是因为 jvm 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class 文件）供 jvm 使用。\n\n.class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项严格按照顺序紧凑地排列在 .class 文件中，中间没有添加任何分隔符。整个 .class 文件本质上就是一张表。\n\n\n# 字节码\n\n\n# 什么是字节码\n\n之所以被称之为字节码，是因为字节码文件由十六进制值组成，而 jvm 以两个十六进制值为一组，即以字节为单位进行读取。在 java 中一般是用 javac 命令编译源代码为字节码文件，一个.java 文件从编译到运行的示例如下图所示。\n\n\n\n对于开发人员，了解字节码可以更准确、直观地理解 java 语言中更深层次的东西，比如通过字节码，可以很直观地看到 volatile 关键字如何在字节码上生效。另外，字节码增强技术在 spring aop、各种 orm 框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益。除此之外，由于 jvm 规范的存在，只要最终可以生成符合规范的字节码就可以在 jvm 上运行，因此这就给了各种运行在 jvm 上的语言（如 scala、groovy、kotlin）一种契机，可以扩展 java 所没有的特性或者实现各种语法糖。理解字节码后再学习这些语言，可以“逆流而上”，从字节码视角看它的设计思路，学习起来也“易如反掌”。\n\n\n# 字节码结构\n\n.java 文件通过 javac 编译后将得到一个.class 文件，比如编写一个简单的 bytecodedemo 类，如下图 2 的左侧部分：\n\n\n\n编译后生成 bytecodedemo.class 文件，打开后是一堆十六进制数，按字节为单位进行分割后展示如图 2 右侧部分所示。上文提及过，jvm 对于字节码是有规范要求的，那么看似杂乱的十六进制符合什么结构呢？jvm 规范要求每一个字节码文件都要由十部分按照固定的顺序组成，整体结构如图 3 所示。接下来我们将一一介绍这十部分：\n\n\n\n（1）魔数（magic number）\n\n每个 .class 文件的头 4 个字节称为 魔数（magic number），它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 .class 文件。魔数的固定值为：0xcafebabe。\n\n> 有趣的是，魔数的固定值是 java 之父 james gosling 制定的，为 cafebabe（咖啡宝贝），而 java 的图标为一杯咖啡。\n\n（2）版本号（version）\n\n版本号为魔数之后的 4 个字节，前两个字节表示次版本号（minor version），后两个字节表示主版本号（major version）。\n\n举例来说，如果版本号为：“00 00 00 34”。那么，次版本号转化为十进制为 0，主版本号转化为十进制为 52，在 oracle 官网中查询序号 52 对应的主版本号为 1.8，所以编译该文件的 java 版本号为 1.8.0。\n\n（3）常量池（constant pool）\n\n紧接着主版本号之后的字节为常量池入口。\n\n常量池主要存放两类常量：\n\n * 字面量 - 如文本字符串、声明为 final 的常量值。\n * 符号引用\n   * 类和接口的全限定名\n   * 字段的名称和描述符\n   * 方法的名称和描述符\n\n常量池整体上分为两部分：常量池计数器以及常量池数据区，如下图 4 所示。\n\n\n\n * 常量池计数器（constant_pool_count） - 由于常量的数量不固定，所以需要先放置两个字节来表示常量池容量计数值。图 2 中示例代码的字节码前 10 个字节如下图 5 所示，将十六进制的 24 转化为十进制值为 36，排除掉下标“0”，也就是说，这个类文件中共有 35 个常量。\n\n\n\n * 常量池数据区 - 数据区是由（constant_pool_count-1）个 cp_info 结构组成，一个 cp_info 结构对应一个常量。在字节码中共有 14 种类型的 cp_info（如下图 6 所示），每种类型的结构都是固定的。\n\n\n\n具体以 constant_utf8_info 为例，它的结构如下图 7 左侧所示。首先一个字节“tag”，它的值取自上图 6 中对应项的 tag，由于它的类型是 utf8_info，所以值为“01”。接下来两个字节标识该字符串的长度 length，然后 length 个字节为这个字符串具体的值。从图 2 中的字节码摘取一个 cp_info 结构，如下图 7 右侧所示。将它翻译过来后，其含义为：该常量类型为 utf8 字符串，长度为一字节，数据为“a”。\n\n\n\n其他类型的 cp_info 结构在本文不再赘述，整体结构大同小异，都是先通过 tag 来标识类型，然后后续 n 个字节来描述长度和（或）数据。先知其所以然，以后可以通过 javap -verbose bytecodedemo 命令，查看 jvm 反编译后的完整常量池，如下图 8 所示。可以看到反编译结果将每一个 cp_info 结构的类型和值都很明确地呈现了出来。\n\n\n\n（4）访问标志\n\n紧接着的 2 个字节代表访问标志，这个标志用于识别一些类或者接口的访问信息，描述该 class 是类还是接口，以及是否被 public、abstract、final 等修饰符修饰。\n\njvm 规范规定了如下图 9 的访问标志（access_flag）。需要注意的是，jvm 并没有穷举所有的访问标志，而是使用按位或操作来进行描述的，比如某个类的修饰符为 public final，则对应的访问修饰符的值为 acc_public | acc_final，即 0x0001 | 0x0010=0x0011。\n\n（5）当前类名\n\n访问标志后的 2 个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。\n\n（6）父类名称\n\n当前类名后的 2 个字节，描述父类的全限定名，同上，保存的也是常量池中的索引值。\n\n（7）接口信息\n\n父类名称后为 2 字节的接口计数器，描述了该类或父类实现的接口数量。紧接着的 n 个字节是所有接口名称的字符串常量的索引值。\n\n（8）字段表\n\n字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量。字段表也分为两部分，第一部分为两个字节，描述字段个数；第二部分是每个字段的详细信息 fields_info。字段表结构如下图所示：\n\n\n\n以图 2 中字节码的字段表为例，如下图 11 所示。其中字段的访问标志查图 9，0002 对应为 private。通过索引下标在图 8 中常量池分别得到字段名为“a”，描述符为“i”（代表 int）。综上，就可以唯一确定出一个类中声明的变量 private int a。\n\n\n\n（9）方法表\n\n字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数；第二部分为每个方法的详细信息。方法的详细信息较为复杂，包括方法的访问标志、方法名、方法的描述符以及方法的属性，如下图所示：\n\n\n\n方法的权限修饰符依然可以通过图 9 的值查询得到，方法名和方法的描述符都是常量池中的索引值，可以通过索引值在常量池中找到。而“方法的属性”这一部分较为复杂，直接借助 javap -verbose 将其反编译为人可以读懂的信息进行解读，如图 13 所示。可以看到属性中包括以下三个部分：\n\n * “code 区”：源代码对应的 jvm 指令操作码，在进行字节码增强时重点操作的就是“code 区”这一部分。\n * “linenumbertable”：行号表，将 code 区的操作码和源代码中的行号对应，debug 时会起到作用（源代码走一行，需要走多少个 jvm 指令操作码）。\n * “localvariabletable”：本地变量表，包含 this 和局部变量，之所以可以在每一个方法内部都可以调用 this，是因为 jvm 将 this 作为每一个方法的第一个参数隐式进行传入。当然，这是针对非 static 方法而言。\n\n\n\n（10）附加属性表\n\n字节码的最后一部分，该项存放了在该文件中类或接口所定义属性的基本信息。\n\n\n# 字节码操作集合\n\n在上图 13 中，code 区的红色编号 0 ～ 17，就是.java 中的方法源代码编译后让 jvm 真正执行的操作码。为了帮助人们理解，反编译后看到的是十六进制操作码所对应的助记符，十六进制值操作码与助记符的对应关系，以及每一个操作码的用处可以查看 oracle 官方文档进行了解，在需要用到时进行查阅即可。比如上图中第一个助记符为 iconst_2，对应到图 2 中的字节码为 0x05，用处是将 int 值 2 压入操作数栈中。以此类推，对 0~17 的助记符理解后，就是完整的 add()方法的实现。\n\n\n# 操作数栈和字节码\n\njvm 的指令集是基于栈而不是寄存器，基于栈可以具备很好的跨平台性（因为寄存器指令集往往和硬件挂钩），但缺点在于，要完成同样的操作，基于栈的实现需要更多指令才能完成（因为栈只是一个 filo 结构，需要频繁压栈出栈）。另外，由于栈是在内存实现的，而寄存器是在 cpu 的高速缓存区，相较而言，基于栈的速度要慢很多，这也是为了跨平台性而做出的牺牲。\n\n我们在上文所说的操作码或者操作集合，其实控制的就是这个 jvm 的操作数栈。为了更直观地感受操作码是如何控制操作数栈的，以及理解常量池、变量表的作用，将 add()方法的对操作数栈的操作制作为 gif，如下图 14 所示，图中仅截取了常量池中被引用的部分，以指令 iconst_2 开始到 ireturn 结束，与图 13 中 code 区 0~17 的指令一一对应：\n\n\n\n\n# 字节码工具\n\n如果每次查看反编译后的字节码都使用 javap 命令的话，好非常繁琐。这里推荐一个 idea 插件：jclasslib。使用效果如图 15 所示，代码编译后在菜单栏"view"中选择"show bytecode with jclasslib"，可以很直观地看到当前字节码文件的类信息、常量池、方法区等信息。\n\n\n\n\n# 字节码增强\n\n\n# asm\n\n对于需要手动操纵字节码的需求，可以使用 asm，它可以直接生产 .class字节码文件，也可以在类被加载入 jvm 之前动态修改类行为（如下图 17 所示）。\n\nasm 的应用场景有 aop（cglib 就是基于 asm）、热部署、修改其他 jar 包中的类等。当然，涉及到如此底层的步骤，实现起来也比较麻烦。\n\n\n\nasm 有两类 api：核心 api 和树形 api\n\n# 核心 api\n\nasm core api 可以类比解析 xml 文件中的 sax 方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用 core api。在 core api 中有以下几个关键类：\n\n * classreader：用于读取已经编译好的.class 文件。\n * classwriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。\n * 各种 visitor 类：如上所述，coreapi 根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的 visitor，比如用于访问方法的 methodvisitor、用于访问类变量的 fieldvisitor、用于访问注解的 annotationvisitor 等。为了实现 aop，重点要使用的是 methodvisitor。\n\n# 树形 api\n\nasm tree api 可以类比解析 xml 文件中的 dom 方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。treeapi 不同于 coreapi，treeapi 通过各种 node 类来映射字节码的各个区域，类比 dom 节点，就可以很好地理解这种编程方式。\n\n\n# javassist\n\n利用 javassist 实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。\n\n其中最重要的是 classpool、ctclass、ctmethod、ctfield 这四个类：\n\n * ctclass（compile-time class） - 编译时类信息，它是一个 class 文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个 ctclass 对象，用来表示这个类文件。\n * classpool - 从开发视角来看，classpool 是一张保存 ctclass 信息的 hashtable，key 为类名，value 为类名对应的 ctclass 对象。当我们需要对某个类进行修改时，就是通过 pool.getctclass("classname")方法从 pool 中获取到相应的 ctclass。\n * ctmethod、ctfield - 这两个比较好理解，对应的是类中的方法和属性。\n\n\n# 参考资料\n\n * 《深入理解 java 虚拟机》\n * 一文让你明白 java 字节码\n * java 字节码增强探秘\n * asm 4.0 官方文档\n * javassist github',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"JVM 类加载",frontmatter:{title:"JVM 类加载",categories:["编程","Java","JavaSE","JVM"],tags:["Java","JavaSE","JVM"],abbrlink:"dce69d41",date:"2020-06-17T15:06:46.000Z",permalink:"/pages/4aea87/"},regularPath:"/06.JVM/05.JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD.html",relativePath:"06.JVM/05.JVM类加载.md",key:"v-9f9ce560",path:"/pages/4aea87/",headers:[{level:2,title:"类加载机制",slug:"类加载机制",normalizedTitle:"类加载机制",charIndex:16},{level:2,title:"类的生命周期",slug:"类的生命周期",normalizedTitle:"类的生命周期",charIndex:376},{level:3,title:"（一）加载",slug:"一-加载",normalizedTitle:"（一）加载",charIndex:689},{level:3,title:"（二）验证",slug:"二-验证",normalizedTitle:"（二）验证",charIndex:1234},{level:3,title:"（三）准备",slug:"三-准备",normalizedTitle:"（三）准备",charIndex:1641},{level:3,title:"（四）解析",slug:"四-解析",normalizedTitle:"（四）解析",charIndex:2980},{level:3,title:"（五）初始化",slug:"五-初始化",normalizedTitle:"（五）初始化",charIndex:3430},{level:4,title:"类初始化方式",slug:"类初始化方式",normalizedTitle:"类初始化方式",charIndex:3733},{level:4,title:"类初始化步骤",slug:"类初始化步骤",normalizedTitle:"类初始化步骤",charIndex:3844},{level:4,title:"类初始化时机",slug:"类初始化时机",normalizedTitle:"类初始化时机",charIndex:3939},{level:4,title:"类初始化细节",slug:"类初始化细节",normalizedTitle:"类初始化细节",charIndex:4613},{level:2,title:"ClassLoader",slug:"classloader",normalizedTitle:"classloader",charIndex:1214},{level:3,title:"类与类加载器",slug:"类与类加载器",normalizedTitle:"类与类加载器",charIndex:6040},{level:3,title:"类加载器分类",slug:"类加载器分类",normalizedTitle:"类加载器分类",charIndex:6243},{level:4,title:"Bootstrap ClassLoader",slug:"bootstrap-classloader",normalizedTitle:"bootstrap classloader",charIndex:6255},{level:4,title:"ExtClassLoader",slug:"extclassloader",normalizedTitle:"extclassloader",charIndex:6602},{level:4,title:"AppClassLoader",slug:"appclassloader",normalizedTitle:"appclassloader",charIndex:6803},{level:4,title:"自定义类加载器",slug:"自定义类加载器",normalizedTitle:"自定义类加载器",charIndex:6555},{level:3,title:"双亲委派",slug:"双亲委派",normalizedTitle:"双亲委派",charIndex:7421},{level:3,title:"ClassLoader 参数",slug:"classloader-参数",normalizedTitle:"classloader 参数",charIndex:11773},{level:2,title:"类的加载",slug:"类的加载",normalizedTitle:"类的加载",charIndex:40},{level:3,title:"类加载方式",slug:"类加载方式",normalizedTitle:"类加载方式",charIndex:12473},{level:3,title:"加载类错误",slug:"加载类错误",normalizedTitle:"加载类错误",charIndex:12914},{level:4,title:"ClassNotFoundException",slug:"classnotfoundexception",normalizedTitle:"classnotfoundexception",charIndex:7945},{level:4,title:"NoClassDefFoundError",slug:"noclassdeffounderror",normalizedTitle:"noclassdeffounderror",charIndex:13479},{level:4,title:"UnsatisfiedLinkError",slug:"unsatisfiedlinkerror",normalizedTitle:"unsatisfiedlinkerror",charIndex:13632},{level:4,title:"ClassCastException",slug:"classcastexception",normalizedTitle:"classcastexception",charIndex:14375},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:14987}],headersStr:"类加载机制 类的生命周期 （一）加载 （二）验证 （三）准备 （四）解析 （五）初始化 类初始化方式 类初始化步骤 类初始化时机 类初始化细节 ClassLoader 类与类加载器 类加载器分类 Bootstrap ClassLoader ExtClassLoader AppClassLoader 自定义类加载器 双亲委派 ClassLoader 参数 类的加载 类加载方式 加载类错误 ClassNotFoundException NoClassDefFoundError UnsatisfiedLinkError ClassCastException 参考资料",content:'# JVM 类加载\n\n\n\n\n# 类加载机制\n\n> 类是在运行期间动态加载的。\n\n类的加载指的是将类的 .class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了访问方法区内的数据结构的接口。\n\n类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class 文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError 错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误\n\n\n# 类的生命周期\n\n\n\nJava 类的完整生命周期包括以下几个阶段：\n\n * 加载（Loading）\n * 链接（Linking）\n   * 验证（Verification）\n   * 准备（Preparation）\n   * 解析（Resolution）\n * 初始化（Initialization）\n * 使用（Using）\n * 卸载（Unloading）\n\n加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。而解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。\n\n类加载过程是指加载、验证、准备、解析和初始化这 5 个阶段。\n\n\n# （一）加载\n\n加载是类加载的一个阶段，注意不要混淆。\n\n加载，是指查找字节流，并且据此创建类的过程。\n\n加载过程完成以下三件事：\n\n * 通过一个类的全限定名来获取定义此类的二进制字节流。\n * 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。\n * 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。\n\n其中二进制字节流可以从以下方式中获取：\n\n * 从 ZIP 包读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。\n * 从网络中获取，这种场景最典型的应用是 Applet。\n * 运行时计算生成，这种场景使用得最多得就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。\n * 由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。\n * 从数据库读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。 ...\n\n> 更详细内容会在 3. ClassLoader 介绍。\n\n\n# （二）验证\n\n验证是链接阶段的第一步。验证的目标是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。\n\n验证阶段大致会完成 4 个阶段的检验动作：\n\n * 文件格式验证 - 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。\n * 元数据验证 - 对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。\n * 字节码验证 - 通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。\n * 符号引用验证 - 发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。\n\n验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。\n\n\n# （三）准备\n\n类变量是被 static 修饰的变量，准备阶段为 static 变量在方法区分配内存并初始化为默认值，使用的是方法区的内存。\n\n实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。（实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次）\n\n初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。\n\npublic static int value = 123;\n\n\n如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。\n\npublic static final int value = 123;\n\n\n准备阶段有以下几点需要注意：\n\n * 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。\n * 这里所设置的初始值通常情况下是数据类型默认的零值（如 0、0L、null、false 等），而不是被在 Java 代码中被显式地赋予的值。\n\n假设一个类变量的定义为：public static int value = 3；\n\n那么变量 value 在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的public static指令是在程序编译后，存放于类构造器（）方法之中的，所以把 value 赋值为 3 的动作将在初始化阶段才会执行。\n\n> 这里还需要注意如下几点：\n> \n>  * 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。\n>  * 对于同时被 static 和 final 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。\n>  * 对于引用数据类型 reference 来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即 null。\n>  * 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。\n\n * 如果类字段的字段属性表中存在ConstantValue属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。\n\n假设上面的类变量 value 被定义为： public static final int value = 3；\n\n编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据ConstantValue的设置将 value 赋值为 3。我们可以理解为 static final 常量在编译期就将其结果放入了调用它的类的常量池中\n\n\n# （四）解析\n\n在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。\n\n举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。\n\n解析阶段目标是将常量池的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。\n\n * 符号引用（Symbolic References） - 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。\n * 直接引用（Direct Reference） - 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。\n\n\n# （五）初始化\n\n在 Java 代码中，如果要初始化一个静态字段，可以在声明时直接赋值，也可以在静态代码块中对其赋值。\n\n如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 < clinit >。\n\n初始化阶段才真正开始执行类中的定义的 Java 程序代码。初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。\n\n# 类初始化方式\n\n * 声明类变量时指定初始值\n * 使用静态代码块为类变量指定初始值\n\n> 在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。\n\n# 类初始化步骤\n\n 1. 如果类还没有被加载和链接，开始加载该类。\n 2. 如果该类的直接父类还没有被初始化，先初始化其父类。\n 3. 如果该类有初始化语句，则依次执行这些初始化语句。\n\n# 类初始化时机\n\n只有主动引用类的时候才会导致类的初始化。\n\n（1）主动引用\n\n类的主动引用包括以下六种：\n\n * 创建类的实例 - 也就是 new 对象\n * 访问静态变量 - 访问某个类或接口的静态变量，或者对该静态变量赋值\n * 访问静态方法\n * 反射 - 如Class.forName(“com.shengsiyuan.Test”)\n * 初始化子类 - 初始化某个类的子类，则其父类也会被初始化\n * 启动类 - Java 虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类\n\n（2）被动引用\n\n以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：\n\n * 通过子类引用父类的静态字段，不会导致子类初始化。\n\nSystem.out.println(SubClass.value); // value 字段在 SuperClass 中定义\n\n\n * 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。\n\nSuperClass[] sca = new SuperClass[10];\n\n\n * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。\n\nSystem.out.println(ConstClass.HELLOWORLD);\n\n\n# 类初始化细节\n\n类初始化 <clinit>() 方法的细节：\n\n * 是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：\n\npublic class Test {\n    static {\n        i = 0;                // 给变量赋值可以正常编译通过\n        System.out.print(i);  // 这句编译器会提示“非法向前引用”\n    }\n    static int i = 1;\n}\n\n\n * 与类的构造函数（或者说实例构造器 <init>()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 <clinit>() 方法运行之前，父类的 <clinit>() 方法已经执行结束。因此虚拟机中第一个执行 <clinit>() 方法的类肯定为 java.lang.Object。\n * 由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码：\n\nstatic class Parent {\n    public static int A = 1;\n    static {\n        A = 2;\n    }\n}\n\nstatic class Sub extends Parent {\n    public static int B = A;\n}\n\npublic static void main(String[] args) {\n     System.out.println(Sub.B);  // 输出结果是父类中的静态变量 A 的值，也就是 2。\n}\n\n\n * <clinit>() 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 <clinit>() 方法。\n * 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。\n * 虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。\n\n\n# ClassLoader\n\nClassLoader 即类加载器，负责将类加载到 JVM。在 Java 虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。\n\nJVM 加载 class 文件到内存有两种方式：\n\n * 隐式加载 - JVM 自动加载需要的类到内存中。\n * 显示加载 - 通过使用 ClassLoader 来加载一个类到内存中。\n\n\n# 类与类加载器\n\n如何判断两个类是否相等：类本身相等，并且使用同一个类加载器进行加载。这是因为每一个 ClassLoader 都拥有一个独立的类名称空间。\n\n这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。\n\n\n# 类加载器分类\n\n\n\n# Bootstrap ClassLoader\n\nBootstrap ClassLoader ，即启动类加载器 ，负责加载 JVM 自身工作所需要的类。\n\nBootstrap ClassLoader 会将存放在 <JAVA_HOME>\\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。\n\nBootstrap ClassLoader 是由 C++ 实现的，它完全由 JVM 自己控制的，启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。\n\n# ExtClassLoader\n\nExtClassLoader，即扩展类加载器，这个类加载器是由 ExtClassLoader(sun.misc.Launcher\\$ExtClassLoader)实现的。\n\nExtClassLoader 负责将 <JAVA_HOME>\\lib\\ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。\n\n# AppClassLoader\n\nAppClassLoader，即应用程序类加载器，这个类加载器是由 AppClassLoader(sun.misc.Launcher\\$AppClassLoader) 实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。\n\nAppClassLoader 负责加载用户类路径（即 classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n# 自定义类加载器\n\n自定义类加载器可以做到如下几点：\n\n * 在执行非置信代码之前，自动验证数字签名。\n * 动态地创建符合用户特定需要的定制化构建类。\n * 从特定的场所取得 java class，例如数据库中和网络中。\n\n假设，我们需要自定义一个名为 FileSystemClassLoader 的类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。\n\njava.lang.ClassLoader 类的方法 loadClass() 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去覆写它，而是通过覆写 findClass() 方法。\n\nClassLoader 常用的场景：\n\n * 容器 - 典型应用：Servlet 容器（如：Tomcat、Jetty）、udf （Mysql、Hive）等。加载解压 jar 包或 war 包后，加载其 Class 到指定的类加载器中运行（通常需要考虑空间隔离）。\n * 热部署、热插拔 - 应用启动后，动态获得某个类信息，然后加载到 JVM 中工作。很多著名的容器软件、框架（如：Spring 等），都使用 ClassLoader 来实现自身的热部署。\n\n【示例】自定义一个类加载器\n\npublic class FileSystemClassLoader extends ClassLoader {\n\n    private String rootDir;\n\n    public FileSystemClassLoader(String rootDir) {\n        this.rootDir = rootDir;\n    }\n\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        byte[] classData = getClassData(name);\n        if (classData == null) {\n            throw new ClassNotFoundException();\n        } else {\n            return defineClass(name, classData, 0, classData.length);\n        }\n    }\n\n    private byte[] getClassData(String className) {\n        String path = classNameToPath(className);\n        try {\n            InputStream ins = new FileInputStream(path);\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int bufferSize = 4096;\n            byte[] buffer = new byte[bufferSize];\n            int bytesNumRead;\n            while ((bytesNumRead = ins.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesNumRead);\n            }\n            return baos.toByteArray();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private String classNameToPath(String className) {\n        return rootDir + File.separatorChar\n                + className.replace(\'.\', File.separatorChar) + ".class";\n    }\n}\n\n\n\n# 双亲委派\n\n理解双亲委派之前，先让我们看一个示例。\n\n【示例】寻找类加载示例\n\npublic static void main(String[] args) {\n    ClassLoader loader = Thread.currentThread().getContextClassLoader();\n    System.out.println(loader);\n    System.out.println(loader.getParent());\n    System.out.println(loader.getParent().getParent());\n}\n\n\n输出：\n\nsun.misc.Launcher$AppClassLoader@18b4aac2\nsun.misc.Launcher$ExtClassLoader@19e1023e\nnull\n\n\n从上面的结果可以看出，并没有获取到 ExtClassLoader 的父 Loader，原因是 Bootstrap Loader（引导类加载器）是用 C 语言实现的，找不到一个确定的返回父 Loader 的方式，于是就返回 null。\n\n下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的 Bootstrap ClassLoader 外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。\n\n\n\n（1）工作过程\n\n一个类加载器首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时才尝试加载。\n\n（2）好处\n\n使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一：\n\n * 系统类防止内存中出现多份同样的字节码\n * 保证 Java 程序安全稳定运行\n\n例如： java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 的类并放到 classpath 中，程序可以编译通过。因为双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 classpath 中的 Object 优先级更高，因为 rt.jar 中的 Object 使用的是启动类加载器，而 classpath 中的 Object 使用的是应用程序类加载器。正因为 rt.jar 中的 Object 优先级更高，因为程序中所有的 Object 都是这个 Object。\n\n（3）实现\n\n以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：\n\npublic abstract class ClassLoader {\n    // The parent class loader for delegation\n    private final ClassLoader parent;\n\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        return loadClass(name, false);\n    }\n\n    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        synchronized (getClassLoadingLock(name)) {\n            // 首先判断该类型是否已经被加载\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                // 如果没有被加载，就委托给父类加载或者委派给启动类加载器加载\n                try {\n                    if (parent != null) {\n                        // 如果存在父类加载器，就委派给父类加载器加载\n                        c = parent.loadClass(name, false);\n                    } else {\n                        // 如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // 如果父类加载器加载失败，会抛出 ClassNotFoundException\n                }\n\n                if (c == null) {\n                    // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能\n                    c = findClass(name);\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        throw new ClassNotFoundException(name);\n    }\n}\n\n\n【说明】\n\n * 先检查类是否已经加载过，如果没有则让父类加载器去加载。\n * 当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。\n\n\n# ClassLoader 参数\n\n在生产环境上启动 java 应用时，通常会指定一些 ClassLoader 参数，以加载应用所需要的 lib：\n\njava -jar xxx.jar -classpath lib/*\n\n\nClassLoader 相关参数选项：\n\n参数选项                                   CLASSLOADER 类型          说明\n-Xbootclasspath                        Bootstrap ClassLoader   设置 Bootstrap ClassLoader 搜索路径。【不常用】\n-Xbootclasspath/a                      Bootstrap ClassLoader   把路径添加到已存在的 Bootstrap ClassLoader 搜索路径后面。【常用】\n-Xbootclasspath/p                      Bootstrap ClassLoader   把路径添加到已存在的 Bootstrap ClassLoader 搜索路径前面。【不常用】\n-Djava.ext.dirs                        ExtClassLoader          设置 ExtClassLoader 搜索路径。\n-Djava.class.path 或 -cp 或 -classpath   AppClassLoader          设置 AppClassLoader 搜索路径。\n\n\n# 类的加载\n\n\n# 类加载方式\n\n类加载有三种方式：\n\n * 命令行启动应用时候由 JVM 初始化加载\n * 通过 Class.forName() 方法动态加载\n * 通过 ClassLoader.loadClass() 方法动态加载\n\nClass.forName() 和 ClassLoader.loadClass() 区别\n\n * Class.forName() 将类的 .class 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 static 块；\n * ClassLoader.loadClass() 只干一件事情，就是将 .class 文件加载到 jvm 中，不会执行 static 中的内容，只有在 newInstance 才会去执行 static 块。\n * Class.forName(name, initialize, loader) 带参函数也可控制是否加载 static 块。并且只有调用了 newInstance() 方法采用调用构造函数，创建类的对象 。\n\n\n# 加载类错误\n\n# ClassNotFoundException\n\nClassNotFoundException 异常出镜率极高。ClassNotFoundException 表示当前 classpath 下找不到指定类。\n\n常见问题原因：\n\n * 调用 Class 的 forName() 方法，未找到类。\n * 调用 ClassLoader 中的 loadClass() 方法，未找到类。\n * 调用 ClassLoader 中的 findSystemClass() 方法，未找到类。\n\n【示例】执行以下代码，会抛出 ClassNotFoundException 异常：\n\npublic class ClassNotFoundExceptionDemo {\n    public static void main(String[] args) {\n        try {\n            Class.forName("NotFound");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n解决方法：检查 classpath 下有没有相应的 class 文件。\n\n# NoClassDefFoundError\n\n常见问题原因：\n\n * 类依赖的 Class 或者 jar 不存在。\n * 类文件存在，但是存在不同的域中。\n\n解决方法：现代 Java 项目，一般使用 maven、gradle 等构建工具管理项目，仔细检查找不到的类所在的 jar 包是否已添加为依赖。\n\n# UnsatisfiedLinkError\n\n这个异常倒不是很常见，但是出错的话，通常是在 JVM 启动的时候如果一不小心将在 JVM 中的某个 lib 删除了，可能就会报这个错误了。\n\n【示例】执行以下代码，会抛出 UnsatisfiedLinkError 错误。\n\npublic class UnsatisfiedLinkErrorDemo {\n\n    public native void nativeMethod();\n\n    static {\n        System.loadLibrary("NoLib");\n    }\n\n    public static void main(String[] args) {\n        new UnsatisfiedLinkErrorDemo().nativeMethod();\n    }\n\n}\n\n\n【输出】\n\njava.lang.UnsatisfiedLinkError: no NoLib in java.library.path\n\tat java.lang.ClassLoader.loadLibrary(ClassLoader.java:1867)\n\tat java.lang.Runtime.loadLibrary0(Runtime.java:870)\n\tat java.lang.System.loadLibrary(System.java:1122)\n\tat io.github.dunwu.javacore.jvm.classloader.exception.UnsatisfiedLinkErrorDemo.<clinit>(UnsatisfiedLinkErrorDemo.java:12)\n\n\n# ClassCastException\n\nClassCastException 异常通常是在程序中强制类型转换失败时出现。\n\n【示例】执行以下代码，会抛出 ClassCastException 异常。\n\npublic class ClassCastExceptionDemo {\n\n    public static void main(String[] args) {\n        Object obj = new Object();\n        EmptyClass newObj = (EmptyClass) obj;\n    }\n\n    static class EmptyClass {}\n\n}\n\n\n【输出】\n\nException in thread "main" java.lang.ClassCastException: java.lang.Object cannot be cast to io.github.dunwu.javacore.jvm.classloader.exception.ClassCastExceptionDemo$EmptyClass\n\tat io.github.dunwu.javacore.jvm.classloader.exception.ClassCastExceptionDemo.main(ClassCastExceptionDemo.java:11)\n\n\n\n# 参考资料\n\n * 《深入理解 Java 虚拟机》\n * 深入拆解 Java 虚拟机\n * 一篇图文彻底弄懂类加载器与双亲委派机制\n * Jvm 系列(一):Java 类的加载机制',normalizedContent:'# jvm 类加载\n\n\n\n\n# 类加载机制\n\n> 类是在运行期间动态加载的。\n\n类的加载指的是将类的 .class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的class对象，class对象封装了类在方法区内的数据结构，并且向 java 程序员提供了访问方法区内的数据结构的接口。\n\n类加载器并不需要等到某个类被“首次主动使用”时再加载它，jvm 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class 文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（linkageerror 错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误\n\n\n# 类的生命周期\n\n\n\njava 类的完整生命周期包括以下几个阶段：\n\n * 加载（loading）\n * 链接（linking）\n   * 验证（verification）\n   * 准备（preparation）\n   * 解析（resolution）\n * 初始化（initialization）\n * 使用（using）\n * 卸载（unloading）\n\n加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。而解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 java 的动态绑定。\n\n类加载过程是指加载、验证、准备、解析和初始化这 5 个阶段。\n\n\n# （一）加载\n\n加载是类加载的一个阶段，注意不要混淆。\n\n加载，是指查找字节流，并且据此创建类的过程。\n\n加载过程完成以下三件事：\n\n * 通过一个类的全限定名来获取定义此类的二进制字节流。\n * 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。\n * 在内存中生成一个代表这个类的 class 对象，作为方法区这个类的各种数据的访问入口。\n\n其中二进制字节流可以从以下方式中获取：\n\n * 从 zip 包读取，这很常见，最终成为日后 jar、ear、war 格式的基础。\n * 从网络中获取，这种场景最典型的应用是 applet。\n * 运行时计算生成，这种场景使用得最多得就是动态代理技术，在 java.lang.reflect.proxy 中，就是用了 proxygenerator.generateproxyclass 的代理类的二进制字节流。\n * 由其他文件生成，典型场景是 jsp 应用，即由 jsp 文件生成对应的 class 类。\n * 从数据库读取，这种场景相对少见，例如有些中间件服务器（如 sap netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。 ...\n\n> 更详细内容会在 3. classloader 介绍。\n\n\n# （二）验证\n\n验证是链接阶段的第一步。验证的目标是确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。\n\n验证阶段大致会完成 4 个阶段的检验动作：\n\n * 文件格式验证 - 验证字节流是否符合 class 文件格式的规范，并且能被当前版本的虚拟机处理。\n * 元数据验证 - 对字节码描述的信息进行语义分析，以保证其描述的信息符合 java 语言规范的要求。\n * 字节码验证 - 通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。\n * 符号引用验证 - 发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。\n\n验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。\n\n\n# （三）准备\n\n类变量是被 static 修饰的变量，准备阶段为 static 变量在方法区分配内存并初始化为默认值，使用的是方法区的内存。\n\n实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 java 堆中。（实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次）\n\n初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。\n\npublic static int value = 123;\n\n\n如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。\n\npublic static final int value = 123;\n\n\n准备阶段有以下几点需要注意：\n\n * 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 java 堆中。\n * 这里所设置的初始值通常情况下是数据类型默认的零值（如 0、0l、null、false 等），而不是被在 java 代码中被显式地赋予的值。\n\n假设一个类变量的定义为：public static int value = 3；\n\n那么变量 value 在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 java 方法，而把 value 赋值为 3 的public static指令是在程序编译后，存放于类构造器（）方法之中的，所以把 value 赋值为 3 的动作将在初始化阶段才会执行。\n\n> 这里还需要注意如下几点：\n> \n>  * 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。\n>  * 对于同时被 static 和 final 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。\n>  * 对于引用数据类型 reference 来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即 null。\n>  * 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。\n\n * 如果类字段的字段属性表中存在constantvalue属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 constvalue 属性所指定的值。\n\n假设上面的类变量 value 被定义为： public static final int value = 3；\n\n编译时 javac 将会为 value 生成 constantvalue 属性，在准备阶段虚拟机就会根据constantvalue的设置将 value 赋值为 3。我们可以理解为 static final 常量在编译期就将其结果放入了调用它的类的常量池中\n\n\n# （四）解析\n\n在 class 文件被加载至 java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。\n\n举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。\n\n解析阶段目标是将常量池的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。\n\n * 符号引用（symbolic references） - 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。\n * 直接引用（direct reference） - 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。\n\n\n# （五）初始化\n\n在 java 代码中，如果要初始化一个静态字段，可以在声明时直接赋值，也可以在静态代码块中对其赋值。\n\n如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 java 编译器标记成常量值（constantvalue），其初始化直接由 java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 java 编译器置于同一方法中，并把它命名为 < clinit >。\n\n初始化阶段才真正开始执行类中的定义的 java 程序代码。初始化，为类的静态变量赋予正确的初始值，jvm 负责对类进行初始化，主要对类变量进行初始化。\n\n# 类初始化方式\n\n * 声明类变量时指定初始值\n * 使用静态代码块为类变量指定初始值\n\n> 在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。\n\n# 类初始化步骤\n\n 1. 如果类还没有被加载和链接，开始加载该类。\n 2. 如果该类的直接父类还没有被初始化，先初始化其父类。\n 3. 如果该类有初始化语句，则依次执行这些初始化语句。\n\n# 类初始化时机\n\n只有主动引用类的时候才会导致类的初始化。\n\n（1）主动引用\n\n类的主动引用包括以下六种：\n\n * 创建类的实例 - 也就是 new 对象\n * 访问静态变量 - 访问某个类或接口的静态变量，或者对该静态变量赋值\n * 访问静态方法\n * 反射 - 如class.forname(“com.shengsiyuan.test”)\n * 初始化子类 - 初始化某个类的子类，则其父类也会被初始化\n * 启动类 - java 虚拟机启动时被标明为启动类的类（java test），直接使用java.exe命令来运行某个主类\n\n（2）被动引用\n\n以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：\n\n * 通过子类引用父类的静态字段，不会导致子类初始化。\n\nsystem.out.println(subclass.value); // value 字段在 superclass 中定义\n\n\n * 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 object 的子类，其中包含了数组的属性和方法。\n\nsuperclass[] sca = new superclass[10];\n\n\n * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。\n\nsystem.out.println(constclass.helloworld);\n\n\n# 类初始化细节\n\n类初始化 <clinit>() 方法的细节：\n\n * 是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：\n\npublic class test {\n    static {\n        i = 0;                // 给变量赋值可以正常编译通过\n        system.out.print(i);  // 这句编译器会提示“非法向前引用”\n    }\n    static int i = 1;\n}\n\n\n * 与类的构造函数（或者说实例构造器 <init>()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 <clinit>() 方法运行之前，父类的 <clinit>() 方法已经执行结束。因此虚拟机中第一个执行 <clinit>() 方法的类肯定为 java.lang.object。\n * 由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码：\n\nstatic class parent {\n    public static int a = 1;\n    static {\n        a = 2;\n    }\n}\n\nstatic class sub extends parent {\n    public static int b = a;\n}\n\npublic static void main(string[] args) {\n     system.out.println(sub.b);  // 输出结果是父类中的静态变量 a 的值，也就是 2。\n}\n\n\n * <clinit>() 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 <clinit>() 方法。\n * 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。\n * 虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。\n\n\n# classloader\n\nclassloader 即类加载器，负责将类加载到 jvm。在 java 虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。\n\njvm 加载 class 文件到内存有两种方式：\n\n * 隐式加载 - jvm 自动加载需要的类到内存中。\n * 显示加载 - 通过使用 classloader 来加载一个类到内存中。\n\n\n# 类与类加载器\n\n如何判断两个类是否相等：类本身相等，并且使用同一个类加载器进行加载。这是因为每一个 classloader 都拥有一个独立的类名称空间。\n\n这里的相等，包括类的 class 对象的 equals() 方法、isassignablefrom() 方法、isinstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。\n\n\n# 类加载器分类\n\n\n\n# bootstrap classloader\n\nbootstrap classloader ，即启动类加载器 ，负责加载 jvm 自身工作所需要的类。\n\nbootstrap classloader 会将存放在 <java_home>\\lib 目录中的，或者被 -xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。\n\nbootstrap classloader 是由 c++ 实现的，它完全由 jvm 自己控制的，启动类加载器无法被 java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。\n\n# extclassloader\n\nextclassloader，即扩展类加载器，这个类加载器是由 extclassloader(sun.misc.launcher\\$extclassloader)实现的。\n\nextclassloader 负责将 <java_home>\\lib\\ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。\n\n# appclassloader\n\nappclassloader，即应用程序类加载器，这个类加载器是由 appclassloader(sun.misc.launcher\\$appclassloader) 实现的。由于这个类加载器是 classloader 中的 getsystemclassloader() 方法的返回值，因此一般称为系统类加载器。\n\nappclassloader 负责加载用户类路径（即 classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n# 自定义类加载器\n\n自定义类加载器可以做到如下几点：\n\n * 在执行非置信代码之前，自动验证数字签名。\n * 动态地创建符合用户特定需要的定制化构建类。\n * 从特定的场所取得 java class，例如数据库中和网络中。\n\n假设，我们需要自定义一个名为 filesystemclassloader 的类加载器，继承自 java.lang.classloader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineclass() 方法来把这些字节代码转换成 java.lang.class 类的实例。\n\njava.lang.classloader 类的方法 loadclass() 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去覆写它，而是通过覆写 findclass() 方法。\n\nclassloader 常用的场景：\n\n * 容器 - 典型应用：servlet 容器（如：tomcat、jetty）、udf （mysql、hive）等。加载解压 jar 包或 war 包后，加载其 class 到指定的类加载器中运行（通常需要考虑空间隔离）。\n * 热部署、热插拔 - 应用启动后，动态获得某个类信息，然后加载到 jvm 中工作。很多著名的容器软件、框架（如：spring 等），都使用 classloader 来实现自身的热部署。\n\n【示例】自定义一个类加载器\n\npublic class filesystemclassloader extends classloader {\n\n    private string rootdir;\n\n    public filesystemclassloader(string rootdir) {\n        this.rootdir = rootdir;\n    }\n\n    protected class<?> findclass(string name) throws classnotfoundexception {\n        byte[] classdata = getclassdata(name);\n        if (classdata == null) {\n            throw new classnotfoundexception();\n        } else {\n            return defineclass(name, classdata, 0, classdata.length);\n        }\n    }\n\n    private byte[] getclassdata(string classname) {\n        string path = classnametopath(classname);\n        try {\n            inputstream ins = new fileinputstream(path);\n            bytearrayoutputstream baos = new bytearrayoutputstream();\n            int buffersize = 4096;\n            byte[] buffer = new byte[buffersize];\n            int bytesnumread;\n            while ((bytesnumread = ins.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesnumread);\n            }\n            return baos.tobytearray();\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n        return null;\n    }\n\n    private string classnametopath(string classname) {\n        return rootdir + file.separatorchar\n                + classname.replace(\'.\', file.separatorchar) + ".class";\n    }\n}\n\n\n\n# 双亲委派\n\n理解双亲委派之前，先让我们看一个示例。\n\n【示例】寻找类加载示例\n\npublic static void main(string[] args) {\n    classloader loader = thread.currentthread().getcontextclassloader();\n    system.out.println(loader);\n    system.out.println(loader.getparent());\n    system.out.println(loader.getparent().getparent());\n}\n\n\n输出：\n\nsun.misc.launcher$appclassloader@18b4aac2\nsun.misc.launcher$extclassloader@19e1023e\nnull\n\n\n从上面的结果可以看出，并没有获取到 extclassloader 的父 loader，原因是 bootstrap loader（引导类加载器）是用 c 语言实现的，找不到一个确定的返回父 loader 的方式，于是就返回 null。\n\n下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（parents delegation model）。该模型要求除了顶层的 bootstrap classloader 外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（composition）关系来实现，而不是通过继承（inheritance）的关系实现。\n\n\n\n（1）工作过程\n\n一个类加载器首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时才尝试加载。\n\n（2）好处\n\n使得 java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一：\n\n * 系统类防止内存中出现多份同样的字节码\n * 保证 java 程序安全稳定运行\n\n例如： java.lang.object 存放在 rt.jar 中，如果编写另外一个 java.lang.object 的类并放到 classpath 中，程序可以编译通过。因为双亲委派模型的存在，所以在 rt.jar 中的 object 比在 classpath 中的 object 优先级更高，因为 rt.jar 中的 object 使用的是启动类加载器，而 classpath 中的 object 使用的是应用程序类加载器。正因为 rt.jar 中的 object 优先级更高，因为程序中所有的 object 都是这个 object。\n\n（3）实现\n\n以下是抽象类 java.lang.classloader 的代码片段，其中的 loadclass() 方法运行过程如下：\n\npublic abstract class classloader {\n    // the parent class loader for delegation\n    private final classloader parent;\n\n    public class<?> loadclass(string name) throws classnotfoundexception {\n        return loadclass(name, false);\n    }\n\n    protected class<?> loadclass(string name, boolean resolve) throws classnotfoundexception {\n        synchronized (getclassloadinglock(name)) {\n            // 首先判断该类型是否已经被加载\n            class<?> c = findloadedclass(name);\n            if (c == null) {\n                // 如果没有被加载，就委托给父类加载或者委派给启动类加载器加载\n                try {\n                    if (parent != null) {\n                        // 如果存在父类加载器，就委派给父类加载器加载\n                        c = parent.loadclass(name, false);\n                    } else {\n                        // 如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native class findbootstrapclass(string name)\n                        c = findbootstrapclassornull(name);\n                    }\n                } catch (classnotfoundexception e) {\n                    // 如果父类加载器加载失败，会抛出 classnotfoundexception\n                }\n\n                if (c == null) {\n                    // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能\n                    c = findclass(name);\n                }\n            }\n            if (resolve) {\n                resolveclass(c);\n            }\n            return c;\n        }\n    }\n\n    protected class<?> findclass(string name) throws classnotfoundexception {\n        throw new classnotfoundexception(name);\n    }\n}\n\n\n【说明】\n\n * 先检查类是否已经加载过，如果没有则让父类加载器去加载。\n * 当父类加载器加载失败时抛出 classnotfoundexception，此时尝试自己去加载。\n\n\n# classloader 参数\n\n在生产环境上启动 java 应用时，通常会指定一些 classloader 参数，以加载应用所需要的 lib：\n\njava -jar xxx.jar -classpath lib/*\n\n\nclassloader 相关参数选项：\n\n参数选项                                   classloader 类型          说明\n-xbootclasspath                        bootstrap classloader   设置 bootstrap classloader 搜索路径。【不常用】\n-xbootclasspath/a                      bootstrap classloader   把路径添加到已存在的 bootstrap classloader 搜索路径后面。【常用】\n-xbootclasspath/p                      bootstrap classloader   把路径添加到已存在的 bootstrap classloader 搜索路径前面。【不常用】\n-djava.ext.dirs                        extclassloader          设置 extclassloader 搜索路径。\n-djava.class.path 或 -cp 或 -classpath   appclassloader          设置 appclassloader 搜索路径。\n\n\n# 类的加载\n\n\n# 类加载方式\n\n类加载有三种方式：\n\n * 命令行启动应用时候由 jvm 初始化加载\n * 通过 class.forname() 方法动态加载\n * 通过 classloader.loadclass() 方法动态加载\n\nclass.forname() 和 classloader.loadclass() 区别\n\n * class.forname() 将类的 .class 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 static 块；\n * classloader.loadclass() 只干一件事情，就是将 .class 文件加载到 jvm 中，不会执行 static 中的内容，只有在 newinstance 才会去执行 static 块。\n * class.forname(name, initialize, loader) 带参函数也可控制是否加载 static 块。并且只有调用了 newinstance() 方法采用调用构造函数，创建类的对象 。\n\n\n# 加载类错误\n\n# classnotfoundexception\n\nclassnotfoundexception 异常出镜率极高。classnotfoundexception 表示当前 classpath 下找不到指定类。\n\n常见问题原因：\n\n * 调用 class 的 forname() 方法，未找到类。\n * 调用 classloader 中的 loadclass() 方法，未找到类。\n * 调用 classloader 中的 findsystemclass() 方法，未找到类。\n\n【示例】执行以下代码，会抛出 classnotfoundexception 异常：\n\npublic class classnotfoundexceptiondemo {\n    public static void main(string[] args) {\n        try {\n            class.forname("notfound");\n        } catch (classnotfoundexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n解决方法：检查 classpath 下有没有相应的 class 文件。\n\n# noclassdeffounderror\n\n常见问题原因：\n\n * 类依赖的 class 或者 jar 不存在。\n * 类文件存在，但是存在不同的域中。\n\n解决方法：现代 java 项目，一般使用 maven、gradle 等构建工具管理项目，仔细检查找不到的类所在的 jar 包是否已添加为依赖。\n\n# unsatisfiedlinkerror\n\n这个异常倒不是很常见，但是出错的话，通常是在 jvm 启动的时候如果一不小心将在 jvm 中的某个 lib 删除了，可能就会报这个错误了。\n\n【示例】执行以下代码，会抛出 unsatisfiedlinkerror 错误。\n\npublic class unsatisfiedlinkerrordemo {\n\n    public native void nativemethod();\n\n    static {\n        system.loadlibrary("nolib");\n    }\n\n    public static void main(string[] args) {\n        new unsatisfiedlinkerrordemo().nativemethod();\n    }\n\n}\n\n\n【输出】\n\njava.lang.unsatisfiedlinkerror: no nolib in java.library.path\n\tat java.lang.classloader.loadlibrary(classloader.java:1867)\n\tat java.lang.runtime.loadlibrary0(runtime.java:870)\n\tat java.lang.system.loadlibrary(system.java:1122)\n\tat io.github.dunwu.javacore.jvm.classloader.exception.unsatisfiedlinkerrordemo.<clinit>(unsatisfiedlinkerrordemo.java:12)\n\n\n# classcastexception\n\nclasscastexception 异常通常是在程序中强制类型转换失败时出现。\n\n【示例】执行以下代码，会抛出 classcastexception 异常。\n\npublic class classcastexceptiondemo {\n\n    public static void main(string[] args) {\n        object obj = new object();\n        emptyclass newobj = (emptyclass) obj;\n    }\n\n    static class emptyclass {}\n\n}\n\n\n【输出】\n\nexception in thread "main" java.lang.classcastexception: java.lang.object cannot be cast to io.github.dunwu.javacore.jvm.classloader.exception.classcastexceptiondemo$emptyclass\n\tat io.github.dunwu.javacore.jvm.classloader.exception.classcastexceptiondemo.main(classcastexceptiondemo.java:11)\n\n\n\n# 参考资料\n\n * 《深入理解 java 虚拟机》\n * 深入拆解 java 虚拟机\n * 一篇图文彻底弄懂类加载器与双亲委派机制\n * jvm 系列(一):java 类的加载机制',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"JavaAgent 应用指南",frontmatter:{title:"JavaAgent 应用指南",categories:["编程","Java","JavaSE","JVM"],tags:["Java","JavaSE","JVM","JavaAgent"],abbrlink:"fb29b599",date:"2022-04-08T17:29:48.000Z",permalink:"/pages/f634e5/"},regularPath:"/06.JVM/08.JavaAgent.html",relativePath:"06.JVM/08.JavaAgent.md",key:"v-7b2d21b6",path:"/pages/f634e5/",headers:[{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:654}],headersStr:"参考资料",content:"# JavaAgent 应用指南\n\nJavaagent 是什么？\n\nJavaagent 是 java 命令的一个参数。参数 javaagent 可以用于指定一个 jar 包，它利用 JVM 提供的 Instrumentation API 来更改加载 JVM 中的现有字节码。\n\n 1. 这个 jar 包的 MANIFEST.MF 文件必须指定 Premain-Class 项。\n 2. Premain-Class 指定的那个类必须实现 premain() 方法。\n\npremain 方法，从字面上理解，就是运行在 main 函数之前的的类。当 Java 虚拟机启动时，在执行 main 函数之前，JVM 会先运行-javaagent所指定 jar 包内 Premain-Class 这个类的 premain 方法 。\n\n在命令行输入 java可以看到相应的参数，其中有 和 java agent 相关的：\n\n-agentlib:<libname>[=<选项>]\n\t\t\t  加载本机代理库 <libname>, 例如 -agentlib:hprof\n\t\t\t  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help\n-agentpath:<pathname>[=<选项>]\n\t\t\t  按完整路径名加载本机代理库\n-javaagent:<jarpath>[=<选项>]\n\t\t\t  加载 Java 编程语言代理, 请参阅 java.lang.instrument\n\n\n\n# 参考资料\n\n * java.lang.instrument",normalizedContent:"# javaagent 应用指南\n\njavaagent 是什么？\n\njavaagent 是 java 命令的一个参数。参数 javaagent 可以用于指定一个 jar 包，它利用 jvm 提供的 instrumentation api 来更改加载 jvm 中的现有字节码。\n\n 1. 这个 jar 包的 manifest.mf 文件必须指定 premain-class 项。\n 2. premain-class 指定的那个类必须实现 premain() 方法。\n\npremain 方法，从字面上理解，就是运行在 main 函数之前的的类。当 java 虚拟机启动时，在执行 main 函数之前，jvm 会先运行-javaagent所指定 jar 包内 premain-class 这个类的 premain 方法 。\n\n在命令行输入 java可以看到相应的参数，其中有 和 java agent 相关的：\n\n-agentlib:<libname>[=<选项>]\n\t\t\t  加载本机代理库 <libname>, 例如 -agentlib:hprof\n\t\t\t  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help\n-agentpath:<pathname>[=<选项>]\n\t\t\t  按完整路径名加载本机代理库\n-javaagent:<jarpath>[=<选项>]\n\t\t\t  加载 java 编程语言代理, 请参阅 java.lang.instrument\n\n\n\n# 参考资料\n\n * java.lang.instrument",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"JVM 命令行工具",frontmatter:{title:"JVM 命令行工具",categories:["编程","Java","JavaSE","JVM"],tags:["Java","JavaSE","JVM","命令行"],abbrlink:"927942cc",date:"2020-07-30T17:56:33.000Z",permalink:"/pages/fb1445/"},regularPath:"/06.JVM/11.JVM%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html",relativePath:"06.JVM/11.JVM命令行工具.md",key:"v-6d0e3968",path:"/pages/fb1445/",headers:[{level:2,title:"jps",slug:"jps",normalizedTitle:"jps",charIndex:149},{level:3,title:"jps 命令用法",slug:"jps-命令用法",normalizedTitle:"jps 命令用法",charIndex:684},{level:3,title:"jps 使用示例",slug:"jps-使用示例",normalizedTitle:"jps 使用示例",charIndex:1024},{level:2,title:"jstat",slug:"jstat",normalizedTitle:"jstat",charIndex:186},{level:3,title:"jstat 命令用法",slug:"jstat-命令用法",normalizedTitle:"jstat 命令用法",charIndex:1428},{level:3,title:"jstat 使用示例",slug:"jstat-使用示例",normalizedTitle:"jstat 使用示例",charIndex:2179},{level:4,title:"类加载统计",slug:"类加载统计",normalizedTitle:"类加载统计",charIndex:304},{level:4,title:"编译统计",slug:"编译统计",normalizedTitle:"编译统计",charIndex:2226},{level:4,title:"GC 统计",slug:"gc-统计",normalizedTitle:"gc 统计",charIndex:2828},{level:2,title:"jmap",slug:"jmap",normalizedTitle:"jmap",charIndex:266},{level:3,title:"jmap 命令用法",slug:"jmap-命令用法",normalizedTitle:"jmap 命令用法",charIndex:5231},{level:3,title:"jstat 使用示例",slug:"jstat-使用示例-2",normalizedTitle:"jstat 使用示例",charIndex:2179},{level:4,title:"生成 heapdump 快照",slug:"生成-heapdump-快照",normalizedTitle:"生成 heapdump 快照",charIndex:5576},{level:4,title:"查看实例数最多的类",slug:"查看实例数最多的类",normalizedTitle:"查看实例数最多的类",charIndex:5817},{level:4,title:"查看指定进程的堆信息",slug:"查看指定进程的堆信息",normalizedTitle:"查看指定进程的堆信息",charIndex:6093},{level:2,title:"jstack",slug:"jstack",normalizedTitle:"jstack",charIndex:357},{level:3,title:"jstack 命令用法",slug:"jstack-命令用法",normalizedTitle:"jstack 命令用法",charIndex:8158},{level:3,title:"thread dump 文件",slug:"thread-dump-文件",normalizedTitle:"thread dump 文件",charIndex:8302},{level:4,title:"第一部分：Full thread dump identifier",slug:"第一部分-full-thread-dump-identifier",normalizedTitle:"第一部分：full thread dump identifier",charIndex:8352},{level:4,title:"第二部分：Java EE middleware, third party & custom application Threads",slug:"第二部分-java-ee-middleware-third-party-custom-application-threads",normalizedTitle:"第二部分：java ee middleware, third party &amp; custom application threads",charIndex:null},{level:4,title:"第三部分：HotSpot VM Thread",slug:"第三部分-hotspot-vm-thread",normalizedTitle:"第三部分：hotspot vm thread",charIndex:9780},{level:5,title:'"Attach Listener"',slug:"attach-listener",normalizedTitle:"&quot;attach listener&quot;",charIndex:null},{level:5,title:'"DestroyJavaVM"',slug:"destroyjavavm",normalizedTitle:"&quot;destroyjavavm&quot;",charIndex:null},{level:5,title:'"Service Thread"',slug:"service-thread",normalizedTitle:"&quot;service thread&quot;",charIndex:null},{level:5,title:'"CompilerThread"',slug:"compilerthread",normalizedTitle:"&quot;compilerthread&quot;",charIndex:null},{level:5,title:'"Signal Dispatcher"',slug:"signal-dispatcher",normalizedTitle:"&quot;signal dispatcher&quot;",charIndex:null},{level:5,title:'"Finalizer"',slug:"finalizer",normalizedTitle:"&quot;finalizer&quot;",charIndex:null},{level:5,title:'"Reference Handler"',slug:"reference-handler",normalizedTitle:"&quot;reference handler&quot;",charIndex:null},{level:5,title:'"VM Thread"',slug:"vm-thread",normalizedTitle:"&quot;vm thread&quot;",charIndex:null},{level:4,title:"第四部分：HotSpot GC Thread",slug:"第四部分-hotspot-gc-thread",normalizedTitle:"第四部分：hotspot gc thread",charIndex:13318},{level:5,title:'"VM Periodic Task Thread"',slug:"vm-periodic-task-thread",normalizedTitle:"&quot;vm periodic task thread&quot;",charIndex:null},{level:5,title:'"GC task thread#0 (ParallelGC)"',slug:"gc-task-thread-0-parallelgc",normalizedTitle:"&quot;gc task thread#0 (parallelgc)&quot;",charIndex:null},{level:5,title:'"Gang worker#0 (Parallel GC Threads)"',slug:"gang-worker-0-parallel-gc-threads",normalizedTitle:"&quot;gang worker#0 (parallel gc threads)&quot;",charIndex:null},{level:5,title:'"Concurrent Mark-Sweep GC Thread"',slug:"concurrent-mark-sweep-gc-thread",normalizedTitle:"&quot;concurrent mark-sweep gc thread&quot;",charIndex:null},{level:5,title:'"Surrogate Locker Thread (Concurrent GC)"',slug:"surrogate-locker-thread-concurrent-gc",normalizedTitle:"&quot;surrogate locker thread (concurrent gc)&quot;",charIndex:null},{level:4,title:"第五部分：JNI global references count",slug:"第五部分-jni-global-references-count",normalizedTitle:"第五部分：jni global references count",charIndex:16301},{level:3,title:"系统线程状态",slug:"系统线程状态",normalizedTitle:"系统线程状态",charIndex:9562},{level:4,title:"deadlock",slug:"deadlock",normalizedTitle:"deadlock",charIndex:16520},{level:4,title:"runnable",slug:"runnable",normalizedTitle:"runnable",charIndex:10437},{level:4,title:"blocked",slug:"blocked",normalizedTitle:"blocked",charIndex:19170},{level:4,title:"waiting on condition",slug:"waiting-on-condition",normalizedTitle:"waiting on condition",charIndex:8718},{level:4,title:"waiting for monitor entry 或 in Object.wait()",slug:"waiting-for-monitor-entry-或-in-object-wait",normalizedTitle:"waiting for monitor entry 或 in object.wait()",charIndex:22453},{level:3,title:"jstack 使用示例",slug:"jstack-使用示例",normalizedTitle:"jstack 使用示例",charIndex:23679},{level:4,title:"找出某 Java 进程中最耗费 CPU 的 Java 线程",slug:"找出某-java-进程中最耗费-cpu-的-java-线程",normalizedTitle:"找出某 java 进程中最耗费 cpu 的 java 线程",charIndex:23694},{level:4,title:"生成 threaddump 文件",slug:"生成-threaddump-文件",normalizedTitle:"生成 threaddump 文件",charIndex:24951},{level:2,title:"jinfo",slug:"jinfo",normalizedTitle:"jinfo",charIndex:480},{level:2,title:"jhat",slug:"jhat",normalizedTitle:"jhat",charIndex:448},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:25975}],headersStr:'jps jps 命令用法 jps 使用示例 jstat jstat 命令用法 jstat 使用示例 类加载统计 编译统计 GC 统计 jmap jmap 命令用法 jstat 使用示例 生成 heapdump 快照 查看实例数最多的类 查看指定进程的堆信息 jstack jstack 命令用法 thread dump 文件 第一部分：Full thread dump identifier 第二部分：Java EE middleware, third party & custom application Threads 第三部分：HotSpot VM Thread "Attach Listener" "DestroyJavaVM" "Service Thread" "CompilerThread" "Signal Dispatcher" "Finalizer" "Reference Handler" "VM Thread" 第四部分：HotSpot GC Thread "VM Periodic Task Thread" "GC task thread#0 (ParallelGC)" "Gang worker#0 (Parallel GC Threads)" "Concurrent Mark-Sweep GC Thread" "Surrogate Locker Thread (Concurrent GC)" 第五部分：JNI global references count 系统线程状态 deadlock runnable blocked waiting on condition waiting for monitor entry 或 in Object.wait() jstack 使用示例 找出某 Java 进程中最耗费 CPU 的 Java 线程 生成 threaddump 文件 jinfo jhat 参考资料',content:'# JVM 命令行工具\n\n> Java 程序员免不了故障排查工作，所以经常需要使用一些 JVM 工具。\n> \n> JDK 自带了一些实用的命令行工具来监控、分析 JVM 信息，掌握它们，非常有助于 TroubleShooting。\n\n以下是较常用的 JDK 命令行工具：\n\n名称       描述\njps      JVM 进程状态工具。显示系统内的所有 JVM 进程。\njstat    JVM 统计监控工具。监控虚拟机运行时状态信息，它可以显示出 JVM 进程中的类装载、内存、GC、JIT\n         编译等运行数据。\njmap     JVM 堆内存分析工具。用于打印 JVM 进程对象直方图、类加载统计。并且可以生成堆转储快照（一般称为 heapdump\n         或 dump 文件）。\njstack   JVM 栈查看工具。用于打印 JVM 进程的线程和锁的情况。并且可以生成线程快照（一般称为 threaddump 或\n         javacore 文件）。\njhat     用来分析 jmap 生成的 dump 文件。\njinfo    JVM 信息查看工具。用于实时查看和调整 JVM 进程参数。\njcmd     JVM 命令行调试 工具。用于向 JVM 进程发送调试命令。\n\n\n# jps\n\n> jps(JVM Process Status Tool) 是虚拟机进程状态工具。它可以显示指定系统内所有的 HotSpot 虚拟机进程状态信息。jps 通过 RMI 协议查询开启了 RMI 服务的远程虚拟机进程状态。\n\n\n# jps 命令用法\n\njps [option] [hostid]\njps [-help]\n\n\n如果不指定 hostid 就默认为当前主机或服务器。\n\n常用参数：\n\n * option - 选项参数\n   * -m - 输出 JVM 启动时传递给 main() 的参数。\n   * -l - 输出主类的全名，如果进程执行的是 jar 包，输出 jar 路径。\n   * -v - 显示传递给 JVM 的参数。\n   * -q - 仅输出本地 JVM 进程 ID。\n   * -V - 仅输出本地 JVM 标识符。\n * hostid - RMI 注册表中注册的主机名。如果不指定 hostid 就默认为当前主机或服务器。\n\n其中 option、hostid 参数也可以不写。\n\n\n# jps 使用示例\n\n【示例】列出本地 Java 进程\n\n$ jps\n18027 Java2Demo.JAR\n18032 jps\n18005 jstat\n\n\n【示例】列出本地 Java 进程 ID\n\n$ jps -q\n8841\n1292\n5398\n\n\n【示例】列出本地 Java 进程 ID，并输出主类的全名，如果进程执行的是 jar 包，输出 jar 路径\n\n$ jps -l remote.domain\n3002 /opt/jdk1.7.0/demo/jfc/Java2D/Java2Demo.JAR\n2857 sun.tools.jstatd.jstatd\n\n\n\n# jstat\n\n> jstat(JVM statistics Monitoring)，是虚拟机统计信息监视工具。jstat 用于监视虚拟机运行时状态信息，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据。\n\n\n# jstat 命令用法\n\n命令格式：\n\njstat [option] VMID [interval] [count]\n\n\n常用参数：\n\n * option - 选项参数，用于指定用户需要查询的虚拟机信息\n   * -class - 监视类装载、卸载数量、总空间以及类装载所耗费的时间\n   * -compiler：显示 JIT 编译的相关信息；\n   * -gc：监视 Java 堆状况，包括 Eden 区、两个 survivor 区、老年代、永久代等区的容量、已用空间、GC 时间合计等信息。\n   * -gccapacity：显示各个代的容量以及使用情况；\n   * -gcmetacapacity：显示 Metaspace 的大小；\n   * -gcnew：显示新生代信息；\n   * -gcnewcapacity：显示新生代大小和使用情况；\n   * -gcold：显示老年代和永久代的信息；\n   * -gcoldcapacity：显示老年代的大小；\n   * -gcutil：显示垃圾回收统计信息；\n   * -gccause：显示垃圾回收的相关信息（通 -gcutil），同时显示最后一次或当前正在发生的垃圾回收的诱因；\n   * -printcompilation：输出 JIT 编译的方法信息。\n * VMID - 如果是本地虚拟机进程，则 VMID 与 LVMID 是一致的；如果是远程虚拟机进程，那 VMID 的格式应当是：[protocol:][//]lvmid[@hostname[:port]/servername]\n * interval - 查询间隔\n * count - 查询次数\n\n> 【参考】更详细说明可以参考：jstat 命令查看 jvm 的 GC 情况\n\n\n# jstat 使用示例\n\n# 类加载统计\n\n使用 jstat -class pid 命令可以查看编译统计信息。\n\n【参数】\n\n * Loaded - 加载 class 的数量\n * Bytes - 所占用空间大小\n * Unloaded - 未加载数量\n * Bytes - 未加载占用空间\n * Time - 时间\n\n【示例】查看类加载信息\n\n$ jstat -class 7129\nLoaded  Bytes  Unloaded  Bytes     Time\n 26749 50405.3      873  1216.8      19.75\n\n\n# 编译统计\n\n使用 jstat -compiler pid 命令可以查看编译统计信息。\n\n【示例】\n\n$ jstat -compiler 7129\nCompiled Failed Invalid   Time   FailedType FailedMethod\n   42030      2       0   302.53          1 org/apache/felix/framework/BundleWiringImpl$BundleClassLoader findClass\n\n\n【参数】\n\n * Compiled - 编译数量\n * Failed - 失败数量\n * Invalid - 不可用数量\n * Time - 时间\n * FailedType - 失败类型\n * FailedMethod - 失败的方法\n\n# GC 统计\n\n使用 jstat -gc pid time 命令可以查看 GC 统计信息。\n\n【示例】以 250 毫秒的间隔进行 7 个采样，并显示-gcutil 选项指定的输出。\n\n$ jstat -gcutil 21891 250 7\n  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT\n  0.00  97.02  70.31  66.80  95.52  89.14      7    0.300     0    0.000    0.300\n  0.00  97.02  86.23  66.80  95.52  89.14      7    0.300     0    0.000    0.300\n  0.00  97.02  96.53  66.80  95.52  89.14      7    0.300     0    0.000    0.300\n 91.03   0.00   1.98  68.19  95.89  91.24      8    0.378     0    0.000    0.378\n 91.03   0.00  15.82  68.19  95.89  91.24      8    0.378     0    0.000    0.378\n 91.03   0.00  17.80  68.19  95.89  91.24      8    0.378     0    0.000    0.378\n 91.03   0.00  17.80  68.19  95.89  91.24      8    0.378     0    0.000    0.378\n\n\n【示例】以 1 秒的间隔进行 4 个采样，并显示-gc 选项指定的输出。\n\n$ jstat -gc 25196 1s 4\n S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT\n20928.0 20928.0  0.0    0.0   167936.0  8880.5   838912.0   80291.2   106668.0 100032.1 12772.0 11602.2    760   14.332  580   656.218  670.550\n20928.0 20928.0  0.0    0.0   167936.0  8880.5   838912.0   80291.2   106668.0 100032.1 12772.0 11602.2    760   14.332  580   656.218  670.550\n20928.0 20928.0  0.0    0.0   167936.0  8880.5   838912.0   80291.2   106668.0 100032.1 12772.0 11602.2    760   14.332  580   656.218  670.550\n20928.0 20928.0  0.0    0.0   167936.0  8880.5   838912.0   80291.2   106668.0 100032.1 12772.0 11602.2    760   14.332  580   656.218  670.550\n\n\n参数说明：\n\n * S0C：年轻代中 To Survivor 的容量（单位 KB）；\n * S1C：年轻代中 From Survivor 的容量（单位 KB）；\n * S0U：年轻代中 To Survivor 目前已使用空间（单位 KB）；\n * S1U：年轻代中 From Survivor 目前已使用空间（单位 KB）；\n * EC：年轻代中 Eden 的容量（单位 KB）；\n * EU：年轻代中 Eden 目前已使用空间（单位 KB）；\n * OC：Old 代的容量（单位 KB）；\n * OU：Old 代目前已使用空间（单位 KB）；\n * MC：Metaspace 的容量（单位 KB）；\n * MU：Metaspace 目前已使用空间（单位 KB）；\n * YGC：从应用程序启动到采样时年轻代中 gc 次数；\n * YGCT：从应用程序启动到采样时年轻代中 gc 所用时间 (s)；\n * FGC：从应用程序启动到采样时 old 代（全 gc）gc 次数；\n * FGCT：从应用程序启动到采样时 old 代（全 gc）gc 所用时间 (s)；\n * GCT：从应用程序启动到采样时 gc 用的总时间 (s)。\n\n> 注：更详细的参数含义可以参考官方文档：http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html\n\n\n# jmap\n\n> jmap(JVM Memory Map) 是 Java 内存映像工具。jmap 用于生成堆转储快照（一般称为 heapdump 或 dump 文件）。jmap 不仅能生成 dump 文件，还可以查询 finalize 执行队列、Java 堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。\n> \n> 如果不使用这个命令，还可以使用 -XX:+HeapDumpOnOutOfMemoryError 参数来让虚拟机出现 OOM 的时候，自动生成 dump 文件。\n\n\n# jmap 命令用法\n\n命令格式：\n\njmap [option] pid\n\n\noption 选项参数：\n\n * -dump - 生成堆转储快照。-dump:live 只保存堆中的存活对象。\n * -finalizerinfo - 显示在 F-Queue 队列等待执行 finalizer 方法的对象\n * -heap - 显示 Java 堆详细信息。\n * -histo - 显示堆中对象的统计信息，包括类、实例数量、合计容量。-histo:live 只统计堆中的存活对象。\n * -permstat - to print permanent generation statistics\n * -F - 当-dump 没有响应时，强制生成 dump 快照\n\n\n# jstat 使用示例\n\n# 生成 heapdump 快照\n\ndump 堆到文件，format 指定输出格式，live 指明是活着的对象，file 指定文件名\n\n$ jmap -dump:live,format=b,file=dump.hprof 28920\nDumping heap to /home/xxx/dump.hprof ...\nHeap dump file created\n\n\ndump.hprof 这个后缀是为了后续可以直接用 MAT(Memory Anlysis Tool)等工具打开。\n\n# 查看实例数最多的类\n\n$ jmap -histo 29527 | head -n 6\n\n num     #instances         #bytes  class name\n----------------------------------------------\n   1:      13673280     1438961864  [C\n   2:       1207166      411277184  [I\n   3:       7382322      347307096  [Ljava.lang.Object;\n\n\n# 查看指定进程的堆信息\n\n注意：使用 CMS GC 情况下，jmap -heap PID 的执行有可能会导致 java 进程挂起。\n\n$ jmap -heap 12379\nAttaching to process ID 12379, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 17.0-b16\n\nusing thread-local object allocation.\nParallel GC with 6 thread(s)\n\nHeap Configuration:\n   MinHeapFreeRatio = 40\n   MaxHeapFreeRatio = 70\n   MaxHeapSize      = 83886080 (80.0MB)\n   NewSize          = 1310720 (1.25MB)\n   MaxNewSize       = 17592186044415 MB\n   OldSize          = 5439488 (5.1875MB)\n   NewRatio         = 2\n   SurvivorRatio    = 8\n   PermSize         = 20971520 (20.0MB)\n   MaxPermSize      = 88080384 (84.0MB)\n\nHeap Usage:\nPS Young Generation\nEden Space:\n   capacity = 9306112 (8.875MB)\n   used     = 5375360 (5.1263427734375MB)\n   free     = 3930752 (3.7486572265625MB)\n   57.761608714788736% used\nFrom Space:\n   capacity = 9306112 (8.875MB)\n   used     = 3425240 (3.2665634155273438MB)\n   free     = 5880872 (5.608436584472656MB)\n   36.80634834397007% used\nTo Space:\n   capacity = 9306112 (8.875MB)\n   used     = 0 (0.0MB)\n   free     = 9306112 (8.875MB)\n   0.0% used\nPS Old Generation\n   capacity = 55967744 (53.375MB)\n   used     = 48354640 (46.11457824707031MB)\n   free     = 7613104 (7.2604217529296875MB)\n   86.39733629427693% used\nPS Perm Generation\n   capacity = 62062592 (59.1875MB)\n   used     = 60243112 (57.452308654785156MB)\n   free     = 1819480 (1.7351913452148438MB)\n   97.06831451706046% used\n\n\n\n# jstack\n\n> jstack(Stack Trace for java) 是 Java 堆栈跟踪工具。jstack 用来打印目标 Java 进程中各个线程的栈轨迹，以及这些线程所持有的锁，并可以生成 java 虚拟机当前时刻的线程快照（一般称为 threaddump 或 javacore 文件）。\n> \n> 线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。\n\njstack 通常会结合 top -Hp pid 或 pidstat -p pid -t 一起查看具体线程的状态，也经常用来排查一些死锁的异常。\n\n线程出现停顿的时候通过 jstack 来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果 java 程序崩溃生成 core 文件，jstack 工具可以用来获得 core 文件的 java stack 和 native stack 的信息，从而可以轻松地知道 java 程序是如何崩溃和在程序何处发生问题。另外，jstack 工具还可以附属到正在运行的 java 程序中，看到当时运行的 java 程序的 java stack 和 native stack 的信息, 如果现在运行的 java 程序呈现 hung 的状态，jstack 是非常有用的。\n\n\n# jstack 命令用法\n\n命令格式：\n\njstack [option] pid\n\n\noption 选项参数\n\n * -F - 当正常输出请求不被响应时，强制输出线程堆栈\n * -l - 除堆栈外，显示关于锁的附加信息\n * -m - 打印 java 和 jni 框架的所有栈信息\n\n\n# thread dump 文件\n\n\n\n一个 Thread Dump 文件大致可以分为五个部分。\n\n# 第一部分：Full thread dump identifier\n\n这一部分是内容最开始的部分，展示了快照文件的生成时间和 JVM 的版本信息。\n\n2017-10-19 10:46:44\nFull thread dump Java HotSpot(TM) 64-Bit Server VM (24.79-b02 mixed mode):\n\n\n# 第二部分：Java EE middleware, third party & custom application Threads\n\n这是整个文件的核心部分，里面展示了 JavaEE 容器（如 tomcat、resin 等）、自己的程序中所使用的线程信息。\n\n"resin-22129" daemon prio=10 tid=0x00007fbe5c34e000 nid=0x4cb1 waiting on condition [0x00007fbe4ff7c000]\n   java.lang.Thread.State: WAITING (parking)\n    at sun.misc.Unsafe.park(Native Method)\n    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:315)\n    at com.caucho.env.thread2.ResinThread2.park(ResinThread2.java:196)\n    at com.caucho.env.thread2.ResinThread2.runTasks(ResinThread2.java:147)\n    at com.caucho.env.thread2.ResinThread2.run(ResinThread2.java:118)\n\n\n参数说明：\n\n * "resin-22129" **线程名称：**如果使用 java.lang.Thread 类生成一个线程的时候，线程名称为 Thread-(数字) 的形式，这里是 resin 生成的线程；\n * daemon **线程类型：**线程分为守护线程 (daemon) 和非守护线程 (non-daemon) 两种，通常都是守护线程；\n * prio=10 **线程优先级：**默认为 5，数字越大优先级越高；\n * tid=0x00007fbe5c34e000 **JVM 线程的 id：**JVM 内部线程的唯一标识，通过 java.lang.Thread.getId()获取，通常用自增的方式实现；\n * nid=0x4cb1 **系统线程 id：**对应的系统线程 id（Native Thread ID)，可以通过 top 命令进行查看，现场 id 是十六进制的形式；\n * waiting on condition **系统线程状态：**这里是系统的线程状态；\n * [0x00007fbe4ff7c000] **起始栈地址：**线程堆栈调用的其实内存地址；\n * java.lang.Thread.State: WAITING (parking) **JVM 线程状态：**这里标明了线程在代码级别的状态。\n * **线程调用栈信息：**下面就是当前线程调用的详细栈信息，用于代码的分析。堆栈信息应该从下向上解读，因为程序调用的顺序是从下向上的。\n\n# 第三部分：HotSpot VM Thread\n\n这一部分展示了 JVM 内部线程的信息，用于执行内部的原生操作。下面常见的集中内置线程：\n\n# "Attach Listener"\n\n该线程负责接收外部命令，执行该命令并把结果返回给调用者，此种类型的线程通常在桌面程序中出现。\n\n"Attach Listener" daemon prio=5 tid=0x00007fc6b6800800 nid=0x3b07 waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n\n# "DestroyJavaVM"\n\n执行 main() 的线程在执行完之后调用 JNI 中的 jni_DestroyJavaVM() 方法会唤起 DestroyJavaVM 线程，处于等待状态，等待其它线程（java 线程和 native 线程）退出时通知它卸载 JVM。\n\n"DestroyJavaVM" prio=5 tid=0x00007fc6b3001000 nid=0x1903 waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n\n# "Service Thread"\n\n用于启动服务的线程\n\n"Service Thread" daemon prio=10 tid=0x00007fbea81b3000 nid=0x5f2 runnable [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n\n# "CompilerThread"\n\n用来调用 JITing，实时编译装卸类。通常 JVM 会启动多个线程来处理这部分工作，线程名称后面的数字也会累加，比如 CompilerThread1。\n\n"C2 CompilerThread1" daemon prio=10 tid=0x00007fbea814b000 nid=0x5f1 waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n"C2 CompilerThread0" daemon prio=10 tid=0x00007fbea8142000 nid=0x5f0 waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n\n# "Signal Dispatcher"\n\nAttach Listener 线程的职责是接收外部 jvm 命令，当命令接收成功后，会交给 signal dispather 线程去进行分发到各个不同的模块处理命令，并且返回处理结果。 signal dispather 线程也是在第一次接收外部 jvm 命令时，进行初始化工作。\n\n"Signal Dispatcher" daemon prio=10 tid=0x00007fbea81bf800 nid=0x5ef runnable [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n\n# "Finalizer"\n\n这个线程也是在 main 线程之后创建的，其优先级为 10，主要用于在垃圾收集前，调用对象的 finalize() 方法；关于 Finalizer 线程的几点：\n\n * 只有当开始一轮垃圾收集时，才会开始调用 finalize()方法；因此并不是所有对象的 finalize()方法都会被执行；\n * 该线程也是 daemon 线程，因此如果虚拟机中没有其他非 daemon 线程，不管该线程有没有执行完 finalize()方法，JVM 也会退出；\n * JVM 在垃圾收集时会将失去引用的对象包装成 Finalizer 对象（Reference 的实现），并放入 ReferenceQueue，由 Finalizer 线程来处理；最后将该 Finalizer 对象的引用置为 null，由垃圾收集器来回收；\n\nJVM 为什么要单独用一个线程来执行 finalize() 方法呢？\n\n如果 JVM 的垃圾收集线程自己来做，很有可能由于在 finalize()方法中误操作导致 GC 线程停止或不可控，这对 GC 线程来说是一种灾难。\n\n"Finalizer" daemon prio=10 tid=0x00007fbea80da000 nid=0x5eb in Object.wait() [0x00007fbeac044000]\n   java.lang.Thread.State: WAITING (on object monitor)\n    at java.lang.Object.wait(Native Method)\n    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:135)\n    - locked <0x00000006d173c1a8> (a java.lang.ref.ReferenceQueue$Lock)\n    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:151)\n    at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)\n\n\n# "Reference Handler"\n\nJVM 在创建 main 线程后就创建 Reference Handler 线程，其优先级最高，为 10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。\n\n"Reference Handler" daemon prio=10 tid=0x00007fbea80d8000 nid=0x5ea in Object.wait() [0x00007fbeac085000]\n   java.lang.Thread.State: WAITING (on object monitor)\n    at java.lang.Object.wait(Native Method)\n    at java.lang.Object.wait(Object.java:503)\n    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:133)\n    - locked <0x00000006d173c1f0> (a java.lang.ref.Reference$Lock)\n\n\n# "VM Thread"\n\nJVM 中线程的母体，根据 HotSpot 源码中关于 vmThread.hpp 里面的注释，它是一个单例的对象（最原始的线程）会产生或触发所有其他的线程，这个单例的 VM 线程是会被其他线程所使用来做一些 VM 操作（如清扫垃圾等）。 在 VM Thread 的结构体里有一个 VMOperationQueue 列队，所有的 VM 线程操作(vm_operation)都会被保存到这个列队当中，VMThread 本身就是一个线程，它的线程负责执行一个自轮询的 loop 函数(具体可以参考：VMThread.cpp 里面的 void VMThread::loop()) ，该 loop 函数从 VMOperationQueue 列队中按照优先级取出当前需要执行的操作对象(VM_Operation)，并且调用 VM_Operation->evaluate 函数去执行该操作类型本身的业务逻辑。 VM 操作类型被定义在 vm_operations.hpp 文件内，列举几个：ThreadStop、ThreadDump、PrintThreads、GenCollectFull、GenCollectFullConcurrent、CMS_Initial_Mark、CMS_Final_Remark….. 有兴趣的同学，可以自己去查看源文件。\n\n"VM Thread" prio=10 tid=0x00007fbea80d3800 nid=0x5e9 runnable\n\n\n# 第四部分：HotSpot GC Thread\n\nJVM 中用于进行资源回收的线程，包括以下几种类型的线程：\n\n# "VM Periodic Task Thread"\n\n该线程是 JVM 周期性任务调度的线程，它由 WatcherThread 创建，是一个单例对象。该线程在 JVM 内使用得比较频繁，比如：定期的内存监控、JVM 运行状况监控。\n\n"VM Periodic Task Thread" prio=10 tid=0x00007fbea82ae800 nid=0x5fa waiting on condition\n\n\n可以使用 jstat 命令查看 GC 的情况，比如查看某个进程没有存活必要的引用可以使用命令 jstat -gcutil 250 7 参数中 pid 是进程 id，后面的 250 和 7 表示每 250 毫秒打印一次，总共打印 7 次。 这对于防止因为应用代码中直接使用 native 库或者第三方的一些监控工具的内存泄漏有非常大的帮助。\n\n# "GC task thread#0 (ParallelGC)"\n\n垃圾回收线程，该线程会负责进行垃圾回收。通常 JVM 会启动多个线程来处理这个工作，线程名称中#后面的数字也会累加。\n\n"GC task thread#0 (ParallelGC)" prio=5 tid=0x00007fc6b480d000 nid=0x2503 runnable\n\n"GC task thread#1 (ParallelGC)" prio=5 tid=0x00007fc6b2812000 nid=0x2703 runnable\n\n"GC task thread#2 (ParallelGC)" prio=5 tid=0x00007fc6b2812800 nid=0x2903 runnable\n\n"GC task thread#3 (ParallelGC)" prio=5 tid=0x00007fc6b2813000 nid=0x2b03 runnable\n\n\n如果在 JVM 中增加了 -XX:+UseConcMarkSweepGC 参数将会启用 CMS （Concurrent Mark-Sweep）GC Thread 方式，以下是该模式下的线程类型：\n\n# "Gang worker#0 (Parallel GC Threads)"\n\n原来垃圾回收线程 GC task thread#0 (ParallelGC) 被替换为 Gang worker#0 (Parallel GC Threads)。Gang worker 是 JVM 用于年轻代垃圾回收(minor gc)的线程。\n\n"Gang worker#0 (Parallel GC Threads)" prio=10 tid=0x00007fbea801b800 nid=0x5e4 runnable\n\n"Gang worker#1 (Parallel GC Threads)" prio=10 tid=0x00007fbea801d800 nid=0x5e7 runnable\n\n\n# "Concurrent Mark-Sweep GC Thread"\n\n并发标记清除垃圾回收器（就是通常所说的 CMS GC）线程， 该线程主要针对于年老代垃圾回收。\n\n"Concurrent Mark-Sweep GC Thread" prio=10 tid=0x00007fbea8073800 nid=0x5e8 runnable\n\n\n# "Surrogate Locker Thread (Concurrent GC)"\n\n此线程主要配合 CMS 垃圾回收器来使用，是一个守护线程，主要负责处理 GC 过程中 Java 层的 Reference（指软引用、弱引用等等）与 jvm 内部层面的对象状态同步。\n\n"Surrogate Locker Thread (Concurrent GC)" daemon prio=10 tid=0x00007fbea8158800 nid=0x5ee waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n\n这里以 WeakHashMap 为例进行说明，首先是一个关键点：\n\n * WeakHashMap 和 HashMap 一样，内部有一个 Entry[]数组;\n * WeakHashMap 的 Entry 比较特殊，它的继承体系结构为 Entry->WeakReference->Reference;\n * Reference 里面有一个全局锁对象：Lock，它也被称为 pending_lock，注意：它是静态对象；\n * Reference 里面有一个静态变量：pending；\n * Reference 里面有一个静态内部类：ReferenceHandler 的线程，它在 static 块里面被初始化并且启动，启动完成后处于 wait 状态，它在一个 Lock 同步锁模块中等待；\n * WeakHashMap 里面还实例化了一个 ReferenceQueue 列队\n\n假设，WeakHashMap 对象里面已经保存了很多对象的引用，JVM 在进行 CMS GC 的时候会创建一个 ConcurrentMarkSweepThread（简称 CMST）线程去进行 GC。ConcurrentMarkSweepThread 线程被创建的同时会创建一个 SurrogateLockerThread（简称 SLT）线程并且启动它，SLT 启动之后，处于等待阶段。 CMST 开始 GC 时，会发一个消息给 SLT 让它去获取 Java 层 Reference 对象的全局锁：Lock。直到 CMS GC 完毕之后，JVM 会将 WeakHashMap 中所有被回收的对象所属的 WeakReference 容器对象放入到 Reference 的 pending 属性当中（每次 GC 完毕之后，pending 属性基本上都不会为 null 了），然后通知 SLT 释放并且 notify 全局锁:Lock。此时激活了 ReferenceHandler 线程的 run 方法，使其脱离 wait 状态，开始工作了。 ReferenceHandler 这个线程会将 pending 中的所有 WeakReference 对象都移动到它们各自的列队当中，比如当前这个 WeakReference 属于某个 WeakHashMap 对象，那么它就会被放入相应的 ReferenceQueue 列队里面（该列队是链表结构）。 当我们下次从 WeakHashMap 对象里面 get、put 数据或者调用 size 方法的时候，WeakHashMap 就会将 ReferenceQueue 列队中的 WeakReference 依依 poll 出来去和 Entry[]数据做比较，如果发现相同的，则说明这个 Entry 所保存的对象已经被 GC 掉了，那么将 Entry[]内的 Entry 对象剔除掉。\n\n# 第五部分：JNI global references count\n\n这一部分主要回收那些在 native 代码上被引用，但在 java 代码中却没有存活必要的引用，对于防止因为应用代码中直接使用 native 库或第三方的一些监控工具的内存泄漏有非常大的帮助。\n\nJNI global references: 830\n\n\n下一篇文章将要讲述一个直接找出 CPU 100% 线程的例子。\n\n\n# 系统线程状态\n\n系统线程有如下状态：\n\n# deadlock\n\n死锁线程，一般指多个线程调用期间进入了相互资源占用，导致一直等待无法释放的情况。\n\n【示例】deadlock 示例\n\n"DEADLOCK_TEST-1" daemon prio=6 tid=0x000000000690f800 nid=0x1820 waiting for monitor entry [0x000000000805f000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)\n                - waiting to lock <0x00000007d58f5e60> (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)\n                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)\n                - locked <0x00000007d58f5e48> (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)\n                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)\n\n   Locked ownable synchronizers:\n                - None\n\n"DEADLOCK_TEST-2" daemon prio=6 tid=0x0000000006858800 nid=0x17b8 waiting for monitor entry [0x000000000815f000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)\n                - waiting to lock <0x00000007d58f5e78> (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)\n                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)\n                - locked <0x00000007d58f5e60> (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)\n                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)\n\n   Locked ownable synchronizers:\n                - None\n\n"DEADLOCK_TEST-3" daemon prio=6 tid=0x0000000006859000 nid=0x25dc waiting for monitor entry [0x000000000825f000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)\n                - waiting to lock <0x00000007d58f5e48> (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)\n                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)\n                - locked <0x00000007d58f5e78> (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)\n                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)\n\n   Locked ownable synchronizers:\n                - None\n\n\n# runnable\n\n一般指该线程正在执行状态中，该线程占用了资源，正在处理某个操作，如通过 SQL 语句查询数据库、对某个文件进行写入等。\n\n# blocked\n\n线程正处于阻塞状态，指当前线程执行过程中，所需要的资源长时间等待却一直未能获取到，被容器的线程管理器标识为阻塞状态，可以理解为等待资源超时的线程。\n\n【示例】blocked 示例\n\n"BLOCKED_TEST pool-1-thread-2" prio=6 tid=0x0000000007673800 nid=0x260c waiting for monitor entry [0x0000000008abf000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n                at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:43)\n                - waiting to lock <0x0000000780a000b0> (a com.nbp.theplatform.threaddump.ThreadBlockedState)\n                at com.nbp.theplatform.threaddump.ThreadBlockedState$2.run(ThreadBlockedState.java:26)\n                at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n                at java.lang.Thread.run(Thread.java:662)\n   Locked ownable synchronizers:\n                - <0x0000000780b0c6a0> (a java.util.concurrent.locks.ReentrantLock$NonfairSync)\n"BLOCKED_TEST pool-1-thread-3" prio=6 tid=0x00000000074f5800 nid=0x1994 waiting for monitor entry [0x0000000008bbf000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n                at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:42)\n                - waiting to lock <0x0000000780a000b0> (a com.nbp.theplatform.threaddump.ThreadBlockedState)\n                at com.nbp.theplatform.threaddump.ThreadBlockedState$3.run(ThreadBlockedState.java:34)\n                at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886\n                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n                at java.lang.Thread.run(Thread.java:662)\n   Locked ownable synchronizers:\n                - <0x0000000780b0e1b8> (a java.util.concurrent.locks.ReentrantLock$NonfairSync)\n\n\n# waiting on condition\n\n线程正处于等待资源或等待某个条件的发生，具体的原因需要结合下面堆栈信息进行分析。\n\n（1）如果堆栈信息明确是应用代码，则证明该线程正在等待资源，一般是大量读取某种资源且该资源采用了资源锁的情况下，线程进入等待状态，等待资源的读取，或者正在等待其他线程的执行等。\n\n（2）如果发现有大量的线程都正处于这种状态，并且堆栈信息中得知正等待网络读写，这是因为网络阻塞导致线程无法执行，很有可能是一个网络瓶颈的征兆：\n\n * 网络非常繁忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；\n\n * 网络可能是空闲的，但由于路由或防火墙等原因，导致包无法正常到达；\n\n所以一定要结合系统的一些性能观察工具进行综合分析，比如 netstat 统计单位时间的发送包的数量，看是否很明显超过了所在网络带宽的限制；观察 CPU 的利用率，看系统态的 CPU 时间是否明显大于用户态的 CPU 时间。这些都指向由于网络带宽所限导致的网络瓶颈。\n\n（3）还有一种常见的情况是该线程在 sleep，等待 sleep 的时间到了，将被唤醒。\n\n【示例】等待状态样例\n\n "IoWaitThread" prio=6 tid=0x0000000007334800 nid=0x2b3c waiting on condition [0x000000000893f000]\n   java.lang.Thread.State: WAITING (parking)\n                at sun.misc.Unsafe.park(Native Method)\n                - parking to wait for  <0x00000007d5c45850> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n                at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156)\n                at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1987)\n                at java.util.concurrent.LinkedBlockingDeque.takeFirst(LinkedBlockingDeque.java:440)\n                at java.util.concurrent.LinkedBlockingDeque.take(LinkedBlockingDeque.java:629)\n                at com.nbp.theplatform.threaddump.ThreadIoWaitState$IoWaitHandler2.run(ThreadIoWaitState.java:89)\n                at java.lang.Thread.run(Thread.java:662)\n\n\n# waiting for monitor entry 或 in Object.wait()\n\nMoniter 是 Java 中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 class 的锁，每个对象都有，也仅有一个 Monitor。\n\n\n\n从上图可以看出，每个 Monitor 在某个时刻只能被一个线程拥有，该线程就是 "Active Thread"，而其他线程都是 "Waiting Thread"，分别在两个队列 "Entry Set"和"Waint Set"里面等待。其中在 "Entry Set" 中等待的线程状态是 waiting for monitor entry，在 "Wait Set" 中等待的线程状态是 in Object.wait()。\n\n（1）"Entry Set"里面的线程。\n\n我们称被 synchronized 保护起来的代码段为临界区，对应的代码如下：\n\nsynchronized(obj) {\n}\n\n\n当一个线程申请进入临界区时，它就进入了 "Entry Set" 队列中，这时候有两种可能性：\n\n * 该 Monitor 不被其他线程拥有，"Entry Set"里面也没有其他等待的线程。本线程即成为相应类或者对象的 Monitor 的 Owner，执行临界区里面的代码；此时在 Thread Dump 中显示线程处于 "Runnable" 状态。\n * 该 Monitor 被其他线程拥有，本线程在 "Entry Set" 队列中等待。此时在 Thread Dump 中显示线程处于 "waiting for monity entry" 状态。\n\n临界区的设置是为了保证其内部的代码执行的原子性和完整性，但因为临界区在任何时间只允许线程串行通过，这和我们使用多线程的初衷是相反的。如果在多线程程序中大量使用 synchronized，或者不适当的使用它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在 Thread Dump 中发现这个情况，应该审视源码并对其进行改进。\n\n（2）"Wait Set"里面的线程\n\n当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（通常是被 synchronized 的对象）的 wait()方法，放弃 Monitor，进入 "Wait Set"队列。只有当别的线程在该对象上调用了 notify()或者 notifyAll()方法，"Wait Set"队列中的线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到运行态。"Wait Set"中的线程在 Thread Dump 中显示的状态为 in Object.wait()。通常来说，当 CPU 很忙的时候关注 Runnable 状态的线程，反之则关注 waiting for monitor entry 状态的线程。\n\n\n# jstack 使用示例\n\n# 找出某 Java 进程中最耗费 CPU 的 Java 线程\n\n（1）找出 Java 进程\n\n假设应用名称为 myapp：\n\n$ jps | grep myapp\n29527 myapp.jar\n\n\n得到进程 ID 为 21711\n\n（2）找出该进程内最耗费 CPU 的线程，可以使用 ps -Lfp pid 或者 ps -mp pid -o THREAD, tid, time 或者 top -Hp pid\n\nTIME 列就是各个 Java 线程耗费的 CPU 时间，CPU 时间最长的是线程 ID 为 21742 的线程，用\n\nprintf "%x\\n" 21742\n\n\n得到 21742 的十六进制值为 54ee，下面会用到。\n\n（3）使用 jstack 打印线程堆栈信息\n\n下一步终于轮到 jstack 上场了，它用来输出进程 21711 的堆栈信息，然后根据线程 ID 的十六进制值 grep，如下：\n\n$ jstack 21711 | grep 54ee\n"PollIntervalRetrySchedulerThread" prio=10 tid=0x00007f950043e000 nid=0x54ee in Object.wait() [0x00007f94c6eda000]\n\n\n可以看到 CPU 消耗在 PollIntervalRetrySchedulerThread 这个类的 Object.wait()。\n\n> 注：上面的例子中，默认只显示了一行信息，但很多时候我们希望查看更详细的调用栈。可以通过指定 -A <num> 的方式来显示行数。例如：jstack -l <pid> | grep <thread-hex-id> -A 10\n\n（4）分析代码\n\n我找了下我的代码，定位到下面的代码：\n\n// Idle wait\ngetLog().info("Thread [" + getName() + "] is idle waiting...");\nschedulerThreadState = PollTaskSchedulerThreadState.IdleWaiting;\nlong now = System.currentTimeMillis();\nlong waitTime = now + getIdleWaitTime();\nlong timeUntilContinue = waitTime - now;\nsynchronized(sigLock) {\n\ttry {\n    \tif(!halted.get()) {\n    \t\tsigLock.wait(timeUntilContinue);\n    \t}\n    }\n\tcatch (InterruptedException ignore) {\n    }\n}\n\n\n它是轮询任务的空闲等待代码，上面的 sigLock.wait(timeUntilContinue) 就对应了前面的 Object.wait()。\n\n# 生成 threaddump 文件\n\n可以使用 jstack -l <pid> > <file-path> 命令生成 threaddump 文件\n\n【示例】生成进程 ID 为 8841 的 Java 进程的 threaddump 文件。\n\njstack -l 8841 > /home/threaddump.txt\n\n\n\n# jinfo\n\n> jinfo(JVM Configuration info)，是 Java 配置信息工具。jinfo 用于实时查看和调整虚拟机运行参数。如传递给 Java 虚拟机的-X（即输出中的 jvm_args）、-XX参数（即输出中的 VM Flags），以及可在 Java 层面通过System.getProperty获取的-D参数（即输出中的 System Properties）。\n\n之前的 jps -v 口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用 jinfo 口令。\n\njinfo 命令格式：\n\njinfo [option] pid\n\n\noption 选项参数：\n\n * -flag - 输出指定 args 参数的值\n * -sysprops - 输出系统属性，等同于 System.getProperties()\n\n【示例】jinfo 使用示例\n\n$ jinfo -sysprops 29527\nAttaching to process ID 29527, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.222-b10\n...\n\n\n\n# jhat\n\n> jhat(JVM Heap Analysis Tool)，是虚拟机堆转储快照分析工具。jhat 与 jmap 搭配使用，用来分析 jmap 生成的 dump 文件。jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看。\n> \n> 注意：一般不会直接在服务器上进行分析，因为 jhat 是一个耗时并且耗费硬件资源的过程，一般把服务器生成的 dump 文件，用 jvisualvm 、Eclipse Memory Analyzer、IBM HeapAnalyzer 等工具来分析。\n\n命令格式：\n\njhat [dumpfile]\n\n\n\n# 参考资料\n\n * 《深入理解 Java 虚拟机》\n * 《Java 性能调优实战》\n * JVM 性能调优监控工具 jps、jstack、jmap、jhat、jstat、hprof 使用详解\n * jconsole 官方文档\n * jconsole 工具使用\n * jstat 命令查看 jvm 的 GC 情况\n * 利用内存分析工具（Memory Analyzer Tool，MAT）分析 java 项目内存泄露\n * JVM 故障分析及性能优化系列之一：使用 jstack 定位线程堆栈信息',normalizedContent:'# jvm 命令行工具\n\n> java 程序员免不了故障排查工作，所以经常需要使用一些 jvm 工具。\n> \n> jdk 自带了一些实用的命令行工具来监控、分析 jvm 信息，掌握它们，非常有助于 troubleshooting。\n\n以下是较常用的 jdk 命令行工具：\n\n名称       描述\njps      jvm 进程状态工具。显示系统内的所有 jvm 进程。\njstat    jvm 统计监控工具。监控虚拟机运行时状态信息，它可以显示出 jvm 进程中的类装载、内存、gc、jit\n         编译等运行数据。\njmap     jvm 堆内存分析工具。用于打印 jvm 进程对象直方图、类加载统计。并且可以生成堆转储快照（一般称为 heapdump\n         或 dump 文件）。\njstack   jvm 栈查看工具。用于打印 jvm 进程的线程和锁的情况。并且可以生成线程快照（一般称为 threaddump 或\n         javacore 文件）。\njhat     用来分析 jmap 生成的 dump 文件。\njinfo    jvm 信息查看工具。用于实时查看和调整 jvm 进程参数。\njcmd     jvm 命令行调试 工具。用于向 jvm 进程发送调试命令。\n\n\n# jps\n\n> jps(jvm process status tool) 是虚拟机进程状态工具。它可以显示指定系统内所有的 hotspot 虚拟机进程状态信息。jps 通过 rmi 协议查询开启了 rmi 服务的远程虚拟机进程状态。\n\n\n# jps 命令用法\n\njps [option] [hostid]\njps [-help]\n\n\n如果不指定 hostid 就默认为当前主机或服务器。\n\n常用参数：\n\n * option - 选项参数\n   * -m - 输出 jvm 启动时传递给 main() 的参数。\n   * -l - 输出主类的全名，如果进程执行的是 jar 包，输出 jar 路径。\n   * -v - 显示传递给 jvm 的参数。\n   * -q - 仅输出本地 jvm 进程 id。\n   * -v - 仅输出本地 jvm 标识符。\n * hostid - rmi 注册表中注册的主机名。如果不指定 hostid 就默认为当前主机或服务器。\n\n其中 option、hostid 参数也可以不写。\n\n\n# jps 使用示例\n\n【示例】列出本地 java 进程\n\n$ jps\n18027 java2demo.jar\n18032 jps\n18005 jstat\n\n\n【示例】列出本地 java 进程 id\n\n$ jps -q\n8841\n1292\n5398\n\n\n【示例】列出本地 java 进程 id，并输出主类的全名，如果进程执行的是 jar 包，输出 jar 路径\n\n$ jps -l remote.domain\n3002 /opt/jdk1.7.0/demo/jfc/java2d/java2demo.jar\n2857 sun.tools.jstatd.jstatd\n\n\n\n# jstat\n\n> jstat(jvm statistics monitoring)，是虚拟机统计信息监视工具。jstat 用于监视虚拟机运行时状态信息，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、jit 编译等运行数据。\n\n\n# jstat 命令用法\n\n命令格式：\n\njstat [option] vmid [interval] [count]\n\n\n常用参数：\n\n * option - 选项参数，用于指定用户需要查询的虚拟机信息\n   * -class - 监视类装载、卸载数量、总空间以及类装载所耗费的时间\n   * -compiler：显示 jit 编译的相关信息；\n   * -gc：监视 java 堆状况，包括 eden 区、两个 survivor 区、老年代、永久代等区的容量、已用空间、gc 时间合计等信息。\n   * -gccapacity：显示各个代的容量以及使用情况；\n   * -gcmetacapacity：显示 metaspace 的大小；\n   * -gcnew：显示新生代信息；\n   * -gcnewcapacity：显示新生代大小和使用情况；\n   * -gcold：显示老年代和永久代的信息；\n   * -gcoldcapacity：显示老年代的大小；\n   * -gcutil：显示垃圾回收统计信息；\n   * -gccause：显示垃圾回收的相关信息（通 -gcutil），同时显示最后一次或当前正在发生的垃圾回收的诱因；\n   * -printcompilation：输出 jit 编译的方法信息。\n * vmid - 如果是本地虚拟机进程，则 vmid 与 lvmid 是一致的；如果是远程虚拟机进程，那 vmid 的格式应当是：[protocol:][//]lvmid[@hostname[:port]/servername]\n * interval - 查询间隔\n * count - 查询次数\n\n> 【参考】更详细说明可以参考：jstat 命令查看 jvm 的 gc 情况\n\n\n# jstat 使用示例\n\n# 类加载统计\n\n使用 jstat -class pid 命令可以查看编译统计信息。\n\n【参数】\n\n * loaded - 加载 class 的数量\n * bytes - 所占用空间大小\n * unloaded - 未加载数量\n * bytes - 未加载占用空间\n * time - 时间\n\n【示例】查看类加载信息\n\n$ jstat -class 7129\nloaded  bytes  unloaded  bytes     time\n 26749 50405.3      873  1216.8      19.75\n\n\n# 编译统计\n\n使用 jstat -compiler pid 命令可以查看编译统计信息。\n\n【示例】\n\n$ jstat -compiler 7129\ncompiled failed invalid   time   failedtype failedmethod\n   42030      2       0   302.53          1 org/apache/felix/framework/bundlewiringimpl$bundleclassloader findclass\n\n\n【参数】\n\n * compiled - 编译数量\n * failed - 失败数量\n * invalid - 不可用数量\n * time - 时间\n * failedtype - 失败类型\n * failedmethod - 失败的方法\n\n# gc 统计\n\n使用 jstat -gc pid time 命令可以查看 gc 统计信息。\n\n【示例】以 250 毫秒的间隔进行 7 个采样，并显示-gcutil 选项指定的输出。\n\n$ jstat -gcutil 21891 250 7\n  s0     s1     e      o      m     ccs    ygc     ygct    fgc    fgct     gct\n  0.00  97.02  70.31  66.80  95.52  89.14      7    0.300     0    0.000    0.300\n  0.00  97.02  86.23  66.80  95.52  89.14      7    0.300     0    0.000    0.300\n  0.00  97.02  96.53  66.80  95.52  89.14      7    0.300     0    0.000    0.300\n 91.03   0.00   1.98  68.19  95.89  91.24      8    0.378     0    0.000    0.378\n 91.03   0.00  15.82  68.19  95.89  91.24      8    0.378     0    0.000    0.378\n 91.03   0.00  17.80  68.19  95.89  91.24      8    0.378     0    0.000    0.378\n 91.03   0.00  17.80  68.19  95.89  91.24      8    0.378     0    0.000    0.378\n\n\n【示例】以 1 秒的间隔进行 4 个采样，并显示-gc 选项指定的输出。\n\n$ jstat -gc 25196 1s 4\n s0c    s1c    s0u    s1u      ec       eu        oc         ou       mc     mu    ccsc   ccsu   ygc     ygct    fgc    fgct     gct\n20928.0 20928.0  0.0    0.0   167936.0  8880.5   838912.0   80291.2   106668.0 100032.1 12772.0 11602.2    760   14.332  580   656.218  670.550\n20928.0 20928.0  0.0    0.0   167936.0  8880.5   838912.0   80291.2   106668.0 100032.1 12772.0 11602.2    760   14.332  580   656.218  670.550\n20928.0 20928.0  0.0    0.0   167936.0  8880.5   838912.0   80291.2   106668.0 100032.1 12772.0 11602.2    760   14.332  580   656.218  670.550\n20928.0 20928.0  0.0    0.0   167936.0  8880.5   838912.0   80291.2   106668.0 100032.1 12772.0 11602.2    760   14.332  580   656.218  670.550\n\n\n参数说明：\n\n * s0c：年轻代中 to survivor 的容量（单位 kb）；\n * s1c：年轻代中 from survivor 的容量（单位 kb）；\n * s0u：年轻代中 to survivor 目前已使用空间（单位 kb）；\n * s1u：年轻代中 from survivor 目前已使用空间（单位 kb）；\n * ec：年轻代中 eden 的容量（单位 kb）；\n * eu：年轻代中 eden 目前已使用空间（单位 kb）；\n * oc：old 代的容量（单位 kb）；\n * ou：old 代目前已使用空间（单位 kb）；\n * mc：metaspace 的容量（单位 kb）；\n * mu：metaspace 目前已使用空间（单位 kb）；\n * ygc：从应用程序启动到采样时年轻代中 gc 次数；\n * ygct：从应用程序启动到采样时年轻代中 gc 所用时间 (s)；\n * fgc：从应用程序启动到采样时 old 代（全 gc）gc 次数；\n * fgct：从应用程序启动到采样时 old 代（全 gc）gc 所用时间 (s)；\n * gct：从应用程序启动到采样时 gc 用的总时间 (s)。\n\n> 注：更详细的参数含义可以参考官方文档：http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html\n\n\n# jmap\n\n> jmap(jvm memory map) 是 java 内存映像工具。jmap 用于生成堆转储快照（一般称为 heapdump 或 dump 文件）。jmap 不仅能生成 dump 文件，还可以查询 finalize 执行队列、java 堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。\n> \n> 如果不使用这个命令，还可以使用 -xx:+heapdumponoutofmemoryerror 参数来让虚拟机出现 oom 的时候，自动生成 dump 文件。\n\n\n# jmap 命令用法\n\n命令格式：\n\njmap [option] pid\n\n\noption 选项参数：\n\n * -dump - 生成堆转储快照。-dump:live 只保存堆中的存活对象。\n * -finalizerinfo - 显示在 f-queue 队列等待执行 finalizer 方法的对象\n * -heap - 显示 java 堆详细信息。\n * -histo - 显示堆中对象的统计信息，包括类、实例数量、合计容量。-histo:live 只统计堆中的存活对象。\n * -permstat - to print permanent generation statistics\n * -f - 当-dump 没有响应时，强制生成 dump 快照\n\n\n# jstat 使用示例\n\n# 生成 heapdump 快照\n\ndump 堆到文件，format 指定输出格式，live 指明是活着的对象，file 指定文件名\n\n$ jmap -dump:live,format=b,file=dump.hprof 28920\ndumping heap to /home/xxx/dump.hprof ...\nheap dump file created\n\n\ndump.hprof 这个后缀是为了后续可以直接用 mat(memory anlysis tool)等工具打开。\n\n# 查看实例数最多的类\n\n$ jmap -histo 29527 | head -n 6\n\n num     #instances         #bytes  class name\n----------------------------------------------\n   1:      13673280     1438961864  [c\n   2:       1207166      411277184  [i\n   3:       7382322      347307096  [ljava.lang.object;\n\n\n# 查看指定进程的堆信息\n\n注意：使用 cms gc 情况下，jmap -heap pid 的执行有可能会导致 java 进程挂起。\n\n$ jmap -heap 12379\nattaching to process id 12379, please wait...\ndebugger attached successfully.\nserver compiler detected.\njvm version is 17.0-b16\n\nusing thread-local object allocation.\nparallel gc with 6 thread(s)\n\nheap configuration:\n   minheapfreeratio = 40\n   maxheapfreeratio = 70\n   maxheapsize      = 83886080 (80.0mb)\n   newsize          = 1310720 (1.25mb)\n   maxnewsize       = 17592186044415 mb\n   oldsize          = 5439488 (5.1875mb)\n   newratio         = 2\n   survivorratio    = 8\n   permsize         = 20971520 (20.0mb)\n   maxpermsize      = 88080384 (84.0mb)\n\nheap usage:\nps young generation\neden space:\n   capacity = 9306112 (8.875mb)\n   used     = 5375360 (5.1263427734375mb)\n   free     = 3930752 (3.7486572265625mb)\n   57.761608714788736% used\nfrom space:\n   capacity = 9306112 (8.875mb)\n   used     = 3425240 (3.2665634155273438mb)\n   free     = 5880872 (5.608436584472656mb)\n   36.80634834397007% used\nto space:\n   capacity = 9306112 (8.875mb)\n   used     = 0 (0.0mb)\n   free     = 9306112 (8.875mb)\n   0.0% used\nps old generation\n   capacity = 55967744 (53.375mb)\n   used     = 48354640 (46.11457824707031mb)\n   free     = 7613104 (7.2604217529296875mb)\n   86.39733629427693% used\nps perm generation\n   capacity = 62062592 (59.1875mb)\n   used     = 60243112 (57.452308654785156mb)\n   free     = 1819480 (1.7351913452148438mb)\n   97.06831451706046% used\n\n\n\n# jstack\n\n> jstack(stack trace for java) 是 java 堆栈跟踪工具。jstack 用来打印目标 java 进程中各个线程的栈轨迹，以及这些线程所持有的锁，并可以生成 java 虚拟机当前时刻的线程快照（一般称为 threaddump 或 javacore 文件）。\n> \n> 线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。\n\njstack 通常会结合 top -hp pid 或 pidstat -p pid -t 一起查看具体线程的状态，也经常用来排查一些死锁的异常。\n\n线程出现停顿的时候通过 jstack 来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果 java 程序崩溃生成 core 文件，jstack 工具可以用来获得 core 文件的 java stack 和 native stack 的信息，从而可以轻松地知道 java 程序是如何崩溃和在程序何处发生问题。另外，jstack 工具还可以附属到正在运行的 java 程序中，看到当时运行的 java 程序的 java stack 和 native stack 的信息, 如果现在运行的 java 程序呈现 hung 的状态，jstack 是非常有用的。\n\n\n# jstack 命令用法\n\n命令格式：\n\njstack [option] pid\n\n\noption 选项参数\n\n * -f - 当正常输出请求不被响应时，强制输出线程堆栈\n * -l - 除堆栈外，显示关于锁的附加信息\n * -m - 打印 java 和 jni 框架的所有栈信息\n\n\n# thread dump 文件\n\n\n\n一个 thread dump 文件大致可以分为五个部分。\n\n# 第一部分：full thread dump identifier\n\n这一部分是内容最开始的部分，展示了快照文件的生成时间和 jvm 的版本信息。\n\n2017-10-19 10:46:44\nfull thread dump java hotspot(tm) 64-bit server vm (24.79-b02 mixed mode):\n\n\n# 第二部分：java ee middleware, third party & custom application threads\n\n这是整个文件的核心部分，里面展示了 javaee 容器（如 tomcat、resin 等）、自己的程序中所使用的线程信息。\n\n"resin-22129" daemon prio=10 tid=0x00007fbe5c34e000 nid=0x4cb1 waiting on condition [0x00007fbe4ff7c000]\n   java.lang.thread.state: waiting (parking)\n    at sun.misc.unsafe.park(native method)\n    at java.util.concurrent.locks.locksupport.park(locksupport.java:315)\n    at com.caucho.env.thread2.resinthread2.park(resinthread2.java:196)\n    at com.caucho.env.thread2.resinthread2.runtasks(resinthread2.java:147)\n    at com.caucho.env.thread2.resinthread2.run(resinthread2.java:118)\n\n\n参数说明：\n\n * "resin-22129" **线程名称：**如果使用 java.lang.thread 类生成一个线程的时候，线程名称为 thread-(数字) 的形式，这里是 resin 生成的线程；\n * daemon **线程类型：**线程分为守护线程 (daemon) 和非守护线程 (non-daemon) 两种，通常都是守护线程；\n * prio=10 **线程优先级：**默认为 5，数字越大优先级越高；\n * tid=0x00007fbe5c34e000 **jvm 线程的 id：**jvm 内部线程的唯一标识，通过 java.lang.thread.getid()获取，通常用自增的方式实现；\n * nid=0x4cb1 **系统线程 id：**对应的系统线程 id（native thread id)，可以通过 top 命令进行查看，现场 id 是十六进制的形式；\n * waiting on condition **系统线程状态：**这里是系统的线程状态；\n * [0x00007fbe4ff7c000] **起始栈地址：**线程堆栈调用的其实内存地址；\n * java.lang.thread.state: waiting (parking) **jvm 线程状态：**这里标明了线程在代码级别的状态。\n * **线程调用栈信息：**下面就是当前线程调用的详细栈信息，用于代码的分析。堆栈信息应该从下向上解读，因为程序调用的顺序是从下向上的。\n\n# 第三部分：hotspot vm thread\n\n这一部分展示了 jvm 内部线程的信息，用于执行内部的原生操作。下面常见的集中内置线程：\n\n# "attach listener"\n\n该线程负责接收外部命令，执行该命令并把结果返回给调用者，此种类型的线程通常在桌面程序中出现。\n\n"attach listener" daemon prio=5 tid=0x00007fc6b6800800 nid=0x3b07 waiting on condition [0x0000000000000000]\n   java.lang.thread.state: runnable\n\n\n# "destroyjavavm"\n\n执行 main() 的线程在执行完之后调用 jni 中的 jni_destroyjavavm() 方法会唤起 destroyjavavm 线程，处于等待状态，等待其它线程（java 线程和 native 线程）退出时通知它卸载 jvm。\n\n"destroyjavavm" prio=5 tid=0x00007fc6b3001000 nid=0x1903 waiting on condition [0x0000000000000000]\n   java.lang.thread.state: runnable\n\n\n# "service thread"\n\n用于启动服务的线程\n\n"service thread" daemon prio=10 tid=0x00007fbea81b3000 nid=0x5f2 runnable [0x0000000000000000]\n   java.lang.thread.state: runnable\n\n\n# "compilerthread"\n\n用来调用 jiting，实时编译装卸类。通常 jvm 会启动多个线程来处理这部分工作，线程名称后面的数字也会累加，比如 compilerthread1。\n\n"c2 compilerthread1" daemon prio=10 tid=0x00007fbea814b000 nid=0x5f1 waiting on condition [0x0000000000000000]\n   java.lang.thread.state: runnable\n\n"c2 compilerthread0" daemon prio=10 tid=0x00007fbea8142000 nid=0x5f0 waiting on condition [0x0000000000000000]\n   java.lang.thread.state: runnable\n\n\n# "signal dispatcher"\n\nattach listener 线程的职责是接收外部 jvm 命令，当命令接收成功后，会交给 signal dispather 线程去进行分发到各个不同的模块处理命令，并且返回处理结果。 signal dispather 线程也是在第一次接收外部 jvm 命令时，进行初始化工作。\n\n"signal dispatcher" daemon prio=10 tid=0x00007fbea81bf800 nid=0x5ef runnable [0x0000000000000000]\n   java.lang.thread.state: runnable\n\n\n# "finalizer"\n\n这个线程也是在 main 线程之后创建的，其优先级为 10，主要用于在垃圾收集前，调用对象的 finalize() 方法；关于 finalizer 线程的几点：\n\n * 只有当开始一轮垃圾收集时，才会开始调用 finalize()方法；因此并不是所有对象的 finalize()方法都会被执行；\n * 该线程也是 daemon 线程，因此如果虚拟机中没有其他非 daemon 线程，不管该线程有没有执行完 finalize()方法，jvm 也会退出；\n * jvm 在垃圾收集时会将失去引用的对象包装成 finalizer 对象（reference 的实现），并放入 referencequeue，由 finalizer 线程来处理；最后将该 finalizer 对象的引用置为 null，由垃圾收集器来回收；\n\njvm 为什么要单独用一个线程来执行 finalize() 方法呢？\n\n如果 jvm 的垃圾收集线程自己来做，很有可能由于在 finalize()方法中误操作导致 gc 线程停止或不可控，这对 gc 线程来说是一种灾难。\n\n"finalizer" daemon prio=10 tid=0x00007fbea80da000 nid=0x5eb in object.wait() [0x00007fbeac044000]\n   java.lang.thread.state: waiting (on object monitor)\n    at java.lang.object.wait(native method)\n    at java.lang.ref.referencequeue.remove(referencequeue.java:135)\n    - locked <0x00000006d173c1a8> (a java.lang.ref.referencequeue$lock)\n    at java.lang.ref.referencequeue.remove(referencequeue.java:151)\n    at java.lang.ref.finalizer$finalizerthread.run(finalizer.java:209)\n\n\n# "reference handler"\n\njvm 在创建 main 线程后就创建 reference handler 线程，其优先级最高，为 10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。\n\n"reference handler" daemon prio=10 tid=0x00007fbea80d8000 nid=0x5ea in object.wait() [0x00007fbeac085000]\n   java.lang.thread.state: waiting (on object monitor)\n    at java.lang.object.wait(native method)\n    at java.lang.object.wait(object.java:503)\n    at java.lang.ref.reference$referencehandler.run(reference.java:133)\n    - locked <0x00000006d173c1f0> (a java.lang.ref.reference$lock)\n\n\n# "vm thread"\n\njvm 中线程的母体，根据 hotspot 源码中关于 vmthread.hpp 里面的注释，它是一个单例的对象（最原始的线程）会产生或触发所有其他的线程，这个单例的 vm 线程是会被其他线程所使用来做一些 vm 操作（如清扫垃圾等）。 在 vm thread 的结构体里有一个 vmoperationqueue 列队，所有的 vm 线程操作(vm_operation)都会被保存到这个列队当中，vmthread 本身就是一个线程，它的线程负责执行一个自轮询的 loop 函数(具体可以参考：vmthread.cpp 里面的 void vmthread::loop()) ，该 loop 函数从 vmoperationqueue 列队中按照优先级取出当前需要执行的操作对象(vm_operation)，并且调用 vm_operation->evaluate 函数去执行该操作类型本身的业务逻辑。 vm 操作类型被定义在 vm_operations.hpp 文件内，列举几个：threadstop、threaddump、printthreads、gencollectfull、gencollectfullconcurrent、cms_initial_mark、cms_final_remark….. 有兴趣的同学，可以自己去查看源文件。\n\n"vm thread" prio=10 tid=0x00007fbea80d3800 nid=0x5e9 runnable\n\n\n# 第四部分：hotspot gc thread\n\njvm 中用于进行资源回收的线程，包括以下几种类型的线程：\n\n# "vm periodic task thread"\n\n该线程是 jvm 周期性任务调度的线程，它由 watcherthread 创建，是一个单例对象。该线程在 jvm 内使用得比较频繁，比如：定期的内存监控、jvm 运行状况监控。\n\n"vm periodic task thread" prio=10 tid=0x00007fbea82ae800 nid=0x5fa waiting on condition\n\n\n可以使用 jstat 命令查看 gc 的情况，比如查看某个进程没有存活必要的引用可以使用命令 jstat -gcutil 250 7 参数中 pid 是进程 id，后面的 250 和 7 表示每 250 毫秒打印一次，总共打印 7 次。 这对于防止因为应用代码中直接使用 native 库或者第三方的一些监控工具的内存泄漏有非常大的帮助。\n\n# "gc task thread#0 (parallelgc)"\n\n垃圾回收线程，该线程会负责进行垃圾回收。通常 jvm 会启动多个线程来处理这个工作，线程名称中#后面的数字也会累加。\n\n"gc task thread#0 (parallelgc)" prio=5 tid=0x00007fc6b480d000 nid=0x2503 runnable\n\n"gc task thread#1 (parallelgc)" prio=5 tid=0x00007fc6b2812000 nid=0x2703 runnable\n\n"gc task thread#2 (parallelgc)" prio=5 tid=0x00007fc6b2812800 nid=0x2903 runnable\n\n"gc task thread#3 (parallelgc)" prio=5 tid=0x00007fc6b2813000 nid=0x2b03 runnable\n\n\n如果在 jvm 中增加了 -xx:+useconcmarksweepgc 参数将会启用 cms （concurrent mark-sweep）gc thread 方式，以下是该模式下的线程类型：\n\n# "gang worker#0 (parallel gc threads)"\n\n原来垃圾回收线程 gc task thread#0 (parallelgc) 被替换为 gang worker#0 (parallel gc threads)。gang worker 是 jvm 用于年轻代垃圾回收(minor gc)的线程。\n\n"gang worker#0 (parallel gc threads)" prio=10 tid=0x00007fbea801b800 nid=0x5e4 runnable\n\n"gang worker#1 (parallel gc threads)" prio=10 tid=0x00007fbea801d800 nid=0x5e7 runnable\n\n\n# "concurrent mark-sweep gc thread"\n\n并发标记清除垃圾回收器（就是通常所说的 cms gc）线程， 该线程主要针对于年老代垃圾回收。\n\n"concurrent mark-sweep gc thread" prio=10 tid=0x00007fbea8073800 nid=0x5e8 runnable\n\n\n# "surrogate locker thread (concurrent gc)"\n\n此线程主要配合 cms 垃圾回收器来使用，是一个守护线程，主要负责处理 gc 过程中 java 层的 reference（指软引用、弱引用等等）与 jvm 内部层面的对象状态同步。\n\n"surrogate locker thread (concurrent gc)" daemon prio=10 tid=0x00007fbea8158800 nid=0x5ee waiting on condition [0x0000000000000000]\n   java.lang.thread.state: runnable\n\n\n这里以 weakhashmap 为例进行说明，首先是一个关键点：\n\n * weakhashmap 和 hashmap 一样，内部有一个 entry[]数组;\n * weakhashmap 的 entry 比较特殊，它的继承体系结构为 entry->weakreference->reference;\n * reference 里面有一个全局锁对象：lock，它也被称为 pending_lock，注意：它是静态对象；\n * reference 里面有一个静态变量：pending；\n * reference 里面有一个静态内部类：referencehandler 的线程，它在 static 块里面被初始化并且启动，启动完成后处于 wait 状态，它在一个 lock 同步锁模块中等待；\n * weakhashmap 里面还实例化了一个 referencequeue 列队\n\n假设，weakhashmap 对象里面已经保存了很多对象的引用，jvm 在进行 cms gc 的时候会创建一个 concurrentmarksweepthread（简称 cmst）线程去进行 gc。concurrentmarksweepthread 线程被创建的同时会创建一个 surrogatelockerthread（简称 slt）线程并且启动它，slt 启动之后，处于等待阶段。 cmst 开始 gc 时，会发一个消息给 slt 让它去获取 java 层 reference 对象的全局锁：lock。直到 cms gc 完毕之后，jvm 会将 weakhashmap 中所有被回收的对象所属的 weakreference 容器对象放入到 reference 的 pending 属性当中（每次 gc 完毕之后，pending 属性基本上都不会为 null 了），然后通知 slt 释放并且 notify 全局锁:lock。此时激活了 referencehandler 线程的 run 方法，使其脱离 wait 状态，开始工作了。 referencehandler 这个线程会将 pending 中的所有 weakreference 对象都移动到它们各自的列队当中，比如当前这个 weakreference 属于某个 weakhashmap 对象，那么它就会被放入相应的 referencequeue 列队里面（该列队是链表结构）。 当我们下次从 weakhashmap 对象里面 get、put 数据或者调用 size 方法的时候，weakhashmap 就会将 referencequeue 列队中的 weakreference 依依 poll 出来去和 entry[]数据做比较，如果发现相同的，则说明这个 entry 所保存的对象已经被 gc 掉了，那么将 entry[]内的 entry 对象剔除掉。\n\n# 第五部分：jni global references count\n\n这一部分主要回收那些在 native 代码上被引用，但在 java 代码中却没有存活必要的引用，对于防止因为应用代码中直接使用 native 库或第三方的一些监控工具的内存泄漏有非常大的帮助。\n\njni global references: 830\n\n\n下一篇文章将要讲述一个直接找出 cpu 100% 线程的例子。\n\n\n# 系统线程状态\n\n系统线程有如下状态：\n\n# deadlock\n\n死锁线程，一般指多个线程调用期间进入了相互资源占用，导致一直等待无法释放的情况。\n\n【示例】deadlock 示例\n\n"deadlock_test-1" daemon prio=6 tid=0x000000000690f800 nid=0x1820 waiting for monitor entry [0x000000000805f000]\n   java.lang.thread.state: blocked (on object monitor)\n                at com.nbp.theplatform.threaddump.threaddeadlockstate$deadlockthread.gomonitordeadlock(threaddeadlockstate.java:197)\n                - waiting to lock <0x00000007d58f5e60> (a com.nbp.theplatform.threaddump.threaddeadlockstate$monitor)\n                at com.nbp.theplatform.threaddump.threaddeadlockstate$deadlockthread.monitorourlock(threaddeadlockstate.java:182)\n                - locked <0x00000007d58f5e48> (a com.nbp.theplatform.threaddump.threaddeadlockstate$monitor)\n                at com.nbp.theplatform.threaddump.threaddeadlockstate$deadlockthread.run(threaddeadlockstate.java:135)\n\n   locked ownable synchronizers:\n                - none\n\n"deadlock_test-2" daemon prio=6 tid=0x0000000006858800 nid=0x17b8 waiting for monitor entry [0x000000000815f000]\n   java.lang.thread.state: blocked (on object monitor)\n                at com.nbp.theplatform.threaddump.threaddeadlockstate$deadlockthread.gomonitordeadlock(threaddeadlockstate.java:197)\n                - waiting to lock <0x00000007d58f5e78> (a com.nbp.theplatform.threaddump.threaddeadlockstate$monitor)\n                at com.nbp.theplatform.threaddump.threaddeadlockstate$deadlockthread.monitorourlock(threaddeadlockstate.java:182)\n                - locked <0x00000007d58f5e60> (a com.nbp.theplatform.threaddump.threaddeadlockstate$monitor)\n                at com.nbp.theplatform.threaddump.threaddeadlockstate$deadlockthread.run(threaddeadlockstate.java:135)\n\n   locked ownable synchronizers:\n                - none\n\n"deadlock_test-3" daemon prio=6 tid=0x0000000006859000 nid=0x25dc waiting for monitor entry [0x000000000825f000]\n   java.lang.thread.state: blocked (on object monitor)\n                at com.nbp.theplatform.threaddump.threaddeadlockstate$deadlockthread.gomonitordeadlock(threaddeadlockstate.java:197)\n                - waiting to lock <0x00000007d58f5e48> (a com.nbp.theplatform.threaddump.threaddeadlockstate$monitor)\n                at com.nbp.theplatform.threaddump.threaddeadlockstate$deadlockthread.monitorourlock(threaddeadlockstate.java:182)\n                - locked <0x00000007d58f5e78> (a com.nbp.theplatform.threaddump.threaddeadlockstate$monitor)\n                at com.nbp.theplatform.threaddump.threaddeadlockstate$deadlockthread.run(threaddeadlockstate.java:135)\n\n   locked ownable synchronizers:\n                - none\n\n\n# runnable\n\n一般指该线程正在执行状态中，该线程占用了资源，正在处理某个操作，如通过 sql 语句查询数据库、对某个文件进行写入等。\n\n# blocked\n\n线程正处于阻塞状态，指当前线程执行过程中，所需要的资源长时间等待却一直未能获取到，被容器的线程管理器标识为阻塞状态，可以理解为等待资源超时的线程。\n\n【示例】blocked 示例\n\n"blocked_test pool-1-thread-2" prio=6 tid=0x0000000007673800 nid=0x260c waiting for monitor entry [0x0000000008abf000]\n   java.lang.thread.state: blocked (on object monitor)\n                at com.nbp.theplatform.threaddump.threadblockedstate.monitorlock(threadblockedstate.java:43)\n                - waiting to lock <0x0000000780a000b0> (a com.nbp.theplatform.threaddump.threadblockedstate)\n                at com.nbp.theplatform.threaddump.threadblockedstate$2.run(threadblockedstate.java:26)\n                at java.util.concurrent.threadpoolexecutor$worker.runtask(threadpoolexecutor.java:886)\n                at java.util.concurrent.threadpoolexecutor$worker.run(threadpoolexecutor.java:908)\n                at java.lang.thread.run(thread.java:662)\n   locked ownable synchronizers:\n                - <0x0000000780b0c6a0> (a java.util.concurrent.locks.reentrantlock$nonfairsync)\n"blocked_test pool-1-thread-3" prio=6 tid=0x00000000074f5800 nid=0x1994 waiting for monitor entry [0x0000000008bbf000]\n   java.lang.thread.state: blocked (on object monitor)\n                at com.nbp.theplatform.threaddump.threadblockedstate.monitorlock(threadblockedstate.java:42)\n                - waiting to lock <0x0000000780a000b0> (a com.nbp.theplatform.threaddump.threadblockedstate)\n                at com.nbp.theplatform.threaddump.threadblockedstate$3.run(threadblockedstate.java:34)\n                at java.util.concurrent.threadpoolexecutor$worker.runtask(threadpoolexecutor.java:886\n                at java.util.concurrent.threadpoolexecutor$worker.run(threadpoolexecutor.java:908)\n                at java.lang.thread.run(thread.java:662)\n   locked ownable synchronizers:\n                - <0x0000000780b0e1b8> (a java.util.concurrent.locks.reentrantlock$nonfairsync)\n\n\n# waiting on condition\n\n线程正处于等待资源或等待某个条件的发生，具体的原因需要结合下面堆栈信息进行分析。\n\n（1）如果堆栈信息明确是应用代码，则证明该线程正在等待资源，一般是大量读取某种资源且该资源采用了资源锁的情况下，线程进入等待状态，等待资源的读取，或者正在等待其他线程的执行等。\n\n（2）如果发现有大量的线程都正处于这种状态，并且堆栈信息中得知正等待网络读写，这是因为网络阻塞导致线程无法执行，很有可能是一个网络瓶颈的征兆：\n\n * 网络非常繁忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；\n\n * 网络可能是空闲的，但由于路由或防火墙等原因，导致包无法正常到达；\n\n所以一定要结合系统的一些性能观察工具进行综合分析，比如 netstat 统计单位时间的发送包的数量，看是否很明显超过了所在网络带宽的限制；观察 cpu 的利用率，看系统态的 cpu 时间是否明显大于用户态的 cpu 时间。这些都指向由于网络带宽所限导致的网络瓶颈。\n\n（3）还有一种常见的情况是该线程在 sleep，等待 sleep 的时间到了，将被唤醒。\n\n【示例】等待状态样例\n\n "iowaitthread" prio=6 tid=0x0000000007334800 nid=0x2b3c waiting on condition [0x000000000893f000]\n   java.lang.thread.state: waiting (parking)\n                at sun.misc.unsafe.park(native method)\n                - parking to wait for  <0x00000007d5c45850> (a java.util.concurrent.locks.abstractqueuedsynchronizer$conditionobject)\n                at java.util.concurrent.locks.locksupport.park(locksupport.java:156)\n                at java.util.concurrent.locks.abstractqueuedsynchronizer$conditionobject.await(abstractqueuedsynchronizer.java:1987)\n                at java.util.concurrent.linkedblockingdeque.takefirst(linkedblockingdeque.java:440)\n                at java.util.concurrent.linkedblockingdeque.take(linkedblockingdeque.java:629)\n                at com.nbp.theplatform.threaddump.threadiowaitstate$iowaithandler2.run(threadiowaitstate.java:89)\n                at java.lang.thread.run(thread.java:662)\n\n\n# waiting for monitor entry 或 in object.wait()\n\nmoniter 是 java 中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 class 的锁，每个对象都有，也仅有一个 monitor。\n\n\n\n从上图可以看出，每个 monitor 在某个时刻只能被一个线程拥有，该线程就是 "active thread"，而其他线程都是 "waiting thread"，分别在两个队列 "entry set"和"waint set"里面等待。其中在 "entry set" 中等待的线程状态是 waiting for monitor entry，在 "wait set" 中等待的线程状态是 in object.wait()。\n\n（1）"entry set"里面的线程。\n\n我们称被 synchronized 保护起来的代码段为临界区，对应的代码如下：\n\nsynchronized(obj) {\n}\n\n\n当一个线程申请进入临界区时，它就进入了 "entry set" 队列中，这时候有两种可能性：\n\n * 该 monitor 不被其他线程拥有，"entry set"里面也没有其他等待的线程。本线程即成为相应类或者对象的 monitor 的 owner，执行临界区里面的代码；此时在 thread dump 中显示线程处于 "runnable" 状态。\n * 该 monitor 被其他线程拥有，本线程在 "entry set" 队列中等待。此时在 thread dump 中显示线程处于 "waiting for monity entry" 状态。\n\n临界区的设置是为了保证其内部的代码执行的原子性和完整性，但因为临界区在任何时间只允许线程串行通过，这和我们使用多线程的初衷是相反的。如果在多线程程序中大量使用 synchronized，或者不适当的使用它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在 thread dump 中发现这个情况，应该审视源码并对其进行改进。\n\n（2）"wait set"里面的线程\n\n当线程获得了 monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（通常是被 synchronized 的对象）的 wait()方法，放弃 monitor，进入 "wait set"队列。只有当别的线程在该对象上调用了 notify()或者 notifyall()方法，"wait set"队列中的线程才得到机会去竞争，但是只有一个线程获得对象的 monitor，恢复到运行态。"wait set"中的线程在 thread dump 中显示的状态为 in object.wait()。通常来说，当 cpu 很忙的时候关注 runnable 状态的线程，反之则关注 waiting for monitor entry 状态的线程。\n\n\n# jstack 使用示例\n\n# 找出某 java 进程中最耗费 cpu 的 java 线程\n\n（1）找出 java 进程\n\n假设应用名称为 myapp：\n\n$ jps | grep myapp\n29527 myapp.jar\n\n\n得到进程 id 为 21711\n\n（2）找出该进程内最耗费 cpu 的线程，可以使用 ps -lfp pid 或者 ps -mp pid -o thread, tid, time 或者 top -hp pid\n\ntime 列就是各个 java 线程耗费的 cpu 时间，cpu 时间最长的是线程 id 为 21742 的线程，用\n\nprintf "%x\\n" 21742\n\n\n得到 21742 的十六进制值为 54ee，下面会用到。\n\n（3）使用 jstack 打印线程堆栈信息\n\n下一步终于轮到 jstack 上场了，它用来输出进程 21711 的堆栈信息，然后根据线程 id 的十六进制值 grep，如下：\n\n$ jstack 21711 | grep 54ee\n"pollintervalretryschedulerthread" prio=10 tid=0x00007f950043e000 nid=0x54ee in object.wait() [0x00007f94c6eda000]\n\n\n可以看到 cpu 消耗在 pollintervalretryschedulerthread 这个类的 object.wait()。\n\n> 注：上面的例子中，默认只显示了一行信息，但很多时候我们希望查看更详细的调用栈。可以通过指定 -a <num> 的方式来显示行数。例如：jstack -l <pid> | grep <thread-hex-id> -a 10\n\n（4）分析代码\n\n我找了下我的代码，定位到下面的代码：\n\n// idle wait\ngetlog().info("thread [" + getname() + "] is idle waiting...");\nschedulerthreadstate = polltaskschedulerthreadstate.idlewaiting;\nlong now = system.currenttimemillis();\nlong waittime = now + getidlewaittime();\nlong timeuntilcontinue = waittime - now;\nsynchronized(siglock) {\n\ttry {\n    \tif(!halted.get()) {\n    \t\tsiglock.wait(timeuntilcontinue);\n    \t}\n    }\n\tcatch (interruptedexception ignore) {\n    }\n}\n\n\n它是轮询任务的空闲等待代码，上面的 siglock.wait(timeuntilcontinue) 就对应了前面的 object.wait()。\n\n# 生成 threaddump 文件\n\n可以使用 jstack -l <pid> > <file-path> 命令生成 threaddump 文件\n\n【示例】生成进程 id 为 8841 的 java 进程的 threaddump 文件。\n\njstack -l 8841 > /home/threaddump.txt\n\n\n\n# jinfo\n\n> jinfo(jvm configuration info)，是 java 配置信息工具。jinfo 用于实时查看和调整虚拟机运行参数。如传递给 java 虚拟机的-x（即输出中的 jvm_args）、-xx参数（即输出中的 vm flags），以及可在 java 层面通过system.getproperty获取的-d参数（即输出中的 system properties）。\n\n之前的 jps -v 口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用 jinfo 口令。\n\njinfo 命令格式：\n\njinfo [option] pid\n\n\noption 选项参数：\n\n * -flag - 输出指定 args 参数的值\n * -sysprops - 输出系统属性，等同于 system.getproperties()\n\n【示例】jinfo 使用示例\n\n$ jinfo -sysprops 29527\nattaching to process id 29527, please wait...\ndebugger attached successfully.\nserver compiler detected.\njvm version is 25.222-b10\n...\n\n\n\n# jhat\n\n> jhat(jvm heap analysis tool)，是虚拟机堆转储快照分析工具。jhat 与 jmap 搭配使用，用来分析 jmap 生成的 dump 文件。jhat 内置了一个微型的 http/html 服务器，生成 dump 的分析结果后，可以在浏览器中查看。\n> \n> 注意：一般不会直接在服务器上进行分析，因为 jhat 是一个耗时并且耗费硬件资源的过程，一般把服务器生成的 dump 文件，用 jvisualvm 、eclipse memory analyzer、ibm heapanalyzer 等工具来分析。\n\n命令格式：\n\njhat [dumpfile]\n\n\n\n# 参考资料\n\n * 《深入理解 java 虚拟机》\n * 《java 性能调优实战》\n * jvm 性能调优监控工具 jps、jstack、jmap、jhat、jstat、hprof 使用详解\n * jconsole 官方文档\n * jconsole 工具使用\n * jstat 命令查看 jvm 的 gc 情况\n * 利用内存分析工具（memory analyzer tool，mat）分析 java 项目内存泄露\n * jvm 故障分析及性能优化系列之一：使用 jstack 定位线程堆栈信息',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"JVM GUI 工具",frontmatter:{title:"JVM GUI 工具",categories:["编程","Java","JavaSE","JVM"],tags:["Java","JavaSE","JVM","GUI"],abbrlink:"5cc5921a",date:"2020-07-30T17:56:33.000Z",permalink:"/pages/08ac9d/"},regularPath:"/06.JVM/12.JVM_GUI%E5%B7%A5%E5%85%B7.html",relativePath:"06.JVM/12.JVM_GUI工具.md",key:"v-f2b27b04",path:"/pages/08ac9d/",headers:[{level:2,title:"jconsole",slug:"jconsole",normalizedTitle:"jconsole",charIndex:88},{level:3,title:"开启 JMX",slug:"开启-jmx",normalizedTitle:"开启 jmx",charIndex:313},{level:3,title:"连接 jconsole",slug:"连接-jconsole",normalizedTitle:"连接 jconsole",charIndex:742},{level:3,title:"jconsole 界面",slug:"jconsole-界面",normalizedTitle:"jconsole 界面",charIndex:831},{level:2,title:"jvisualvm",slug:"jvisualvm",normalizedTitle:"jvisualvm",charIndex:365},{level:3,title:"jvisualvm 概述页面",slug:"jvisualvm-概述页面",normalizedTitle:"jvisualvm 概述页面",charIndex:1207},{level:3,title:"jvisualvm 监控页面",slug:"jvisualvm-监控页面",normalizedTitle:"jvisualvm 监控页面",charIndex:1289},{level:3,title:"jvisualvm 线程页面",slug:"jvisualvm-线程页面",normalizedTitle:"jvisualvm 线程页面",charIndex:1362},{level:3,title:"jvisualvm 抽样器页面",slug:"jvisualvm-抽样器页面",normalizedTitle:"jvisualvm 抽样器页面",charIndex:1453},{level:2,title:"MAT",slug:"mat",normalizedTitle:"mat",charIndex:1513},{level:3,title:"MAT 配置",slug:"mat-配置",normalizedTitle:"mat 配置",charIndex:1710},{level:3,title:"MAT 分析",slug:"mat-分析",normalizedTitle:"mat 分析",charIndex:2025},{level:2,title:"JProfile",slug:"jprofile",normalizedTitle:"jprofile",charIndex:2549},{level:2,title:"Arthas",slug:"arthas",normalizedTitle:"arthas",charIndex:2645},{level:3,title:"Arthas 基础命令",slug:"arthas-基础命令",normalizedTitle:"arthas 基础命令",charIndex:2821},{level:3,title:"Arthas jvm 相关命令",slug:"arthas-jvm-相关命令",normalizedTitle:"arthas jvm 相关命令",charIndex:3312},{level:3,title:"Arthas class/classloader 相关命令",slug:"arthas-class-classloader-相关命令",normalizedTitle:"arthas class/classloader 相关命令",charIndex:3685},{level:3,title:"Arthas monitor/watch/trace 相关命令",slug:"arthas-monitor-watch-trace-相关命令",normalizedTitle:"arthas monitor/watch/trace 相关命令",charIndex:3972},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4282}],headersStr:"jconsole 开启 JMX 连接 jconsole jconsole 界面 jvisualvm jvisualvm 概述页面 jvisualvm 监控页面 jvisualvm 线程页面 jvisualvm 抽样器页面 MAT MAT 配置 MAT 分析 JProfile Arthas Arthas 基础命令 Arthas jvm 相关命令 Arthas class/classloader 相关命令 Arthas monitor/watch/trace 相关命令 参考资料",content:'# JVM GUI 工具\n\n> Java 程序员免不了故障排查工作，所以经常需要使用一些 JVM 工具。\n> \n> 本文系统性的介绍一下常用的 JVM GUI 工具。\n\n\n# jconsole\n\n> jconsole 是 JDK 自带的 GUI 工具。jconsole(Java Monitoring and Management Console) 是一种基于 JMX 的可视化监视与管理工具。\n> \n> jconsole 的管理功能是针对 JMX MBean 进行管理，由于 MBean 可以使用代码、中间件服务器的管理控制台或所有符合 JMX 规范的软件进行访问。\n\n注意：使用 jconsole 的前提是 Java 应用开启 JMX。\n\n\n# 开启 JMX\n\nJava 应用开启 JMX 后，可以使用 jconsole 或 jvisualvm 进行监控 Java 程序的基本信息和运行情况。\n\n开启方法是，在 java 指令后，添加以下参数：\n\n-Dcom.sun.management.jmxremote=true\n-Dcom.sun.management.jmxremote.ssl=false\n-Dcom.sun.management.jmxremote.authenticate=false\n-Djava.rmi.server.hostname=127.0.0.1\n-Dcom.sun.management.jmxremote.port=18888\n\n\n * -Djava.rmi.server.hostname - 指定 Java 程序运行的服务器\n * -Dcom.sun.management.jmxremote.port - 指定 JMX 服务监听端口\n\n\n# 连接 jconsole\n\n如果是本地 Java 进程，jconsole 可以直接绑定连接。\n\n如果是远程 Java 进程，需要连接 Java 进程的 JMX 端口。\n\n\n\n\n# jconsole 界面\n\n进入 jconsole 应用后，可以看到以下 tab 页面。\n\n * 概述 - 显示有关 Java VM 和监视值的概述信息。\n * 内存 - 显示有关内存使用的信息。内存页相当于可视化的 jstat 命令。\n * 线程 - 显示有关线程使用的信息。\n * 类 - 显示有关类加载的信息。\n * VM 摘要 - 显示有关 Java VM 的信息。\n * MBean - 显示有关 MBean 的信息。\n\n\n\n\n# jvisualvm\n\n> jvisualvm 是 JDK 自带的 GUI 工具。jvisualvm(All-In-One Java Troubleshooting Tool) 是多合一故障处理工具。它支持运行监视、故障处理、性能分析等功能。\n\n个人觉得 jvisualvm 比 jconsole 好用。\n\n\n# jvisualvm 概述页面\n\njvisualvm 概述页面可以查看当前 Java 进程的基本信息，如：JDK 版本、Java 进程、JVM 参数等。\n\n\n\n\n# jvisualvm 监控页面\n\n在 jvisualvm 监控页面，可以看到 Java 进程的 CPU、内存、类加载、线程的实时变化。\n\n\n\n\n# jvisualvm 线程页面\n\njvisualvm 线程页面展示了当前的线程状态。\n\n\n\njvisualvm 还可以生成线程 Dump 文件，帮助进一步分析线程栈信息。\n\n\n\n\n# jvisualvm 抽样器页面\n\njvisualvm 可以对 CPU、内存进行抽样，帮助我们进行性能分析。\n\n\n\n\n# MAT\n\nMAT 即 Eclipse Memory Analyzer Tool 的缩写。\n\nMAT 本身也能够获取堆的二进制快照。该功能将借助 jps 列出当前正在运行的 Java 进程，以供选择并获取快照。由于 jps 会将自己列入其中，因此你会在列表中发现一个已经结束运行的 jps 进程。\n\nMAT 可以独立安装（官方下载地址），也可以作为 Eclipse IDE 的插件安装。\n\n\n# MAT 配置\n\nMAT 解压后，安装目录下有个 MemoryAnalyzer.ini 文件。\n\nMemoryAnalyzer.ini 中有个重要的参数 Xmx 表示最大内存，默认为：-vmargs -Xmx1024m\n\n如果试图用 MAT 导入的 dump 文件超过 1024 M，会报错：\n\nAn internal error occurred during: "Parsing heap dump from XXX"\n\n\n此时，可以适当调整 Xmx 大小。如果设置的 Xmx 数值过大，本机内存不足以支撑，启动 MAT 会报错：\n\nFailed to create the Java Virtual Machine\n\n\n\n# MAT 分析\n\n\n\n点击 Leak Suspects 可以进入内存泄漏页面。\n\n（1）首先，可以查看饼图了解内存的整体消耗情况\n\n\n\n（2）缩小范围，寻找问题疑似点\n\n\n\n可以点击进入详情页面，在详情页面 Shortest Paths To the Accumulation Point 表示 GC root 到内存消耗聚集点的最短路径，如果某个内存消耗聚集点有路径到达 GC root，则该内存消耗聚集点不会被当做垃圾被回收。\n\n为了找到内存泄露，我获取了两个堆转储文件，两个文件获取时间间隔是一天（因为内存只是小幅度增长，短时间很难发现问题）。对比两个文件的对象，通过对比后的结果可以很方便定位内存泄露。\n\nMAT 同时打开两个堆转储文件，分别打开 Histogram，如下图。在下图中方框 1 按钮用于对比两个 Histogram，对比后在方框 2 处选择 Group By package，然后对比各对象的变化。不难发现 heap3.hprof 比 heap6.hprof 少了 64 个 eventInfo 对象，如果对代码比较熟悉的话想必这样一个结果是能够给程序员一定的启示的。而我也是根据这个启示差找到了最终内存泄露的位置。\n\n\n# JProfile\n\nJProfiler 是一款性能分析工具。\n\n由于它是收费的，所以我本人使用较少。但是，它确实功能强大，且方便使用，还可以和 Intellij Idea 集成。\n\n\n\n\n# Arthas\n\nArthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪 Java 代码；实时监控 JVM 状态。\n\nArthas 支持 JDK 6+，支持 Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。\n\n\n\n\n# Arthas 基础命令\n\n * help——查看命令帮助信息\n * cat——打印文件内容，和 linux 里的 cat 命令类似\n * echo–打印参数，和 linux 里的 echo 命令类似\n * grep——匹配查找，和 linux 里的 grep 命令类似\n * tee——复制标准输入到标准输出和指定的文件，和 linux 里的 tee 命令类似\n * pwd——返回当前的工作目录，和 linux 命令类似\n * cls——清空当前屏幕区域\n * session——查看当前会话的信息\n * reset——重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端关闭时会重置所有增强过的类\n * version——输出当前目标 Java 进程所加载的 Arthas 版本号\n * history——打印命令历史\n * quit——退出当前 Arthas 客户端，其他 Arthas 客户端不受影响\n * stop——关闭 Arthas 服务端，所有 Arthas 客户端全部退出\n * keymap——Arthas 快捷键列表及自定义快捷键\n\n\n# Arthas jvm 相关命令\n\n * dashboard——当前系统的实时数据面板\n * thread——查看当前 JVM 的线程堆栈信息\n * jvm——查看当前 JVM 的信息\n * sysprop——查看和修改 JVM 的系统属性\n * sysenv——查看 JVM 的环境变量\n * vmoption——查看和修改 JVM 里诊断相关的 option\n * perfcounter——查看当前 JVM 的 Perf Counter 信息\n * logger——查看和修改 logger\n * getstatic——查看类的静态属性\n * ognl——执行 ognl 表达式\n * mbean——查看 Mbean 的信息\n * heapdump——dump java heap, 类似 jmap 命令的 heap dump 功能\n\n\n# Arthas class/classloader 相关命令\n\n * sc——查看 JVM 已加载的类信息\n * sm——查看已加载类的方法信息\n * jad——反编译指定已加载类的源码\n * mc——内存编译器，内存编译.java文件为.class文件\n * redefine——加载外部的.class文件，redefine 到 JVM 里\n * dump——dump 已加载类的 byte code 到特定目录\n * classloader——查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getResource\n\n\n# Arthas monitor/watch/trace 相关命令\n\n> 请注意，这些命令，都通过字节码增强技术来实现的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此在线上、预发使用时，请尽量明确需要观测的类、方法以及条件，诊断结束要执行 stop 或将增强过的类执行 reset 命令。\n\n * monitor——方法执行监控\n * watch——方法执行数据观测\n * trace——方法内部调用路径，并输出方法路径上的每个节点上耗时\n * stack——输出当前方法被调用的调用路径\n * tt——方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测\n\n\n# 参考资料\n\n * 《深入理解 Java 虚拟机》\n * 《Java 性能调优实战》\n * jconsole 官方文档\n * jconsole 工具使用\n * jvisualvm 官方文档\n * Java jvisualvm 简要说明\n * 利用内存分析工具（Memory Analyzer Tool，MAT）分析 java 项目内存泄露',normalizedContent:'# jvm gui 工具\n\n> java 程序员免不了故障排查工作，所以经常需要使用一些 jvm 工具。\n> \n> 本文系统性的介绍一下常用的 jvm gui 工具。\n\n\n# jconsole\n\n> jconsole 是 jdk 自带的 gui 工具。jconsole(java monitoring and management console) 是一种基于 jmx 的可视化监视与管理工具。\n> \n> jconsole 的管理功能是针对 jmx mbean 进行管理，由于 mbean 可以使用代码、中间件服务器的管理控制台或所有符合 jmx 规范的软件进行访问。\n\n注意：使用 jconsole 的前提是 java 应用开启 jmx。\n\n\n# 开启 jmx\n\njava 应用开启 jmx 后，可以使用 jconsole 或 jvisualvm 进行监控 java 程序的基本信息和运行情况。\n\n开启方法是，在 java 指令后，添加以下参数：\n\n-dcom.sun.management.jmxremote=true\n-dcom.sun.management.jmxremote.ssl=false\n-dcom.sun.management.jmxremote.authenticate=false\n-djava.rmi.server.hostname=127.0.0.1\n-dcom.sun.management.jmxremote.port=18888\n\n\n * -djava.rmi.server.hostname - 指定 java 程序运行的服务器\n * -dcom.sun.management.jmxremote.port - 指定 jmx 服务监听端口\n\n\n# 连接 jconsole\n\n如果是本地 java 进程，jconsole 可以直接绑定连接。\n\n如果是远程 java 进程，需要连接 java 进程的 jmx 端口。\n\n\n\n\n# jconsole 界面\n\n进入 jconsole 应用后，可以看到以下 tab 页面。\n\n * 概述 - 显示有关 java vm 和监视值的概述信息。\n * 内存 - 显示有关内存使用的信息。内存页相当于可视化的 jstat 命令。\n * 线程 - 显示有关线程使用的信息。\n * 类 - 显示有关类加载的信息。\n * vm 摘要 - 显示有关 java vm 的信息。\n * mbean - 显示有关 mbean 的信息。\n\n\n\n\n# jvisualvm\n\n> jvisualvm 是 jdk 自带的 gui 工具。jvisualvm(all-in-one java troubleshooting tool) 是多合一故障处理工具。它支持运行监视、故障处理、性能分析等功能。\n\n个人觉得 jvisualvm 比 jconsole 好用。\n\n\n# jvisualvm 概述页面\n\njvisualvm 概述页面可以查看当前 java 进程的基本信息，如：jdk 版本、java 进程、jvm 参数等。\n\n\n\n\n# jvisualvm 监控页面\n\n在 jvisualvm 监控页面，可以看到 java 进程的 cpu、内存、类加载、线程的实时变化。\n\n\n\n\n# jvisualvm 线程页面\n\njvisualvm 线程页面展示了当前的线程状态。\n\n\n\njvisualvm 还可以生成线程 dump 文件，帮助进一步分析线程栈信息。\n\n\n\n\n# jvisualvm 抽样器页面\n\njvisualvm 可以对 cpu、内存进行抽样，帮助我们进行性能分析。\n\n\n\n\n# mat\n\nmat 即 eclipse memory analyzer tool 的缩写。\n\nmat 本身也能够获取堆的二进制快照。该功能将借助 jps 列出当前正在运行的 java 进程，以供选择并获取快照。由于 jps 会将自己列入其中，因此你会在列表中发现一个已经结束运行的 jps 进程。\n\nmat 可以独立安装（官方下载地址），也可以作为 eclipse ide 的插件安装。\n\n\n# mat 配置\n\nmat 解压后，安装目录下有个 memoryanalyzer.ini 文件。\n\nmemoryanalyzer.ini 中有个重要的参数 xmx 表示最大内存，默认为：-vmargs -xmx1024m\n\n如果试图用 mat 导入的 dump 文件超过 1024 m，会报错：\n\nan internal error occurred during: "parsing heap dump from xxx"\n\n\n此时，可以适当调整 xmx 大小。如果设置的 xmx 数值过大，本机内存不足以支撑，启动 mat 会报错：\n\nfailed to create the java virtual machine\n\n\n\n# mat 分析\n\n\n\n点击 leak suspects 可以进入内存泄漏页面。\n\n（1）首先，可以查看饼图了解内存的整体消耗情况\n\n\n\n（2）缩小范围，寻找问题疑似点\n\n\n\n可以点击进入详情页面，在详情页面 shortest paths to the accumulation point 表示 gc root 到内存消耗聚集点的最短路径，如果某个内存消耗聚集点有路径到达 gc root，则该内存消耗聚集点不会被当做垃圾被回收。\n\n为了找到内存泄露，我获取了两个堆转储文件，两个文件获取时间间隔是一天（因为内存只是小幅度增长，短时间很难发现问题）。对比两个文件的对象，通过对比后的结果可以很方便定位内存泄露。\n\nmat 同时打开两个堆转储文件，分别打开 histogram，如下图。在下图中方框 1 按钮用于对比两个 histogram，对比后在方框 2 处选择 group by package，然后对比各对象的变化。不难发现 heap3.hprof 比 heap6.hprof 少了 64 个 eventinfo 对象，如果对代码比较熟悉的话想必这样一个结果是能够给程序员一定的启示的。而我也是根据这个启示差找到了最终内存泄露的位置。\n\n\n# jprofile\n\njprofiler 是一款性能分析工具。\n\n由于它是收费的，所以我本人使用较少。但是，它确实功能强大，且方便使用，还可以和 intellij idea 集成。\n\n\n\n\n# arthas\n\narthas 是 alibaba 开源的 java 诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪 java 代码；实时监控 jvm 状态。\n\narthas 支持 jdk 6+，支持 linux/mac/windows，采用命令行交互模式，同时提供丰富的 tab 自动补全功能，进一步方便进行问题的定位和诊断。\n\n\n\n\n# arthas 基础命令\n\n * help——查看命令帮助信息\n * cat——打印文件内容，和 linux 里的 cat 命令类似\n * echo–打印参数，和 linux 里的 echo 命令类似\n * grep——匹配查找，和 linux 里的 grep 命令类似\n * tee——复制标准输入到标准输出和指定的文件，和 linux 里的 tee 命令类似\n * pwd——返回当前的工作目录，和 linux 命令类似\n * cls——清空当前屏幕区域\n * session——查看当前会话的信息\n * reset——重置增强类，将被 arthas 增强过的类全部还原，arthas 服务端关闭时会重置所有增强过的类\n * version——输出当前目标 java 进程所加载的 arthas 版本号\n * history——打印命令历史\n * quit——退出当前 arthas 客户端，其他 arthas 客户端不受影响\n * stop——关闭 arthas 服务端，所有 arthas 客户端全部退出\n * keymap——arthas 快捷键列表及自定义快捷键\n\n\n# arthas jvm 相关命令\n\n * dashboard——当前系统的实时数据面板\n * thread——查看当前 jvm 的线程堆栈信息\n * jvm——查看当前 jvm 的信息\n * sysprop——查看和修改 jvm 的系统属性\n * sysenv——查看 jvm 的环境变量\n * vmoption——查看和修改 jvm 里诊断相关的 option\n * perfcounter——查看当前 jvm 的 perf counter 信息\n * logger——查看和修改 logger\n * getstatic——查看类的静态属性\n * ognl——执行 ognl 表达式\n * mbean——查看 mbean 的信息\n * heapdump——dump java heap, 类似 jmap 命令的 heap dump 功能\n\n\n# arthas class/classloader 相关命令\n\n * sc——查看 jvm 已加载的类信息\n * sm——查看已加载类的方法信息\n * jad——反编译指定已加载类的源码\n * mc——内存编译器，内存编译.java文件为.class文件\n * redefine——加载外部的.class文件，redefine 到 jvm 里\n * dump——dump 已加载类的 byte code 到特定目录\n * classloader——查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getresource\n\n\n# arthas monitor/watch/trace 相关命令\n\n> 请注意，这些命令，都通过字节码增强技术来实现的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此在线上、预发使用时，请尽量明确需要观测的类、方法以及条件，诊断结束要执行 stop 或将增强过的类执行 reset 命令。\n\n * monitor——方法执行监控\n * watch——方法执行数据观测\n * trace——方法内部调用路径，并输出方法路径上的每个节点上耗时\n * stack——输出当前方法被调用的调用路径\n * tt——方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测\n\n\n# 参考资料\n\n * 《深入理解 java 虚拟机》\n * 《java 性能调优实战》\n * jconsole 官方文档\n * jconsole 工具使用\n * jvisualvm 官方文档\n * java jvisualvm 简要说明\n * 利用内存分析工具（memory analyzer tool，mat）分析 java 项目内存泄露',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"JVM 实战",frontmatter:{title:"JVM 实战",categories:["编程","Java","JavaSE","JVM"],tags:["Java","JavaSE","JVM"],abbrlink:"629fb135",date:"2019-10-28T22:04:39.000Z",permalink:"/pages/e12478/"},regularPath:"/06.JVM/21.JVM%E5%AE%9E%E6%88%98.html",relativePath:"06.JVM/21.JVM实战.md",key:"v-7c58f187",path:"/pages/e12478/",headers:[{level:2,title:"JVM 调优概述",slug:"jvm-调优概述",normalizedTitle:"jvm 调优概述",charIndex:13},{level:3,title:"GC 性能指标",slug:"gc-性能指标",normalizedTitle:"gc 性能指标",charIndex:26},{level:3,title:"调优原则",slug:"调优原则",normalizedTitle:"调优原则",charIndex:387},{level:4,title:"降低 Minor GC 频率",slug:"降低-minor-gc-频率",normalizedTitle:"降低 minor gc 频率",charIndex:535},{level:4,title:"降低 Full GC 的频率",slug:"降低-full-gc-的频率",normalizedTitle:"降低 full gc 的频率",charIndex:409},{level:4,title:"降低 Full GC 的时间",slug:"降低-full-gc-的时间",normalizedTitle:"降低 full gc 的时间",charIndex:1598},{level:3,title:"GC 优化的过程",slug:"gc-优化的过程",normalizedTitle:"gc 优化的过程",charIndex:2298},{level:4,title:"（1）监控 GC 状态",slug:"_1-监控-gc-状态",normalizedTitle:"（1）监控 gc 状态",charIndex:2330},{level:4,title:"（2）分析 GC 日志",slug:"_2-分析-gc-日志",normalizedTitle:"（2）分析 gc 日志",charIndex:2376},{level:4,title:"（3）选择合适 GC 回收器",slug:"_3-选择合适-gc-回收器",normalizedTitle:"（3）选择合适 gc 回收器",charIndex:2857},{level:4,title:"（4）分析结果",slug:"_4-分析结果",normalizedTitle:"（4）分析结果",charIndex:2973},{level:4,title:"（5）应用优化配置",slug:"_5-应用优化配置",normalizedTitle:"（5）应用优化配置",charIndex:3110},{level:2,title:"GC 日志",slug:"gc-日志",normalizedTitle:"gc 日志",charIndex:2382},{level:3,title:"获取 GC 日志",slug:"获取-gc-日志",normalizedTitle:"获取 gc 日志",charIndex:3206},{level:4,title:"jstat 命令查看 GC",slug:"jstat-命令查看-gc",normalizedTitle:"jstat 命令查看 gc",charIndex:3276},{level:4,title:"打印 GC 的参数",slug:"打印-gc-的参数",normalizedTitle:"打印 gc 的参数",charIndex:3672},{level:3,title:"分析 GC 日志",slug:"分析-gc-日志",normalizedTitle:"分析 gc 日志",charIndex:2379},{level:4,title:"CPU 过高",slug:"cpu-过高",normalizedTitle:"cpu 过高",charIndex:6062},{level:2,title:"GC 配置",slug:"gc-配置",normalizedTitle:"gc 配置",charIndex:10821},{level:3,title:"堆大小设置",slug:"堆大小设置",normalizedTitle:"堆大小设置",charIndex:10882},{level:3,title:"JVM 内存配置",slug:"jvm-内存配置",normalizedTitle:"jvm 内存配置",charIndex:11097},{level:3,title:"GC 类型配置",slug:"gc-类型配置",normalizedTitle:"gc 类型配置",charIndex:11541},{level:3,title:"垃圾回收器通用参数",slug:"垃圾回收器通用参数",normalizedTitle:"垃圾回收器通用参数",charIndex:11974},{level:3,title:"JMX",slug:"jmx",normalizedTitle:"jmx",charIndex:12219},{level:3,title:"远程 DEBUG",slug:"远程-debug",normalizedTitle:"远程 debug",charIndex:12586},{level:3,title:"HeapDump",slug:"heapdump",normalizedTitle:"heapdump",charIndex:12766},{level:3,title:"辅助配置",slug:"辅助配置",normalizedTitle:"辅助配置",charIndex:12844},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:13027}],headersStr:"JVM 调优概述 GC 性能指标 调优原则 降低 Minor GC 频率 降低 Full GC 的频率 降低 Full GC 的时间 GC 优化的过程 （1）监控 GC 状态 （2）分析 GC 日志 （3）选择合适 GC 回收器 （4）分析结果 （5）应用优化配置 GC 日志 获取 GC 日志 jstat 命令查看 GC 打印 GC 的参数 分析 GC 日志 CPU 过高 GC 配置 堆大小设置 JVM 内存配置 GC 类型配置 垃圾回收器通用参数 JMX 远程 DEBUG HeapDump 辅助配置 参考资料",content:'# JVM 实战\n\n\n# JVM 调优概述\n\n\n# GC 性能指标\n\n对于 JVM 调优来说，需要先明确调优的目标。 从性能的角度看，通常关注三个指标：\n\n * 吞吐量（throughput） - 指不考虑 GC 引起的停顿时间或内存消耗，垃圾收集器能支撑应用达到的最高性能指标。\n * 停顿时间（latency） - 其度量标准是缩短由于垃圾啊收集引起的停顿时间或者完全消除因垃圾收集所引起的停顿，避免应用运行时发生抖动。\n * 垃圾回收频率 - 久发生一次指垃圾回收呢？通常垃圾回收的频率越低越好，增大堆内存空间可以有效降低垃圾回收发生的频率，但同时也意味着堆积的回收对象越多，最终也会增加回收时的停顿时间。所以我们只要适当地增大堆内存空间，保证正常的垃圾回收频率即可。\n\n大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。\n\n\n# 调优原则\n\nGC 优化的两个目标：\n\n * 降低 Full GC 的频率\n * 减少 Full GC 的执行时间\n\nGC 优化的基本原则是：将不同的 GC 参数应用到两个及以上的服务器上然后比较它们的性能，然后将那些被证明可以提高性能或减少 GC 执行时间的参数应用于最终的工作服务器上。\n\n# 降低 Minor GC 频率\n\n如果新生代空间较小，Eden 区很快被填满，就会导致频繁 Minor GC，因此我们可以通过增大新生代空间来降低 Minor GC 的频率。\n\n可能你会有这样的疑问，扩容 Eden 区虽然可以减少 Minor GC 的次数，但不会增加单次 Minor GC 的时间吗？如果单次 Minor GC 的时间增加，那也很难达到我们期待的优化效果呀。\n\n我们知道，单次 Minor GC 时间是由两部分组成：T1（扫描新生代）和 T2（复制存活对象）。假设一个对象在 Eden 区的存活时间为 500ms，Minor GC 的时间间隔是 300ms，那么正常情况下，Minor GC 的时间为 ：T1+T2。\n\n当我们增大新生代空间，Minor GC 的时间间隔可能会扩大到 600ms，此时一个存活 500ms 的对象就会在 Eden 区中被回收掉，此时就不存在复制存活对象了，所以再发生 Minor GC 的时间为：两次扫描新生代，即 2T1。\n\n可见，扩容后，Minor GC 时增加了 T1，但省去了 T2 的时间。通常在虚拟机中，复制对象的成本要远高于扫描成本。\n\n如果在堆内存中存在较多的长期存活的对象，此时增加年轻代空间，反而会增加 Minor GC 的时间。如果堆中的短期对象很多，那么扩容新生代，单次 Minor GC 时间不会显著增加。因此，单次 Minor GC 时间更多取决于 GC 后存活对象的数量，而非 Eden 区的大小。\n\n# 降低 Full GC 的频率\n\nFull GC 相对来说会比 Minor GC 更耗时。减少进入老年代的对象数量可以显著降低 Full GC 的频率。\n\n减少创建大对象：如果对象占用内存过大，在 Eden 区被创建后会直接被传入老年代。在平常的业务场景中，我们习惯一次性从数据库中查询出一个大对象用于 web 端显示。例如，我之前碰到过一个一次性查询出 60 个字段的业务操作，这种大对象如果超过年轻代最大对象阈值，会被直接创建在老年代；即使被创建在了年轻代，由于年轻代的内存空间有限，通过 Minor GC 之后也会进入到老年代。这种大对象很容易产生较多的 Full GC。\n\n我们可以将这种大对象拆解出来，首次只查询一些比较重要的字段，如果还需要其它字段辅助查看，再通过第二次查询显示剩余的字段。\n\n**增大堆内存空间：**在堆内存不足的情况下，增大堆内存空间，且设置初始化堆内存为最大堆内存，也可以降低 Full GC 的频率。\n\n# 降低 Full GC 的时间\n\nFull GC 的执行时间比 Minor GC 要长很多，因此，如果在 Full GC 上花费过多的时间（超过 1s），将可能出现超时错误。\n\n * 如果通过减小老年代内存来减少 Full GC 时间，可能会引起 OutOfMemoryError 或者导致 Full GC 的频率升高。\n * 另外，如果通过增加老年代内存来降低 Full GC 的频率，Full GC 的时间可能因此增加。\n\n因此，你需要把老年代的大小设置成一个“合适”的值。\n\nGC 优化需要考虑的 JVM 参数\n\n类型        参数                  描述\n堆内存大小     -Xms                启动 JVM 时堆内存的大小\n          -Xmx                堆内存最大限制\n新生代空间大小   -XX:NewRatio        新生代和老年代的内存比\n          -XX:NewSize         新生代内存大小\n          -XX:SurvivorRatio   Eden 区和 Survivor 区的内存比\n\nGC 优化时最常用的参数是-Xms,-Xmx和-XX:NewRatio。-Xms和-Xmx参数通常是必须的，所以NewRatio的值将对 GC 性能产生重要的影响。\n\n有些人可能会问如何设置永久代内存大小，你可以用-XX:PermSize和-XX:MaxPermSize参数来进行设置，但是要记住，只有当出现OutOfMemoryError错误时你才需要去设置永久代内存。\n\n\n# GC 优化的过程\n\nGC 优化的过程大致可分为以下步骤：\n\n# （1）监控 GC 状态\n\n你需要监控 GC 从而检查系统中运行的 GC 的各种状态。\n\n# （2）分析 GC 日志\n\n在检查 GC 状态后，你需要分析监控结构并决定是否需要进行 GC 优化。如果分析结果显示运行 GC 的时间只有 0.1-0.3 秒，那么就不需要把时间浪费在 GC 优化上，但如果运行 GC 的时间达到 1-3 秒，甚至大于 10 秒，那么 GC 优化将是很有必要的。\n\n但是，如果你已经分配了大约 10GB 内存给 Java，并且这些内存无法省下，那么就无法进行 GC 优化了。在进行 GC 优化之前，你需要考虑为什么你需要分配这么大的内存空间，如果你分配了 1GB 或 2GB 大小的内存并且出现了OutOfMemoryError，那你就应该执行**堆快照（heap dump）**来消除导致异常的原因。\n\n> 🔔 注意：\n\n> **堆快照（heap dump）**是一个用来检查 Java 内存中的对象和数据的内存文件。该文件可以通过执行 JDK 中的jmap命令来创建。在创建文件的过程中，所有 Java 程序都将暂停，因此，不要在系统执行过程中创建该文件。\n\n> 你可以在互联网上搜索 heap dump 的详细说明。\n\n# （3）选择合适 GC 回收器\n\n如果你决定要进行 GC 优化，那么你需要选择一个 GC 回收器，并且为它设置合理 JVM 参数。此时如果你有多个服务器，请如上文提到的那样，在每台机器上设置不同的 GC 参数并分析它们的区别。\n\n# （4）分析结果\n\n在设置完 GC 参数后就可以开始收集数据，请在收集至少 24 小时后再进行结果分析。如果你足够幸运，你可能会找到系统的最佳 GC 参数。如若不然，你还需要分析输出日志并检查分配的内存，然后需要通过不断调整 GC 类型/内存大小来找到系统的最佳参数。\n\n# （5）应用优化配置\n\n如果 GC 优化的结果令人满意，就可以将参数应用到所有服务器上，并停止 GC 优化。\n\n在下面的章节中，你将会看到上述每一步所做的具体工作。\n\n\n# GC 日志\n\n\n# 获取 GC 日志\n\n获取 GC 日志有两种方式：\n\n * 使用 jstat 命令动态查看\n * 在容器中设置相关参数打印 GC 日志\n\n# jstat 命令查看 GC\n\njstat -gc 统计垃圾回收堆的行为：\n\njstat -gc 1262\n S0C    S1C     S0U     S1U   EC       EU        OC         OU        PC       PU         YGC    YGCT    FGC    FGCT     GCT\n26112.0 24064.0 6562.5  0.0   564224.0 76274.5   434176.0   388518.3  524288.0 42724.7    320    6.417   1      0.398    6.815\n\n\n也可以设置间隔固定时间来打印：\n\njstat -gc 1262 2000 20\n\n\n这个命令意思就是每隔 2000ms 输出 1262 的 gc 情况，一共输出 20 次\n\n# 打印 GC 的参数\n\n通过 JVM 参数预先设置 GC 日志，通常有以下几种 JVM 参数设置：\n\n-XX:+PrintGC 输出 GC 日志\n-XX:+PrintGCDetails 输出 GC 的详细日志\n-XX:+PrintGCTimeStamps 输出 GC 的时间戳（以基准时间的形式）\n-XX:+PrintGCDateStamps 输出 GC 的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）\n-XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息\n-verbose:gc -Xloggc:../logs/gc.log 日志文件的输出路径\n\n\n如果是长时间的 GC 日志，我们很难通过文本形式去查看整体的 GC 性能。此时，我们可以通过GCView工具打开日志文件，图形化界面查看整体的 GC 性能。\n\n【示例】Tomcat 设置示例\n\nJAVA_OPTS="-server -Xms2000m -Xmx2000m -Xmn800m -XX:PermSize=64m -XX:MaxPermSize=256m -XX:SurvivorRatio=4\n-verbose:gc -Xloggc:$CATALINA_HOME/logs/gc.log\n-Djava.awt.headless=true\n-XX:+PrintGCTimeStamps -XX:+PrintGCDetails\n-Dsun.rmi.dgc.server.gcInterval=600000 -Dsun.rmi.dgc.client.gcInterval=600000\n-XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=15"\n\n\n * -Xms2000m -Xmx2000m -Xmn800m -XX:PermSize=64m -XX:MaxPermSize=256m Xms，即为 jvm 启动时得 JVM 初始堆大小,Xmx 为 jvm 的最大堆大小，xmn 为新生代的大小，permsize 为永久代的初始大小，MaxPermSize 为永久代的最大空间。\n * -XX:SurvivorRatio=4 SurvivorRatio 为新生代空间中的 Eden 区和救助空间 Survivor 区的大小比值，默认是 8，则两个 Survivor 区与一个 Eden 区的比值为 2:8,一个 Survivor 区占整个年轻代的 1/10。调小这个参数将增大 survivor 区，让对象尽量在 survitor 区呆长一点，减少进入年老代的对象。去掉救助空间的想法是让大部分不能马上回收的数据尽快进入年老代，加快年老代的回收频率，减少年老代暴涨的可能性，这个是通过将-XX:SurvivorRatio 设置成比较大的值（比如 65536)来做到。\n * -verbose:gc -Xloggc:$CATALINA_HOME/logs/gc.log 将虚拟机每次垃圾回收的信息写到日志文件中，文件名由 file 指定，文件格式是平文件，内容和-verbose:gc 输出内容相同。\n * -Djava.awt.headless=true Headless 模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。\n * -XX:+PrintGCTimeStamps -XX:+PrintGCDetails 设置 gc 日志的格式\n * -Dsun.rmi.dgc.server.gcInterval=600000 -Dsun.rmi.dgc.client.gcInterval=600000 指定 rmi 调用时 gc 的时间间隔\n * -XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=15 采用并发 gc 方式，经过 15 次 minor gc 后进入年老代\n\n\n# 分析 GC 日志\n\nYoung GC 回收日志:\n\n2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K->10738K(274944K)] 371093K->147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs]\n\n\nFull GC 回收日志:\n\n2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K->0K(274944K)] [ParOldGen: 136447K->140379K(302592K)] 147186K->140379K(577536K) [PSPermGen: 85411K->85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]\n\n\n通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen 属于 Parallel 收集器。其中 PSYoungGen 表示 gc 回收前后年轻代的内存变化；ParOldGen 表示 gc 回收前后老年代的内存变化；PSPermGen 表示 gc 回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少 full gc 的次数\n\n通过两张图非常明显看出 gc 日志构成：\n\nYOUNG GC\n\n\n\nFULL GC\n\n\n\n# CPU 过高\n\n定位步骤：\n\n（1）执行 top -c 命令，找到 cpu 最高的进程的 id\n\n（2）jstack PID 导出 Java 应用程序的线程堆栈信息。\n\n示例：\n\njstack 6795\n\n"Low Memory Detector" daemon prio=10 tid=0x081465f8 nid=0x7 runnable [0x00000000..0x00000000]\n        "CompilerThread0" daemon prio=10 tid=0x08143c58 nid=0x6 waiting on condition [0x00000000..0xfb5fd798]\n        "Signal Dispatcher" daemon prio=10 tid=0x08142f08 nid=0x5 waiting on condition [0x00000000..0x00000000]\n        "Finalizer" daemon prio=10 tid=0x08137ca0 nid=0x4 in Object.wait() [0xfbeed000..0xfbeeddb8]\n\n        at java.lang.Object.wait(Native Method)\n\n        - waiting on <0xef600848> (a java.lang.ref.ReferenceQueue$Lock)\n\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:116)\n\n        - locked <0xef600848> (a java.lang.ref.ReferenceQueue$Lock)\n\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:132)\n\n        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:159)\n\n        "Reference Handler" daemon prio=10 tid=0x081370f0 nid=0x3 in Object.wait() [0xfbf4a000..0xfbf4aa38]\n\n        at java.lang.Object.wait(Native Method)\n\n        - waiting on <0xef600758> (a java.lang.ref.Reference$Lock)\n\n        at java.lang.Object.wait(Object.java:474)\n\n        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:116)\n\n        - locked <0xef600758> (a java.lang.ref.Reference$Lock)\n\n        "VM Thread" prio=10 tid=0x08134878 nid=0x2 runnable\n\n        "VM Periodic Task Thread" prio=10 tid=0x08147768 nid=0x8 waiting on condition\n\n\n在打印的堆栈日志文件中，tid 和 nid 的含义：\n\nnid : 对应的 Linux 操作系统下的 tid 线程号，也就是前面转化的 16 进制数字\ntid: 这个应该是 jvm 的 jmm 内存规范中的唯一地址定位\n\n\n在 CPU 过高的情况下，查找响应的线程，一般定位都是用 nid 来定位的。而如果发生死锁之类的问题，一般用 tid 来定位。\n\n（3）定位 CPU 高的线程打印其 nid\n\n查看线程下具体进程信息的命令如下：\n\ntop -H -p 6735\n\ntop - 14:20:09 up 611 days,  2:56,  1 user,  load average: 13.19, 7.76, 7.82\nThreads: 6991 total,  17 running, 6974 sleeping,   0 stopped,   0 zombie\n%Cpu(s): 90.4 us,  2.1 sy,  0.0 ni,  7.0 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st\nKiB Mem:  32783044 total, 32505008 used,   278036 free,   120304 buffers\nKiB Swap:        0 total,        0 used,        0 free. 4497428 cached Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND\n 6800 root      20   0 27.299g 0.021t   7172 S 54.7 70.1 187:55.61 java\n 6803 root      20   0 27.299g 0.021t   7172 S 54.4 70.1 187:52.59 java\n 6798 root      20   0 27.299g 0.021t   7172 S 53.7 70.1 187:55.08 java\n 6801 root      20   0 27.299g 0.021t   7172 S 53.7 70.1 187:55.25 java\n 6797 root      20   0 27.299g 0.021t   7172 S 53.1 70.1 187:52.78 java\n 6804 root      20   0 27.299g 0.021t   7172 S 53.1 70.1 187:55.76 java\n 6802 root      20   0 27.299g 0.021t   7172 S 52.1 70.1 187:54.79 java\n 6799 root      20   0 27.299g 0.021t   7172 S 51.8 70.1 187:53.36 java\n 6807 root      20   0 27.299g 0.021t   7172 S 13.6 70.1  48:58.60 java\n11014 root      20   0 27.299g 0.021t   7172 R  8.4 70.1   8:00.32 java\n10642 root      20   0 27.299g 0.021t   7172 R  6.5 70.1   6:32.06 java\n 6808 root      20   0 27.299g 0.021t   7172 S  6.1 70.1 159:08.40 java\n11315 root      20   0 27.299g 0.021t   7172 S  3.9 70.1   5:54.10 java\n12545 root      20   0 27.299g 0.021t   7172 S  3.9 70.1   6:55.48 java\n23353 root      20   0 27.299g 0.021t   7172 S  3.9 70.1   2:20.55 java\n24868 root      20   0 27.299g 0.021t   7172 S  3.9 70.1   2:12.46 java\n 9146 root      20   0 27.299g 0.021t   7172 S  3.6 70.1   7:42.72 java\n\n\n由此可以看出占用 CPU 较高的线程，但是这些还不高，无法直接定位到具体的类。nid 是 16 进制的，所以我们要获取线程的 16 进制 ID：\n\nprintf "%x\\n" 6800\n\n\n输出结果:45cd\n\n\n然后根据输出结果到 jstack 打印的堆栈日志中查定位：\n\n"catalina-exec-5692" daemon prio=10 tid=0x00007f3b05013800 nid=0x45cd waiting on condition [0x00007f3ae08e3000]\n   java.lang.Thread.State: TIMED_WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00000006a7800598> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:226)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2082)\n        at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)\n        at org.apache.tomcat.util.threads.TaskQueue.poll(TaskQueue.java:86)\n        at org.apache.tomcat.util.threads.TaskQueue.poll(TaskQueue.java:32)\n        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1068)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n        at java.lang.Thread.run(Thread.java:745)\n\n\n\n# GC 配置\n\n> 详细参数说明请参考官方文档：JavaHotSpot VM Options，这里仅列举常用参数。\n\n\n# 堆大小设置\n\n年轻代的设置很关键。\n\nJVM 中最大堆大小有三方面限制：\n\n 1. 相关操作系统的数据模型（32-bt 还是 64-bit）限制；\n 2. 系统的可用虚拟内存限制；\n 3. 系统的可用物理内存限制。\n\n整个堆大小 = 年轻代大小 + 年老代大小 + 持久代大小\n\n\n * 持久代一般固定大小为 64m。使用 -XX:PermSize 设置。\n * 官方推荐年轻代占整个堆的 3/8。使用 -Xmn 设置。\n\n\n# JVM 内存配置\n\n配置                  描述\n-Xss                虚拟机栈大小。\n-Xms                堆空间初始值。\n-Xmx                堆空间最大值。\n-Xmn                新生代空间大小。\n-XX:NewSize         新生代空间初始值。\n-XX:MaxNewSize      新生代空间最大值。\n-XX:NewRatio        新生代与年老代的比例。默认为 2，意味着老年代是新生代的 2 倍。\n-XX:SurvivorRatio   新生代中调整 eden 区与 survivor 区的比例，默认为 8。即 eden 区为 80% 的大小，两个\n                    survivor 分别为 10% 的大小。\n-XX:PermSize        永久代空间的初始值。\n-XX:MaxPermSize     永久代空间的最大值。\n\n\n# GC 类型配置\n\n配置                        描述\n-XX:+UseSerialGC          使用 Serial + Serial Old 垃圾回收器组合\n-XX:+UseParallelGC        使用 Parallel Scavenge + Parallel Old 垃圾回收器组合\n-XX:+UseParallelOldGC     使用 Parallel Old 垃圾回收器（JDK5 后已无用）\n-XX:+UseParNewGC          使用 ParNew + Serial Old 垃圾回收器\n-XX:+UseConcMarkSweepGC   使用 CMS + ParNew + Serial Old 垃圾回收器组合\n-XX:+UseG1GC              使用 G1 垃圾回收器\n-XX:ParallelCMSThreads    并发标记扫描垃圾回收器 = 为使用的线程数量\n\n\n# 垃圾回收器通用参数\n\n配置                       描述\nPretenureSizeThreshold   晋升年老代的对象大小。默认为 0。比如设为 10M，则超过 10M 的对象将不在 eden 区分配，而直接进入年老代。\nMaxTenuringThreshold     晋升老年代的最大年龄。默认为 15。比如设为 10，则对象在 10 次普通 GC 后将会被放入年老代。\nDisableExplicitGC        禁用 System.gc()\n\n\n# JMX\n\n开启 JMX 后，可以使用 jconsole 或 jvisualvm 进行监控 Java 程序的基本信息和运行情况。\n\n-Dcom.sun.management.jmxremote=true\n-Dcom.sun.management.jmxremote.ssl=false\n-Dcom.sun.management.jmxremote.authenticate=false\n-Djava.rmi.server.hostname=127.0.0.1\n-Dcom.sun.management.jmxremote.port=18888\n\n\n-Djava.rmi.server.hostname 指定 Java 程序运行的服务器，-Dcom.sun.management.jmxremote.port 指定服务监听端口。\n\n\n# 远程 DEBUG\n\n如果开启 Java 应用的远程 Debug 功能，需要指定如下参数：\n\n-Xdebug\n-Xnoagent\n-Djava.compiler=NONE\n-Xrunjdwp:transport=dt_socket,address=28888,server=y,suspend=n\n\n\naddress 即为远程 debug 的监听端口。\n\n\n# HeapDump\n\n-XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError\n\n\n\n# 辅助配置\n\n配置                                描述\n-XX:+PrintGCDetails               打印 GC 日志\n-Xloggc:<filename>                指定 GC 日志文件名\n-XX:+HeapDumpOnOutOfMemoryError   内存溢出时输出堆快照文件\n\n\n# 参考资料\n\n * 《深入理解 Java 虚拟机》\n * 《Java 性能调优实战》\n * 从表到里学习 JVM 实现\n * JVM（4）：Jvm 调优-命令篇\n * Java 系列笔记(4) - JVM 监控与调优\n * Java 服务 GC 参数调优案例\n * JVM 调优总结（5）：典型配置\n * 如何合理的规划一次 jvm 性能调优\n * jvm 系列(九):如何优化 Java GC「译」\n * https://my.oschina.net/feichexia/blog/196575',normalizedContent:'# jvm 实战\n\n\n# jvm 调优概述\n\n\n# gc 性能指标\n\n对于 jvm 调优来说，需要先明确调优的目标。 从性能的角度看，通常关注三个指标：\n\n * 吞吐量（throughput） - 指不考虑 gc 引起的停顿时间或内存消耗，垃圾收集器能支撑应用达到的最高性能指标。\n * 停顿时间（latency） - 其度量标准是缩短由于垃圾啊收集引起的停顿时间或者完全消除因垃圾收集所引起的停顿，避免应用运行时发生抖动。\n * 垃圾回收频率 - 久发生一次指垃圾回收呢？通常垃圾回收的频率越低越好，增大堆内存空间可以有效降低垃圾回收发生的频率，但同时也意味着堆积的回收对象越多，最终也会增加回收时的停顿时间。所以我们只要适当地增大堆内存空间，保证正常的垃圾回收频率即可。\n\n大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。\n\n\n# 调优原则\n\ngc 优化的两个目标：\n\n * 降低 full gc 的频率\n * 减少 full gc 的执行时间\n\ngc 优化的基本原则是：将不同的 gc 参数应用到两个及以上的服务器上然后比较它们的性能，然后将那些被证明可以提高性能或减少 gc 执行时间的参数应用于最终的工作服务器上。\n\n# 降低 minor gc 频率\n\n如果新生代空间较小，eden 区很快被填满，就会导致频繁 minor gc，因此我们可以通过增大新生代空间来降低 minor gc 的频率。\n\n可能你会有这样的疑问，扩容 eden 区虽然可以减少 minor gc 的次数，但不会增加单次 minor gc 的时间吗？如果单次 minor gc 的时间增加，那也很难达到我们期待的优化效果呀。\n\n我们知道，单次 minor gc 时间是由两部分组成：t1（扫描新生代）和 t2（复制存活对象）。假设一个对象在 eden 区的存活时间为 500ms，minor gc 的时间间隔是 300ms，那么正常情况下，minor gc 的时间为 ：t1+t2。\n\n当我们增大新生代空间，minor gc 的时间间隔可能会扩大到 600ms，此时一个存活 500ms 的对象就会在 eden 区中被回收掉，此时就不存在复制存活对象了，所以再发生 minor gc 的时间为：两次扫描新生代，即 2t1。\n\n可见，扩容后，minor gc 时增加了 t1，但省去了 t2 的时间。通常在虚拟机中，复制对象的成本要远高于扫描成本。\n\n如果在堆内存中存在较多的长期存活的对象，此时增加年轻代空间，反而会增加 minor gc 的时间。如果堆中的短期对象很多，那么扩容新生代，单次 minor gc 时间不会显著增加。因此，单次 minor gc 时间更多取决于 gc 后存活对象的数量，而非 eden 区的大小。\n\n# 降低 full gc 的频率\n\nfull gc 相对来说会比 minor gc 更耗时。减少进入老年代的对象数量可以显著降低 full gc 的频率。\n\n减少创建大对象：如果对象占用内存过大，在 eden 区被创建后会直接被传入老年代。在平常的业务场景中，我们习惯一次性从数据库中查询出一个大对象用于 web 端显示。例如，我之前碰到过一个一次性查询出 60 个字段的业务操作，这种大对象如果超过年轻代最大对象阈值，会被直接创建在老年代；即使被创建在了年轻代，由于年轻代的内存空间有限，通过 minor gc 之后也会进入到老年代。这种大对象很容易产生较多的 full gc。\n\n我们可以将这种大对象拆解出来，首次只查询一些比较重要的字段，如果还需要其它字段辅助查看，再通过第二次查询显示剩余的字段。\n\n**增大堆内存空间：**在堆内存不足的情况下，增大堆内存空间，且设置初始化堆内存为最大堆内存，也可以降低 full gc 的频率。\n\n# 降低 full gc 的时间\n\nfull gc 的执行时间比 minor gc 要长很多，因此，如果在 full gc 上花费过多的时间（超过 1s），将可能出现超时错误。\n\n * 如果通过减小老年代内存来减少 full gc 时间，可能会引起 outofmemoryerror 或者导致 full gc 的频率升高。\n * 另外，如果通过增加老年代内存来降低 full gc 的频率，full gc 的时间可能因此增加。\n\n因此，你需要把老年代的大小设置成一个“合适”的值。\n\ngc 优化需要考虑的 jvm 参数\n\n类型        参数                  描述\n堆内存大小     -xms                启动 jvm 时堆内存的大小\n          -xmx                堆内存最大限制\n新生代空间大小   -xx:newratio        新生代和老年代的内存比\n          -xx:newsize         新生代内存大小\n          -xx:survivorratio   eden 区和 survivor 区的内存比\n\ngc 优化时最常用的参数是-xms,-xmx和-xx:newratio。-xms和-xmx参数通常是必须的，所以newratio的值将对 gc 性能产生重要的影响。\n\n有些人可能会问如何设置永久代内存大小，你可以用-xx:permsize和-xx:maxpermsize参数来进行设置，但是要记住，只有当出现outofmemoryerror错误时你才需要去设置永久代内存。\n\n\n# gc 优化的过程\n\ngc 优化的过程大致可分为以下步骤：\n\n# （1）监控 gc 状态\n\n你需要监控 gc 从而检查系统中运行的 gc 的各种状态。\n\n# （2）分析 gc 日志\n\n在检查 gc 状态后，你需要分析监控结构并决定是否需要进行 gc 优化。如果分析结果显示运行 gc 的时间只有 0.1-0.3 秒，那么就不需要把时间浪费在 gc 优化上，但如果运行 gc 的时间达到 1-3 秒，甚至大于 10 秒，那么 gc 优化将是很有必要的。\n\n但是，如果你已经分配了大约 10gb 内存给 java，并且这些内存无法省下，那么就无法进行 gc 优化了。在进行 gc 优化之前，你需要考虑为什么你需要分配这么大的内存空间，如果你分配了 1gb 或 2gb 大小的内存并且出现了outofmemoryerror，那你就应该执行**堆快照（heap dump）**来消除导致异常的原因。\n\n> 🔔 注意：\n\n> **堆快照（heap dump）**是一个用来检查 java 内存中的对象和数据的内存文件。该文件可以通过执行 jdk 中的jmap命令来创建。在创建文件的过程中，所有 java 程序都将暂停，因此，不要在系统执行过程中创建该文件。\n\n> 你可以在互联网上搜索 heap dump 的详细说明。\n\n# （3）选择合适 gc 回收器\n\n如果你决定要进行 gc 优化，那么你需要选择一个 gc 回收器，并且为它设置合理 jvm 参数。此时如果你有多个服务器，请如上文提到的那样，在每台机器上设置不同的 gc 参数并分析它们的区别。\n\n# （4）分析结果\n\n在设置完 gc 参数后就可以开始收集数据，请在收集至少 24 小时后再进行结果分析。如果你足够幸运，你可能会找到系统的最佳 gc 参数。如若不然，你还需要分析输出日志并检查分配的内存，然后需要通过不断调整 gc 类型/内存大小来找到系统的最佳参数。\n\n# （5）应用优化配置\n\n如果 gc 优化的结果令人满意，就可以将参数应用到所有服务器上，并停止 gc 优化。\n\n在下面的章节中，你将会看到上述每一步所做的具体工作。\n\n\n# gc 日志\n\n\n# 获取 gc 日志\n\n获取 gc 日志有两种方式：\n\n * 使用 jstat 命令动态查看\n * 在容器中设置相关参数打印 gc 日志\n\n# jstat 命令查看 gc\n\njstat -gc 统计垃圾回收堆的行为：\n\njstat -gc 1262\n s0c    s1c     s0u     s1u   ec       eu        oc         ou        pc       pu         ygc    ygct    fgc    fgct     gct\n26112.0 24064.0 6562.5  0.0   564224.0 76274.5   434176.0   388518.3  524288.0 42724.7    320    6.417   1      0.398    6.815\n\n\n也可以设置间隔固定时间来打印：\n\njstat -gc 1262 2000 20\n\n\n这个命令意思就是每隔 2000ms 输出 1262 的 gc 情况，一共输出 20 次\n\n# 打印 gc 的参数\n\n通过 jvm 参数预先设置 gc 日志，通常有以下几种 jvm 参数设置：\n\n-xx:+printgc 输出 gc 日志\n-xx:+printgcdetails 输出 gc 的详细日志\n-xx:+printgctimestamps 输出 gc 的时间戳（以基准时间的形式）\n-xx:+printgcdatestamps 输出 gc 的时间戳（以日期的形式，如 2013-05-04t21:53:59.234+0800）\n-xx:+printheapatgc 在进行 gc 的前后打印出堆的信息\n-verbose:gc -xloggc:../logs/gc.log 日志文件的输出路径\n\n\n如果是长时间的 gc 日志，我们很难通过文本形式去查看整体的 gc 性能。此时，我们可以通过gcview工具打开日志文件，图形化界面查看整体的 gc 性能。\n\n【示例】tomcat 设置示例\n\njava_opts="-server -xms2000m -xmx2000m -xmn800m -xx:permsize=64m -xx:maxpermsize=256m -xx:survivorratio=4\n-verbose:gc -xloggc:$catalina_home/logs/gc.log\n-djava.awt.headless=true\n-xx:+printgctimestamps -xx:+printgcdetails\n-dsun.rmi.dgc.server.gcinterval=600000 -dsun.rmi.dgc.client.gcinterval=600000\n-xx:+useconcmarksweepgc -xx:maxtenuringthreshold=15"\n\n\n * -xms2000m -xmx2000m -xmn800m -xx:permsize=64m -xx:maxpermsize=256m xms，即为 jvm 启动时得 jvm 初始堆大小,xmx 为 jvm 的最大堆大小，xmn 为新生代的大小，permsize 为永久代的初始大小，maxpermsize 为永久代的最大空间。\n * -xx:survivorratio=4 survivorratio 为新生代空间中的 eden 区和救助空间 survivor 区的大小比值，默认是 8，则两个 survivor 区与一个 eden 区的比值为 2:8,一个 survivor 区占整个年轻代的 1/10。调小这个参数将增大 survivor 区，让对象尽量在 survitor 区呆长一点，减少进入年老代的对象。去掉救助空间的想法是让大部分不能马上回收的数据尽快进入年老代，加快年老代的回收频率，减少年老代暴涨的可能性，这个是通过将-xx:survivorratio 设置成比较大的值（比如 65536)来做到。\n * -verbose:gc -xloggc:$catalina_home/logs/gc.log 将虚拟机每次垃圾回收的信息写到日志文件中，文件名由 file 指定，文件格式是平文件，内容和-verbose:gc 输出内容相同。\n * -djava.awt.headless=true headless 模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。\n * -xx:+printgctimestamps -xx:+printgcdetails 设置 gc 日志的格式\n * -dsun.rmi.dgc.server.gcinterval=600000 -dsun.rmi.dgc.client.gcinterval=600000 指定 rmi 调用时 gc 的时间间隔\n * -xx:+useconcmarksweepgc -xx:maxtenuringthreshold=15 采用并发 gc 方式，经过 15 次 minor gc 后进入年老代\n\n\n# 分析 gc 日志\n\nyoung gc 回收日志:\n\n2016-07-05t10:43:18.093+0800: 25.395: [gc [psyounggen: 274931k->10738k(274944k)] 371093k->147186k(450048k), 0.0668480 secs] [times: user=0.17 sys=0.08, real=0.07 secs]\n\n\nfull gc 回收日志:\n\n2016-07-05t10:43:18.160+0800: 25.462: [full gc [psyounggen: 10738k->0k(274944k)] [paroldgen: 136447k->140379k(302592k)] 147186k->140379k(577536k) [pspermgen: 85411k->85376k(171008k)], 0.6763541 secs] [times: user=1.75 sys=0.02, real=0.68 secs]\n\n\n通过上面日志分析得出，psyounggen、paroldgen、pspermgen 属于 parallel 收集器。其中 psyounggen 表示 gc 回收前后年轻代的内存变化；paroldgen 表示 gc 回收前后老年代的内存变化；pspermgen 表示 gc 回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少 full gc 的次数\n\n通过两张图非常明显看出 gc 日志构成：\n\nyoung gc\n\n\n\nfull gc\n\n\n\n# cpu 过高\n\n定位步骤：\n\n（1）执行 top -c 命令，找到 cpu 最高的进程的 id\n\n（2）jstack pid 导出 java 应用程序的线程堆栈信息。\n\n示例：\n\njstack 6795\n\n"low memory detector" daemon prio=10 tid=0x081465f8 nid=0x7 runnable [0x00000000..0x00000000]\n        "compilerthread0" daemon prio=10 tid=0x08143c58 nid=0x6 waiting on condition [0x00000000..0xfb5fd798]\n        "signal dispatcher" daemon prio=10 tid=0x08142f08 nid=0x5 waiting on condition [0x00000000..0x00000000]\n        "finalizer" daemon prio=10 tid=0x08137ca0 nid=0x4 in object.wait() [0xfbeed000..0xfbeeddb8]\n\n        at java.lang.object.wait(native method)\n\n        - waiting on <0xef600848> (a java.lang.ref.referencequeue$lock)\n\n        at java.lang.ref.referencequeue.remove(referencequeue.java:116)\n\n        - locked <0xef600848> (a java.lang.ref.referencequeue$lock)\n\n        at java.lang.ref.referencequeue.remove(referencequeue.java:132)\n\n        at java.lang.ref.finalizer$finalizerthread.run(finalizer.java:159)\n\n        "reference handler" daemon prio=10 tid=0x081370f0 nid=0x3 in object.wait() [0xfbf4a000..0xfbf4aa38]\n\n        at java.lang.object.wait(native method)\n\n        - waiting on <0xef600758> (a java.lang.ref.reference$lock)\n\n        at java.lang.object.wait(object.java:474)\n\n        at java.lang.ref.reference$referencehandler.run(reference.java:116)\n\n        - locked <0xef600758> (a java.lang.ref.reference$lock)\n\n        "vm thread" prio=10 tid=0x08134878 nid=0x2 runnable\n\n        "vm periodic task thread" prio=10 tid=0x08147768 nid=0x8 waiting on condition\n\n\n在打印的堆栈日志文件中，tid 和 nid 的含义：\n\nnid : 对应的 linux 操作系统下的 tid 线程号，也就是前面转化的 16 进制数字\ntid: 这个应该是 jvm 的 jmm 内存规范中的唯一地址定位\n\n\n在 cpu 过高的情况下，查找响应的线程，一般定位都是用 nid 来定位的。而如果发生死锁之类的问题，一般用 tid 来定位。\n\n（3）定位 cpu 高的线程打印其 nid\n\n查看线程下具体进程信息的命令如下：\n\ntop -h -p 6735\n\ntop - 14:20:09 up 611 days,  2:56,  1 user,  load average: 13.19, 7.76, 7.82\nthreads: 6991 total,  17 running, 6974 sleeping,   0 stopped,   0 zombie\n%cpu(s): 90.4 us,  2.1 sy,  0.0 ni,  7.0 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st\nkib mem:  32783044 total, 32505008 used,   278036 free,   120304 buffers\nkib swap:        0 total,        0 used,        0 free. 4497428 cached mem\n\n  pid user      pr  ni    virt    res    shr s %cpu %mem     time+ command\n 6800 root      20   0 27.299g 0.021t   7172 s 54.7 70.1 187:55.61 java\n 6803 root      20   0 27.299g 0.021t   7172 s 54.4 70.1 187:52.59 java\n 6798 root      20   0 27.299g 0.021t   7172 s 53.7 70.1 187:55.08 java\n 6801 root      20   0 27.299g 0.021t   7172 s 53.7 70.1 187:55.25 java\n 6797 root      20   0 27.299g 0.021t   7172 s 53.1 70.1 187:52.78 java\n 6804 root      20   0 27.299g 0.021t   7172 s 53.1 70.1 187:55.76 java\n 6802 root      20   0 27.299g 0.021t   7172 s 52.1 70.1 187:54.79 java\n 6799 root      20   0 27.299g 0.021t   7172 s 51.8 70.1 187:53.36 java\n 6807 root      20   0 27.299g 0.021t   7172 s 13.6 70.1  48:58.60 java\n11014 root      20   0 27.299g 0.021t   7172 r  8.4 70.1   8:00.32 java\n10642 root      20   0 27.299g 0.021t   7172 r  6.5 70.1   6:32.06 java\n 6808 root      20   0 27.299g 0.021t   7172 s  6.1 70.1 159:08.40 java\n11315 root      20   0 27.299g 0.021t   7172 s  3.9 70.1   5:54.10 java\n12545 root      20   0 27.299g 0.021t   7172 s  3.9 70.1   6:55.48 java\n23353 root      20   0 27.299g 0.021t   7172 s  3.9 70.1   2:20.55 java\n24868 root      20   0 27.299g 0.021t   7172 s  3.9 70.1   2:12.46 java\n 9146 root      20   0 27.299g 0.021t   7172 s  3.6 70.1   7:42.72 java\n\n\n由此可以看出占用 cpu 较高的线程，但是这些还不高，无法直接定位到具体的类。nid 是 16 进制的，所以我们要获取线程的 16 进制 id：\n\nprintf "%x\\n" 6800\n\n\n输出结果:45cd\n\n\n然后根据输出结果到 jstack 打印的堆栈日志中查定位：\n\n"catalina-exec-5692" daemon prio=10 tid=0x00007f3b05013800 nid=0x45cd waiting on condition [0x00007f3ae08e3000]\n   java.lang.thread.state: timed_waiting (parking)\n        at sun.misc.unsafe.park(native method)\n        - parking to wait for  <0x00000006a7800598> (a java.util.concurrent.locks.abstractqueuedsynchronizer$conditionobject)\n        at java.util.concurrent.locks.locksupport.parknanos(locksupport.java:226)\n        at java.util.concurrent.locks.abstractqueuedsynchronizer$conditionobject.awaitnanos(abstractqueuedsynchronizer.java:2082)\n        at java.util.concurrent.linkedblockingqueue.poll(linkedblockingqueue.java:467)\n        at org.apache.tomcat.util.threads.taskqueue.poll(taskqueue.java:86)\n        at org.apache.tomcat.util.threads.taskqueue.poll(taskqueue.java:32)\n        at java.util.concurrent.threadpoolexecutor.gettask(threadpoolexecutor.java:1068)\n        at java.util.concurrent.threadpoolexecutor.runworker(threadpoolexecutor.java:1130)\n        at java.util.concurrent.threadpoolexecutor$worker.run(threadpoolexecutor.java:615)\n        at org.apache.tomcat.util.threads.taskthread$wrappingrunnable.run(taskthread.java:61)\n        at java.lang.thread.run(thread.java:745)\n\n\n\n# gc 配置\n\n> 详细参数说明请参考官方文档：javahotspot vm options，这里仅列举常用参数。\n\n\n# 堆大小设置\n\n年轻代的设置很关键。\n\njvm 中最大堆大小有三方面限制：\n\n 1. 相关操作系统的数据模型（32-bt 还是 64-bit）限制；\n 2. 系统的可用虚拟内存限制；\n 3. 系统的可用物理内存限制。\n\n整个堆大小 = 年轻代大小 + 年老代大小 + 持久代大小\n\n\n * 持久代一般固定大小为 64m。使用 -xx:permsize 设置。\n * 官方推荐年轻代占整个堆的 3/8。使用 -xmn 设置。\n\n\n# jvm 内存配置\n\n配置                  描述\n-xss                虚拟机栈大小。\n-xms                堆空间初始值。\n-xmx                堆空间最大值。\n-xmn                新生代空间大小。\n-xx:newsize         新生代空间初始值。\n-xx:maxnewsize      新生代空间最大值。\n-xx:newratio        新生代与年老代的比例。默认为 2，意味着老年代是新生代的 2 倍。\n-xx:survivorratio   新生代中调整 eden 区与 survivor 区的比例，默认为 8。即 eden 区为 80% 的大小，两个\n                    survivor 分别为 10% 的大小。\n-xx:permsize        永久代空间的初始值。\n-xx:maxpermsize     永久代空间的最大值。\n\n\n# gc 类型配置\n\n配置                        描述\n-xx:+useserialgc          使用 serial + serial old 垃圾回收器组合\n-xx:+useparallelgc        使用 parallel scavenge + parallel old 垃圾回收器组合\n-xx:+useparalleloldgc     使用 parallel old 垃圾回收器（jdk5 后已无用）\n-xx:+useparnewgc          使用 parnew + serial old 垃圾回收器\n-xx:+useconcmarksweepgc   使用 cms + parnew + serial old 垃圾回收器组合\n-xx:+useg1gc              使用 g1 垃圾回收器\n-xx:parallelcmsthreads    并发标记扫描垃圾回收器 = 为使用的线程数量\n\n\n# 垃圾回收器通用参数\n\n配置                       描述\npretenuresizethreshold   晋升年老代的对象大小。默认为 0。比如设为 10m，则超过 10m 的对象将不在 eden 区分配，而直接进入年老代。\nmaxtenuringthreshold     晋升老年代的最大年龄。默认为 15。比如设为 10，则对象在 10 次普通 gc 后将会被放入年老代。\ndisableexplicitgc        禁用 system.gc()\n\n\n# jmx\n\n开启 jmx 后，可以使用 jconsole 或 jvisualvm 进行监控 java 程序的基本信息和运行情况。\n\n-dcom.sun.management.jmxremote=true\n-dcom.sun.management.jmxremote.ssl=false\n-dcom.sun.management.jmxremote.authenticate=false\n-djava.rmi.server.hostname=127.0.0.1\n-dcom.sun.management.jmxremote.port=18888\n\n\n-djava.rmi.server.hostname 指定 java 程序运行的服务器，-dcom.sun.management.jmxremote.port 指定服务监听端口。\n\n\n# 远程 debug\n\n如果开启 java 应用的远程 debug 功能，需要指定如下参数：\n\n-xdebug\n-xnoagent\n-djava.compiler=none\n-xrunjdwp:transport=dt_socket,address=28888,server=y,suspend=n\n\n\naddress 即为远程 debug 的监听端口。\n\n\n# heapdump\n\n-xx:-omitstacktraceinfastthrow -xx:+heapdumponoutofmemoryerror\n\n\n\n# 辅助配置\n\n配置                                描述\n-xx:+printgcdetails               打印 gc 日志\n-xloggc:<filename>                指定 gc 日志文件名\n-xx:+heapdumponoutofmemoryerror   内存溢出时输出堆快照文件\n\n\n# 参考资料\n\n * 《深入理解 java 虚拟机》\n * 《java 性能调优实战》\n * 从表到里学习 jvm 实现\n * jvm（4）：jvm 调优-命令篇\n * java 系列笔记(4) - jvm 监控与调优\n * java 服务 gc 参数调优案例\n * jvm 调优总结（5）：典型配置\n * 如何合理的规划一次 jvm 性能调优\n * jvm 系列(九):如何优化 java gc「译」\n * https://my.oschina.net/feichexia/blog/196575',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 故障诊断",frontmatter:{title:"Java 故障诊断",categories:["编程","Java","JavaSE","JVM"],tags:["Java","JavaSE","JVM","故障诊断"],abbrlink:"10485f44",date:"2020-07-30T17:56:33.000Z",permalink:"/pages/92bd85/"},regularPath:"/06.JVM/22.Java%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD.html",relativePath:"06.JVM/22.Java故障诊断.md",key:"v-4de46402",path:"/pages/92bd85/",headers:[{level:2,title:"故障定位思路",slug:"故障定位思路",normalizedTitle:"故障定位思路",charIndex:16},{level:2,title:"CPU 问题",slug:"cpu-问题",normalizedTitle:"cpu 问题",charIndex:126},{level:3,title:"查找 CPU 占用率较高的进程、线程",slug:"查找-cpu-占用率较高的进程、线程",normalizedTitle:"查找 cpu 占用率较高的进程、线程",charIndex:260},{level:3,title:"是否存在频繁 GC",slug:"是否存在频繁-gc",normalizedTitle:"是否存在频繁 gc",charIndex:1639},{level:3,title:"是否存在频繁上下文切换",slug:"是否存在频繁上下文切换",normalizedTitle:"是否存在频繁上下文切换",charIndex:2678},{level:2,title:"内存问题",slug:"内存问题",normalizedTitle:"内存问题",charIndex:3292},{level:2,title:"磁盘问题",slug:"磁盘问题",normalizedTitle:"磁盘问题",charIndex:3635},{level:3,title:"查看磁盘空间使用率",slug:"查看磁盘空间使用率",normalizedTitle:"查看磁盘空间使用率",charIndex:3644},{level:3,title:"查看磁盘读写性能",slug:"查看磁盘读写性能",normalizedTitle:"查看磁盘读写性能",charIndex:4064},{level:3,title:"查看具体的文件读写情况",slug:"查看具体的文件读写情况",normalizedTitle:"查看具体的文件读写情况",charIndex:4819},{level:2,title:"网络问题",slug:"网络问题",normalizedTitle:"网络问题",charIndex:4856},{level:3,title:"无法连接",slug:"无法连接",normalizedTitle:"无法连接",charIndex:4865},{level:3,title:"网络超时",slug:"网络超时",normalizedTitle:"网络超时",charIndex:4944},{level:3,title:"TCP 队列溢出",slug:"tcp-队列溢出",normalizedTitle:"tcp 队列溢出",charIndex:5608},{level:3,title:"RST 异常",slug:"rst-异常",normalizedTitle:"rst 异常",charIndex:6664},{level:3,title:"TIMEWAIT 和 CLOSEWAIT",slug:"time-wait-和-close-wait",normalizedTitle:"timewait 和 closewait",charIndex:null},{level:4,title:"TIME_WAIT",slug:"time-wait",normalizedTitle:"time_wait",charIndex:7704},{level:4,title:"CLOSE_WAIT",slug:"close-wait",normalizedTitle:"close_wait",charIndex:7716},{level:2,title:"GC 问题",slug:"gc-问题",normalizedTitle:"gc 问题",charIndex:1707},{level:3,title:"OOM",slug:"oom",normalizedTitle:"oom",charIndex:3331},{level:3,title:"Minor GC",slug:"minor-gc",normalizedTitle:"minor gc",charIndex:9293},{level:4,title:"Minor GC 过频",slug:"minor-gc-过频",normalizedTitle:"minor gc 过频",charIndex:9541},{level:4,title:"Minor GC 耗时过长",slug:"minor-gc-耗时过长",normalizedTitle:"minor gc 耗时过长",charIndex:9725},{level:3,title:"Full GC 过频",slug:"full-gc-过频",normalizedTitle:"full gc 过频",charIndex:9952},{level:2,title:"常用 Linux 命令",slug:"常用-linux-命令",normalizedTitle:"常用 linux 命令",charIndex:10712},{level:3,title:"top",slug:"top",normalizedTitle:"top",charIndex:418},{level:3,title:"vmstat",slug:"vmstat",normalizedTitle:"vmstat",charIndex:2708},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:11312}],headersStr:"故障定位思路 CPU 问题 查找 CPU 占用率较高的进程、线程 是否存在频繁 GC 是否存在频繁上下文切换 内存问题 磁盘问题 查看磁盘空间使用率 查看磁盘读写性能 查看具体的文件读写情况 网络问题 无法连接 网络超时 TCP 队列溢出 RST 异常 TIMEWAIT 和 CLOSEWAIT TIME_WAIT CLOSE_WAIT GC 问题 OOM Minor GC Minor GC 过频 Minor GC 耗时过长 Full GC 过频 常用 Linux 命令 top vmstat 参考资料",content:"# Java 故障诊断\n\n\n# 故障定位思路\n\nJava 应用出现线上故障，如何进行诊断？\n\n我们在定位线上问题时要有一个整体的思路，顺藤摸瓜，才能较快的找到问题原因。\n\n一般来说，服务器故障诊断的整体思路如下：\n\n\n\n应用故障诊断思路：\n\n\n\n\n# CPU 问题\n\n一、CPU 使用率过高：往往是由于程序逻辑问题导致的。常见导致 CPU 飙升的问题场景如：死循环，无限递归、频繁 GC、线程上下文切换过多。\n\n二、CPU 始终升不上去：往往是由于程序中存在大量 IO 操作并且时间很长（数据库读写、日志等）。\n\n\n# 查找 CPU 占用率较高的进程、线程\n\n线上环境的 Java 应用可能有多个进程、线程，所以，要先找到 CPU 占用率较高的进程、线程。\n\n（1）使用 ps 命令查看 xxx 应用的进程 ID（PID）\n\nps -ef | grep xxx\n\n\n也可以使用 jps 命令来查看。\n\n（2）如果应用有多个进程，可以用 top 命令查看哪个占用 CPU 较高。\n\n（3）用 top -Hp pid 来找到 CPU 使用率比较高的一些线程。\n\n（4）将占用 CPU 最高的 PID 转换为 16 进制，使用 printf '%x\\n' pid 得到 nid\n\n（5）使用 jstack pic | grep 'nid' -C5 命令，查看堆栈信息：\n\n$ jstack 7129 | grep '0x1c23' -C5\n        at java.lang.Object.wait(Object.java:502)\n        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)\n        - locked <0x00000000b5383ff0> (a java.lang.ref.Reference$Lock)\n        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)\n\n\"main\" #1 prio=5 os_prio=0 tid=0x00007f4df400a800 nid=0x1c23 in Object.wait() [0x00007f4dfdec8000]\n   java.lang.Thread.State: WAITING (on object monitor)\n        at java.lang.Object.wait(Native Method)\n        - waiting on <0x00000000b5384018> (a org.apache.felix.framework.util.ThreadGate)\n        at org.apache.felix.framework.util.ThreadGate.await(ThreadGate.java:79)\n        - locked <0x00000000b5384018> (a org.apache.felix.framework.util.ThreadGate)\n\n\n（6）更常见的操作是用 jstack 生成堆栈快照，然后基于快照文件进行分析。生成快照命令：\n\njstack -F -l pid >> threaddump.log\n\n\n（7）分析堆栈信息\n\n一般来说，状态为 WAITING、TIMED_WAITING 、BLOCKED 的线程更可能出现问题。可以执行以下命令查看线程状态统计：\n\ncat threaddump.log | grep \"java.lang.Thread.State\" | sort -nr | uniq -c\n\n\n如果存在大量 WAITING、TIMED_WAITING 、BLOCKED ，那么多半是有问题啦。\n\n\n# 是否存在频繁 GC\n\n如果应用频繁 GC，也可能导致 CPU 飙升。为何频繁 GC 可以使用 jstack 来分析问题（分析和解决频繁 GC 问题，在后续讲解）。\n\n那么，如何判断 Java 进程 GC 是否频繁？\n\n可以使用 jstat -gc pid 1000 命令来观察 GC 状态。\n\n$ jstat -gc 29527 200 5\n S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT\n22528.0 22016.0  0.0   21388.2 4106752.0 921244.7 5592576.0  2086826.5  110716.0 103441.1 12416.0 11167.7   3189   90.057  10      2.140   92.197\n22528.0 22016.0  0.0   21388.2 4106752.0 921244.7 5592576.0  2086826.5  110716.0 103441.1 12416.0 11167.7   3189   90.057  10      2.140   92.197\n22528.0 22016.0  0.0   21388.2 4106752.0 921244.7 5592576.0  2086826.5  110716.0 103441.1 12416.0 11167.7   3189   90.057  10      2.140   92.197\n22528.0 22016.0  0.0   21388.2 4106752.0 921244.7 5592576.0  2086826.5  110716.0 103441.1 12416.0 11167.7   3189   90.057  10      2.140   92.197\n22528.0 22016.0  0.0   21388.2 4106752.0 921244.7 5592576.0  2086826.5  110716.0 103441.1 12416.0 11167.7   3189   90.057  10      2.140   92.197\n\n\n\n# 是否存在频繁上下文切换\n\n针对频繁上下文切换问题，可以使用 vmstat pid 命令来进行查看。\n\n$ vmstat 7129\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0   6836 737532   1588 3504956    0    0     1     4    5    3  0  0 100  0  0\n\n\n其中，cs 一列代表了上下文切换的次数。\n\n【解决方法】\n\n如果，线程上下文切换很频繁，可以考虑在应用中针对线程进行优化，方法有：\n\n * 无锁并发：多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照 Hash 取模分段，不同的线程处理不同段的数据；\n * CAS 算法：Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁；\n * 最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态；\n * 使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换；\n\n\n# 内存问题\n\n内存问题诊断起来相对比 CPU 麻烦一些，场景也比较多。主要包括 OOM、GC 问题和堆外内存。一般来讲，我们会先用 free 命令先来检查一发内存的各种情况。\n\n诊断内存问题，一般首先会用 free 命令查看一下机器的物理内存使用情况。\n\n$ free\n              total        used        free      shared  buff/cache   available\nMem:        8011164     3767900      735364        8804     3507900     3898568\nSwap:       5242876        6836     5236040\n\n\n\n# 磁盘问题\n\n\n# 查看磁盘空间使用率\n\n可以使用 df -hl 命令查看磁盘空间使用率。\n\n$ df -hl\nFilesystem      Size  Used Avail Use% Mounted on\ndevtmpfs        494M     0  494M   0% /dev\ntmpfs           504M     0  504M   0% /dev/shm\ntmpfs           504M   58M  447M  12% /run\ntmpfs           504M     0  504M   0% /sys/fs/cgroup\n/dev/sda2        20G  5.7G   13G  31% /\n/dev/sda1       380M  142M  218M  40% /boot\ntmpfs           101M     0  101M   0% /run/user/0\n\n\n\n# 查看磁盘读写性能\n\n可以使用 iostat 命令查看磁盘读写性能。\n\niostat -d -k -x\nLinux 3.10.0-327.el7.x86_64 (elk-server)        03/07/2020      _x86_64_        (4 CPU)\n\nDevice:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util\nsda               0.00     0.14    0.01    1.63     0.42   157.56   193.02     0.00    2.52   11.43    2.48   0.60   0.10\nscd0              0.00     0.00    0.00    0.00     0.00     0.00     8.00     0.00    0.27    0.27    0.00   0.27   0.00\ndm-0              0.00     0.00    0.01    1.78     0.41   157.56   177.19     0.00    2.46   12.09    2.42   0.59   0.10\ndm-1              0.00     0.00    0.00    0.00     0.00     0.00    16.95     0.00    1.04    1.04    0.00   1.02   0.00\n\n\n\n# 查看具体的文件读写情况\n\n可以使用 lsof -p pid 命令\n\n\n# 网络问题\n\n\n# 无法连接\n\n可以通过 ping 命令，查看是否能连通。\n\n通过 netstat -nlp | grep <port> 命令，查看服务端口是否在工作。\n\n\n# 网络超时\n\n网络超时问题大部分出在应用层面。超时大体可以分为连接超时和读写超时，某些使用连接池的客户端框架还会存在获取连接超时和空闲连接清理超时。\n\n * 读写超时。readTimeout/writeTimeout，有些框架叫做 so_timeout 或者 socketTimeout，均指的是数据读写超时。注意这边的超时大部分是指逻辑上的超时。soa 的超时指的也是读超时。读写超时一般都只针对客户端设置。\n * 连接超时。connectionTimeout，客户端通常指与服务端建立连接的最大时间。服务端这边 connectionTimeout 就有些五花八门了，jetty 中表示空闲连接清理时间，tomcat 则表示连接维持的最大时间。\n * 其他。包括连接获取超时 connectionAcquireTimeout 和空闲连接清理超时 idleConnectionTimeout。多用于使用连接池或队列的客户端或服务端框架。\n\n我们在设置各种超时时间中，需要确认的是尽量保持客户端的超时小于服务端的超时，以保证连接正常结束。\n\n在实际开发中，我们关心最多的应该是接口的读写超时了。\n\n如何设置合理的接口超时是一个问题。如果接口超时设置的过长，那么有可能会过多地占用服务端的 tcp 连接。而如果接口设置的过短，那么接口超时就会非常频繁。\n\n服务端接口明明 rt 降低，但客户端仍然一直超时又是另一个问题。这个问题其实很简单，客户端到服务端的链路包括网络传输、排队以及服务处理等，每一个环节都可能是耗时的原因。\n\n\n# TCP 队列溢出\n\ntcp 队列溢出是个相对底层的错误，它可能会造成超时、rst 等更表层的错误。因此错误也更隐蔽，所以我们单独说一说。\n\n如上图所示，这里有两个队列：syns queue(半连接队列）、accept queue（全连接队列）。三次握手，在 server 收到 client 的 syn 后，把消息放到 syns queue，回复 syn+ack 给 client，server 收到 client 的 ack，如果这时 accept queue 没满，那就从 syns queue 拿出暂存的信息放入 accept queue 中，否则按 tcp_abort_on_overflow 指示的执行。\n\ntcp_abort_on_overflow 0 表示如果三次握手第三步的时候 accept queue 满了那么 server 扔掉 client 发过来的 ack。tcp_abort_on_overflow 1 则表示第三步的时候如果全连接队列满了，server 发送一个 rst 包给 client，表示废掉这个握手过程和这个连接，意味着日志里可能会有很多connection reset / connection reset by peer。\n\n那么在实际开发中，我们怎么能快速定位到 tcp 队列溢出呢？\n\nnetstat 命令，执行 netstat -s | egrep \"listen|LISTEN\" 如上图所示，overflowed 表示全连接队列溢出的次数，sockets dropped 表示半连接队列溢出的次数。\n\nss 命令，执行 ss -lnt 上面看到 Send-Q 表示第三列的 listen 端口上的全连接队列最大为 5，第一列 Recv-Q 为全连接队列当前使用了多少。\n\n接着我们看看怎么设置全连接、半连接队列大小吧：\n\n全连接队列的大小取决于 min(backlog, somaxconn)。backlog 是在 socket 创建的时候传入的，somaxconn 是一个 os 级别的系统参数。而半连接队列的大小取决于 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。\n\n在日常开发中，我们往往使用 servlet 容器作为服务端，所以我们有时候也需要关注容器的连接队列大小。在 tomcat 中 backlog 叫做acceptCount，在 jetty 里面则是acceptQueueSize。\n\n\n# RST 异常\n\nRST 包表示连接重置，用于关闭一些无用的连接，通常表示异常关闭，区别于四次挥手。\n\n在实际开发中，我们往往会看到connection reset / connection reset by peer错误，这种情况就是 RST 包导致的。\n\n端口不存在\n\n如果像不存在的端口发出建立连接 SYN 请求，那么服务端发现自己并没有这个端口则会直接返回一个 RST 报文，用于中断连接。\n\n主动代替 FIN 终止连接\n\n一般来说，正常的连接关闭都是需要通过 FIN 报文实现，然而我们也可以用 RST 报文来代替 FIN，表示直接终止连接。实际开发中，可设置 SO_LINGER 数值来控制，这种往往是故意的，来跳过 TIMED_WAIT，提供交互效率，不闲就慎用。\n\n客户端或服务端有一边发生了异常，该方向对端发送 RST 以告知关闭连接\n\n我们上面讲的 tcp 队列溢出发送 RST 包其实也是属于这一种。这种往往是由于某些原因，一方无法再能正常处理请求连接了(比如程序崩了，队列满了)，从而告知另一方关闭连接。\n\n接收到的 TCP 报文不在已知的 TCP 连接内\n\n比如，一方机器由于网络实在太差 TCP 报文失踪了，另一方关闭了该连接，然后过了许久收到了之前失踪的 TCP 报文，但由于对应的 TCP 连接已不存在，那么会直接发一个 RST 包以便开启新的连接。\n\n一方长期未收到另一方的确认报文，在一定时间或重传次数后发出 RST 报文\n\n这种大多也和网络环境相关了，网络环境差可能会导致更多的 RST 报文。\n\n之前说过 RST 报文多会导致程序报错，在一个已关闭的连接上读操作会报connection reset，而在一个已关闭的连接上写操作则会报connection reset by peer。通常我们可能还会看到broken pipe错误，这是管道层面的错误，表示对已关闭的管道进行读写，往往是在收到 RST，报出connection reset错后继续读写数据报的错，这个在 glibc 源码注释中也有介绍。\n\n我们在诊断故障时候怎么确定有 RST 包的存在呢？当然是使用 tcpdump 命令进行抓包，并使用 wireshark 进行简单分析了。tcpdump -i en0 tcp -w xxx.cap，en0 表示监听的网卡。\n\n接下来我们通过 wireshark 打开抓到的包，可能就能看到如下图所示，红色的就表示 RST 包了。\n\n\n# TIME_WAIT 和 CLOSE_WAIT\n\nTIME_WAIT 和 CLOSE_WAIT 是啥意思相信大家都知道。 在线上时，我们可以直接用命令netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'来查看 time-wait 和 close_wait 的数量\n\n用 ss 命令会更快ss -ant | awk '{++S[$1]} END {for(a in S) print a, S[a]}'\n\n\n\n# TIME_WAIT\n\ntime_wait 的存在一是为了丢失的数据包被后面连接复用，二是为了在 2MSL 的时间范围内正常关闭连接。它的存在其实会大大减少 RST 包的出现。\n\n过多的 time_wait 在短连接频繁的场景比较容易出现。这种情况可以在服务端做一些内核参数调优:\n\n#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭\nnet.ipv4.tcp_tw_reuse = 1\n#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭\nnet.ipv4.tcp_tw_recycle = 1\n\n\n当然我们不要忘记在 NAT 环境下因为时间戳错乱导致数据包被拒绝的坑了，另外的办法就是改小tcp_max_tw_buckets，超过这个数的 time_wait 都会被干掉，不过这也会导致报time wait bucket table overflow的错。\n\n# CLOSE_WAIT\n\nclose_wait 往往都是因为应用程序写的有问题，没有在 ACK 后再次发起 FIN 报文。close_wait 出现的概率甚至比 time_wait 要更高，后果也更严重。往往是由于某个地方阻塞住了，没有正常关闭连接，从而渐渐地消耗完所有的线程。\n\n想要定位这类问题，最好是通过 jstack 来分析线程堆栈来诊断问题，具体可参考上述章节。这里仅举一个例子。\n\n开发同学说应用上线后 CLOSE_WAIT 就一直增多，直到挂掉为止，jstack 后找到比较可疑的堆栈是大部分线程都卡在了countdownlatch.await方法，找开发同学了解后得知使用了多线程但是确没有 catch 异常，修改后发现异常仅仅是最简单的升级 sdk 后常出现的class not found。\n\n\n# GC 问题\n\nGC 问题除了影响 CPU 也会影响内存，诊断思路也是一致的。\n\n（1）通常，先使用 jstat 来查看分代变化情况，比如 minor gc 或 full gc 次数是不是太频繁、耗时太久。\n\n线程量太大，且不被及时 GC 也会引发 OOM，大部分就是之前说的 unable to create new native thread。除了 jstack 细细分析 dump 文件外，我们一般先会看下总体线程。\n\n可以执行以下命令中任意一个，没来查看当前进程创建的总线程数。\n\npstreee -p pid | wc -l\nls -l /proc/pid/task | wc -l\n\n\n堆内内存泄漏总是和 GC 异常相伴。不过 GC 问题不只是和内存问题相关，还有可能引起 CPU 负载、网络问题等系列并发症，只是相对来说和内存联系紧密些，所以我们在此单独总结一下 GC 相关问题。\n\n我们在 cpu 章介绍了使用 jstat 来获取当前 GC 分代变化信息。而更多时候，我们是通过 GC 日志来诊断问题的，在启动参数中加上-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps来开启 GC 日志。 常见的 Minor GC、Full GC 日志含义在此就不做赘述了。\n\n针对 gc 日志，我们就能大致推断出 Minor GC 与 fullGC 是否过于频繁或者耗时过长，从而对症下药。我们下面将对 G1 垃圾收集器来做分析，这边也建议大家使用 G1-XX:+UseG1GC。\n\n\n# OOM\n\n查看 GC 日志，如果有明显提示 OOM 问题，那就可以根据提示信息，较为快速的定位问题。\n\n> OOM 定位可以参考：JVM 内存管理 之 OutOfMemoryError\n\n\n# Minor GC\n\n# Minor GC 过频\n\nMinor GC 频繁一般是短周期的 Java 小对象较多。\n\n（1）先考虑是不是 Eden 区/新生代设置的太小了，看能否通过调整 -Xmn、-XX:SurvivorRatio 等参数设置来解决问题。\n\n（2）如果参数正常，但是 Minor GC 频率还是太高，就需要使用 jmap 和 MAT 对 dump 文件进行进一步诊断了。\n\n# Minor GC 耗时过长\n\nMinor GC 耗时过长问题就要看 GC 日志里耗时耗在哪一块了。\n\n以 G1 GC 日志为例，可以关注 Root Scanning、Object Copy、Ref Proc 等阶段。Ref Proc 耗时长，就要注意引用相关的对象。Root Scanning 耗时长，就要注意线程数、跨代引用。Object Copy 则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。\n\n\n# Full GC 过频\n\nG1 中更多的还是 mixedGC，但 mixedGC 可以和 Minor GC 思路一样去诊断。触发 fullGC 了一般都会有问题，G1 会退化使用 Serial 收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。\n\nfullGC 的原因可能包括以下这些，以及参数调整方面的一些思路：\n\n * 并发阶段失败：在并发标记阶段，MixGC 之前老年代就被填满了，那么这时候 G1 就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数-XX:ConcGCThreads。\n * 晋升失败：在 GC 的时候没有足够的内存供存活/晋升对象使用，所以触发了 Full GC。这时候可以通过-XX:G1ReservePercent来增加预留内存百分比，减少-XX:InitiatingHeapOccupancyPercent来提前启动标记，-XX:ConcGCThreads来增加标记线程数也是可以的。\n * 大对象分配失败：大对象找不到合适的 region 空间进行分配，就会进行 fullGC，这种情况下可以增大内存或者增大-XX:G1HeapRegionSize。\n * 程序主动执行 System.gc()：不要随便写就对了。\n\n另外，我们可以在启动参数中配置-XX:HeapDumpPath=/xxx/dump.hprof来 dump fullGC 相关的文件，并通过 jinfo 来进行 gc 前后的 dump\n\njinfo -flag +HeapDumpBeforeFullGC pid\njinfo -flag +HeapDumpAfterFullGC pid\n\n\n这样得到 2 份 dump 文件，对比后主要关注被 gc 掉的问题对象来定位问题。\n\n\n# 常用 Linux 命令\n\n在故障排查时，有一些 Linux 命令十分有用，建议掌握。\n\n\n# top\n\ntop 命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。\n\n通常，会使用 top -Hp pid 查看具体线程使用系统资源情况。\n\n> 命令详情参考：http://man.linuxde.net/top\n\n\n# vmstat\n\nvmstat 是一款指定采样周期和次数的功能性监测工具，我们可以看到，它不仅可以统计内存的使用情况，还可以观测到 CPU 的使用率、swap 的使用情况。但 vmstat 一般很少用来查看内存的使用情况，而是经常被用来观察进程的上下文切换。\n\n * r：等待运行的进程数；\n * b：处于非中断睡眠状态的进程数；\n * swpd：虚拟内存使用情况；\n * free：空闲的内存；\n * buff：用来作为缓冲的内存数；\n * si：从磁盘交换到内存的交换页数量；\n * so：从内存交换到磁盘的交换页数量；\n * bi：发送到块设备的块数；\n * bo：从块设备接收到的块数；\n * in：每秒中断数；\n * cs：每秒上下文切换次数；\n * us：用户 CPU 使用时间；\n * sy：内核 CPU 系统使用时间；\n * id：空闲时间；\n * wa：等待 I/O 时间；\n * st：运行虚拟机窃取的时间。\n\n\n# 参考资料\n\n * 《Java 性能调优实战》\n * JAVA 线上故障诊断全套路\n * 从实际案例聊聊 Java 应用的 GC 优化",normalizedContent:"# java 故障诊断\n\n\n# 故障定位思路\n\njava 应用出现线上故障，如何进行诊断？\n\n我们在定位线上问题时要有一个整体的思路，顺藤摸瓜，才能较快的找到问题原因。\n\n一般来说，服务器故障诊断的整体思路如下：\n\n\n\n应用故障诊断思路：\n\n\n\n\n# cpu 问题\n\n一、cpu 使用率过高：往往是由于程序逻辑问题导致的。常见导致 cpu 飙升的问题场景如：死循环，无限递归、频繁 gc、线程上下文切换过多。\n\n二、cpu 始终升不上去：往往是由于程序中存在大量 io 操作并且时间很长（数据库读写、日志等）。\n\n\n# 查找 cpu 占用率较高的进程、线程\n\n线上环境的 java 应用可能有多个进程、线程，所以，要先找到 cpu 占用率较高的进程、线程。\n\n（1）使用 ps 命令查看 xxx 应用的进程 id（pid）\n\nps -ef | grep xxx\n\n\n也可以使用 jps 命令来查看。\n\n（2）如果应用有多个进程，可以用 top 命令查看哪个占用 cpu 较高。\n\n（3）用 top -hp pid 来找到 cpu 使用率比较高的一些线程。\n\n（4）将占用 cpu 最高的 pid 转换为 16 进制，使用 printf '%x\\n' pid 得到 nid\n\n（5）使用 jstack pic | grep 'nid' -c5 命令，查看堆栈信息：\n\n$ jstack 7129 | grep '0x1c23' -c5\n        at java.lang.object.wait(object.java:502)\n        at java.lang.ref.reference.tryhandlepending(reference.java:191)\n        - locked <0x00000000b5383ff0> (a java.lang.ref.reference$lock)\n        at java.lang.ref.reference$referencehandler.run(reference.java:153)\n\n\"main\" #1 prio=5 os_prio=0 tid=0x00007f4df400a800 nid=0x1c23 in object.wait() [0x00007f4dfdec8000]\n   java.lang.thread.state: waiting (on object monitor)\n        at java.lang.object.wait(native method)\n        - waiting on <0x00000000b5384018> (a org.apache.felix.framework.util.threadgate)\n        at org.apache.felix.framework.util.threadgate.await(threadgate.java:79)\n        - locked <0x00000000b5384018> (a org.apache.felix.framework.util.threadgate)\n\n\n（6）更常见的操作是用 jstack 生成堆栈快照，然后基于快照文件进行分析。生成快照命令：\n\njstack -f -l pid >> threaddump.log\n\n\n（7）分析堆栈信息\n\n一般来说，状态为 waiting、timed_waiting 、blocked 的线程更可能出现问题。可以执行以下命令查看线程状态统计：\n\ncat threaddump.log | grep \"java.lang.thread.state\" | sort -nr | uniq -c\n\n\n如果存在大量 waiting、timed_waiting 、blocked ，那么多半是有问题啦。\n\n\n# 是否存在频繁 gc\n\n如果应用频繁 gc，也可能导致 cpu 飙升。为何频繁 gc 可以使用 jstack 来分析问题（分析和解决频繁 gc 问题，在后续讲解）。\n\n那么，如何判断 java 进程 gc 是否频繁？\n\n可以使用 jstat -gc pid 1000 命令来观察 gc 状态。\n\n$ jstat -gc 29527 200 5\n s0c    s1c    s0u    s1u      ec       eu        oc         ou       mc     mu    ccsc   ccsu   ygc     ygct    fgc    fgct     gct\n22528.0 22016.0  0.0   21388.2 4106752.0 921244.7 5592576.0  2086826.5  110716.0 103441.1 12416.0 11167.7   3189   90.057  10      2.140   92.197\n22528.0 22016.0  0.0   21388.2 4106752.0 921244.7 5592576.0  2086826.5  110716.0 103441.1 12416.0 11167.7   3189   90.057  10      2.140   92.197\n22528.0 22016.0  0.0   21388.2 4106752.0 921244.7 5592576.0  2086826.5  110716.0 103441.1 12416.0 11167.7   3189   90.057  10      2.140   92.197\n22528.0 22016.0  0.0   21388.2 4106752.0 921244.7 5592576.0  2086826.5  110716.0 103441.1 12416.0 11167.7   3189   90.057  10      2.140   92.197\n22528.0 22016.0  0.0   21388.2 4106752.0 921244.7 5592576.0  2086826.5  110716.0 103441.1 12416.0 11167.7   3189   90.057  10      2.140   92.197\n\n\n\n# 是否存在频繁上下文切换\n\n针对频繁上下文切换问题，可以使用 vmstat pid 命令来进行查看。\n\n$ vmstat 7129\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0   6836 737532   1588 3504956    0    0     1     4    5    3  0  0 100  0  0\n\n\n其中，cs 一列代表了上下文切换的次数。\n\n【解决方法】\n\n如果，线程上下文切换很频繁，可以考虑在应用中针对线程进行优化，方法有：\n\n * 无锁并发：多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 id 按照 hash 取模分段，不同的线程处理不同段的数据；\n * cas 算法：java 的 atomic 包使用 cas 算法来更新数据，而不需要加锁；\n * 最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态；\n * 使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换；\n\n\n# 内存问题\n\n内存问题诊断起来相对比 cpu 麻烦一些，场景也比较多。主要包括 oom、gc 问题和堆外内存。一般来讲，我们会先用 free 命令先来检查一发内存的各种情况。\n\n诊断内存问题，一般首先会用 free 命令查看一下机器的物理内存使用情况。\n\n$ free\n              total        used        free      shared  buff/cache   available\nmem:        8011164     3767900      735364        8804     3507900     3898568\nswap:       5242876        6836     5236040\n\n\n\n# 磁盘问题\n\n\n# 查看磁盘空间使用率\n\n可以使用 df -hl 命令查看磁盘空间使用率。\n\n$ df -hl\nfilesystem      size  used avail use% mounted on\ndevtmpfs        494m     0  494m   0% /dev\ntmpfs           504m     0  504m   0% /dev/shm\ntmpfs           504m   58m  447m  12% /run\ntmpfs           504m     0  504m   0% /sys/fs/cgroup\n/dev/sda2        20g  5.7g   13g  31% /\n/dev/sda1       380m  142m  218m  40% /boot\ntmpfs           101m     0  101m   0% /run/user/0\n\n\n\n# 查看磁盘读写性能\n\n可以使用 iostat 命令查看磁盘读写性能。\n\niostat -d -k -x\nlinux 3.10.0-327.el7.x86_64 (elk-server)        03/07/2020      _x86_64_        (4 cpu)\n\ndevice:         rrqm/s   wrqm/s     r/s     w/s    rkb/s    wkb/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util\nsda               0.00     0.14    0.01    1.63     0.42   157.56   193.02     0.00    2.52   11.43    2.48   0.60   0.10\nscd0              0.00     0.00    0.00    0.00     0.00     0.00     8.00     0.00    0.27    0.27    0.00   0.27   0.00\ndm-0              0.00     0.00    0.01    1.78     0.41   157.56   177.19     0.00    2.46   12.09    2.42   0.59   0.10\ndm-1              0.00     0.00    0.00    0.00     0.00     0.00    16.95     0.00    1.04    1.04    0.00   1.02   0.00\n\n\n\n# 查看具体的文件读写情况\n\n可以使用 lsof -p pid 命令\n\n\n# 网络问题\n\n\n# 无法连接\n\n可以通过 ping 命令，查看是否能连通。\n\n通过 netstat -nlp | grep <port> 命令，查看服务端口是否在工作。\n\n\n# 网络超时\n\n网络超时问题大部分出在应用层面。超时大体可以分为连接超时和读写超时，某些使用连接池的客户端框架还会存在获取连接超时和空闲连接清理超时。\n\n * 读写超时。readtimeout/writetimeout，有些框架叫做 so_timeout 或者 sockettimeout，均指的是数据读写超时。注意这边的超时大部分是指逻辑上的超时。soa 的超时指的也是读超时。读写超时一般都只针对客户端设置。\n * 连接超时。connectiontimeout，客户端通常指与服务端建立连接的最大时间。服务端这边 connectiontimeout 就有些五花八门了，jetty 中表示空闲连接清理时间，tomcat 则表示连接维持的最大时间。\n * 其他。包括连接获取超时 connectionacquiretimeout 和空闲连接清理超时 idleconnectiontimeout。多用于使用连接池或队列的客户端或服务端框架。\n\n我们在设置各种超时时间中，需要确认的是尽量保持客户端的超时小于服务端的超时，以保证连接正常结束。\n\n在实际开发中，我们关心最多的应该是接口的读写超时了。\n\n如何设置合理的接口超时是一个问题。如果接口超时设置的过长，那么有可能会过多地占用服务端的 tcp 连接。而如果接口设置的过短，那么接口超时就会非常频繁。\n\n服务端接口明明 rt 降低，但客户端仍然一直超时又是另一个问题。这个问题其实很简单，客户端到服务端的链路包括网络传输、排队以及服务处理等，每一个环节都可能是耗时的原因。\n\n\n# tcp 队列溢出\n\ntcp 队列溢出是个相对底层的错误，它可能会造成超时、rst 等更表层的错误。因此错误也更隐蔽，所以我们单独说一说。\n\n如上图所示，这里有两个队列：syns queue(半连接队列）、accept queue（全连接队列）。三次握手，在 server 收到 client 的 syn 后，把消息放到 syns queue，回复 syn+ack 给 client，server 收到 client 的 ack，如果这时 accept queue 没满，那就从 syns queue 拿出暂存的信息放入 accept queue 中，否则按 tcp_abort_on_overflow 指示的执行。\n\ntcp_abort_on_overflow 0 表示如果三次握手第三步的时候 accept queue 满了那么 server 扔掉 client 发过来的 ack。tcp_abort_on_overflow 1 则表示第三步的时候如果全连接队列满了，server 发送一个 rst 包给 client，表示废掉这个握手过程和这个连接，意味着日志里可能会有很多connection reset / connection reset by peer。\n\n那么在实际开发中，我们怎么能快速定位到 tcp 队列溢出呢？\n\nnetstat 命令，执行 netstat -s | egrep \"listen|listen\" 如上图所示，overflowed 表示全连接队列溢出的次数，sockets dropped 表示半连接队列溢出的次数。\n\nss 命令，执行 ss -lnt 上面看到 send-q 表示第三列的 listen 端口上的全连接队列最大为 5，第一列 recv-q 为全连接队列当前使用了多少。\n\n接着我们看看怎么设置全连接、半连接队列大小吧：\n\n全连接队列的大小取决于 min(backlog, somaxconn)。backlog 是在 socket 创建的时候传入的，somaxconn 是一个 os 级别的系统参数。而半连接队列的大小取决于 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。\n\n在日常开发中，我们往往使用 servlet 容器作为服务端，所以我们有时候也需要关注容器的连接队列大小。在 tomcat 中 backlog 叫做acceptcount，在 jetty 里面则是acceptqueuesize。\n\n\n# rst 异常\n\nrst 包表示连接重置，用于关闭一些无用的连接，通常表示异常关闭，区别于四次挥手。\n\n在实际开发中，我们往往会看到connection reset / connection reset by peer错误，这种情况就是 rst 包导致的。\n\n端口不存在\n\n如果像不存在的端口发出建立连接 syn 请求，那么服务端发现自己并没有这个端口则会直接返回一个 rst 报文，用于中断连接。\n\n主动代替 fin 终止连接\n\n一般来说，正常的连接关闭都是需要通过 fin 报文实现，然而我们也可以用 rst 报文来代替 fin，表示直接终止连接。实际开发中，可设置 so_linger 数值来控制，这种往往是故意的，来跳过 timed_wait，提供交互效率，不闲就慎用。\n\n客户端或服务端有一边发生了异常，该方向对端发送 rst 以告知关闭连接\n\n我们上面讲的 tcp 队列溢出发送 rst 包其实也是属于这一种。这种往往是由于某些原因，一方无法再能正常处理请求连接了(比如程序崩了，队列满了)，从而告知另一方关闭连接。\n\n接收到的 tcp 报文不在已知的 tcp 连接内\n\n比如，一方机器由于网络实在太差 tcp 报文失踪了，另一方关闭了该连接，然后过了许久收到了之前失踪的 tcp 报文，但由于对应的 tcp 连接已不存在，那么会直接发一个 rst 包以便开启新的连接。\n\n一方长期未收到另一方的确认报文，在一定时间或重传次数后发出 rst 报文\n\n这种大多也和网络环境相关了，网络环境差可能会导致更多的 rst 报文。\n\n之前说过 rst 报文多会导致程序报错，在一个已关闭的连接上读操作会报connection reset，而在一个已关闭的连接上写操作则会报connection reset by peer。通常我们可能还会看到broken pipe错误，这是管道层面的错误，表示对已关闭的管道进行读写，往往是在收到 rst，报出connection reset错后继续读写数据报的错，这个在 glibc 源码注释中也有介绍。\n\n我们在诊断故障时候怎么确定有 rst 包的存在呢？当然是使用 tcpdump 命令进行抓包，并使用 wireshark 进行简单分析了。tcpdump -i en0 tcp -w xxx.cap，en0 表示监听的网卡。\n\n接下来我们通过 wireshark 打开抓到的包，可能就能看到如下图所示，红色的就表示 rst 包了。\n\n\n# time_wait 和 close_wait\n\ntime_wait 和 close_wait 是啥意思相信大家都知道。 在线上时，我们可以直接用命令netstat -n | awk '/^tcp/ {++s[$nf]} end {for(a in s) print a, s[a]}'来查看 time-wait 和 close_wait 的数量\n\n用 ss 命令会更快ss -ant | awk '{++s[$1]} end {for(a in s) print a, s[a]}'\n\n\n\n# time_wait\n\ntime_wait 的存在一是为了丢失的数据包被后面连接复用，二是为了在 2msl 的时间范围内正常关闭连接。它的存在其实会大大减少 rst 包的出现。\n\n过多的 time_wait 在短连接频繁的场景比较容易出现。这种情况可以在服务端做一些内核参数调优:\n\n#表示开启重用。允许将time-wait sockets重新用于新的tcp连接，默认为0，表示关闭\nnet.ipv4.tcp_tw_reuse = 1\n#表示开启tcp连接中time-wait sockets的快速回收，默认为0，表示关闭\nnet.ipv4.tcp_tw_recycle = 1\n\n\n当然我们不要忘记在 nat 环境下因为时间戳错乱导致数据包被拒绝的坑了，另外的办法就是改小tcp_max_tw_buckets，超过这个数的 time_wait 都会被干掉，不过这也会导致报time wait bucket table overflow的错。\n\n# close_wait\n\nclose_wait 往往都是因为应用程序写的有问题，没有在 ack 后再次发起 fin 报文。close_wait 出现的概率甚至比 time_wait 要更高，后果也更严重。往往是由于某个地方阻塞住了，没有正常关闭连接，从而渐渐地消耗完所有的线程。\n\n想要定位这类问题，最好是通过 jstack 来分析线程堆栈来诊断问题，具体可参考上述章节。这里仅举一个例子。\n\n开发同学说应用上线后 close_wait 就一直增多，直到挂掉为止，jstack 后找到比较可疑的堆栈是大部分线程都卡在了countdownlatch.await方法，找开发同学了解后得知使用了多线程但是确没有 catch 异常，修改后发现异常仅仅是最简单的升级 sdk 后常出现的class not found。\n\n\n# gc 问题\n\ngc 问题除了影响 cpu 也会影响内存，诊断思路也是一致的。\n\n（1）通常，先使用 jstat 来查看分代变化情况，比如 minor gc 或 full gc 次数是不是太频繁、耗时太久。\n\n线程量太大，且不被及时 gc 也会引发 oom，大部分就是之前说的 unable to create new native thread。除了 jstack 细细分析 dump 文件外，我们一般先会看下总体线程。\n\n可以执行以下命令中任意一个，没来查看当前进程创建的总线程数。\n\npstreee -p pid | wc -l\nls -l /proc/pid/task | wc -l\n\n\n堆内内存泄漏总是和 gc 异常相伴。不过 gc 问题不只是和内存问题相关，还有可能引起 cpu 负载、网络问题等系列并发症，只是相对来说和内存联系紧密些，所以我们在此单独总结一下 gc 相关问题。\n\n我们在 cpu 章介绍了使用 jstat 来获取当前 gc 分代变化信息。而更多时候，我们是通过 gc 日志来诊断问题的，在启动参数中加上-verbose:gc -xx:+printgcdetails -xx:+printgcdatestamps -xx:+printgctimestamps来开启 gc 日志。 常见的 minor gc、full gc 日志含义在此就不做赘述了。\n\n针对 gc 日志，我们就能大致推断出 minor gc 与 fullgc 是否过于频繁或者耗时过长，从而对症下药。我们下面将对 g1 垃圾收集器来做分析，这边也建议大家使用 g1-xx:+useg1gc。\n\n\n# oom\n\n查看 gc 日志，如果有明显提示 oom 问题，那就可以根据提示信息，较为快速的定位问题。\n\n> oom 定位可以参考：jvm 内存管理 之 outofmemoryerror\n\n\n# minor gc\n\n# minor gc 过频\n\nminor gc 频繁一般是短周期的 java 小对象较多。\n\n（1）先考虑是不是 eden 区/新生代设置的太小了，看能否通过调整 -xmn、-xx:survivorratio 等参数设置来解决问题。\n\n（2）如果参数正常，但是 minor gc 频率还是太高，就需要使用 jmap 和 mat 对 dump 文件进行进一步诊断了。\n\n# minor gc 耗时过长\n\nminor gc 耗时过长问题就要看 gc 日志里耗时耗在哪一块了。\n\n以 g1 gc 日志为例，可以关注 root scanning、object copy、ref proc 等阶段。ref proc 耗时长，就要注意引用相关的对象。root scanning 耗时长，就要注意线程数、跨代引用。object copy 则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。\n\n\n# full gc 过频\n\ng1 中更多的还是 mixedgc，但 mixedgc 可以和 minor gc 思路一样去诊断。触发 fullgc 了一般都会有问题，g1 会退化使用 serial 收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。\n\nfullgc 的原因可能包括以下这些，以及参数调整方面的一些思路：\n\n * 并发阶段失败：在并发标记阶段，mixgc 之前老年代就被填满了，那么这时候 g1 就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数-xx:concgcthreads。\n * 晋升失败：在 gc 的时候没有足够的内存供存活/晋升对象使用，所以触发了 full gc。这时候可以通过-xx:g1reservepercent来增加预留内存百分比，减少-xx:initiatingheapoccupancypercent来提前启动标记，-xx:concgcthreads来增加标记线程数也是可以的。\n * 大对象分配失败：大对象找不到合适的 region 空间进行分配，就会进行 fullgc，这种情况下可以增大内存或者增大-xx:g1heapregionsize。\n * 程序主动执行 system.gc()：不要随便写就对了。\n\n另外，我们可以在启动参数中配置-xx:heapdumppath=/xxx/dump.hprof来 dump fullgc 相关的文件，并通过 jinfo 来进行 gc 前后的 dump\n\njinfo -flag +heapdumpbeforefullgc pid\njinfo -flag +heapdumpafterfullgc pid\n\n\n这样得到 2 份 dump 文件，对比后主要关注被 gc 掉的问题对象来定位问题。\n\n\n# 常用 linux 命令\n\n在故障排查时，有一些 linux 命令十分有用，建议掌握。\n\n\n# top\n\ntop 命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。\n\n通常，会使用 top -hp pid 查看具体线程使用系统资源情况。\n\n> 命令详情参考：http://man.linuxde.net/top\n\n\n# vmstat\n\nvmstat 是一款指定采样周期和次数的功能性监测工具，我们可以看到，它不仅可以统计内存的使用情况，还可以观测到 cpu 的使用率、swap 的使用情况。但 vmstat 一般很少用来查看内存的使用情况，而是经常被用来观察进程的上下文切换。\n\n * r：等待运行的进程数；\n * b：处于非中断睡眠状态的进程数；\n * swpd：虚拟内存使用情况；\n * free：空闲的内存；\n * buff：用来作为缓冲的内存数；\n * si：从磁盘交换到内存的交换页数量；\n * so：从内存交换到磁盘的交换页数量；\n * bi：发送到块设备的块数；\n * bo：从块设备接收到的块数；\n * in：每秒中断数；\n * cs：每秒上下文切换次数；\n * us：用户 cpu 使用时间；\n * sy：内核 cpu 系统使用时间；\n * id：空闲时间；\n * wa：等待 i/o 时间；\n * st：运行虚拟机窃取的时间。\n\n\n# 参考资料\n\n * 《java 性能调优实战》\n * java 线上故障诊断全套路\n * 从实际案例聊聊 java 应用的 gc 优化",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"JVM 教程",frontmatter:{title:"JVM 教程",categories:["编程","Java","JavaSE","JVM"],tags:["Java","JavaSE","JVM"],abbrlink:"bfd57dfe",date:"2020-06-04T13:51:01.000Z",hidden:!0,permalink:"/pages/272f03/"},regularPath:"/06.JVM/",relativePath:"06.JVM/README.md",key:"v-97c6d734",path:"/pages/272f03/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:51},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:473},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:598}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# JVM 教程\n\n> 【Java 虚拟机】总结、整理了个人对于 JVM 的学习、应用心得。\n\n\n# 📖 内容\n\n * JVM 体系结构\n * JVM 内存区域 - 关键词：程序计数器、虚拟机栈、本地方法栈、堆、方法区、运行时常量池、直接内存、OutOfMemoryError、StackOverflowError\n * JVM 垃圾收集 - 关键词：GC Roots、Serial、Parallel、CMS、G1、Minor GC、Full GC\n * JVM 字节码 - 关键词：bytecode、asm、javassist\n * JVM 类加载 - 关键词：ClassLoader、双亲委派\n * JVM 命令行工具 - 关键词：jps、jstat、jmap 、jstack、jhat、jinfo\n * JVM GUI 工具 - 关键词：jconsole、jvisualvm、MAT、JProfile、Arthas\n * JVM 实战 - 关键词：配置、调优\n * Java 故障诊断 - 关键词：CPU、内存、磁盘、网络、GC\n\n\n# 📚 资料\n\n * 《深入理解 Java 虚拟机》\n * 《Java 核心技术面试精讲》\n * 《Java 性能调优实战》\n * 《Java 业务开发常见错误 100 例》\n * 深入拆解 Java 虚拟机\n * 从表到里学习 JVM 实现\n\n\n# 🚪 传送\n\n◾ 🏠 JAVACORE 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"# jvm 教程\n\n> 【java 虚拟机】总结、整理了个人对于 jvm 的学习、应用心得。\n\n\n# 📖 内容\n\n * jvm 体系结构\n * jvm 内存区域 - 关键词：程序计数器、虚拟机栈、本地方法栈、堆、方法区、运行时常量池、直接内存、outofmemoryerror、stackoverflowerror\n * jvm 垃圾收集 - 关键词：gc roots、serial、parallel、cms、g1、minor gc、full gc\n * jvm 字节码 - 关键词：bytecode、asm、javassist\n * jvm 类加载 - 关键词：classloader、双亲委派\n * jvm 命令行工具 - 关键词：jps、jstat、jmap 、jstack、jhat、jinfo\n * jvm gui 工具 - 关键词：jconsole、jvisualvm、mat、jprofile、arthas\n * jvm 实战 - 关键词：配置、调优\n * java 故障诊断 - 关键词：cpu、内存、磁盘、网络、gc\n\n\n# 📚 资料\n\n * 《深入理解 java 虚拟机》\n * 《java 核心技术面试精讲》\n * 《java 性能调优实战》\n * 《java 业务开发常见错误 100 例》\n * 深入拆解 java 虚拟机\n * 从表到里学习 jvm 实现\n\n\n# 🚪 传送\n\n◾ 🏠 javacore 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"jvm-and-java",frontmatter:{title:"jvm-and-java",categories:["编程","Java","JavaSE","JVM"],tags:["Java","JavaSE","JVM"],abbrlink:"cb223828",date:"2020-10-16T20:29:24.000Z",permalink:"/pages/b98932/"},regularPath:"/06.JVM/jvm-and-java.html",relativePath:"06.JVM/jvm-and-java.md",key:"v-4a04eb05",path:"/pages/b98932/",headers:[{level:2,title:"JVM 如何执行方法调用",slug:"jvm-如何执行方法调用",normalizedTitle:"jvm 如何执行方法调用",charIndex:20},{level:3,title:"静态绑定和动态绑定",slug:"静态绑定和动态绑定",normalizedTitle:"静态绑定和动态绑定",charIndex:403},{level:3,title:"调用指令的符号引用",slug:"调用指令的符号引用",normalizedTitle:"调用指令的符号引用",charIndex:1692},{level:3,title:"虚方法调用",slug:"虚方法调用",normalizedTitle:"虚方法调用",charIndex:1926},{level:3,title:"方法表",slug:"方法表",normalizedTitle:"方法表",charIndex:1914},{level:3,title:"内联缓存",slug:"内联缓存",normalizedTitle:"内联缓存",charIndex:2431},{level:2,title:"JVM 如何处理异常",slug:"jvm-如何处理异常",normalizedTitle:"jvm 如何处理异常",charIndex:2573},{level:3,title:"JVM 如何捕获异常",slug:"jvm-如何捕获异常",normalizedTitle:"jvm 如何捕获异常",charIndex:2588},{level:3,title:"Java 7 的 Supressed 异常以及语法糖",slug:"java-7-的-supressed-异常以及语法糖",normalizedTitle:"java 7 的 supressed 异常以及语法糖",charIndex:3708},{level:2,title:"JVM 如何实现反射",slug:"jvm-如何实现反射",normalizedTitle:"jvm 如何实现反射",charIndex:5102},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5117}],headersStr:"JVM 如何执行方法调用 静态绑定和动态绑定 调用指令的符号引用 虚方法调用 方法表 内联缓存 JVM 如何处理异常 JVM 如何捕获异常 Java 7 的 Supressed 异常以及语法糖 JVM 如何实现反射 参考资料",content:'# JVM 和 Java 特性\n\n\n# JVM 如何执行方法调用\n\n在 Java 程序里，如果同一个类中出现多个名字相同，并且参数类型相同的方法，那么它无法通过编译。如果我们想要在同一个类中定义名字相同的方法，那么它们的参数类型必须不同。这些方法之间的关系，我们称之为重载。\n\n重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：\n\n 1. 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；\n 2. 如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；\n 3. 如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。\n\n\n# 静态绑定和动态绑定\n\nJava 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。方法描述符，它是由方法的参数类型以及返回类型所构成。\n\nJava 虚拟机中关于方法重写的判定同样基于方法描述符。也就是说，如果子类定义了与父类中非私有、非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写。\n\n由于对重载方法的区分在编译阶段已经完成，我们可以认为 Java 虚拟机不存在重载这一概念。因此，在某些文章中，重载也被称为静态绑定（static binding），或者编译时多态（compile-time polymorphism）；而重写则被称为动态绑定（dynamic binding）。\n\n确切地说，Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。\n\n具体来说，Java 字节码中与调用相关的指令共有五种。\n\n 1. invokestatic：用于调用静态方法。\n 2. invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。\n 3. invokevirtual：用于调用非私有实例方法。\n 4. invokeinterface：用于调用接口方法。\n 5. invokedynamic：用于调用动态方法。\n\n【示例】\n\ninterface 客户 {\n  boolean isVIP();\n}\n\nclass 商户 {\n  public double 折后价格 (double 原价, 客户 某客户) {\n    return 原价 * 0.8d;\n  }\n}\n\nclass 奸商 extends 商户 {\n  @Override\n  public double 折后价格 (double 原价, 客户 某客户) {\n    if (某客户.isVIP()) {                         // invokeinterface\n      return 原价 * 价格歧视 ();                    // invokestatic\n    } else {\n      return super. 折后价格 (原价, 某客户);          // invokespecial\n    }\n  }\n  public static double 价格歧视 () {\n    // 咱们的杀熟算法太粗暴了，应该将客户城市作为随机数生成器的种子。\n    return new Random()                          // invokespecial\n           .nextDouble()                         // invokevirtual\n           + 0.8d;\n  }\n}\n\n\n\n# 调用指令的符号引用\n\n在编译过程中，我们并不知道目标方法的具体内存地址。因此，Java 编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。\n\n符号引用存储在 class 文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。\n\n对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。\n\n\n# 虚方法调用\n\nJava 里所有非私有实例方法调用都会被编译成 invokevirtual 指令，而接口方法调用都会被编译成 invokeinterface 指令。这两种指令，均属于 Java 虚拟机中的虚方法调用。\n\n在 Java 虚拟机中，静态绑定包括用于调用静态方法的 invokestatic 指令，和用于调用构造器、私有实例方法以及超类非私有实例方法的 invokespecial 指令。如果虚方法调用指向一个标记为 final 的方法，那么 Java 虚拟机也可以静态绑定该虚方法调用的目标方法。\n\n\n# 方法表\n\n方法表是 Java 虚拟机实现动态绑定的关键所在。\n\n方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。\n\n这些方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。方法表满足两个特质：其一，子类方法表中包含父类方法表中的所有方法；其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。\n\n在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。\n\n\n# 内联缓存\n\n内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。\n\n\n# JVM 如何处理异常\n\n\n# JVM 如何捕获异常\n\n在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成。这些指针的值是字节码索引（bytecode index，bci），用以定位字节码。\n\n其中，from 指针和 to 指针标示了该异常处理器所监控的范围，例如 try 代码块所覆盖的范围。target 指针则指向异常处理器的起始位置，例如 catch 代码块的起始位置。\n\npublic static void main(String[] args) {\n  try {\n    mayThrowException();\n  } catch (Exception e) {\n    e.printStackTrace();\n  }\n}\n// 对应的 Java 字节码\npublic static void main(java.lang.String[]);\n  Code:\n    0: invokestatic mayThrowException:()V\n    3: goto 11\n    6: astore_1\n    7: aload_1\n    8: invokevirtual java.lang.Exception.printStackTrace\n   11: return\n  Exception table:\n    from  to target type\n      0   3   6  Class java/lang/Exception  // 异常表条目\n\n\n说明：编译过后，该方法的异常表拥有一个条目。其 from 指针和 to 指针分别为 0 和 3，代表它的监控范围从索引为 0 的字节码开始，到索引为 3 的字节码结束（不包括 3）。该条目的 target 指针是 6，代表这个异常处理器从索引为 6 的字节码开始。条目的最后一列，代表该异常处理器所捕获的异常类型正是 Exception。\n\n当程序触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，Java 虚拟机会将控制流转移至该条目 target 指针指向的字节码。\n\n如果遍历完所有异常表条目，Java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 Java 栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。\n\n\n# Java 7 的 Supressed 异常以及语法糖\n\n如果 catch 代码块捕获了异常，并且触发了另一个异常，那么 finally 捕获并且重抛的异常是哪个呢？答案是后者。也就是说原本的异常便会被忽略掉，这对于代码调试来说十分不利。\n\nJava 7 引入了 Supressed 异常来解决这个问题。这个新特性允许开发人员将一个异常附于另一个异常之上。因此，抛出的异常可以附带多个异常的信息。\n\nJava 7 专门构造了一个名为 try-with-resources 的语法糖，在字节码层面自动使用 Supressed 异常。\n\npublic class Foo implements AutoCloseable {\n  private final String name;\n  public Foo(String name) { this.name = name; }\n\n  @Override\n  public void close() {\n    throw new RuntimeException(name);\n  }\n\n  public static void main(String[] args) {\n    try (Foo foo0 = new Foo("Foo0"); // try-with-resources\n         Foo foo1 = new Foo("Foo1");\n         Foo foo2 = new Foo("Foo2")) {\n      throw new RuntimeException("Initial");\n    }\n  }\n}\n\n// 运行结果：\nException in thread "main" java.lang.RuntimeException: Initial\n        at Foo.main(Foo.java:18)\n        Suppressed: java.lang.RuntimeException: Foo2\n                at Foo.close(Foo.java:13)\n                at Foo.main(Foo.java:19)\n        Suppressed: java.lang.RuntimeException: Foo1\n                at Foo.close(Foo.java:13)\n                at Foo.main(Foo.java:19)\n        Suppressed: java.lang.RuntimeException: Foo0\n                at Foo.close(Foo.java:13)\n                at Foo.main(Foo.java:19)\n\n\n除了 try-with-resources 语法糖之外，Java 7 还支持在同一 catch 代码块中捕获多种异常。实际实现非常简单，生成多个异常表条目即可。\n\n// 在同一 catch 代码块中捕获多种异常\ntry {\n  ...\n} catch (SomeException | OtherException e) {\n  ...\n}\n\n\n\n# JVM 如何实现反射\n\n\n# 参考资料\n\n * 《深入理解 Java 虚拟机》\n * 深入拆解 Java 虚拟机',normalizedContent:'# jvm 和 java 特性\n\n\n# jvm 如何执行方法调用\n\n在 java 程序里，如果同一个类中出现多个名字相同，并且参数类型相同的方法，那么它无法通过编译。如果我们想要在同一个类中定义名字相同的方法，那么它们的参数类型必须不同。这些方法之间的关系，我们称之为重载。\n\n重载的方法在编译过程中即可完成识别。具体到每一个方法调用，java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：\n\n 1. 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；\n 2. 如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；\n 3. 如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。\n\n\n# 静态绑定和动态绑定\n\njava 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。方法描述符，它是由方法的参数类型以及返回类型所构成。\n\njava 虚拟机中关于方法重写的判定同样基于方法描述符。也就是说，如果子类定义了与父类中非私有、非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，java 虚拟机才会判定为重写。\n\n由于对重载方法的区分在编译阶段已经完成，我们可以认为 java 虚拟机不存在重载这一概念。因此，在某些文章中，重载也被称为静态绑定（static binding），或者编译时多态（compile-time polymorphism）；而重写则被称为动态绑定（dynamic binding）。\n\n确切地说，java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。\n\n具体来说，java 字节码中与调用相关的指令共有五种。\n\n 1. invokestatic：用于调用静态方法。\n 2. invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。\n 3. invokevirtual：用于调用非私有实例方法。\n 4. invokeinterface：用于调用接口方法。\n 5. invokedynamic：用于调用动态方法。\n\n【示例】\n\ninterface 客户 {\n  boolean isvip();\n}\n\nclass 商户 {\n  public double 折后价格 (double 原价, 客户 某客户) {\n    return 原价 * 0.8d;\n  }\n}\n\nclass 奸商 extends 商户 {\n  @override\n  public double 折后价格 (double 原价, 客户 某客户) {\n    if (某客户.isvip()) {                         // invokeinterface\n      return 原价 * 价格歧视 ();                    // invokestatic\n    } else {\n      return super. 折后价格 (原价, 某客户);          // invokespecial\n    }\n  }\n  public static double 价格歧视 () {\n    // 咱们的杀熟算法太粗暴了，应该将客户城市作为随机数生成器的种子。\n    return new random()                          // invokespecial\n           .nextdouble()                         // invokevirtual\n           + 0.8d;\n  }\n}\n\n\n\n# 调用指令的符号引用\n\n在编译过程中，我们并不知道目标方法的具体内存地址。因此，java 编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。\n\n符号引用存储在 class 文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。\n\n对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。\n\n\n# 虚方法调用\n\njava 里所有非私有实例方法调用都会被编译成 invokevirtual 指令，而接口方法调用都会被编译成 invokeinterface 指令。这两种指令，均属于 java 虚拟机中的虚方法调用。\n\n在 java 虚拟机中，静态绑定包括用于调用静态方法的 invokestatic 指令，和用于调用构造器、私有实例方法以及超类非私有实例方法的 invokespecial 指令。如果虚方法调用指向一个标记为 final 的方法，那么 java 虚拟机也可以静态绑定该虚方法调用的目标方法。\n\n\n# 方法表\n\n方法表是 java 虚拟机实现动态绑定的关键所在。\n\n方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。\n\n这些方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。方法表满足两个特质：其一，子类方法表中包含父类方法表中的所有方法；其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。\n\n在执行过程中，java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。\n\n\n# 内联缓存\n\n内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。\n\n\n# jvm 如何处理异常\n\n\n# jvm 如何捕获异常\n\n在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成。这些指针的值是字节码索引（bytecode index，bci），用以定位字节码。\n\n其中，from 指针和 to 指针标示了该异常处理器所监控的范围，例如 try 代码块所覆盖的范围。target 指针则指向异常处理器的起始位置，例如 catch 代码块的起始位置。\n\npublic static void main(string[] args) {\n  try {\n    maythrowexception();\n  } catch (exception e) {\n    e.printstacktrace();\n  }\n}\n// 对应的 java 字节码\npublic static void main(java.lang.string[]);\n  code:\n    0: invokestatic maythrowexception:()v\n    3: goto 11\n    6: astore_1\n    7: aload_1\n    8: invokevirtual java.lang.exception.printstacktrace\n   11: return\n  exception table:\n    from  to target type\n      0   3   6  class java/lang/exception  // 异常表条目\n\n\n说明：编译过后，该方法的异常表拥有一个条目。其 from 指针和 to 指针分别为 0 和 3，代表它的监控范围从索引为 0 的字节码开始，到索引为 3 的字节码结束（不包括 3）。该条目的 target 指针是 6，代表这个异常处理器从索引为 6 的字节码开始。条目的最后一列，代表该异常处理器所捕获的异常类型正是 exception。\n\n当程序触发异常时，java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，java 虚拟机会将控制流转移至该条目 target 指针指向的字节码。\n\n如果遍历完所有异常表条目，java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 java 栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，java 虚拟机需要遍历当前线程 java 栈上所有方法的异常表。\n\n\n# java 7 的 supressed 异常以及语法糖\n\n如果 catch 代码块捕获了异常，并且触发了另一个异常，那么 finally 捕获并且重抛的异常是哪个呢？答案是后者。也就是说原本的异常便会被忽略掉，这对于代码调试来说十分不利。\n\njava 7 引入了 supressed 异常来解决这个问题。这个新特性允许开发人员将一个异常附于另一个异常之上。因此，抛出的异常可以附带多个异常的信息。\n\njava 7 专门构造了一个名为 try-with-resources 的语法糖，在字节码层面自动使用 supressed 异常。\n\npublic class foo implements autocloseable {\n  private final string name;\n  public foo(string name) { this.name = name; }\n\n  @override\n  public void close() {\n    throw new runtimeexception(name);\n  }\n\n  public static void main(string[] args) {\n    try (foo foo0 = new foo("foo0"); // try-with-resources\n         foo foo1 = new foo("foo1");\n         foo foo2 = new foo("foo2")) {\n      throw new runtimeexception("initial");\n    }\n  }\n}\n\n// 运行结果：\nexception in thread "main" java.lang.runtimeexception: initial\n        at foo.main(foo.java:18)\n        suppressed: java.lang.runtimeexception: foo2\n                at foo.close(foo.java:13)\n                at foo.main(foo.java:19)\n        suppressed: java.lang.runtimeexception: foo1\n                at foo.close(foo.java:13)\n                at foo.main(foo.java:19)\n        suppressed: java.lang.runtimeexception: foo0\n                at foo.close(foo.java:13)\n                at foo.main(foo.java:19)\n\n\n除了 try-with-resources 语法糖之外，java 7 还支持在同一 catch 代码块中捕获多种异常。实际实现非常简单，生成多个异常表条目即可。\n\n// 在同一 catch 代码块中捕获多种异常\ntry {\n  ...\n} catch (someexception | otherexception e) {\n  ...\n}\n\n\n\n# jvm 如何实现反射\n\n\n# 参考资料\n\n * 《深入理解 java 虚拟机》\n * 深入拆解 java 虚拟机',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Java 面试总结",frontmatter:{title:"Java 面试总结",categories:["编程","Java","JavaSE"],tags:["Java","JavaSE","面试"],abbrlink:"ebd55e42",date:"2020-06-04T13:51:00.000Z"},regularPath:"/99.Java%E9%9D%A2%E8%AF%95.html",relativePath:"99.Java面试.md",key:"v-c9acc070",path:"/99.Java%E9%9D%A2%E8%AF%95.html",headers:[{level:2,title:"基础",slug:"基础",normalizedTitle:"基础",charIndex:16},{level:3,title:"工具类",slug:"工具类",normalizedTitle:"工具类",charIndex:23},{level:4,title:"String",slug:"string",normalizedTitle:"string",charIndex:30},{level:3,title:"面向对象",slug:"面向对象",normalizedTitle:"面向对象",charIndex:291},{level:3,title:"反射",slug:"反射",normalizedTitle:"反射",charIndex:416},{level:4,title:"⭐ 创建实例",slug:"⭐-创建实例",normalizedTitle:"⭐ 创建实例",charIndex:422},{level:4,title:"⭐ 加载实例",slug:"⭐-加载实例",normalizedTitle:"⭐ 加载实例",charIndex:538},{level:4,title:"⭐⭐ 动态代理",slug:"⭐⭐-动态代理",normalizedTitle:"⭐⭐ 动态代理",charIndex:748},{level:3,title:"JDK8",slug:"jdk8",normalizedTitle:"jdk8",charIndex:1164},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1173},{level:4,title:"⭐ hashcode",slug:"⭐-hashcode",normalizedTitle:"⭐ hashcode",charIndex:1179},{level:2,title:"IO",slug:"io",normalizedTitle:"io",charIndex:1768},{level:3,title:"NIO",slug:"nio",normalizedTitle:"nio",charIndex:1775},{level:3,title:"序列化",slug:"序列化",normalizedTitle:"序列化",charIndex:1820},{level:4,title:"⭐ 序列化问题",slug:"⭐-序列化问题",normalizedTitle:"⭐ 序列化问题",charIndex:1827},{level:2,title:"容器",slug:"容器",normalizedTitle:"容器",charIndex:2160},{level:3,title:"List",slug:"list",normalizedTitle:"list",charIndex:2167},{level:4,title:"ArrayList 和 LinkedList 有什么区别？",slug:"arraylist-和-linkedlist-有什么区别",normalizedTitle:"arraylist 和 linkedlist 有什么区别？",charIndex:2175},{level:3,title:"Map",slug:"map",normalizedTitle:"map",charIndex:2259},{level:2,title:"并发",slug:"并发",normalizedTitle:"并发",charIndex:2287},{level:3,title:"并发简介",slug:"并发简介",normalizedTitle:"并发简介",charIndex:2294},{level:4,title:"什么是进程？什么是线程？进程和线程的区别？",slug:"什么是进程-什么是线程-进程和线程的区别",normalizedTitle:"什么是进程？什么是线程？进程和线程的区别？",charIndex:2302},{level:4,title:"并发（多线程）编程的好处是什么？",slug:"并发-多线程-编程的好处是什么",normalizedTitle:"并发（多线程）编程的好处是什么？",charIndex:2568},{level:4,title:"并发一定比串行更快吗？",slug:"并发一定比串行更快吗",normalizedTitle:"并发一定比串行更快吗？",charIndex:2628},{level:4,title:"如何让正在运行的线程暂停一段时间？",slug:"如何让正在运行的线程暂停一段时间",normalizedTitle:"如何让正在运行的线程暂停一段时间？",charIndex:2902},{level:4,title:"什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？",slug:"什么是线程调度器-thread-scheduler-和时间分片-time-slicing",normalizedTitle:"什么是线程调度器(thread scheduler)和时间分片(time slicing)？",charIndex:3029},{level:4,title:"在多线程中，什么是上下文切换(context-switching)？",slug:"在多线程中-什么是上下文切换-context-switching",normalizedTitle:"在多线程中，什么是上下文切换(context-switching)？",charIndex:3288},{level:4,title:"如何确保线程安全？",slug:"如何确保线程安全",normalizedTitle:"如何确保线程安全？",charIndex:3393},{level:4,title:"什么是死锁(Deadlock)？如何分析和避免死锁？",slug:"什么是死锁-deadlock-如何分析和避免死锁",normalizedTitle:"什么是死锁(deadlock)？如何分析和避免死锁？",charIndex:3475},{level:3,title:"线程基础",slug:"线程基础",normalizedTitle:"线程基础",charIndex:3696},{level:4,title:"Java 线程生命周期中有哪些状态？各状态之间如何切换？",slug:"java-线程生命周期中有哪些状态-各状态之间如何切换",normalizedTitle:"java 线程生命周期中有哪些状态？各状态之间如何切换？",charIndex:3704},{level:4,title:"创建线程有哪些方式？这些方法各自利弊是什么？",slug:"创建线程有哪些方式-这些方法各自利弊是什么",normalizedTitle:"创建线程有哪些方式？这些方法各自利弊是什么？",charIndex:4542},{level:4,title:"什么是 Callable 和 Future？什么是 FutureTask？",slug:"什么是-callable-和-future-什么是-futuretask",normalizedTitle:"什么是 callable 和 future？什么是 futuretask？",charIndex:5364},{level:4,title:"start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？",slug:"start-和-run-有什么区别-可以直接调用-thread-类的-run-方法么",normalizedTitle:"start() 和 run() 有什么区别？可以直接调用 thread 类的 run() 方法么？",charIndex:6e3},{level:4,title:"sleep()、yield()、join() 方法有什么区别？为什么 sleep() 和 yield() 方法是静态（static）的？",slug:"sleep-、yield-、join-方法有什么区别-为什么-sleep-和-yield-方法是静态-static-的",normalizedTitle:"sleep()、yield()、join() 方法有什么区别？为什么 sleep() 和 yield() 方法是静态（static）的？",charIndex:6236},{level:4,title:"Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？",slug:"java-的线程优先级如何控制-高优先级的-java-线程一定先执行吗",normalizedTitle:"java 的线程优先级如何控制？高优先级的 java 线程一定先执行吗？",charIndex:6998},{level:4,title:"什么是守护线程？为什么要用守护线程？如何创建守护线程？",slug:"什么是守护线程-为什么要用守护线程-如何创建守护线程",normalizedTitle:"什么是守护线程？为什么要用守护线程？如何创建守护线程？",charIndex:7327},{level:4,title:"线程间是如何通信的？",slug:"线程间是如何通信的",normalizedTitle:"线程间是如何通信的？",charIndex:7805},{level:4,title:"为什么线程通信的方法 wait(), notify() 和 notifyAll() 被定义在 Object 类里？",slug:"为什么线程通信的方法-wait-notify-和-notifyall-被定义在-object-类里",normalizedTitle:"为什么线程通信的方法 wait(), notify() 和 notifyall() 被定义在 object 类里？",charIndex:7979},{level:4,title:"为什么 wait(), notify() 和 notifyAll() 必须在同步方法或者同步块中被调用？",slug:"为什么-wait-notify-和-notifyall-必须在同步方法或者同步块中被调用",normalizedTitle:"为什么 wait(), notify() 和 notifyall() 必须在同步方法或者同步块中被调用？",charIndex:8205},{level:3,title:"并发机制的底层实现",slug:"并发机制的底层实现",normalizedTitle:"并发机制的底层实现",charIndex:8469},{level:4,title:"⭐⭐⭐ synchronized",slug:"⭐⭐⭐-synchronized",normalizedTitle:"⭐⭐⭐ synchronized",charIndex:8505},{level:4,title:"⭐ volatile",slug:"⭐-volatile",normalizedTitle:"⭐ volatile",charIndex:9437},{level:4,title:"⭐⭐ CAS",slug:"⭐⭐-cas",normalizedTitle:"⭐⭐ cas",charIndex:10327},{level:4,title:"⭐ ThreadLocal",slug:"⭐-threadlocal",normalizedTitle:"⭐ threadlocal",charIndex:11332},{level:3,title:"内存模型",slug:"内存模型",normalizedTitle:"内存模型",charIndex:12024},{level:4,title:"什么是 Java 内存模型",slug:"什么是-java-内存模型",normalizedTitle:"什么是 java 内存模型",charIndex:12032},{level:3,title:"同步容器和并发容器",slug:"同步容器和并发容器",normalizedTitle:"同步容器和并发容器",charIndex:12999},{level:4,title:"⭐ 同步容器",slug:"⭐-同步容器",normalizedTitle:"⭐ 同步容器",charIndex:13033},{level:4,title:"⭐⭐⭐ ConcurrentHashMap",slug:"⭐⭐⭐-concurrenthashmap",normalizedTitle:"⭐⭐⭐ concurrenthashmap",charIndex:13432},{level:4,title:"⭐⭐ CopyOnWriteArrayList",slug:"⭐⭐-copyonwritearraylist",normalizedTitle:"⭐⭐ copyonwritearraylist",charIndex:14051},{level:3,title:"并发锁",slug:"并发锁",normalizedTitle:"并发锁",charIndex:14512},{level:4,title:"⭐⭐ 锁类型",slug:"⭐⭐-锁类型",normalizedTitle:"⭐⭐ 锁类型",charIndex:14539},{level:4,title:"⭐⭐ AQS",slug:"⭐⭐-aqs",normalizedTitle:"⭐⭐ aqs",charIndex:15361},{level:4,title:"⭐⭐ ReentrantLock",slug:"⭐⭐-reentrantlock",normalizedTitle:"⭐⭐ reentrantlock",charIndex:16528},{level:4,title:"⭐ ReentrantReadWriteLock",slug:"⭐-reentrantreadwritelock",normalizedTitle:"⭐ reentrantreadwritelock",charIndex:17078},{level:4,title:"⭐ Condition",slug:"⭐-condition",normalizedTitle:"⭐ condition",charIndex:17630},{level:4,title:"⭐⭐ 死锁",slug:"⭐⭐-死锁",normalizedTitle:"⭐⭐ 死锁",charIndex:17796},{level:3,title:"原子变量类",slug:"原子变量类",normalizedTitle:"原子变量类",charIndex:17956},{level:4,title:"⭐ 原子类简介",slug:"⭐-原子类简介",normalizedTitle:"⭐ 原子类简介",charIndex:17985},{level:4,title:"⭐ 原子类的原理",slug:"⭐-原子类的原理",normalizedTitle:"⭐ 原子类的原理",charIndex:18621},{level:3,title:"并发工具类",slug:"并发工具类",normalizedTitle:"并发工具类",charIndex:18754},{level:4,title:"⭐ CountDownLatch",slug:"⭐-countdownlatch",normalizedTitle:"⭐ countdownlatch",charIndex:18785},{level:4,title:"⭐ CyclicBarrier",slug:"⭐-cyclicbarrier",normalizedTitle:"⭐ cyclicbarrier",charIndex:19069},{level:4,title:"⭐ Semaphore",slug:"⭐-semaphore",normalizedTitle:"⭐ semaphore",charIndex:19537},{level:3,title:"线程池",slug:"线程池",normalizedTitle:"线程池",charIndex:5553},{level:4,title:"⭐⭐ ThreadPoolExecutor",slug:"⭐⭐-threadpoolexecutor",normalizedTitle:"⭐⭐ threadpoolexecutor",charIndex:19845},{level:4,title:"⭐ Executors",slug:"⭐-executors",normalizedTitle:"⭐ executors",charIndex:22437},{level:2,title:"JVM",slug:"jvm",normalizedTitle:"jvm",charIndex:677},{level:3,title:"内存管理",slug:"内存管理",normalizedTitle:"内存管理",charIndex:23316},{level:3,title:"OOM",slug:"oom",normalizedTitle:"oom",charIndex:23325},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:23333}],headersStr:"基础 工具类 String 面向对象 反射 ⭐ 创建实例 ⭐ 加载实例 ⭐⭐ 动态代理 JDK8 其他 ⭐ hashcode IO NIO 序列化 ⭐ 序列化问题 容器 List ArrayList 和 LinkedList 有什么区别？ Map 并发 并发简介 什么是进程？什么是线程？进程和线程的区别？ 并发（多线程）编程的好处是什么？ 并发一定比串行更快吗？ 如何让正在运行的线程暂停一段时间？ 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？ 在多线程中，什么是上下文切换(context-switching)？ 如何确保线程安全？ 什么是死锁(Deadlock)？如何分析和避免死锁？ 线程基础 Java 线程生命周期中有哪些状态？各状态之间如何切换？ 创建线程有哪些方式？这些方法各自利弊是什么？ 什么是 Callable 和 Future？什么是 FutureTask？ start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？ sleep()、yield()、join() 方法有什么区别？为什么 sleep() 和 yield() 方法是静态（static）的？ Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？ 什么是守护线程？为什么要用守护线程？如何创建守护线程？ 线程间是如何通信的？ 为什么线程通信的方法 wait(), notify() 和 notifyAll() 被定义在 Object 类里？ 为什么 wait(), notify() 和 notifyAll() 必须在同步方法或者同步块中被调用？ 并发机制的底层实现 ⭐⭐⭐ synchronized ⭐ volatile ⭐⭐ CAS ⭐ ThreadLocal 内存模型 什么是 Java 内存模型 同步容器和并发容器 ⭐ 同步容器 ⭐⭐⭐ ConcurrentHashMap ⭐⭐ CopyOnWriteArrayList 并发锁 ⭐⭐ 锁类型 ⭐⭐ AQS ⭐⭐ ReentrantLock ⭐ ReentrantReadWriteLock ⭐ Condition ⭐⭐ 死锁 原子变量类 ⭐ 原子类简介 ⭐ 原子类的原理 并发工具类 ⭐ CountDownLatch ⭐ CyclicBarrier ⭐ Semaphore 线程池 ⭐⭐ ThreadPoolExecutor ⭐ Executors JVM 内存管理 OOM 参考资料",content:'# Java 面试总结\n\n\n# 基础\n\n\n# 工具类\n\n# String\n\n> String 类能被继承吗？\n> \n> String，StringBuffer，StringBuilder 的区别。\n\nString 类不能被继承。因为其被 final 修饰，所以无法被继承。\n\nStringBuffer，StringBuilder 拼接字符串，使用 append 比 String 效率高。因为 String 会隐式 new String 对象。\n\nStringBuffer 主要方法都用 synchronized 修饰，是线程安全的；而 StringBuilder 不是。\n\n\n# 面向对象\n\n> 抽象类和接口的区别？\n> \n> 类可以继承多个类么？接口可以继承多个接口么？类可以实现多个接口么？\n\n类只能继承一个类，但是可以实现多个接口。接口可以继承多个接口。\n\n> 继承和聚合的区别在哪？\n\n一般，能用聚合就别用继承。\n\n\n# 反射\n\n# ⭐ 创建实例\n\n> 反射创建实例有几种方式？\n\n通过反射来创建实例对象主要有两种方式：\n\n * 用 Class 对象的 newInstance 方法。\n * 用 Constructor 对象的 newInstance 方法。\n\n# ⭐ 加载实例\n\n> 加载实例有几种方式？\n> \n> Class.forName("className") 和 ClassLoader.laodClass("className") 有什么区别？\n\n * Class.forName("className") 加载的是已经初始化到 JVM 中的类。\n * ClassLoader.laodClass("className") 装载的是还没有初始化到 JVM 中的类。\n\n# ⭐⭐ 动态代理\n\n> 动态代理有几种实现方式？有什么特点？\n> \n> JDK 动态代理和 CGLIB 动态代理有什么区别？\n\n（1）JDK 方式\n\n代理类与委托类实现同一接口，主要是通过代理类实现 InvocationHandler 并重写 invoke 方法来进行动态代理的，在 invoke 方法中将对方法进行处理。\n\nJDK 动态代理特点：\n\n * 优点：相对于静态代理模式，不需要硬编码接口，代码复用率高。\n * 缺点：强制要求代理类实现 InvocationHandler 接口。\n\n（2）CGLIB\n\nCGLIB 底层，其实是借助了 ASM 这个强大的 Java 字节码框架去进行字节码增强操作。\n\nCGLIB 动态代理特点：\n\n优点：使用字节码增强，比 JDK 动态代理方式性能高。可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口。\n\n缺点：不能对 final 类以及 final 方法进行代理。\n\n\n# JDK8\n\n\n# 其他\n\n# ⭐ hashcode\n\n> 有==运算符了，为什么还需要 equals 啊？\n> \n> 说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需 要重新实现这两个方法。\n> \n> 有没有可能 2 个不相等的对象有相同的 hashcode\n\n（1）有==运算符了，为什么还需要 equals 啊？\n\nequals 等价于==,而==运算符是判断两个对象是不是同一个对象，即他们的地址是否相等。而覆写 equals 更多的是追求两个对象在逻辑上的相等，你可以说是值相等，也可说是内容相等。\n\n（2）说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需 要重新实现这两个方法。\n\n在集合查找时，hashcode 能大大降低对象比较次数，提高查找效率！\n\n（3）有没有可能 2 个不相等的对象有相同的 hashcode\n\n有可能。\n\n * 如果两个对象 equals，Java 运行时环境会认为他们的 hashcode 一定相等。\n * 如果两个对象不 equals，他们的 hashcode 有可能相等。\n * 如果两个对象 hashcode 相等，他们不一定 equals。\n * 如果两个对象 hashcode 不相等，他们一定不 equals。\n\n\n# IO\n\n\n# NIO\n\n> 什么是 NIO？\n> \n> NIO 和 BIO、AIO 有何差别？\n\n\n# 序列化\n\n# ⭐ 序列化问题\n\n> 序列化、反序列化有哪些问题？如何解决？\n\nJava 的序列化能保证对象状态的持久保存，但是遇到一些对象结构复杂的情况还是难以处理，这里归纳一下：\n\n * 当父类继承 Serializable 接口时，所有子类都可以被序列化。\n * 子类实现了 Serializable 接口，父类没有，则父类的属性不会被序列化（不报错，数据丢失），子类的属性仍可以正确序列化。\n * 如果序列化的属性是对象，则这个对象也必须实现 Serializable 接口，否则会报错。\n * 在反序列化时，如果对象的属性有修改或删减，则修改的部分属性会丢失，但不会报错。\n * 在反序列化时，如果 serialVersionUID 被修改，则反序列化时会失败。\n\n\n# 容器\n\n\n# List\n\n# ArrayList 和 LinkedList 有什么区别？\n\nArrayList 是数组链表，访问效率更高。\n\nLinkedList 是双链表，数据有序存储。\n\n\n# Map\n\n请描述 HashMap 的实现原理？\n\n\n# 并发\n\n\n# 并发简介\n\n# 什么是进程？什么是线程？进程和线程的区别？\n\n * 什么是进程？\n   * 简言之，进程可视为一个正在运行的程序。\n   * 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。\n * 什么是线程？\n   * 线程是操作系统进行调度的基本单位。\n * 进程 vs. 线程\n   * 一个程序至少有一个进程，一个进程至少有一个线程。\n   * 线程比进程划分更细，所以执行开销更小，并发性更高。\n   * 进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。\n\n# 并发（多线程）编程的好处是什么？\n\n * 更有效率的利用多处理器核心\n * 更快的响应时间\n * 更好的编程模型\n\n# 并发一定比串行更快吗？\n\n答：否。\n\n要点：创建线程和线程上下文切换有一定开销。\n\n说明：即使是单核处理器也支持多线程。CPU 通过给每个线程分配时间切片的算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保持上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。\n\n引申\n\n * 如何减少上下文切换？\n   * 尽量少用锁\n   * CAS 算法\n   * 线程数要合理\n   * 协程：在单线程中实现多任务调度，并在单线程中维持多个任务的切换\n\n# 如何让正在运行的线程暂停一段时间？\n\n我们可以使用 Thread 类的 Sleep() 方法让线程暂停一段时间。\n\n需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为 Runnable，并且根据线程调度，它将得到执行。\n\n# 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？\n\n线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。\n\n时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。\n\n分配 CPU 时间可以基于线程优先级或者线程等待的时间。线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。\n\n# 在多线程中，什么是上下文切换(context-switching)？\n\n上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。\n\n# 如何确保线程安全？\n\n * 原子类(atomic concurrent classes)\n * 锁\n * volatile 关键字\n * 不变类和线程安全类\n\n# 什么是死锁(Deadlock)？如何分析和避免死锁？\n\n死锁是指两个以上的线程永远相互阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。\n\n分析死锁，我们需要查看 Java 应用程序的线程转储。我们需要找出那些状态为 BLOCKED 的线程和他们等待的资源。每个资源都有一个唯一的 id，用这个 id 我们可以找出哪些线程已经拥有了它的对象锁。\n\n避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。\n\n\n# 线程基础\n\n# Java 线程生命周期中有哪些状态？各状态之间如何切换？\n\n\n\njava.lang.Thread.State 中定义了 6 种不同的线程状态，在给定的一个时刻，线程只能处于其中的一个状态。\n\n以下是各状态的说明，以及状态间的联系：\n\n * 开始（New） - 还没有调用 start() 方法的线程处于此状态。\n * 可运行（Runnable） - 已经调用了 start() 方法的线程状态。此状态意味着，线程已经准备好了，一旦被线程调度器分配了 CPU 时间片，就可以运行线程。\n * 阻塞（Blocked） - 阻塞状态。线程阻塞的线程状态等待监视器锁定。处于阻塞状态的线程正在等待监视器锁定，以便在调用 Object.wait() 之后输入同步块/方法或重新输入同步块/方法。\n * 等待（Waiting） - 等待状态。一个线程处于等待状态，是由于执行了 3 个方法中的任意方法：\n   * Object.wait()\n   * Thread.join()\n   * LockSupport.park()\n * 定时等待（Timed waiting） - 等待指定时间的状态。一个线程处于定时等待状态，是由于执行了以下方法中的任意方法：\n   * Thread.sleep(sleeptime)\n   * Object.wait(timeout)\n   * Thread.join(timeout)\n   * LockSupport.parkNanos(timeout)\n   * LockSupport.parkUntil(timeout)\n * 终止(Terminated) - 线程 run() 方法执行结束，或者因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。\n\n> 👉 参考阅读：JavaThread Methods and Thread States 👉 参考阅读：Java 线程的 5 种状态及切换(透彻讲解)\n\n# 创建线程有哪些方式？这些方法各自利弊是什么？\n\n创建线程主要有三种方式：\n\n1. 继承 Thread 类\n\n * 定义 Thread 类的子类，并重写该类的 run() 方法，该 run() 方法的方法体就代表了线程要完成的任务。因此把 run() 方法称为执行体。\n * 创建 Thread 子类的实例，即创建了线程对象。\n * 调用线程对象的 start() 方法来启动该线程。\n\n2. 实现 Runnable 接口\n\n * 定义 Runnable 接口的实现类，并重写该接口的 run() 方法，该 run() 方法的方法体同样是该线程的线程执行体。\n * 创建 Runnable 实现类的实例，并以此实例作为 Thread 对象，该 Thread 对象才是真正的线程对象。\n * 调用线程对象的 start() 方法来启动该线程。\n\n3. 通过 Callable 接口和 Future 接口\n\n * 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。\n * 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。\n * 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。\n * 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值\n\n三种创建线程方式对比\n\n * 实现 Runnable 接口优于继承 Thread 类，因为根据开放封闭原则——实现接口更便于扩展；\n * 实现 Runnable 接口的线程没有返回值；而使用 Callable / Future 方式可以让线程有返回值。\n\n> 👉 参考阅读：Java 创建线程的三种方式及其对比\n\n# 什么是 Callable 和 Future？什么是 FutureTask？\n\n什么是 Callable 和 Future？\n\nJava 5 在 concurrency 包中引入了 Callable 接口，它和 Runnable 接口很相似，但它可以返回一个对象或者抛出一个异常。\n\nCallable 接口使用泛型去定义它的返回类型。Executors 类提供了一些有用的方法去在线程池中执行 Callable 内的任务。由于 Callable 任务是并行的，我们必须等待它返回的结果。Future 对象为我们解决了这个问题。在线程池提交 Callable 任务后返回了一个 Future 对象，使用它我们可以知道 Callable 任务的状态和得到 Callable 返回的执行结果。Future 提供了 get() 方法让我们可以等待 Callable 结束并获取它的执行结果。\n\n什么是 FutureTask？\n\nFutureTask 是 Future 的一个基础实现，我们可以将它同 Executors 使用处理异步任务。通常我们不需要使用 FutureTask 类，单当我们打算重写 Future 接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。阅读 Java FutureTask 例子，学习如何使用它。\n\n> 👉 参考阅读：Java 并发编程：Callable、Future 和 FutureTask\n\n# start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？\n\n * run() 方法是线程的执行体。\n * start() 方法负责启动线程，然后 JVM 会让这个线程去执行 run() 方法。\n\n可以直接调用 Thread 类的 run() 方法么？\n\n * 可以。但是如果直接调用 Thread 的 run() 方法，它的行为就会和普通的方法一样。\n * 为了在新的线程中执行我们的代码，必须使用 start() 方法。\n\n# sleep()、yield()、join() 方法有什么区别？为什么 sleep() 和 yield() 方法是静态（static）的？\n\nyield()\n\n * yield() 方法可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程从 Running 状态转入 Runnable 状态。\n * 当某个线程调用了 yield() 方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。\n\nsleep()\n\n * sleep() 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入 Blocked 状态。\n * 该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。\n * 但是，sleep() 方法不会释放“锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。\n\njoin()\n\n * join() 方法会使当前线程转入 Blocked 状态，等待调用 join() 方法的线程结束后才能继续执行。\n\n为什么 sleep() 和 yield() 方法是静态（static）的？\n\n * Thread 类的 sleep() 和 yield() 方法将处理 Running 状态的线程。所以在其他处于非 Running 状态的线程上执行这两个方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。\n\n> 👉 参考阅读：Java 线程中 yield 与 join 方法的区别 👉 参考阅读：sleep()，wait()，yield()和 join()方法的区别\n\n# Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？\n\nJava 中的线程优先级如何控制\n\n * Java 中的线程优先级的范围是 [1,10]，一般来说，高优先级的线程在运行时会具有优先权。可以通过 thread.setPriority(Thread.MAX_PRIORITY) 的方式设置，默认优先级为 5。\n\n高优先级的 Java 线程一定先执行吗\n\n * 即使设置了线程的优先级，也无法保证高优先级的线程一定先执行。\n * 原因：这是因为 Java 线程优先级依赖于操作系统的支持，然而，不同的操作系统支持的线程优先级并不相同，不能很好的和 Java 中线程优先级一一对应。\n * 结论：Java 线程优先级控制并不可靠。\n\n# 什么是守护线程？为什么要用守护线程？如何创建守护线程？\n\n什么是守护线程\n\n * 守护线程（Daemon Thread）是在后台执行并且不会阻止 JVM 终止的线程。\n * 与守护线程（Daemon Thread）相反的，叫用户线程（User Thread），也就是非守护线程。\n\n为什么要用守护线程\n\n * 守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。典型的应用就是垃圾回收器。\n\n如何创建守护线程\n\n * 使用 thread.setDaemon(true) 可以设置 thread 线程为守护线程。\n * 注意点：\n   * 正在运行的用户线程无法设置为守护线程，所以 thread.setDaemon(true) 必须在 thread.start() 之前设置，否则会抛出 llegalThreadStateException 异常；\n   * 一个守护线程创建的子线程依然是守护线程。\n   * 不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。\n\n> 👉 参考阅读：Java 中守护线程的总结\n\n# 线程间是如何通信的？\n\n当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object 类中 wait(), notify() 和 notifyAll() 方法可以用于线程间通信关于资源的锁的状态。\n\n> 👉 参考阅读：Java 并发编程：线程间协作的两种方式：wait、notify、notifyAll 和 Condition\n\n# 为什么线程通信的方法 wait(), notify() 和 notifyAll() 被定义在 Object 类里？\n\nJava 的每个对象中都有一个锁(monitor，也可以成为监视器) 并且 wait()、notify() 等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在 Java 的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是 Object 类的一部分，这样 Java 的每一个类都有用于线程间通信的基本方法\n\n# 为什么 wait(), notify() 和 notifyAll() 必须在同步方法或者同步块中被调用？\n\n当一个线程需要调用对象的 wait() 方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify() 方法。同样的，当一个线程需要调用对象的 notify() 方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。\n\n由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。\n\n\n# 并发机制的底层实现\n\n> 👉 参考阅读：Java 并发核心机制\n\n# ⭐⭐⭐ synchronized\n\n> synchronized 有什么作用？\n> \n> synchronized 的原理是什么？\n> \n> 同步方法和同步块，哪个更好？\n> \n> JDK1.6 对synchronized 做了哪些优化？\n> \n> 使用 synchronized 修饰静态方法和非静态方法有什么区别？\n\n作用\n\nsynchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。\n\nsynchronized 有 3 种应用方式：\n\n * 同步实例方法 - 对于普通同步方法，锁是当前实例对象\n * 同步静态方法 - 对于静态同步方法，锁是当前类的 Class 对象\n * 同步代码块 - 对于同步方法块，锁是 synchonized 括号里配置的对象\n\n原理\n\nsynchronized 经过编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象。如果 synchronized 明确制定了对象参数，那就是这个对象的引用；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是静态方法，去对对应的对象实例或 Class 对象来作为锁对象。\n\nsynchronized 同步块对同一线程来说是可重入的，不会出现锁死问题。\n\nsynchronized 同步块是互斥的，即已进入的线程执行完成前，会阻塞其他试图进入的线程。\n\n优化\n\nJava 1.6 以后，synchronized 做了大量的优化，其性能已经与 Lock 、ReadWriteLock 基本上持平。\n\nsynchronized 的优化是将锁粒度分为不同级别，synchronized 会根据运行状态动态的由低到高调整锁级别（偏向锁 -> 轻量级锁 -> 重量级锁），以减少阻塞。\n\n同步方法 or 同步块？\n\n * 同步块是更好的选择。\n * 因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。\n\n# ⭐ volatile\n\n> volatile 有什么作用？\n> \n> volatile 的原理是什么？\n> \n> volatile 能代替锁吗？\n> \n> volatile 和 synchronized 的区别？\n\nvolatile 无法替代 synchronized ，因为 volatile 无法保证操作的原子性。\n\n作用\n\n被 volatile 关键字修饰的变量有两层含义：\n\n * 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n * 禁止指令重排序。\n\n原理\n\n观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令。\n\nlock 前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供 3 个功能：\n\n * 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n * 它会强制将对缓存的修改操作立即写入主存；\n * 如果是写操作，它会导致其他 CPU 中对应的缓存行无效。\n\nvolatile 和 synchronized 的区别？\n\n * volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。\n * volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的。\n * volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性\n * volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。\n * volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。\n\n# ⭐⭐ CAS\n\n> 什么是 CAS？\n> \n> CAS 有什么作用？\n> \n> CAS 的原理是什么？\n> \n> CAS 的三大问题？\n\n作用\n\nCAS（Compare and Swap），字面意思为比较并交换。CAS 有 3 个操作数，分别是：内存值 V，旧的预期值 A，要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。\n\n原理\n\nJava 主要利用 Unsafe 这个类提供的 CAS 操作。Unsafe 的 CAS 依赖的是 JV M 针对不同的操作系统实现的 Atomic::cmpxchg 指令。\n\n三大问题\n\n 1. ABA 问题：因为 CAS 需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是 A，变成了 B，又变成了 A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA 问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么 A－B－A 就会变成 1A-2B－3A。\n 2. 循环时间长开销大。自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。\n 3. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量 i ＝ 2,j=a，合并一下 ij=2a，然后用 CAS 来操作 ij。从 Java1.5 开始 JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。\n\n# ⭐ ThreadLocal\n\n> ThreadLocal 有什么作用？\n> \n> ThreadLocal 的原理是什么？\n> \n> 如何解决 ThreadLocal 内存泄漏问题？\n\n作用\n\nThreadLocal 是一个存储线程本地副本的工具类。\n\n原理\n\nThread 类中维护着一个 ThreadLocal.ThreadLocalMap 类型的成员 threadLocals。这个成员就是用来存储当前线程独占的变量副本。\n\nThreadLocalMap 是 ThreadLocal 的内部类，它维护着一个 Entry 数组， Entry 用于保存键值对，其 key 是 ThreadLocal 对象，value 是传递进来的对象（变量副本）。 Entry 继承了 WeakReference ，所以是弱引用。\n\n内存泄漏问题\n\nThreadLocalMap 的 Entry 继承了 WeakReference，所以它的 key （ThreadLocal 对象）是弱引用，而 value （变量副本）是强引用。\n\n * 如果 ThreadLocal 对象没有外部强引用来引用它，那么 ThreadLocal 对象会在下次 GC 时被回收。\n * 此时，Entry 中的 key 已经被回收，但是 value 由于是强引用不会被垃圾收集器回收。如果创建 ThreadLocal 的线程一直持续运行，那么 value 就会一直得不到回收，产生内存泄露。\n\n那么如何避免内存泄漏呢？方法就是：使用 ThreadLocal 的 set 方法后，显示的调用 remove 方法 。\n\n\n# 内存模型\n\n# 什么是 Java 内存模型\n\n * Java 内存模型即 Java Memory Model，简称 JMM。JMM 定义了 JVM 在计算机内存(RAM)中的工作方式。JMM 是隶属于 JVM 的。\n * 并发编程领域两个关键问题：线程间通信和线程间同步\n * 线程间通信机制\n   * 共享内存 - 线程间通过写-读内存中的公共状态来隐式进行通信。\n   * 消息传递 - java 中典型的消息传递方式就是 wait()和 notify()。\n * 线程间同步机制\n   * 在共享内存模型中，必须显示指定某个方法或某段代码在线程间互斥地执行。\n   * 在消息传递模型中，由于发送消息必须在接收消息之前，因此同步是隐式进行的。\n * Java 的并发采用的是共享内存模型\n * JMM 决定一个线程对共享变量的写入何时对另一个线程可见。\n * 线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。\n * JMM 把内存分成了两部分：线程栈区和堆区\n   * 线程栈\n     * JVM 中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。\n     * 线程栈还包含了当前方法的所有本地变量信息。线程中的本地变量对其它线程是不可见的。\n   * 堆区\n     * 堆区包含了 Java 应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如 Byte、Integer、Long 等等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。\n   * 一个本地变量如果是原始类型，那么它会被完全存储到栈区。\n   * 一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。\n   * 对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。\n   * 对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。\n\n\n\n> 👉 参考阅读：全面理解 Java 内存模型\n\n\n# 同步容器和并发容器\n\n> 👉 参考阅读：Java 并发容器\n\n# ⭐ 同步容器\n\n> 什么是同步容器？\n> \n> 有哪些常见同步容器？\n> \n> 它们是如何实现线程安全的？\n> \n> 同步容器真的线程安全吗？\n\n类型\n\nVector、Stack、Hashtable\n\n作用/原理\n\n同步容器的同步原理就是在方法上用 synchronized 修饰。 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。\n\nsynchronized 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 synchronized 的容器性能要差。\n\n线程安全\n\n同步容器真的绝对安全吗？\n\n其实也未必。在做复合操作（非原子操作）时，仍然需要加锁来保护。常见复合操作如下：\n\n * 迭代：反复访问元素，直到遍历完全部元素；\n * 跳转：根据指定顺序寻找当前元素的下一个（下 n 个）元素；\n * 条件运算：例如若没有则添加等；\n\n# ⭐⭐⭐ ConcurrentHashMap\n\n> 请描述 ConcurrentHashMap 的实现原理？\n> \n> ConcurrentHashMap 为什么放弃了分段锁？\n\n基础数据结构原理和 HashMap 一样，JDK 1.7 采用 数组＋单链表；JDK 1.8 采用数组＋单链表＋红黑树。\n\n并发安全特性的实现：\n\nJDK 1.7：\n\n * 使用分段锁，设计思路是缩小锁粒度，提高并发吞吐。\n * 写数据时，会使用可重入锁去锁住分段（segment）。\n\nJDK 1.8：\n\n * 取消分段锁，直接采用 transient volatile HashEntry<K,V>[] table 保存数据，采用 table 数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。\n * 写数据时，使用是 CAS + synchronized。\n   * 根据 key 计算出 hashcode 。\n   * 判断是否需要进行初始化。\n   * f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。\n   * 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。\n   * 如果都不满足，则利用 synchronized 锁写入数据。\n   * 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。\n\n# ⭐⭐ CopyOnWriteArrayList\n\n> CopyOnWriteArrayList 的作用？\n> \n> CopyOnWriteArrayList 的原理？\n\n作用\n\nCopyOnWrite 字面意思为写入时复制。CopyOnWriteArrayList 是线程安全的 ArrayList。\n\n原理\n\n * 在 CopyOnWriteAarrayList 中，读操作不同步，因为它们在内部数组的快照上工作，所以多个迭代器可以同时遍历而不会相互阻塞（1,2,4）。\n * 所有的写操作都是同步的。他们在备份数组（3）的副本上工作。写操作完成后，后备阵列将被替换为复制的阵列，并释放锁定。支持数组变得易变，所以替换数组的调用是原子（5）。\n * 写操作后创建的迭代器将能够看到修改的结构（6,7）。\n * 写时复制集合返回的迭代器不会抛出 ConcurrentModificationException，因为它们在数组的快照上工作，并且无论后续的修改（2,4）如何，都会像迭代器创建时那样完全返回元素。\n\n\n\n\n# 并发锁\n\n> 👉 参考阅读：Java 并发锁\n\n# ⭐⭐ 锁类型\n\n> Java 中有哪些锁？\n> \n> 这些锁有什么特性？\n\n可重入锁\n\n * ReentrantLock 、ReentrantReadWriteLock 是可重入锁。这点，从其命名也不难看出。\n * synchronized 也是一个可重入锁。\n\n公平锁与非公平锁\n\n * synchronized 只支持非公平锁。\n * ReentrantLock 、ReentrantReadWriteLock，默认是非公平锁，但支持公平锁。\n\n独享锁与共享锁\n\n * synchronized 、ReentrantLock 只支持独享锁。\n * ReentrantReadWriteLock 其写锁是独享锁，其读锁是共享锁。读锁是共享锁使得并发读是非常高效的，读写，写读 ，写写的过程是互斥的。\n\n悲观锁与乐观锁\n\n * 悲观锁在 Java 中的应用就是通过使用 synchronized 和 Lock 显示加锁来进行互斥同步，这是一种阻塞同步。\n\n * 乐观锁在 Java 中的应用就是采用 CAS 机制（CAS 操作通过 Unsafe 类提供，但这个类不直接暴露为 API，所以都是间接使用，如各种原子类）。\n\n偏向锁、轻量级锁、重量级锁\n\nJava 1.6 以前，重量级锁一般指的是 synchronized ，而轻量级锁指的是 volatile。\n\nJava 1.6 以后，针对 synchronized 做了大量优化，引入 4 种锁状态： 无锁状态、偏向锁、轻量级锁和重量级锁。锁可以单向的从偏向锁升级到轻量级锁，再从轻量级锁升级到重量级锁 。\n\n分段锁\n\n分段锁其实是一种锁的设计，并不是具体的一种锁。典型：JDK1.7 之前的 ConcurrentHashMap\n\n显示锁和内置锁\n\n * 内置锁：synchronized\n * 显示锁：ReentrantLock、ReentrantReadWriteLock 等。\n\n# ⭐⭐ AQS\n\n> 什么是 AQS？\n> \n> AQS 的作用是什么？\n> \n> AQS 的原理？\n\n作用\n\nAbstractQueuedSynchronizer（简称 AQS）是队列同步器，顾名思义，其主要作用是处理同步。它是并发锁和很多同步工具类的实现基石（如 ReentrantLock、ReentrantReadWriteLock、Semaphore 等）。\n\nAQS 提供了对独享锁与共享锁的支持。\n\n原理\n\n（1）数据结构\n\n * state - AQS 使用一个整型的 volatile 变量来 维护同步状态。\n   * 这个整数状态的意义由子类来赋予，如ReentrantLock 中该状态值表示所有者线程已经重复获取该锁的次数，Semaphore 中该状态值表示剩余的许可数量。\n * head 和 tail - AQS 维护了一个 Node 类型（AQS 的内部类）的双链表来完成同步状态的管理。这个双链表是一个双向的 FIFO 队列，通过 head 和 tail 指针进行访问。当 有线程获取锁失败后，就被添加到队列末尾。\n\n（2）获取独占锁\n\nAQS 中使用 acquire(int arg) 方法获取独占锁，其大致流程如下：\n\n 1. 先尝试获取同步状态，如果获取同步状态成功，则结束方法，直接返回。\n 2. 如果获取同步状态不成功，AQS 会不断尝试利用 CAS 操作将当前线程插入等待同步队列的队尾，直到成功为止。\n 3. 接着，不断尝试为等待队列中的线程节点获取独占锁。\n\n（3）释放独占锁\n\nAQS 中使用 release(int arg) 方法释放独占锁，其大致流程如下：\n\n 1. 先尝试获取解锁线程的同步状态，如果获取同步状态不成功，则结束方法，直接返回。\n 2. 如果获取同步状态成功，AQS 会尝试唤醒当前线程节点的后继节点。\n\n（4）获取共享锁\n\nAQS 中使用 acquireShared(int arg) 方法获取共享锁。\n\nacquireShared 方法和 acquire 方法的逻辑很相似，区别仅在于自旋的条件以及节点出队的操作有所不同。\n\n成功获得共享锁的条件如下：\n\n * tryAcquireShared(arg) 返回值大于等于 0 （这意味着共享锁的 permit 还没有用完）。\n * 当前节点的前驱节点是头结点。\n\n（5）释放共享锁\n\nAQS 中使用 releaseShared(int arg) 方法释放共享锁。\n\nreleaseShared 首先会尝试释放同步状态，如果成功，则解锁一个或多个后继线程节点。释放共享锁和释放独享锁流程大体相似，区别在于：\n\n对于独享模式，如果需要 SIGNAL，释放仅相当于调用头节点的 unparkSuccessor。\n\n# ⭐⭐ ReentrantLock\n\n> 什么是 ReentrantLock？\n> \n> 什么是可重入锁？\n> \n> ReentrantLock 有什么用？\n> \n> ReentrantLock 原理？\n\n作用\n\nReentrantLock 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作\n\nReentrantLock 的特性如下：\n\n * ReentrantLock 提供了与 synchronized 相同的互斥性、内存可见性和可重入性。\n * ReentrantLock 支持公平锁和非公平锁（默认）两种模式。\n * ReentrantLock 实现了 Lock 接口，支持了 synchronized 所不具备的灵活性。\n   * synchronized 无法中断一个正在等待获取锁的线程\n   * synchronized 无法在请求获取一个锁时无休止地等待\n\n原理\n\nReentrantLock 基于其内部类 ReentrantLock.Sync 实现，Sync 继承自 AQS。它有两个子类：\n\n * ReentrantLock.FairSync - 公平锁。\n * ReentrantLock.NonfairSync - 非公平锁。\n\n本质上，就是基于 AQS 实现。\n\n# ⭐ ReentrantReadWriteLock\n\n> ReentrantReadWriteLock 是什么？\n> \n> ReentrantReadWriteLock 的作用？\n> \n> ReentrantReadWriteLock 的原理？\n\n作用\n\nReentrantReadWriteLock 是一个可重入的读写锁。ReentrantReadWriteLock 维护了一对读写锁，将读写锁分开，有利于提高并发效率。\n\n原理\n\nReentrantReadWriteLock 本质上也是基于 AQS 实现。有三个核心字段：\n\n * sync - 内部类 ReentrantReadWriteLock.Sync 对象。与 ReentrantLock 类似，它有两个子类：ReentrantReadWriteLock.FairSync 和 ReentrantReadWriteLock.NonfairSync ，分别表示公平锁和非公平锁的实现。\n * readerLock - 内部类 ReentrantReadWriteLock.ReadLock 对象，这是一把读锁。\n * writerLock - 内部类 ReentrantReadWriteLock.WriteLock 对象，这是一把写锁。\n\n# ⭐ Condition\n\n> Condition 有什么用？\n> \n> 使用 Lock 的线程，彼此如何通信？\n\n作用\n\n可以理解为，什么样的锁配什么样的钥匙。\n\n内置锁（synchronized）配合内置条件队列（wait、notify、notifyAll ），显式锁（Lock）配合显式条件队列（Condition ）。\n\n# ⭐⭐ 死锁\n\n> 如何避免死锁？\n\n * 避免一个线程同时获取多个锁\n * 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源\n * 尝试使用定时锁 lock.tryLock(timeout)，避免锁一直不能释放\n * 对于数据库锁，加锁和解锁必须在一个数据库连接中里，否则会出现解锁失败的情况。\n\n\n# 原子变量类\n\n> 👉 参考阅读：Java 原子类\n\n# ⭐ 原子类简介\n\n> 为什么要用原子类？\n> \n> 用过哪些原子类？\n\n作用\n\n常规的锁（Lock、sychronized）由于是阻塞式的，势必影响并发吞吐量。\n\nvolatile 号称轻量级的锁，但不能保证原子性。\n\n为了兼顾原子性和锁的性能问题，所以引入了原子类。\n\n类型\n\n原子变量类可以分为 4 组：\n\n * 基本类型\n   * AtomicBoolean - 布尔类型原子类\n   * AtomicInteger - 整型原子类\n   * AtomicLong - 长整型原子类\n * 引用类型\n   * AtomicReference - 引用类型原子类\n   * AtomicMarkableReference - 带有标记位的引用类型原子类\n   * AtomicStampedReference - 带有版本号的引用类型原子类\n * 数组类型\n   * AtomicIntegerArray - 整形数组原子类\n   * AtomicLongArray - 长整型数组原子类\n   * AtomicReferenceArray - 引用类型数组原子类\n * 属性更新器类型\n   * AtomicIntegerFieldUpdater - 整型字段的原子更新器。\n   * AtomicLongFieldUpdater - 长整型字段的原子更新器。\n   * AtomicReferenceFieldUpdater - 原子更新引用类型里的字段。\n\n# ⭐ 原子类的原理\n\n 1. 处理器实现原子操作：使用总线锁保证原子性，使用缓存锁保证原子性（修改内存地址，缓存一致性机制：阻止同时修改由 2 个以上的处理器缓存的内存区域数据）\n 2. JAVA 实现原子操作：循环使用 CAS （自旋 CAS）实现原子操作\n\n\n# 并发工具类\n\n> 👉 参考阅读：Java 并发工具类\n\n# ⭐ CountDownLatch\n\n> CountDownLatch 作用？\n> \n> CountDownLatch 原理？\n\n作用\n\n字面意思为 递减计数锁。用于控制一个或者多个线程等待多个线程。\n\nCountDownLatch 维护一个计数器 count，表示需要等待的事件数量。countDown 方法递减计数器，表示有一个事件已经发生。调用 await 方法的线程会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。\n\n\n\n原理\n\nCountDownLatch 是基于 AQS(AbstractQueuedSynchronizer) 实现的。\n\n# ⭐ CyclicBarrier\n\n> CyclicBarrier 有什么用？\n> \n> CyclicBarrier 的原理是什么？\n> \n> CyclicBarrier 和 CountDownLatch 有什么区别？\n\n作用\n\n字面意思是 循环栅栏。CyclicBarrier 可以让一组线程等待至某个状态（遵循字面意思，不妨称这个状态为栅栏）之后再全部同时执行。之所以叫循环栅栏是因为：当所有等待线程都被释放以后，CyclicBarrier 可以被重用。\n\nCyclicBarrier 维护一个计数器 count。每次执行 await 方法之后，count 加 1，直到计数器的值和设置的值相等，等待的所有线程才会继续执行。\n\n\n\n原理\n\nCyclicBarrier 是基于 ReentrantLock 和 Condition 实现的。\n\n区别\n\nCyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重用。\n\n# ⭐ Semaphore\n\n> Semaphore 作用？\n\n作用\n\n字面意思为 信号量。Semaphore 用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。\n\nSemaphore 管理着一组虚拟的许可（permit），permit 的初始数量可通过构造方法来指定。每次执行 acquire 方法可以获取一个 permit，如果没有就等待；而 release 方法可以释放一个 permit。\n\n * Semaphore 可以用于实现资源池，如数据库连接池。\n * Semaphore 可以用于将任何一种容器变成有界阻塞容器。\n\n\n\n\n# 线程池\n\n> 👉 参考阅读：Java 线程池\n\n# ⭐⭐ ThreadPoolExecutor\n\n> ThreadPoolExecutor 有哪些参数，各自有什么用？\n> \n> ThreadPoolExecutor 工作原理？\n\n原理\n\n\n\n参数\n\njava.uitl.concurrent.ThreadPoolExecutor 类是 Executor 框架中最核心的一个类。\n\nThreadPoolExecutor 有四个构造方法，前三个都是基于第四个实现。第四个构造方法定义如下：\n\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n\n\n参数说明：\n\n * corePoolSize - 核心线程数量。当有新任务通过 execute 方法提交时 ，线程池会执行以下判断：\n   * 如果运行的线程数少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的。\n   * 如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当 workQueue 满时才创建新的线程去处理任务；\n   * 如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建的线程池的大小是固定的。这时如果有新任务提交，若 workQueue 未满，则将请求放入 workQueue 中，等待有空闲的线程去从 workQueue 中取任务并处理；\n   * 如果运行的线程数量大于等于 maximumPoolSize，这时如果 workQueue 已经满了，则使用 handler 所指定的策略来处理任务；\n   * 所以，任务提交时，判断的顺序为 corePoolSize => workQueue => maximumPoolSize。\n * maximumPoolSize - 最大线程数量。\n   * 如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。\n   * 值得注意的是：如果使用了无界的任务队列这个参数就没什么效果。\n * keepAliveTime：线程保持活动的时间。\n   * 当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime。\n   * 所以，如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。\n * unit - keepAliveTime 的时间单位。有 7 种取值。可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。\n * workQueue - 等待执行的任务队列。用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。\n   * ArrayBlockingQueue - 有界阻塞队列。\n     * 此队列是基于数组的先进先出队列（FIFO）。\n     * 此队列创建时必须指定大小。\n   * LinkedBlockingQueue - 无界阻塞队列。\n     * 此队列是基于链表的先进先出队列（FIFO）。\n     * 如果创建时没有指定此队列大小，则默认为 Integer.MAX_VALUE。\n     * 吞吐量通常要高于 ArrayBlockingQueue。\n     * 使用 LinkedBlockingQueue 意味着： maximumPoolSize 将不起作用，线程池能创建的最大线程数为 corePoolSize，因为任务等待队列是无界队列。\n     * Executors.newFixedThreadPool 使用了这个队列。\n   * SynchronousQueue - 不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。\n     * 每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。\n     * 吞吐量通常要高于 LinkedBlockingQueue。\n     * Executors.newCachedThreadPool 使用了这个队列。\n   * PriorityBlockingQueue - 具有优先级的无界阻塞队列。\n * threadFactory - 线程工厂。可以通过线程工厂给每个创建出来的线程设置更有意义的名字。\n * handler - 饱和策略。它是 RejectedExecutionHandler 类型的变量。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。线程池支持以下策略：\n   * AbortPolicy - 丢弃任务并抛出异常。这也是默认策略。\n   * DiscardPolicy - 丢弃任务，但不抛出异常。\n   * DiscardOldestPolicy - 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。\n   * CallerRunsPolicy - 只用调用者所在的线程来运行任务。\n   * 如果以上策略都不能满足需要，也可以通过实现 RejectedExecutionHandler 接口来定制处理策略。如记录日志或持久化不能处理的任务。\n\n# ⭐ Executors\n\n> Executors 提供了哪些内置的线程池？\n> \n> 这些线程池各自有什么特性？适合用于什么场景？\n\nExecutors 为 Executor，ExecutorService，ScheduledExecutorService，ThreadFactory 和 Callable 类提供了一些工具方法。\n\n（1）newSingleThreadExecutor\n\n创建一个单线程的线程池。\n\n只会创建唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它 。\n\n单工作线程最大的特点是：可保证顺序地执行各个任务。\n\n（2）newFixedThreadPool\n\n创建一个固定大小的线程池。\n\n每次提交一个任务就会新创建一个工作线程，如果工作线程数量达到线程池最大线程数，则将提交的任务存入到阻塞队列中。\n\nFixedThreadPool 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。\n\n（3）newCachedThreadPool\n\n创建一个可缓存的线程池。\n\n * 如果线程池大小超过处理任务所需要的线程数，就会回收部分空闲的线程；\n * 如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。\n * 此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。 因此，使用 CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。\n\n（4）newScheduleThreadPool\n\n创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\n\n# JVM\n\n\n# 内存管理\n\n\n# OOM\n\n\n# 参考资料\n\n * 书籍\n   * 《Java 并发编程实战》\n   * 《Java 并发编程的艺术》\n   * 《深入理解 Java 虚拟机》\n * 文章\n   * Java 线程面试题 Top 50\n   * Java 多线程和并发基础面试问答\n   * 进程和线程关系及区别\n   * JavaThread Methods and Thread States\n   * Java 线程的 5 种状态及切换(透彻讲解)\n   * Java 中守护线程的总结\n   * Java 创建线程的三种方式及其对比\n   * Java 线程的 5 种状态及切换(透彻讲解)\n   * Java 线程方法 join 的简单总结\n   * Java 并发编程：线程间协作的两种方式：wait、notify、notifyAll 和 Condition\n   * Java 并发编程：volatile 关键字解析\n   * Java 并发编程：Callable、Future 和 FutureTask\n   * Java 并发编程：线程池的使用\n   * Java 并发编程',normalizedContent:'# java 面试总结\n\n\n# 基础\n\n\n# 工具类\n\n# string\n\n> string 类能被继承吗？\n> \n> string，stringbuffer，stringbuilder 的区别。\n\nstring 类不能被继承。因为其被 final 修饰，所以无法被继承。\n\nstringbuffer，stringbuilder 拼接字符串，使用 append 比 string 效率高。因为 string 会隐式 new string 对象。\n\nstringbuffer 主要方法都用 synchronized 修饰，是线程安全的；而 stringbuilder 不是。\n\n\n# 面向对象\n\n> 抽象类和接口的区别？\n> \n> 类可以继承多个类么？接口可以继承多个接口么？类可以实现多个接口么？\n\n类只能继承一个类，但是可以实现多个接口。接口可以继承多个接口。\n\n> 继承和聚合的区别在哪？\n\n一般，能用聚合就别用继承。\n\n\n# 反射\n\n# ⭐ 创建实例\n\n> 反射创建实例有几种方式？\n\n通过反射来创建实例对象主要有两种方式：\n\n * 用 class 对象的 newinstance 方法。\n * 用 constructor 对象的 newinstance 方法。\n\n# ⭐ 加载实例\n\n> 加载实例有几种方式？\n> \n> class.forname("classname") 和 classloader.laodclass("classname") 有什么区别？\n\n * class.forname("classname") 加载的是已经初始化到 jvm 中的类。\n * classloader.laodclass("classname") 装载的是还没有初始化到 jvm 中的类。\n\n# ⭐⭐ 动态代理\n\n> 动态代理有几种实现方式？有什么特点？\n> \n> jdk 动态代理和 cglib 动态代理有什么区别？\n\n（1）jdk 方式\n\n代理类与委托类实现同一接口，主要是通过代理类实现 invocationhandler 并重写 invoke 方法来进行动态代理的，在 invoke 方法中将对方法进行处理。\n\njdk 动态代理特点：\n\n * 优点：相对于静态代理模式，不需要硬编码接口，代码复用率高。\n * 缺点：强制要求代理类实现 invocationhandler 接口。\n\n（2）cglib\n\ncglib 底层，其实是借助了 asm 这个强大的 java 字节码框架去进行字节码增强操作。\n\ncglib 动态代理特点：\n\n优点：使用字节码增强，比 jdk 动态代理方式性能高。可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口。\n\n缺点：不能对 final 类以及 final 方法进行代理。\n\n\n# jdk8\n\n\n# 其他\n\n# ⭐ hashcode\n\n> 有==运算符了，为什么还需要 equals 啊？\n> \n> 说一说你对 java.lang.object 对象中 hashcode 和 equals 方法的理解。在什么场景下需 要重新实现这两个方法。\n> \n> 有没有可能 2 个不相等的对象有相同的 hashcode\n\n（1）有==运算符了，为什么还需要 equals 啊？\n\nequals 等价于==,而==运算符是判断两个对象是不是同一个对象，即他们的地址是否相等。而覆写 equals 更多的是追求两个对象在逻辑上的相等，你可以说是值相等，也可说是内容相等。\n\n（2）说一说你对 java.lang.object 对象中 hashcode 和 equals 方法的理解。在什么场景下需 要重新实现这两个方法。\n\n在集合查找时，hashcode 能大大降低对象比较次数，提高查找效率！\n\n（3）有没有可能 2 个不相等的对象有相同的 hashcode\n\n有可能。\n\n * 如果两个对象 equals，java 运行时环境会认为他们的 hashcode 一定相等。\n * 如果两个对象不 equals，他们的 hashcode 有可能相等。\n * 如果两个对象 hashcode 相等，他们不一定 equals。\n * 如果两个对象 hashcode 不相等，他们一定不 equals。\n\n\n# io\n\n\n# nio\n\n> 什么是 nio？\n> \n> nio 和 bio、aio 有何差别？\n\n\n# 序列化\n\n# ⭐ 序列化问题\n\n> 序列化、反序列化有哪些问题？如何解决？\n\njava 的序列化能保证对象状态的持久保存，但是遇到一些对象结构复杂的情况还是难以处理，这里归纳一下：\n\n * 当父类继承 serializable 接口时，所有子类都可以被序列化。\n * 子类实现了 serializable 接口，父类没有，则父类的属性不会被序列化（不报错，数据丢失），子类的属性仍可以正确序列化。\n * 如果序列化的属性是对象，则这个对象也必须实现 serializable 接口，否则会报错。\n * 在反序列化时，如果对象的属性有修改或删减，则修改的部分属性会丢失，但不会报错。\n * 在反序列化时，如果 serialversionuid 被修改，则反序列化时会失败。\n\n\n# 容器\n\n\n# list\n\n# arraylist 和 linkedlist 有什么区别？\n\narraylist 是数组链表，访问效率更高。\n\nlinkedlist 是双链表，数据有序存储。\n\n\n# map\n\n请描述 hashmap 的实现原理？\n\n\n# 并发\n\n\n# 并发简介\n\n# 什么是进程？什么是线程？进程和线程的区别？\n\n * 什么是进程？\n   * 简言之，进程可视为一个正在运行的程序。\n   * 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。\n * 什么是线程？\n   * 线程是操作系统进行调度的基本单位。\n * 进程 vs. 线程\n   * 一个程序至少有一个进程，一个进程至少有一个线程。\n   * 线程比进程划分更细，所以执行开销更小，并发性更高。\n   * 进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。\n\n# 并发（多线程）编程的好处是什么？\n\n * 更有效率的利用多处理器核心\n * 更快的响应时间\n * 更好的编程模型\n\n# 并发一定比串行更快吗？\n\n答：否。\n\n要点：创建线程和线程上下文切换有一定开销。\n\n说明：即使是单核处理器也支持多线程。cpu 通过给每个线程分配时间切片的算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保持上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。\n\n引申\n\n * 如何减少上下文切换？\n   * 尽量少用锁\n   * cas 算法\n   * 线程数要合理\n   * 协程：在单线程中实现多任务调度，并在单线程中维持多个任务的切换\n\n# 如何让正在运行的线程暂停一段时间？\n\n我们可以使用 thread 类的 sleep() 方法让线程暂停一段时间。\n\n需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为 runnable，并且根据线程调度，它将得到执行。\n\n# 什么是线程调度器(thread scheduler)和时间分片(time slicing)？\n\n线程调度器是一个操作系统服务，它负责为 runnable 状态的线程分配 cpu 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。\n\n时间分片是指将可用的 cpu 时间分配给可用的 runnable 线程的过程。\n\n分配 cpu 时间可以基于线程优先级或者线程等待的时间。线程调度并不受到 java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。\n\n# 在多线程中，什么是上下文切换(context-switching)？\n\n上下文切换是存储和恢复 cpu 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。\n\n# 如何确保线程安全？\n\n * 原子类(atomic concurrent classes)\n * 锁\n * volatile 关键字\n * 不变类和线程安全类\n\n# 什么是死锁(deadlock)？如何分析和避免死锁？\n\n死锁是指两个以上的线程永远相互阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。\n\n分析死锁，我们需要查看 java 应用程序的线程转储。我们需要找出那些状态为 blocked 的线程和他们等待的资源。每个资源都有一个唯一的 id，用这个 id 我们可以找出哪些线程已经拥有了它的对象锁。\n\n避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。\n\n\n# 线程基础\n\n# java 线程生命周期中有哪些状态？各状态之间如何切换？\n\n\n\njava.lang.thread.state 中定义了 6 种不同的线程状态，在给定的一个时刻，线程只能处于其中的一个状态。\n\n以下是各状态的说明，以及状态间的联系：\n\n * 开始（new） - 还没有调用 start() 方法的线程处于此状态。\n * 可运行（runnable） - 已经调用了 start() 方法的线程状态。此状态意味着，线程已经准备好了，一旦被线程调度器分配了 cpu 时间片，就可以运行线程。\n * 阻塞（blocked） - 阻塞状态。线程阻塞的线程状态等待监视器锁定。处于阻塞状态的线程正在等待监视器锁定，以便在调用 object.wait() 之后输入同步块/方法或重新输入同步块/方法。\n * 等待（waiting） - 等待状态。一个线程处于等待状态，是由于执行了 3 个方法中的任意方法：\n   * object.wait()\n   * thread.join()\n   * locksupport.park()\n * 定时等待（timed waiting） - 等待指定时间的状态。一个线程处于定时等待状态，是由于执行了以下方法中的任意方法：\n   * thread.sleep(sleeptime)\n   * object.wait(timeout)\n   * thread.join(timeout)\n   * locksupport.parknanos(timeout)\n   * locksupport.parkuntil(timeout)\n * 终止(terminated) - 线程 run() 方法执行结束，或者因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。\n\n> 👉 参考阅读：javathread methods and thread states 👉 参考阅读：java 线程的 5 种状态及切换(透彻讲解)\n\n# 创建线程有哪些方式？这些方法各自利弊是什么？\n\n创建线程主要有三种方式：\n\n1. 继承 thread 类\n\n * 定义 thread 类的子类，并重写该类的 run() 方法，该 run() 方法的方法体就代表了线程要完成的任务。因此把 run() 方法称为执行体。\n * 创建 thread 子类的实例，即创建了线程对象。\n * 调用线程对象的 start() 方法来启动该线程。\n\n2. 实现 runnable 接口\n\n * 定义 runnable 接口的实现类，并重写该接口的 run() 方法，该 run() 方法的方法体同样是该线程的线程执行体。\n * 创建 runnable 实现类的实例，并以此实例作为 thread 对象，该 thread 对象才是真正的线程对象。\n * 调用线程对象的 start() 方法来启动该线程。\n\n3. 通过 callable 接口和 future 接口\n\n * 创建 callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。\n * 创建 callable 实现类的实例，使用 futuretask 类来包装 callable 对象，该 futuretask 对象封装了该 callable 对象的 call() 方法的返回值。\n * 使用 futuretask 对象作为 thread 对象的 target 创建并启动新线程。\n * 调用 futuretask 对象的 get() 方法来获得子线程执行结束后的返回值\n\n三种创建线程方式对比\n\n * 实现 runnable 接口优于继承 thread 类，因为根据开放封闭原则——实现接口更便于扩展；\n * 实现 runnable 接口的线程没有返回值；而使用 callable / future 方式可以让线程有返回值。\n\n> 👉 参考阅读：java 创建线程的三种方式及其对比\n\n# 什么是 callable 和 future？什么是 futuretask？\n\n什么是 callable 和 future？\n\njava 5 在 concurrency 包中引入了 callable 接口，它和 runnable 接口很相似，但它可以返回一个对象或者抛出一个异常。\n\ncallable 接口使用泛型去定义它的返回类型。executors 类提供了一些有用的方法去在线程池中执行 callable 内的任务。由于 callable 任务是并行的，我们必须等待它返回的结果。future 对象为我们解决了这个问题。在线程池提交 callable 任务后返回了一个 future 对象，使用它我们可以知道 callable 任务的状态和得到 callable 返回的执行结果。future 提供了 get() 方法让我们可以等待 callable 结束并获取它的执行结果。\n\n什么是 futuretask？\n\nfuturetask 是 future 的一个基础实现，我们可以将它同 executors 使用处理异步任务。通常我们不需要使用 futuretask 类，单当我们打算重写 future 接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。阅读 java futuretask 例子，学习如何使用它。\n\n> 👉 参考阅读：java 并发编程：callable、future 和 futuretask\n\n# start() 和 run() 有什么区别？可以直接调用 thread 类的 run() 方法么？\n\n * run() 方法是线程的执行体。\n * start() 方法负责启动线程，然后 jvm 会让这个线程去执行 run() 方法。\n\n可以直接调用 thread 类的 run() 方法么？\n\n * 可以。但是如果直接调用 thread 的 run() 方法，它的行为就会和普通的方法一样。\n * 为了在新的线程中执行我们的代码，必须使用 start() 方法。\n\n# sleep()、yield()、join() 方法有什么区别？为什么 sleep() 和 yield() 方法是静态（static）的？\n\nyield()\n\n * yield() 方法可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程从 running 状态转入 runnable 状态。\n * 当某个线程调用了 yield() 方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。\n\nsleep()\n\n * sleep() 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入 blocked 状态。\n * 该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。\n * 但是，sleep() 方法不会释放“锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。\n\njoin()\n\n * join() 方法会使当前线程转入 blocked 状态，等待调用 join() 方法的线程结束后才能继续执行。\n\n为什么 sleep() 和 yield() 方法是静态（static）的？\n\n * thread 类的 sleep() 和 yield() 方法将处理 running 状态的线程。所以在其他处于非 running 状态的线程上执行这两个方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。\n\n> 👉 参考阅读：java 线程中 yield 与 join 方法的区别 👉 参考阅读：sleep()，wait()，yield()和 join()方法的区别\n\n# java 的线程优先级如何控制？高优先级的 java 线程一定先执行吗？\n\njava 中的线程优先级如何控制\n\n * java 中的线程优先级的范围是 [1,10]，一般来说，高优先级的线程在运行时会具有优先权。可以通过 thread.setpriority(thread.max_priority) 的方式设置，默认优先级为 5。\n\n高优先级的 java 线程一定先执行吗\n\n * 即使设置了线程的优先级，也无法保证高优先级的线程一定先执行。\n * 原因：这是因为 java 线程优先级依赖于操作系统的支持，然而，不同的操作系统支持的线程优先级并不相同，不能很好的和 java 中线程优先级一一对应。\n * 结论：java 线程优先级控制并不可靠。\n\n# 什么是守护线程？为什么要用守护线程？如何创建守护线程？\n\n什么是守护线程\n\n * 守护线程（daemon thread）是在后台执行并且不会阻止 jvm 终止的线程。\n * 与守护线程（daemon thread）相反的，叫用户线程（user thread），也就是非守护线程。\n\n为什么要用守护线程\n\n * 守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。典型的应用就是垃圾回收器。\n\n如何创建守护线程\n\n * 使用 thread.setdaemon(true) 可以设置 thread 线程为守护线程。\n * 注意点：\n   * 正在运行的用户线程无法设置为守护线程，所以 thread.setdaemon(true) 必须在 thread.start() 之前设置，否则会抛出 llegalthreadstateexception 异常；\n   * 一个守护线程创建的子线程依然是守护线程。\n   * 不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。\n\n> 👉 参考阅读：java 中守护线程的总结\n\n# 线程间是如何通信的？\n\n当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。object 类中 wait(), notify() 和 notifyall() 方法可以用于线程间通信关于资源的锁的状态。\n\n> 👉 参考阅读：java 并发编程：线程间协作的两种方式：wait、notify、notifyall 和 condition\n\n# 为什么线程通信的方法 wait(), notify() 和 notifyall() 被定义在 object 类里？\n\njava 的每个对象中都有一个锁(monitor，也可以成为监视器) 并且 wait()、notify() 等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在 java 的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是 object 类的一部分，这样 java 的每一个类都有用于线程间通信的基本方法\n\n# 为什么 wait(), notify() 和 notifyall() 必须在同步方法或者同步块中被调用？\n\n当一个线程需要调用对象的 wait() 方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify() 方法。同样的，当一个线程需要调用对象的 notify() 方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。\n\n由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。\n\n\n# 并发机制的底层实现\n\n> 👉 参考阅读：java 并发核心机制\n\n# ⭐⭐⭐ synchronized\n\n> synchronized 有什么作用？\n> \n> synchronized 的原理是什么？\n> \n> 同步方法和同步块，哪个更好？\n> \n> jdk1.6 对synchronized 做了哪些优化？\n> \n> 使用 synchronized 修饰静态方法和非静态方法有什么区别？\n\n作用\n\nsynchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。\n\nsynchronized 有 3 种应用方式：\n\n * 同步实例方法 - 对于普通同步方法，锁是当前实例对象\n * 同步静态方法 - 对于静态同步方法，锁是当前类的 class 对象\n * 同步代码块 - 对于同步方法块，锁是 synchonized 括号里配置的对象\n\n原理\n\nsynchronized 经过编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象。如果 synchronized 明确制定了对象参数，那就是这个对象的引用；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是静态方法，去对对应的对象实例或 class 对象来作为锁对象。\n\nsynchronized 同步块对同一线程来说是可重入的，不会出现锁死问题。\n\nsynchronized 同步块是互斥的，即已进入的线程执行完成前，会阻塞其他试图进入的线程。\n\n优化\n\njava 1.6 以后，synchronized 做了大量的优化，其性能已经与 lock 、readwritelock 基本上持平。\n\nsynchronized 的优化是将锁粒度分为不同级别，synchronized 会根据运行状态动态的由低到高调整锁级别（偏向锁 -> 轻量级锁 -> 重量级锁），以减少阻塞。\n\n同步方法 or 同步块？\n\n * 同步块是更好的选择。\n * 因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。\n\n# ⭐ volatile\n\n> volatile 有什么作用？\n> \n> volatile 的原理是什么？\n> \n> volatile 能代替锁吗？\n> \n> volatile 和 synchronized 的区别？\n\nvolatile 无法替代 synchronized ，因为 volatile 无法保证操作的原子性。\n\n作用\n\n被 volatile 关键字修饰的变量有两层含义：\n\n * 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n * 禁止指令重排序。\n\n原理\n\n观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令。\n\nlock 前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供 3 个功能：\n\n * 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n * 它会强制将对缓存的修改操作立即写入主存；\n * 如果是写操作，它会导致其他 cpu 中对应的缓存行无效。\n\nvolatile 和 synchronized 的区别？\n\n * volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。\n * volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的。\n * volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性\n * volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。\n * volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。\n\n# ⭐⭐ cas\n\n> 什么是 cas？\n> \n> cas 有什么作用？\n> \n> cas 的原理是什么？\n> \n> cas 的三大问题？\n\n作用\n\ncas（compare and swap），字面意思为比较并交换。cas 有 3 个操作数，分别是：内存值 v，旧的预期值 a，要修改的新值 b。当且仅当预期值 a 和内存值 v 相同时，将内存值 v 修改为 b，否则什么都不做。\n\n原理\n\njava 主要利用 unsafe 这个类提供的 cas 操作。unsafe 的 cas 依赖的是 jv m 针对不同的操作系统实现的 atomic::cmpxchg 指令。\n\n三大问题\n\n 1. aba 问题：因为 cas 需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是 a，变成了 b，又变成了 a，那么使用 cas 进行检查时会发现它的值没有发生变化，但是实际上却变化了。aba 问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么 a－b－a 就会变成 1a-2b－3a。\n 2. 循环时间长开销大。自旋 cas 如果长时间不成功，会给 cpu 带来非常大的执行开销。如果 jvm 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使 cpu 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 cpu 流水线被清空（cpu pipeline flush），从而提高 cpu 的执行效率。\n 3. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环 cas 的方式来保证原子操作，但是对多个共享变量操作时，循环 cas 就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量 i ＝ 2,j=a，合并一下 ij=2a，然后用 cas 来操作 ij。从 java1.5 开始 jdk 提供了 atomicreference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 cas 操作。\n\n# ⭐ threadlocal\n\n> threadlocal 有什么作用？\n> \n> threadlocal 的原理是什么？\n> \n> 如何解决 threadlocal 内存泄漏问题？\n\n作用\n\nthreadlocal 是一个存储线程本地副本的工具类。\n\n原理\n\nthread 类中维护着一个 threadlocal.threadlocalmap 类型的成员 threadlocals。这个成员就是用来存储当前线程独占的变量副本。\n\nthreadlocalmap 是 threadlocal 的内部类，它维护着一个 entry 数组， entry 用于保存键值对，其 key 是 threadlocal 对象，value 是传递进来的对象（变量副本）。 entry 继承了 weakreference ，所以是弱引用。\n\n内存泄漏问题\n\nthreadlocalmap 的 entry 继承了 weakreference，所以它的 key （threadlocal 对象）是弱引用，而 value （变量副本）是强引用。\n\n * 如果 threadlocal 对象没有外部强引用来引用它，那么 threadlocal 对象会在下次 gc 时被回收。\n * 此时，entry 中的 key 已经被回收，但是 value 由于是强引用不会被垃圾收集器回收。如果创建 threadlocal 的线程一直持续运行，那么 value 就会一直得不到回收，产生内存泄露。\n\n那么如何避免内存泄漏呢？方法就是：使用 threadlocal 的 set 方法后，显示的调用 remove 方法 。\n\n\n# 内存模型\n\n# 什么是 java 内存模型\n\n * java 内存模型即 java memory model，简称 jmm。jmm 定义了 jvm 在计算机内存(ram)中的工作方式。jmm 是隶属于 jvm 的。\n * 并发编程领域两个关键问题：线程间通信和线程间同步\n * 线程间通信机制\n   * 共享内存 - 线程间通过写-读内存中的公共状态来隐式进行通信。\n   * 消息传递 - java 中典型的消息传递方式就是 wait()和 notify()。\n * 线程间同步机制\n   * 在共享内存模型中，必须显示指定某个方法或某段代码在线程间互斥地执行。\n   * 在消息传递模型中，由于发送消息必须在接收消息之前，因此同步是隐式进行的。\n * java 的并发采用的是共享内存模型\n * jmm 决定一个线程对共享变量的写入何时对另一个线程可见。\n * 线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。\n * jmm 把内存分成了两部分：线程栈区和堆区\n   * 线程栈\n     * jvm 中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。\n     * 线程栈还包含了当前方法的所有本地变量信息。线程中的本地变量对其它线程是不可见的。\n   * 堆区\n     * 堆区包含了 java 应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如 byte、integer、long 等等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。\n   * 一个本地变量如果是原始类型，那么它会被完全存储到栈区。\n   * 一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。\n   * 对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。\n   * 对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。\n\n\n\n> 👉 参考阅读：全面理解 java 内存模型\n\n\n# 同步容器和并发容器\n\n> 👉 参考阅读：java 并发容器\n\n# ⭐ 同步容器\n\n> 什么是同步容器？\n> \n> 有哪些常见同步容器？\n> \n> 它们是如何实现线程安全的？\n> \n> 同步容器真的线程安全吗？\n\n类型\n\nvector、stack、hashtable\n\n作用/原理\n\n同步容器的同步原理就是在方法上用 synchronized 修饰。 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。\n\nsynchronized 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 synchronized 的容器性能要差。\n\n线程安全\n\n同步容器真的绝对安全吗？\n\n其实也未必。在做复合操作（非原子操作）时，仍然需要加锁来保护。常见复合操作如下：\n\n * 迭代：反复访问元素，直到遍历完全部元素；\n * 跳转：根据指定顺序寻找当前元素的下一个（下 n 个）元素；\n * 条件运算：例如若没有则添加等；\n\n# ⭐⭐⭐ concurrenthashmap\n\n> 请描述 concurrenthashmap 的实现原理？\n> \n> concurrenthashmap 为什么放弃了分段锁？\n\n基础数据结构原理和 hashmap 一样，jdk 1.7 采用 数组＋单链表；jdk 1.8 采用数组＋单链表＋红黑树。\n\n并发安全特性的实现：\n\njdk 1.7：\n\n * 使用分段锁，设计思路是缩小锁粒度，提高并发吞吐。\n * 写数据时，会使用可重入锁去锁住分段（segment）。\n\njdk 1.8：\n\n * 取消分段锁，直接采用 transient volatile hashentry<k,v>[] table 保存数据，采用 table 数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。\n * 写数据时，使用是 cas + synchronized。\n   * 根据 key 计算出 hashcode 。\n   * 判断是否需要进行初始化。\n   * f 即为当前 key 定位出的 node，如果为空表示当前位置可以写入数据，利用 cas 尝试写入，失败则自旋保证成功。\n   * 如果当前位置的 hashcode == moved == -1,则需要进行扩容。\n   * 如果都不满足，则利用 synchronized 锁写入数据。\n   * 如果数量大于 treeify_threshold 则要转换为红黑树。\n\n# ⭐⭐ copyonwritearraylist\n\n> copyonwritearraylist 的作用？\n> \n> copyonwritearraylist 的原理？\n\n作用\n\ncopyonwrite 字面意思为写入时复制。copyonwritearraylist 是线程安全的 arraylist。\n\n原理\n\n * 在 copyonwriteaarraylist 中，读操作不同步，因为它们在内部数组的快照上工作，所以多个迭代器可以同时遍历而不会相互阻塞（1,2,4）。\n * 所有的写操作都是同步的。他们在备份数组（3）的副本上工作。写操作完成后，后备阵列将被替换为复制的阵列，并释放锁定。支持数组变得易变，所以替换数组的调用是原子（5）。\n * 写操作后创建的迭代器将能够看到修改的结构（6,7）。\n * 写时复制集合返回的迭代器不会抛出 concurrentmodificationexception，因为它们在数组的快照上工作，并且无论后续的修改（2,4）如何，都会像迭代器创建时那样完全返回元素。\n\n\n\n\n# 并发锁\n\n> 👉 参考阅读：java 并发锁\n\n# ⭐⭐ 锁类型\n\n> java 中有哪些锁？\n> \n> 这些锁有什么特性？\n\n可重入锁\n\n * reentrantlock 、reentrantreadwritelock 是可重入锁。这点，从其命名也不难看出。\n * synchronized 也是一个可重入锁。\n\n公平锁与非公平锁\n\n * synchronized 只支持非公平锁。\n * reentrantlock 、reentrantreadwritelock，默认是非公平锁，但支持公平锁。\n\n独享锁与共享锁\n\n * synchronized 、reentrantlock 只支持独享锁。\n * reentrantreadwritelock 其写锁是独享锁，其读锁是共享锁。读锁是共享锁使得并发读是非常高效的，读写，写读 ，写写的过程是互斥的。\n\n悲观锁与乐观锁\n\n * 悲观锁在 java 中的应用就是通过使用 synchronized 和 lock 显示加锁来进行互斥同步，这是一种阻塞同步。\n\n * 乐观锁在 java 中的应用就是采用 cas 机制（cas 操作通过 unsafe 类提供，但这个类不直接暴露为 api，所以都是间接使用，如各种原子类）。\n\n偏向锁、轻量级锁、重量级锁\n\njava 1.6 以前，重量级锁一般指的是 synchronized ，而轻量级锁指的是 volatile。\n\njava 1.6 以后，针对 synchronized 做了大量优化，引入 4 种锁状态： 无锁状态、偏向锁、轻量级锁和重量级锁。锁可以单向的从偏向锁升级到轻量级锁，再从轻量级锁升级到重量级锁 。\n\n分段锁\n\n分段锁其实是一种锁的设计，并不是具体的一种锁。典型：jdk1.7 之前的 concurrenthashmap\n\n显示锁和内置锁\n\n * 内置锁：synchronized\n * 显示锁：reentrantlock、reentrantreadwritelock 等。\n\n# ⭐⭐ aqs\n\n> 什么是 aqs？\n> \n> aqs 的作用是什么？\n> \n> aqs 的原理？\n\n作用\n\nabstractqueuedsynchronizer（简称 aqs）是队列同步器，顾名思义，其主要作用是处理同步。它是并发锁和很多同步工具类的实现基石（如 reentrantlock、reentrantreadwritelock、semaphore 等）。\n\naqs 提供了对独享锁与共享锁的支持。\n\n原理\n\n（1）数据结构\n\n * state - aqs 使用一个整型的 volatile 变量来 维护同步状态。\n   * 这个整数状态的意义由子类来赋予，如reentrantlock 中该状态值表示所有者线程已经重复获取该锁的次数，semaphore 中该状态值表示剩余的许可数量。\n * head 和 tail - aqs 维护了一个 node 类型（aqs 的内部类）的双链表来完成同步状态的管理。这个双链表是一个双向的 fifo 队列，通过 head 和 tail 指针进行访问。当 有线程获取锁失败后，就被添加到队列末尾。\n\n（2）获取独占锁\n\naqs 中使用 acquire(int arg) 方法获取独占锁，其大致流程如下：\n\n 1. 先尝试获取同步状态，如果获取同步状态成功，则结束方法，直接返回。\n 2. 如果获取同步状态不成功，aqs 会不断尝试利用 cas 操作将当前线程插入等待同步队列的队尾，直到成功为止。\n 3. 接着，不断尝试为等待队列中的线程节点获取独占锁。\n\n（3）释放独占锁\n\naqs 中使用 release(int arg) 方法释放独占锁，其大致流程如下：\n\n 1. 先尝试获取解锁线程的同步状态，如果获取同步状态不成功，则结束方法，直接返回。\n 2. 如果获取同步状态成功，aqs 会尝试唤醒当前线程节点的后继节点。\n\n（4）获取共享锁\n\naqs 中使用 acquireshared(int arg) 方法获取共享锁。\n\nacquireshared 方法和 acquire 方法的逻辑很相似，区别仅在于自旋的条件以及节点出队的操作有所不同。\n\n成功获得共享锁的条件如下：\n\n * tryacquireshared(arg) 返回值大于等于 0 （这意味着共享锁的 permit 还没有用完）。\n * 当前节点的前驱节点是头结点。\n\n（5）释放共享锁\n\naqs 中使用 releaseshared(int arg) 方法释放共享锁。\n\nreleaseshared 首先会尝试释放同步状态，如果成功，则解锁一个或多个后继线程节点。释放共享锁和释放独享锁流程大体相似，区别在于：\n\n对于独享模式，如果需要 signal，释放仅相当于调用头节点的 unparksuccessor。\n\n# ⭐⭐ reentrantlock\n\n> 什么是 reentrantlock？\n> \n> 什么是可重入锁？\n> \n> reentrantlock 有什么用？\n> \n> reentrantlock 原理？\n\n作用\n\nreentrantlock 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作\n\nreentrantlock 的特性如下：\n\n * reentrantlock 提供了与 synchronized 相同的互斥性、内存可见性和可重入性。\n * reentrantlock 支持公平锁和非公平锁（默认）两种模式。\n * reentrantlock 实现了 lock 接口，支持了 synchronized 所不具备的灵活性。\n   * synchronized 无法中断一个正在等待获取锁的线程\n   * synchronized 无法在请求获取一个锁时无休止地等待\n\n原理\n\nreentrantlock 基于其内部类 reentrantlock.sync 实现，sync 继承自 aqs。它有两个子类：\n\n * reentrantlock.fairsync - 公平锁。\n * reentrantlock.nonfairsync - 非公平锁。\n\n本质上，就是基于 aqs 实现。\n\n# ⭐ reentrantreadwritelock\n\n> reentrantreadwritelock 是什么？\n> \n> reentrantreadwritelock 的作用？\n> \n> reentrantreadwritelock 的原理？\n\n作用\n\nreentrantreadwritelock 是一个可重入的读写锁。reentrantreadwritelock 维护了一对读写锁，将读写锁分开，有利于提高并发效率。\n\n原理\n\nreentrantreadwritelock 本质上也是基于 aqs 实现。有三个核心字段：\n\n * sync - 内部类 reentrantreadwritelock.sync 对象。与 reentrantlock 类似，它有两个子类：reentrantreadwritelock.fairsync 和 reentrantreadwritelock.nonfairsync ，分别表示公平锁和非公平锁的实现。\n * readerlock - 内部类 reentrantreadwritelock.readlock 对象，这是一把读锁。\n * writerlock - 内部类 reentrantreadwritelock.writelock 对象，这是一把写锁。\n\n# ⭐ condition\n\n> condition 有什么用？\n> \n> 使用 lock 的线程，彼此如何通信？\n\n作用\n\n可以理解为，什么样的锁配什么样的钥匙。\n\n内置锁（synchronized）配合内置条件队列（wait、notify、notifyall ），显式锁（lock）配合显式条件队列（condition ）。\n\n# ⭐⭐ 死锁\n\n> 如何避免死锁？\n\n * 避免一个线程同时获取多个锁\n * 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源\n * 尝试使用定时锁 lock.trylock(timeout)，避免锁一直不能释放\n * 对于数据库锁，加锁和解锁必须在一个数据库连接中里，否则会出现解锁失败的情况。\n\n\n# 原子变量类\n\n> 👉 参考阅读：java 原子类\n\n# ⭐ 原子类简介\n\n> 为什么要用原子类？\n> \n> 用过哪些原子类？\n\n作用\n\n常规的锁（lock、sychronized）由于是阻塞式的，势必影响并发吞吐量。\n\nvolatile 号称轻量级的锁，但不能保证原子性。\n\n为了兼顾原子性和锁的性能问题，所以引入了原子类。\n\n类型\n\n原子变量类可以分为 4 组：\n\n * 基本类型\n   * atomicboolean - 布尔类型原子类\n   * atomicinteger - 整型原子类\n   * atomiclong - 长整型原子类\n * 引用类型\n   * atomicreference - 引用类型原子类\n   * atomicmarkablereference - 带有标记位的引用类型原子类\n   * atomicstampedreference - 带有版本号的引用类型原子类\n * 数组类型\n   * atomicintegerarray - 整形数组原子类\n   * atomiclongarray - 长整型数组原子类\n   * atomicreferencearray - 引用类型数组原子类\n * 属性更新器类型\n   * atomicintegerfieldupdater - 整型字段的原子更新器。\n   * atomiclongfieldupdater - 长整型字段的原子更新器。\n   * atomicreferencefieldupdater - 原子更新引用类型里的字段。\n\n# ⭐ 原子类的原理\n\n 1. 处理器实现原子操作：使用总线锁保证原子性，使用缓存锁保证原子性（修改内存地址，缓存一致性机制：阻止同时修改由 2 个以上的处理器缓存的内存区域数据）\n 2. java 实现原子操作：循环使用 cas （自旋 cas）实现原子操作\n\n\n# 并发工具类\n\n> 👉 参考阅读：java 并发工具类\n\n# ⭐ countdownlatch\n\n> countdownlatch 作用？\n> \n> countdownlatch 原理？\n\n作用\n\n字面意思为 递减计数锁。用于控制一个或者多个线程等待多个线程。\n\ncountdownlatch 维护一个计数器 count，表示需要等待的事件数量。countdown 方法递减计数器，表示有一个事件已经发生。调用 await 方法的线程会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。\n\n\n\n原理\n\ncountdownlatch 是基于 aqs(abstractqueuedsynchronizer) 实现的。\n\n# ⭐ cyclicbarrier\n\n> cyclicbarrier 有什么用？\n> \n> cyclicbarrier 的原理是什么？\n> \n> cyclicbarrier 和 countdownlatch 有什么区别？\n\n作用\n\n字面意思是 循环栅栏。cyclicbarrier 可以让一组线程等待至某个状态（遵循字面意思，不妨称这个状态为栅栏）之后再全部同时执行。之所以叫循环栅栏是因为：当所有等待线程都被释放以后，cyclicbarrier 可以被重用。\n\ncyclicbarrier 维护一个计数器 count。每次执行 await 方法之后，count 加 1，直到计数器的值和设置的值相等，等待的所有线程才会继续执行。\n\n\n\n原理\n\ncyclicbarrier 是基于 reentrantlock 和 condition 实现的。\n\n区别\n\ncyclicbarrier 和 countdownlatch 都可以用来让一组线程等待其它线程。与 cyclicbarrier 不同的是，countdownlatch 不能重用。\n\n# ⭐ semaphore\n\n> semaphore 作用？\n\n作用\n\n字面意思为 信号量。semaphore 用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。\n\nsemaphore 管理着一组虚拟的许可（permit），permit 的初始数量可通过构造方法来指定。每次执行 acquire 方法可以获取一个 permit，如果没有就等待；而 release 方法可以释放一个 permit。\n\n * semaphore 可以用于实现资源池，如数据库连接池。\n * semaphore 可以用于将任何一种容器变成有界阻塞容器。\n\n\n\n\n# 线程池\n\n> 👉 参考阅读：java 线程池\n\n# ⭐⭐ threadpoolexecutor\n\n> threadpoolexecutor 有哪些参数，各自有什么用？\n> \n> threadpoolexecutor 工作原理？\n\n原理\n\n\n\n参数\n\njava.uitl.concurrent.threadpoolexecutor 类是 executor 框架中最核心的一个类。\n\nthreadpoolexecutor 有四个构造方法，前三个都是基于第四个实现。第四个构造方法定义如下：\n\n    public threadpoolexecutor(int corepoolsize,\n                              int maximumpoolsize,\n                              long keepalivetime,\n                              timeunit unit,\n                              blockingqueue<runnable> workqueue,\n                              threadfactory threadfactory,\n                              rejectedexecutionhandler handler) {\n\n\n参数说明：\n\n * corepoolsize - 核心线程数量。当有新任务通过 execute 方法提交时 ，线程池会执行以下判断：\n   * 如果运行的线程数少于 corepoolsize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的。\n   * 如果线程池中的线程数量大于等于 corepoolsize 且小于 maximumpoolsize，则只有当 workqueue 满时才创建新的线程去处理任务；\n   * 如果设置的 corepoolsize 和 maximumpoolsize 相同，则创建的线程池的大小是固定的。这时如果有新任务提交，若 workqueue 未满，则将请求放入 workqueue 中，等待有空闲的线程去从 workqueue 中取任务并处理；\n   * 如果运行的线程数量大于等于 maximumpoolsize，这时如果 workqueue 已经满了，则使用 handler 所指定的策略来处理任务；\n   * 所以，任务提交时，判断的顺序为 corepoolsize => workqueue => maximumpoolsize。\n * maximumpoolsize - 最大线程数量。\n   * 如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。\n   * 值得注意的是：如果使用了无界的任务队列这个参数就没什么效果。\n * keepalivetime：线程保持活动的时间。\n   * 当线程池中的线程数量大于 corepoolsize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepalivetime。\n   * 所以，如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。\n * unit - keepalivetime 的时间单位。有 7 种取值。可选的单位有天（days），小时（hours），分钟（minutes），毫秒(milliseconds)，微秒(microseconds, 千分之一毫秒)和毫微秒(nanoseconds, 千分之一微秒)。\n * workqueue - 等待执行的任务队列。用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。\n   * arrayblockingqueue - 有界阻塞队列。\n     * 此队列是基于数组的先进先出队列（fifo）。\n     * 此队列创建时必须指定大小。\n   * linkedblockingqueue - 无界阻塞队列。\n     * 此队列是基于链表的先进先出队列（fifo）。\n     * 如果创建时没有指定此队列大小，则默认为 integer.max_value。\n     * 吞吐量通常要高于 arrayblockingqueue。\n     * 使用 linkedblockingqueue 意味着： maximumpoolsize 将不起作用，线程池能创建的最大线程数为 corepoolsize，因为任务等待队列是无界队列。\n     * executors.newfixedthreadpool 使用了这个队列。\n   * synchronousqueue - 不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。\n     * 每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。\n     * 吞吐量通常要高于 linkedblockingqueue。\n     * executors.newcachedthreadpool 使用了这个队列。\n   * priorityblockingqueue - 具有优先级的无界阻塞队列。\n * threadfactory - 线程工厂。可以通过线程工厂给每个创建出来的线程设置更有意义的名字。\n * handler - 饱和策略。它是 rejectedexecutionhandler 类型的变量。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。线程池支持以下策略：\n   * abortpolicy - 丢弃任务并抛出异常。这也是默认策略。\n   * discardpolicy - 丢弃任务，但不抛出异常。\n   * discardoldestpolicy - 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。\n   * callerrunspolicy - 只用调用者所在的线程来运行任务。\n   * 如果以上策略都不能满足需要，也可以通过实现 rejectedexecutionhandler 接口来定制处理策略。如记录日志或持久化不能处理的任务。\n\n# ⭐ executors\n\n> executors 提供了哪些内置的线程池？\n> \n> 这些线程池各自有什么特性？适合用于什么场景？\n\nexecutors 为 executor，executorservice，scheduledexecutorservice，threadfactory 和 callable 类提供了一些工具方法。\n\n（1）newsinglethreadexecutor\n\n创建一个单线程的线程池。\n\n只会创建唯一的工作线程来执行任务，保证所有任务按照指定顺序(fifo, lifo, 优先级)执行。 如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它 。\n\n单工作线程最大的特点是：可保证顺序地执行各个任务。\n\n（2）newfixedthreadpool\n\n创建一个固定大小的线程池。\n\n每次提交一个任务就会新创建一个工作线程，如果工作线程数量达到线程池最大线程数，则将提交的任务存入到阻塞队列中。\n\nfixedthreadpool 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。\n\n（3）newcachedthreadpool\n\n创建一个可缓存的线程池。\n\n * 如果线程池大小超过处理任务所需要的线程数，就会回收部分空闲的线程；\n * 如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。\n * 此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 jvm）能够创建的最大线程大小。 因此，使用 cachedthreadpool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。\n\n（4）newschedulethreadpool\n\n创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\n\n# jvm\n\n\n# 内存管理\n\n\n# oom\n\n\n# 参考资料\n\n * 书籍\n   * 《java 并发编程实战》\n   * 《java 并发编程的艺术》\n   * 《深入理解 java 虚拟机》\n * 文章\n   * java 线程面试题 top 50\n   * java 多线程和并发基础面试问答\n   * 进程和线程关系及区别\n   * javathread methods and thread states\n   * java 线程的 5 种状态及切换(透彻讲解)\n   * java 中守护线程的总结\n   * java 创建线程的三种方式及其对比\n   * java 线程的 5 种状态及切换(透彻讲解)\n   * java 线程方法 join 的简单总结\n   * java 并发编程：线程间协作的两种方式：wait、notify、notifyall 和 condition\n   * java 并发编程：volatile 关键字解析\n   * java 并发编程：callable、future 和 futuretask\n   * java 并发编程：线程池的使用\n   * java 并发编程',charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-3f7bcbb6",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-67a474f6",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-73f01fa5",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3},{title:"Home",frontmatter:{home:!0,heroImage:"img/bg.gif",heroText:"JAVACORE",tagline:"☕ javacore 是一个 Java 核心技术教程。",bannerBg:"none",postList:"none",footer:"CC-BY-SA-4.0 Licensed | Copyright © 2018-Now Dunwu"},regularPath:"/",relativePath:"README.md",key:"v-ceebf0d4",path:"/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:108},{level:3,title:"Java 基础特性",slug:"java-基础特性",normalizedTitle:"java 基础特性",charIndex:134},{level:3,title:"Java 高级特性",slug:"java-高级特性",normalizedTitle:"java 高级特性",charIndex:313},{level:3,title:"Java 容器",slug:"java-容器",normalizedTitle:"java 容器",charIndex:557},{level:3,title:"Java IO",slug:"java-io",normalizedTitle:"java io",charIndex:937},{level:3,title:"Java 并发",slug:"java-并发",normalizedTitle:"java 并发",charIndex:1288},{level:3,title:"Java 虚拟机",slug:"java-虚拟机",normalizedTitle:"java 虚拟机",charIndex:1883},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:2310},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:2943}],headersStr:"📖 内容 Java 基础特性 Java 高级特性 Java 容器 Java IO Java 并发 Java 虚拟机 📚 资料 🚪 传送",content:"> ☕ JavaCore 是一个 Java 核心技术教程。\n> \n>  * 🔁 项目同步维护：Github | Gitee\n>  * 📖 电子书阅读：Github Pages | Gitee Pages\n\n\n# 📖 内容\n\n> Java 面试总结 💯\n\n\n# Java 基础特性\n\n * Java 开发环境\n * Java 基础语法特性\n * Java 基本数据类型\n * Java 面向对象\n * Java 方法\n * Java 数组\n * Java 枚举\n * Java 控制语句\n * Java 异常\n * Java 泛型\n * Java 反射\n * Java 注解\n * Java String 类型\n\n\n# Java 高级特性\n\n * Java 正则从入门到精通 - 关键词：Pattern、Matcher、捕获与非捕获、反向引用、零宽断言、贪婪与懒惰、元字符、DFA、NFA\n * Java 编码和加密 - 关键词：Base64、消息摘要、数字签名、对称加密、非对称加密、MD5、SHA、HMAC、AES、DES、DESede、RSA\n * Java 本地化\n * Java JDK8 - 关键词：Stream、lambda、Optional、@FunctionalInterface\n\n\n# Java 容器\n\n\n\n * Java 容器简介 - 关键词：Collection、泛型、Iterable、Iterator、Comparable、Comparator、Cloneable、fail-fast\n * Java 容器之 List - 关键词：List、ArrayList、LinkedList\n * Java 容器之 Map - 关键词：Map、HashMap、TreeMap、LinkedHashMap、WeakHashMap\n * Java 容器之 Set - 关键词：Set、HashSet、TreeSet、LinkedHashSet、EmumSet\n * Java 容器之 Queue - 关键词：Queue、Deque、ArrayDeque、LinkedList、PriorityQueue\n * Java 容器之 Stream\n\n\n# Java IO\n\n\n\n * Java IO 模型 - 关键词：InputStream、OutputStream、Reader、Writer、阻塞\n * Java NIO - 关键词：Channel、Buffer、Selector、非阻塞、多路复用\n * Java 序列化 - 关键词：Serializable、serialVersionUID、transient、Externalizable、writeObject、readObject\n * Java 网络编程 - 关键词：Socket、ServerSocket、DatagramPacket、DatagramSocket\n * Java IO 工具类 - 关键词：File、RandomAccessFile、System、Scanner\n\n\n# Java 并发\n\n\n\n * Java 并发简介 - 关键词：进程、线程、安全性、活跃性、性能、死锁、饥饿、上下文切换\n * Java 线程基础 - 关键词：Thread、Runnable、Callable、Future、wait、notify、notifyAll、join、sleep、yeild、线程状态、线程通信\n * Java 并发核心机制 - 关键词：synchronized、volatile、CAS、ThreadLocal\n * Java 并发锁 - 关键词：AQS、ReentrantLock、ReentrantReadWriteLock、Condition\n * Java 原子类 - 关键词：CAS、Atomic\n * Java 并发容器 - 关键词：ConcurrentHashMap、CopyOnWriteArrayList\n * Java 线程池 - 关键词：Executor、ExecutorService、ThreadPoolExecutor、Executors\n * Java 并发工具类 - 关键词：CountDownLatch、CyclicBarrier、Semaphore\n * Java 内存模型 - 关键词：JMM、volatile、synchronized、final、Happens-Before、内存屏障\n * ForkJoin 框架\n\n\n# Java 虚拟机\n\n\n\n * JVM 体系结构\n * JVM 内存区域 - 关键词：程序计数器、虚拟机栈、本地方法栈、堆、方法区、运行时常量池、直接内存、OutOfMemoryError、StackOverflowError\n * JVM 垃圾收集 - 关键词：GC Roots、Serial、Parallel、CMS、G1、Minor GC、Full GC\n * JVM 字节码 - 关键词：bytecode、asm、javassist\n * JVM 类加载 - 关键词：ClassLoader、双亲委派\n * JVM 命令行工具 - 关键词：jps、jstat、jmap 、jstack、jhat、jinfo\n * JVM GUI 工具 - 关键词：jconsole、jvisualvm、MAT、JProfile、Arthas\n * JVM 实战 - 关键词：配置、调优\n * Java 故障诊断 - 关键词：CPU、内存、磁盘、网络、GC\n\n\n# 📚 资料\n\n * 书籍\n   * Java 四大名著\n     * 《Java 编程思想（Thinking in java）》\n     * 《Java 核心技术 卷 I 基础知识》\n     * 《Java 核心技术 卷 II 高级特性》\n     * 《Effective Java》\n   * Java 并发\n     * 《Java 并发编程实战》\n     * 《Java 并发编程的艺术》\n   * Java 虚拟机\n     * 《深入理解 Java 虚拟机》\n   * Java 入门\n     * 《O'Reilly：Head First Java》\n     * 《疯狂 Java 讲义》\n   * 其他\n     * 《Head First 设计模式》\n     * 《Java 网络编程》\n     * 《Java 加密与解密的艺术》\n     * 《阿里巴巴 Java 开发手册》\n * 教程、社区\n   * Runoob Java 教程\n   * java-design-patterns\n   * Java\n   * 《Java 核心技术面试精讲》\n   * 《Java 性能调优实战》\n   * 《Java 业务开发常见错误 100 例》\n   * 深入拆解 Java 虚拟机\n   * 《Java 并发编程实战》\n * 面试\n   * CS-Notes\n   * JavaGuide\n   * advanced-java\n\n\n# 🚪 传送\n\n◾ 🏠 JAVACORE 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"> ☕ javacore 是一个 java 核心技术教程。\n> \n>  * 🔁 项目同步维护：github | gitee\n>  * 📖 电子书阅读：github pages | gitee pages\n\n\n# 📖 内容\n\n> java 面试总结 💯\n\n\n# java 基础特性\n\n * java 开发环境\n * java 基础语法特性\n * java 基本数据类型\n * java 面向对象\n * java 方法\n * java 数组\n * java 枚举\n * java 控制语句\n * java 异常\n * java 泛型\n * java 反射\n * java 注解\n * java string 类型\n\n\n# java 高级特性\n\n * java 正则从入门到精通 - 关键词：pattern、matcher、捕获与非捕获、反向引用、零宽断言、贪婪与懒惰、元字符、dfa、nfa\n * java 编码和加密 - 关键词：base64、消息摘要、数字签名、对称加密、非对称加密、md5、sha、hmac、aes、des、desede、rsa\n * java 本地化\n * java jdk8 - 关键词：stream、lambda、optional、@functionalinterface\n\n\n# java 容器\n\n\n\n * java 容器简介 - 关键词：collection、泛型、iterable、iterator、comparable、comparator、cloneable、fail-fast\n * java 容器之 list - 关键词：list、arraylist、linkedlist\n * java 容器之 map - 关键词：map、hashmap、treemap、linkedhashmap、weakhashmap\n * java 容器之 set - 关键词：set、hashset、treeset、linkedhashset、emumset\n * java 容器之 queue - 关键词：queue、deque、arraydeque、linkedlist、priorityqueue\n * java 容器之 stream\n\n\n# java io\n\n\n\n * java io 模型 - 关键词：inputstream、outputstream、reader、writer、阻塞\n * java nio - 关键词：channel、buffer、selector、非阻塞、多路复用\n * java 序列化 - 关键词：serializable、serialversionuid、transient、externalizable、writeobject、readobject\n * java 网络编程 - 关键词：socket、serversocket、datagrampacket、datagramsocket\n * java io 工具类 - 关键词：file、randomaccessfile、system、scanner\n\n\n# java 并发\n\n\n\n * java 并发简介 - 关键词：进程、线程、安全性、活跃性、性能、死锁、饥饿、上下文切换\n * java 线程基础 - 关键词：thread、runnable、callable、future、wait、notify、notifyall、join、sleep、yeild、线程状态、线程通信\n * java 并发核心机制 - 关键词：synchronized、volatile、cas、threadlocal\n * java 并发锁 - 关键词：aqs、reentrantlock、reentrantreadwritelock、condition\n * java 原子类 - 关键词：cas、atomic\n * java 并发容器 - 关键词：concurrenthashmap、copyonwritearraylist\n * java 线程池 - 关键词：executor、executorservice、threadpoolexecutor、executors\n * java 并发工具类 - 关键词：countdownlatch、cyclicbarrier、semaphore\n * java 内存模型 - 关键词：jmm、volatile、synchronized、final、happens-before、内存屏障\n * forkjoin 框架\n\n\n# java 虚拟机\n\n\n\n * jvm 体系结构\n * jvm 内存区域 - 关键词：程序计数器、虚拟机栈、本地方法栈、堆、方法区、运行时常量池、直接内存、outofmemoryerror、stackoverflowerror\n * jvm 垃圾收集 - 关键词：gc roots、serial、parallel、cms、g1、minor gc、full gc\n * jvm 字节码 - 关键词：bytecode、asm、javassist\n * jvm 类加载 - 关键词：classloader、双亲委派\n * jvm 命令行工具 - 关键词：jps、jstat、jmap 、jstack、jhat、jinfo\n * jvm gui 工具 - 关键词：jconsole、jvisualvm、mat、jprofile、arthas\n * jvm 实战 - 关键词：配置、调优\n * java 故障诊断 - 关键词：cpu、内存、磁盘、网络、gc\n\n\n# 📚 资料\n\n * 书籍\n   * java 四大名著\n     * 《java 编程思想（thinking in java）》\n     * 《java 核心技术 卷 i 基础知识》\n     * 《java 核心技术 卷 ii 高级特性》\n     * 《effective java》\n   * java 并发\n     * 《java 并发编程实战》\n     * 《java 并发编程的艺术》\n   * java 虚拟机\n     * 《深入理解 java 虚拟机》\n   * java 入门\n     * 《o'reilly：head first java》\n     * 《疯狂 java 讲义》\n   * 其他\n     * 《head first 设计模式》\n     * 《java 网络编程》\n     * 《java 加密与解密的艺术》\n     * 《阿里巴巴 java 开发手册》\n * 教程、社区\n   * runoob java 教程\n   * java-design-patterns\n   * java\n   * 《java 核心技术面试精讲》\n   * 《java 性能调优实战》\n   * 《java 业务开发常见错误 100 例》\n   * 深入拆解 java 虚拟机\n   * 《java 并发编程实战》\n * 面试\n   * cs-notes\n   * javaguide\n   * advanced-java\n\n\n# 🚪 传送\n\n◾ 🏠 javacore 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/26, 18:19:55",lastUpdatedTimestamp:1650968395e3}],themeConfig:{nav:[{text:"基础特性",link:"/01.基础特性/"},{text:"高级特性",link:"/02.高级特性/"},{text:"容器",link:"/03.容器/"},{text:"IO",link:"/04.IO/"},{text:"并发",link:"/05.并发/"},{text:"JVM",link:"/06.JVM/"},{text:"✨ Java系列",ariaLabel:"Java",items:[{text:"Java 教程 📚",link:"https://dunwu.github.io/java-tutorial/",target:"_blank",rel:""},{text:"JavaCore 教程 📚",link:"https://dunwu.github.io/javacore/",target:"_blank",rel:""},{text:"Spring 教程 📚",link:"https://dunwu.github.io/spring-tutorial/",target:"_blank",rel:""},{text:"Spring Boot 教程 📚",link:"https://dunwu.github.io/spring-boot-tutorial/",target:"_blank",rel:""}]},{text:"🎯 博客",link:"https://github.com/dunwu/blog",target:"_blank",rel:""}],sidebarDepth:2,logo:"https://raw.githubusercontent.com/dunwu/images/dev/common/dunwu-logo.png",repo:"dunwu/db-tutorial",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"📝 帮助改善此页面！",sidebar:{"/01.基础特性/":[["00.Java开发环境.md","Java 开发环境","/pages/9f7bb5/"],["01.Java基础语法.md","Java 基础语法特性","/pages/23333b/"],["02.Java基本数据类型.md","深入理解 Java 基本数据类型","/pages/2e072a/"],["03.Java面向对象.md","Java 面向对象","/pages/d6b776/"],["04.Java方法.md","深入理解 Java 方法","/pages/d17f6e/"],["05.Java数组.md","深入理解 Java 数组","/pages/33ad31/"],["06.Java枚举.md","深入理解 Java 枚举","/pages/ae8c35/"],["07.Java控制语句.md","Java 控制语句","/pages/8e828a/"],["08.Java异常.md","深入理解 Java 异常","/pages/59fbf8/"],["09.Java泛型.md","深入理解 Java 泛型","/pages/987cf1/"],["10.Java反射.md","深入理解 Java 反射和动态代理","/pages/793a2a/"],["11.Java注解.md","深入理解 Java 注解","/pages/66a7ee/"],["41.Java常用工具类.md","Java 常用工具类","/pages/c29a85/"],["42.JavaString类型.md","深入理解 Java String 类型","/pages/0c9e8c/"]],catalogue:{},"/02.高级特性/":[["01.Java正则.md","Java 正则从入门到精通","/pages/272038/"],["02.Java编码和加密.md","Java 编码和加密","/pages/887467/"],["03.Java本地化.md","Java 本地化","/pages/f7bac4/"],["04.JDK8.md","JDK8 入门指南","/pages/8c8dd6/"],["99.Java编程规范.md","Java 编程规范","/pages/c63b72/"]],"/03.容器/":[["01.Java容器简介.md","Java 容器简介","/pages/3b9a57/"],["02.Java容器之List.md","Java 容器之 List","/pages/decaa9/"],["03.Java容器之Map.md","Java 容器之 Map","/pages/6ce173/"],["04.Java容器之Set.md","Java 容器之 Set","/pages/b12803/"],["05.Java容器之Queue.md","Java 容器之 Queue","/pages/3c422d/"],["06.Java容器之Stream.md","Java 容器之 Stream","/pages/7d4bd9/"]],"/04.IO/":[["01.JavaIO模型.md","Java IO 模型","/pages/99f4f4/"],["02.JavaNIO.md","Java NIO","/pages/ff6965/"],["03.Java序列化.md","深入理解 Java 序列化","/pages/287e58/"],["04.Java网络编程.md","Java 网络编程","/pages/e70be2/"],["05.JavaIO工具类.md","Java IO 工具类","/pages/e33faa/"]],"/05.并发/":[["01.Java并发简介.md","Java并发简介","/pages/b39f82/"],["02.Java线程基础.md","Java线程基础","/pages/1f74be/"],["03.Java并发核心机制.md","Java并发核心机制","/pages/4a7f19/"],["04.Java锁.md","Java锁","/pages/37bf7b/"],["05.Java原子类.md","Java原子类","/pages/c29e3a/"],["06.Java并发和容器.md","Java并发和容器","/pages/3038c4/"],["07.Java线程池.md","Java线程池","/pages/241a67/"],["08.Java并发工具类.md","Java并发工具类","/pages/2f46ce/"],["09.Java内存模型.md","Java内存模型","/pages/80f538/"],["10.ForkJoin框架.md","ForkJoin框架","/pages/e96ed2/"],["11.Synchronized.md","Synchronized","/pages/560949/"]],"/06.JVM/":[["01.JVM体系结构.md","JVM 体系结构","/pages/e0de21/"],["02.JVM内存区域.md","Java 内存管理","/pages/692f5d/"],["03.JVM垃圾收集.md","JVM 垃圾收集","/pages/7fb1c8/"],["04.JVM字节码.md","JVM 字节码","/pages/f37148/"],["05.JVM类加载.md","JVM 类加载","/pages/4aea87/"],["08.JavaAgent.md","JavaAgent 应用指南","/pages/f634e5/"],["11.JVM命令行工具.md","JVM 命令行工具","/pages/fb1445/"],["12.JVM_GUI工具.md","JVM GUI 工具","/pages/08ac9d/"],["21.JVM实战.md","JVM 实战","/pages/e12478/"],["22.Java故障诊断.md","Java 故障诊断","/pages/92bd85/"]]},updateBar:{showToArticle:!0},category:!0,tag:!0,archive:!0,author:{name:"dunwu",href:"https://github.com/dunwu"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:forbreak@163.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/dunwu"}]},footer:{createYear:2019,copyrightInfo:"钝悟（dunwu） | CC-BY-SA-4.0"},htmlModules:{pageB:'\n  <div class="wwads-cn wwads-horizontal pageB" data-id="136" style="width:100%;max-height:80px;min-height:auto;"></div>\n  <style>\n    .pageB img{width:80px!important;}\n    .wwads-horizontal .wwads-text, .wwads-content .wwads-text{line-height:1;}\n  </style>\n  ',windowRB:'\n    <div class="wwads-cn wwads-vertical windowRB" data-id="136" style="max-width:160px;\n    min-width: auto;min-height:auto;"></div>\n    <style>\n      .windowRB{ padding: 0;}\n      .windowRB .wwads-img{margin-top: 10px;}\n      .windowRB .wwads-content{margin: 0 10px 10px 10px;}\n      .custom-html-window-rb .close-but{\n        display: none;\n      }\n    </style>\n  '}}};function ss(n){var e=document.createElement("link");e.href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css",e.rel="stylesheet",document.body.appendChild(e);var t=document.createElement("script");function a(n){var e=document.getElementById("gitalk-container");e||((e=document.createElement("div")).id="gitalk-container",e.classList.add("content"));var t,a=document.querySelector(".page");a&&(a.appendChild(e),"undefined"!=typeof Gitalk&&Gitalk instanceof Function&&(t=n.fullPath,console.info(t),new Gitalk({clientID:"664702e30bf8f4c2f9f0",clientSecret:"56c1edc821488957fdaaa6e8d594b67ffdcf2d1f",repo:"javacore",owner:"dunwu",admin:["dunwu"],id:"comment",distractionFreeMode:!1,language:"zh-CN"}).render("gitalk-container")))}t.src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js",document.body.appendChild(t),n.afterEach((function(n){t.onload?a(n):t.onload=function(){a(n)}}))}t(155),t(213),t(144);var cs=t(223),us=t(224),ds=(t(390),t(240),t(43));var ps={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var e=n.frontmatter,t=e.pageComponent,a=e.article,r=e.home;return!(t||!1===a||!0===r)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,e){var t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(ds.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(ds.a)(n,e)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,e){return Object(ds.a)(n,e)})),n;var n},$groupPosts:function(){return function(n){for(var e={},t={},a=function(a,r){var i=n[a].frontmatter,o=i.categories,l=i.tags;"array"===Object(ds.n)(o)&&o.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[a]))})),"array"===Object(ds.n)(l)&&l.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[a]))}))},r=0,i=n.length;r<i;r++)a(r);return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var e=[],t=[];for(var a in n.categories)e.push({key:a,length:n.categories[a].length});for(var r in n.tags)t.push({key:r,length:n.tags[r].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Lr.component(cs.default),Lr.component(us.default);function ms(n){return n.toString().padStart(2,"0")}t(394);Lr.component("Badge",(function(){return Promise.all([t.e(0),t.e(3)]).then(t.bind(null,556))})),Lr.component("CodeBlock",(function(){return Promise.resolve().then(t.bind(null,223))})),Lr.component("CodeGroup",(function(){return Promise.resolve().then(t.bind(null,224))}));t(395),t(396);var hs=[function(n){n.Vue,n.options;var e=n.router;n.siteData;n.isServer||e.afterEach((function(){var n;n=function(){},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout((function(){var n=document.querySelector(".pageB");if(n){var t=n.querySelector(".wwads-hide");t&&(t.onclick=function(){n.style.display="none"}),n.style.display="flex",ss(e)}}),0)}));try{document&&ss(e)}catch(n){console.error(n.message)}},function(n){var e=n.Vue,t=(n.options,n.router,n.siteData);t.pages.map((function(n){var e=n.frontmatter,a=e.date,r=e.author;"string"==typeof a&&"Z"===a.charAt(a.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(ms(n.getUTCMonth()+1),"-").concat(ms(n.getUTCDate())," ").concat(ms(n.getUTCHours()),":").concat(ms(n.getUTCMinutes()),":").concat(ms(n.getUTCSeconds()))}(a)),r?n.author=r:t.themeConfig.author&&(n.author=t.themeConfig.author)})),e.mixin(ps)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(){"undefined"!=typeof window&&function(n,e,t){function a(n){var t=e.createElement("div");t.className="heart",r.push({el:t,x:n.clientX-5,y:n.clientY-5,scale:1,alpha:1,color:"#11a8cd"}),e.body.appendChild(t)}var r=[];n.requestAnimationFrame=n.requestAnimationFrame||n.webkitRequestAnimationFrame||n.mozRequestAnimationFrame||n.oRequestAnimationFrame||n.msRequestAnimationFrame||function(n){setTimeout(n,1e3/60)},function(n){var t=e.createElement("style");t.type="text/css";try{t.appendChild(e.createTextNode(n))}catch(e){t.styleSheet.cssText=n}e.getElementsByTagName("head")[0].appendChild(t)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var e="function"==typeof n.onclick&&n.onclick;n.onclick=function(n){var t=!0;n.path&&n.path.forEach((function(n){1===n.nodeType&&"string"==typeof n.className&&n.className.indexOf("theme-vdoing-content")>-1&&(t=!1)})),t&&(e&&e(),a(n))}}(),function n(){for(var t=0;t<r.length;t++)r[t].alpha<=0?(e.body.removeChild(r[t].el),r.splice(t,1)):(r[t].y--,r[t].scale+=.004,r[t].alpha-=.013,r[t].el.style.cssText="left:"+r[t].x+"px;top:"+r[t].y+"px;opacity:"+r[t].alpha+";transform:scale("+r[t].scale+","+r[t].scale+") rotate(45deg);background:"+r[t].color+";z-index:99999");requestAnimationFrame(n)}()}(window,document)}],vs=[];t(216);function gs(n,e){return(gs=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(217),t(218);function fs(n){return(fs=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function bs(n,e){if(e&&("object"===Io(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function ys(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,a=fs(n);if(e){var r=fs(this).constructor;t=Reflect.construct(a,arguments,r)}else t=a.apply(this,arguments);return bs(this,t)}}var xs=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&gs(n,e)}(t,n);var e=ys(t);function t(){return cl(this,t),e.apply(this,arguments)}return dl(t)}(function(){function n(){cl(this,n),this.store=new Lr({data:{state:{}}})}return dl(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){Lr.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(xs.prototype,{getPageAsyncComponent:qo,getLayoutAsyncComponent:Vo,getAsyncComponent:Uo,getVueComponent:Ho});var ks={install:function(n){var e=new xs;n.$vuepress=e,n.prototype.$vuepress=e}};function ws(n){n.beforeEach((function(e,t,a){if(js(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var r=e.path.replace(/\/$/,"")+".html";js(n,r)?a(r):a()}else a();else{var i=e.path+"/",o=e.path+".html";js(n,o)?a(o):js(n,i)?a(i):a()}}))}function js(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var Ss={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return $o("pageKey",e),Lr.component(e)||Lr.component(e,qo(e)),Lr.component(e)?n(e):n("")}},Ts={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,a=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},a()[t.slotKey])}},Is={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Cs=(t(397),t(398),Object(rs.a)(Is,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function zs(){return(zs=Object(a.a)(regeneratorRuntime.mark((function n(e){var t,a,r,i;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:ls.routerBase||ls.base,ws(a=new So({base:t,mode:"history",fallback:!1,routes:os,scrollBehavior:function(n,e,t){return t||(n.hash?!Lr.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),r={},n.prev=4,n.next=7,Promise.all(hs.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Lr,options:r,router:a,siteData:ls,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return i=new Lr(Object.assign(r,{router:a,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},vs.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:i,router:a});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Lr.config.productionTip=!1,Lr.use(So),Lr.use(ks),Lr.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Lr;To(e),t.$vuepress.$set("siteData",e);var a=n(t.$vuepress.$get("siteData")),r=new a,i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),o={};return Object.keys(i).reduce((function(n,e){return e.startsWith("$")&&(n[e]=i[e].get),n}),o),{computed:o}}((function(n){return function(){function e(){cl(this,e)}return dl(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,a=void 0===t?{}:t;for(var r in a)"/"===r?e=a[r]:0===this.$page.path.indexOf(r)&&(n=a[r]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),ls)),Lr.component("Content",Ss),Lr.component("ContentSlotsDistributor",Ts),Lr.component("OutboundLink",Cs),Lr.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,a=e.children;if(t._isMounted)return a;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Lr.component("Layout",Vo("Layout")),Lr.component("NotFound",Vo("NotFound")),Lr.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:"9b62975"},function(n){return zs.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);